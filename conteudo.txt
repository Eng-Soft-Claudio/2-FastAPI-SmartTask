
--- Início de core/config.py (140 linhas) ---
# app/core/config.py
import os
from pydantic_settings import BaseSettings
from pydantic import EmailStr, Field, RedisDsn, model_validator, HttpUrl
from typing import Optional
from dotenv import load_dotenv
import logging

logger = logging.getLogger(__name__)

# --- Carrega variáveis do .env ---
dotenv_path = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), '.env')
loaded = load_dotenv(dotenv_path=dotenv_path)

class Settings(BaseSettings):
    """
    Configurações da aplicação lidas do ambiente.
    Docs Pydantic Settings: https://docs.pydantic.dev/latest/concepts/pydantic_settings/
    """
    PROJECT_NAME: str = Field("SmartTask API", description="Nome do Projeto")
    API_V1_STR: str = Field("/api/v1", description="Prefixo para a versão 1 da API")

    # --- Configurações MongoDB ---
    MONGODB_URL: str = Field(..., env="MONGODB_URL", description="URL de conexão do MongoDB")
    DATABASE_NAME: str = Field("smarttask_db", description="Nome do banco de dados MongoDB")

     # --- Configurações JWT ---
    JWT_SECRET_KEY: str = Field(..., env="JWT_SECRET_KEY", description="Chave secreta para assinar tokens JWT")
    JWT_ALGORITHM: str = Field("HS256", env="JWT_ALGORITHM", description="Algoritmo de assinatura JWT")
    ACCESS_TOKEN_EXPIRE_MINUTES: int = Field(60 * 24 * 7, env="ACCESS_TOKEN_EXPIRE_MINUTES", description="Validade do token de acesso (minutos)") # Ex: 7 dias

    # --- Configurações de Prioridade ---
    PRIORITY_WEIGHT_DUE_DATE: float = Field(
        100.0, 
        env="PRIORITY_WEIGHT_DUE_DATE",
        description="Peso para o componente de prazo no cálculo de prioridade."
    )
    PRIORITY_WEIGHT_IMPORTANCE: float = Field(
        10.0, 
        env="PRIORITY_WEIGHT_IMPORTANCE",
        description="Peso (multiplicador) para o componente de importância no cálculo de prioridade."
    )
    PRIORITY_DEFAULT_SCORE_NO_DUE_DATE: Optional[float] = Field(
        0.0, 
        env="PRIORITY_DEFAULT_SCORE_NO_DUE_DATE",
        description="Pontuação base de prazo para tarefas sem data de vencimento (pode ser None ou 0)."
    )
    PRIORITY_SCORE_IF_OVERDUE: float = Field(
        1000.0, 
        env="PRIORITY_SCORE_IF_OVERDUE",
        description="Pontuação (ou fator aditivo/multiplicativo) especial para tarefas atrasadas."
    )

    # --- Configuração Webhook ---
    WEBHOOK_URL: Optional[HttpUrl] = Field(
        None,
        env="WEBHOOK_URL",
        description="URL opcional para enviar notificações de eventos de tarefas (webhooks)."
    )
    # Segredo para assinar requests de webhook (HMAC)
    WEBHOOK_SECRET: Optional[str] = Field(
        None,
        env="WEBHOOK_SECRET",
        description="Segredo opcional usado para assinar payloads de webhook para verificação."
    )

    # --- Configurações de E-mail ---
    MAIL_ENABLED: bool = Field(
            default=True,
            env="MAIL_ENABLED",
            description="Flag para habilitar/desabilitar envio de e-mails globalmente."
        )
    MAIL_USERNAME: Optional[str] = Field(None, env="MAIL_USERNAME", description="Usuário do servidor SMTP.")
    MAIL_PASSWORD: Optional[str] = Field(None, env="MAIL_PASSWORD", description="Senha do servidor SMTP.")
    MAIL_FROM: Optional[EmailStr] = Field(
        None,
        env="MAIL_FROM",
        description="Endereço de e-mail remetente."
        )
    MAIL_FROM_NAME: Optional[str] = Field(
        "SmartTask Notificações", 
        env="MAIL_FROM_NAME",
        description="Nome do remetente exibido no e-mail."
        )
    MAIL_PORT: int = Field(
        587,
        env="MAIL_PORT",
        description="Porta do servidor SMTP."
        )
    MAIL_SERVER: Optional[str] = Field(
        None,
        env="MAIL_SERVER",
        description="Endereço do servidor SMTP."
        )
    # Configurações para fastapi-mail
    MAIL_STARTTLS: bool = Field(True, env="MAIL_STARTTLS") 
    MAIL_SSL_TLS: bool = Field(False, env="MAIL_SSL_TLS") 
    USE_CREDENTIALS: bool = Field(True, env="USE_CREDENTIALS")
    VALIDATE_CERTS: bool = Field(True, env="VALIDATE_CERTS") 

    # --- Configurações Adicionais (Templates, Limiar) ---
    EMAIL_TEMPLATES_DIR: str = Field("app/email-templates/build", description="Diretório de templates de e-mail compilados.") # Definiremos isso
    EMAIL_URGENCY_THRESHOLD: float = Field(
        100.0, 
        env="EMAIL_URGENCY_THRESHOLD",
        description="Limiar de priority_score para considerar uma tarefa urgente para notificação."
        )
    FRONTEND_URL: Optional[str] = Field(None, env="FRONTEND_URL", description="URL base do frontend para links no e-mail (se houver).") # Ex: http://localhost:3000

     # --- Configuração Redis ---
    REDIS_URL: Optional[RedisDsn] = Field(
        None, 
        env="REDIS_URL",
        description="URL de conexão do Redis para filas de tarefas (ARQ)."
    )

    # --- Configurações CORS ---

    # --- Configuração Pydantic (case-insensitive)---
    model_config = {
        "case_sensitive": False,
    }

# --- Validação ---
    @model_validator(mode='after')
    def check_mail_config(self) -> 'Settings':
        if self.MAIL_ENABLED and not all([self.MAIL_USERNAME, self.MAIL_PASSWORD, self.MAIL_FROM, self.MAIL_SERVER]):
            raise ValueError(
                "Se MAIL_ENABLED for True, MAIL_USERNAME, MAIL_PASSWORD, MAIL_FROM e MAIL_SERVER devem ser definidos."
            )
        return self

# --- Cria a instância ---
try:
    settings = Settings()
except ValueError as e:
     raise e 
# Validação extra da instância
if settings.WEBHOOK_URL and not isinstance(settings.WEBHOOK_URL, HttpUrl):
     logger.warning(f"WEBHOOK_URL '{settings.WEBHOOK_URL}' não parece ser uma URL válida.")
--- Fim de core/config.py ---

--- Início de core/dependencies.py (84 linhas) ---
# app/core/dependencies.py
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from motor.motor_asyncio import AsyncIOMotorDatabase
from typing import Annotated # Python 3.9+
import uuid

from app.db.mongodb_utils import get_database
from app.core.security import decode_token
from app.db import user_crud
from app.models.user import UserInDB, User # Import User para retorno

# Define o esquema OAuth2 para obter o token do header Authorization: Bearer <token>
# tokenUrl aponta para o nosso endpoint de login que gera o token
# O path relativo deve ser o correto APÓS o prefixo da API
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/v1/auth/login/access-token") # Ajuste se seu prefixo/rota for diferente

# Tipos anotados para dependências (mais legível)
DbDep = Annotated[AsyncIOMotorDatabase, Depends(get_database)]
TokenDep = Annotated[str, Depends(oauth2_scheme)]

async def get_current_user(
    db: DbDep,
    token: TokenDep # Obtém o token do header usando OAuth2PasswordBearer
) -> UserInDB: # Retorna o usuário completo do DB (incluindo senha hasheada)
               # Mude para 'User' se preferir retornar o modelo sem senha hasheada
    """
    Dependência para obter o usuário atual com base no token JWT:
    - Extrai e valida o token do header 'Authorization: Bearer <token>'.
    - Decodifica o token e obtém o ID do usuário ('sub').
    - Busca o usuário no banco de dados pelo ID.
    - Levanta exceção se o token for inválido, expirado ou o usuário não existir/estiver desativado.
    - Retorna o objeto do usuário encontrado.
    """
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Não foi possível validar as credenciais",
        headers={"WWW-Authenticate": "Bearer"},
    )

    # Decodifica o token JWT
    token_payload = decode_token(token)

    if token_payload is None or token_payload.sub is None:
         # Se decode_token retornou None, o token é inválido ou expirou
        raise credentials_exception

    # Tenta converter o 'sub' (subject/ID do usuário) para UUID
    try:
        user_id = uuid.UUID(str(token_payload.sub)) # Garante que sub seja tratado como string
    except ValueError:
         # O 'sub' no token não é um UUID válido
         raise credentials_exception

    # Busca o usuário no banco de dados usando o ID do token
    user = await user_crud.get_user_by_id(db=db, user_id=user_id)
    if user is None:
         # Usuário referenciado no token não existe mais no DB
         raise credentials_exception

    # Opcional: Poderia retornar o modelo User (sem hash de senha) aqui se preferir
    # return User.model_validate(user)
    return user # Retorna UserInDB (útil se precisarmos da info completa internamente)


async def get_current_active_user(
     # Esta dependência *reutiliza* a anterior
    current_user: Annotated[UserInDB, Depends(get_current_user)]
) -> UserInDB: # Mude para User se get_current_user retornar User
    """
    Dependência que garante que o usuário obtido de get_current_user
    não está desativado.
    """
    if current_user.disabled:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Usuário inativo")
    # Se passou, retorna o mesmo usuário validado
    # Poderia retornar User aqui também: User.model_validate(current_user)
    return current_user

# --- Tipos Anotados para Injeção ---
# Define tipos curtos para usar nos endpoints protegidos
CurrentUser = Annotated[UserInDB, Depends(get_current_active_user)]
# Use este se preferir retornar o modelo User sem a senha hasheada:
# CurrentUser = Annotated[User, Depends(get_current_active_user)] # Se get_current_active_user retornar User--- Fim de core/dependencies.py ---

--- Início de core/email.py (107 linhas) ---
# app/core/email.py
import logging
from pathlib import Path
from typing import List, Optional, Dict, Any
from fastapi_mail import FastMail, MessageSchema, ConnectionConfig, MessageType
from pydantic import EmailStr, BaseModel
from app.core.config import settings 

logger = logging.getLogger(__name__)

# --- Configuração da conexão ---
conf = ConnectionConfig(
    MAIL_USERNAME=settings.MAIL_USERNAME or "", 
    MAIL_PASSWORD=settings.MAIL_PASSWORD or "",
    MAIL_FROM=settings.MAIL_FROM or EmailStr("default@example.com"), 
    MAIL_PORT=settings.MAIL_PORT,
    MAIL_SERVER=settings.MAIL_SERVER or "",
    MAIL_FROM_NAME=settings.MAIL_FROM_NAME or "Default Sender",
    MAIL_STARTTLS=settings.MAIL_STARTTLS,
    MAIL_SSL_TLS=settings.MAIL_SSL_TLS,
    USE_CREDENTIALS=settings.USE_CREDENTIALS,
    VALIDATE_CERTS=settings.VALIDATE_CERTS,
    TEMPLATE_FOLDER=Path(settings.EMAIL_TEMPLATES_DIR) if settings.EMAIL_TEMPLATES_DIR else None, 
)

# Instância principal do FastMail
fm = FastMail(conf)

async def send_email_async(
    subject: str,
    recipient_to: List[EmailStr],
    body: Dict[str, Any], 
    template_name: Optional[str] = None, 
    plain_text_body: Optional[str] = None 
):
    """
    Envia um e-mail de forma assíncrona.

    Args:
        subject: Assunto do e-mail.
        recipient_to: Lista de destinatários.
        body: Dicionário com variáveis para preencher o template HTML.
        template_name: Nome do arquivo do template HTML (sem extensão, deve estar em EMAIL_TEMPLATES_DIR).
        plain_text_body: Conteúdo alternativo em texto puro.
    """
    if not settings.MAIL_ENABLED:
        logger.warning("Envio de e-mail desabilitado nas configurações (MAIL_ENABLED=false).")
        return

    if not all([settings.MAIL_USERNAME, settings.MAIL_PASSWORD, settings.MAIL_FROM, settings.MAIL_SERVER]):
        logger.error("Configurações essenciais de e-mail ausentes (USERNAME, PASSWORD, FROM, SERVER). Não foi possível enviar.")
        return

    message = MessageSchema(
        subject=subject,
        recipients=recipient_to,
        template_body=body if template_name else None, 
        body=plain_text_body if not template_name else None, 
        subtype=MessageType.html if template_name else MessageType.plain, 
    )

    try:
        logger.info(f"Tentando enviar e-mail para {recipient_to} com assunto '{subject}'...")
        await fm.send_message(message, template_name=template_name)
        logger.info(f"E-mail enviado com sucesso para {recipient_to}.")
    except Exception as e:
        logger.exception(f"Erro ao enviar e-mail para {recipient_to}: {e}")

# --- Funções utilitárias ---

async def send_urgent_task_notification(
    user_email: EmailStr,
    user_name: str,
    task_title: str,
    task_id: str,
    task_due_date: Optional[str],
    priority_score: float
):
    """Envia notificação de tarefa urgente."""

    subject = f"🚨 Tarefa Urgente no SmartTask: {task_title}"

    # Link para a tarefa
    task_link = f"{settings.FRONTEND_URL}/tasks/{task_id}" if settings.FRONTEND_URL else None

    # Corpo/Contexto para o template
    email_body_data = {
        "task_title": task_title,
        "user_name": user_name,
        "due_date": task_due_date or "N/A",
        "priority_score": f"{priority_score:.2f}", 
        "task_link": task_link,
        "project_name": settings.PROJECT_NAME
    }

    # Nome do template HTML (criaremos abaixo)
    template_name = "urgent_task.html"

    await send_email_async(
        subject=subject,
        recipient_to=[user_email],
        body=email_body_data,
        template_name=template_name,
        plain_text_body=f"Olá {user_name},\nA tarefa '{task_title}' no {settings.PROJECT_NAME} é considerada urgente.\n"
                       f"Prioridade: {priority_score:.2f}, Vencimento: {task_due_date or 'N/A'}.\n"
                       f"{'Acesse a tarefa aqui: ' + task_link if task_link else ''}"
    )--- Fim de core/email.py ---

--- Início de core/security.py (113 linhas) ---
# app/core/security.py
from datetime import datetime, timedelta, timezone
from typing import Any, Union, Optional
from passlib.context import CryptContext
from jose import jwt, JWTError
from pydantic import ValidationError # Para erros de validação de token

from app.core.config import settings # Importa configurações (SECRET_KEY, etc.)
from app.models.token import TokenPayload # Modelo para dados do payload

# --- Configuração do Hashing de Senha ---
# Define o contexto do passlib, especificando os esquemas de hash permitidos
# 'bcrypt' será o padrão para novas senhas. Outros são para senhas legadas (se houver)
# 'deprecated="auto"' significa que senhas com esquemas antigos serão automaticamente atualizadas para bcrypt no login
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

ALGORITHM = settings.JWT_ALGORITHM
ACCESS_TOKEN_EXPIRE_MINUTES = settings.ACCESS_TOKEN_EXPIRE_MINUTES

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """Verifica se a senha fornecida corresponde à senha hasheada."""
    try:
        return pwd_context.verify(plain_password, hashed_password)
    except ValueError: # Pode ocorrer se o hash não for reconhecido
         return False


def get_password_hash(password: str) -> str:
    """Gera o hash de uma senha usando bcrypt."""
    return pwd_context.hash(password)

# --- Funções JWT ---

def create_access_token(subject: Union[str, Any],username: str, expires_delta: Optional[timedelta] = None) -> str:
    """
    Cria um novo token de acesso JWT.

    Args:
        subject: O identificador único do sujeito do token (ex: user ID ou username).
        expires_delta: Tempo de vida do token. Se None, usa o padrão das configurações.

    Returns:
        O token JWT codificado como string.
    """
    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)

    # Garante que o subject (ID do usuário) seja uma string para o JWT
    # Embora Any seja aceito, geralmente é um ID (UUID, int, str)
    subject_str = str(subject)

    to_encode = {
        "exp": expire,
        "sub": subject_str, # User ID
        "username": username # Username
    }

    # Adicione outros dados ao payload se necessário (cuidado com o tamanho do token)
    # to_encode.update({"username": username_do_subject})

    encoded_jwt = jwt.encode(to_encode, settings.JWT_SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt


def decode_token(token: str) -> Optional[TokenPayload]:
    """
    Decodifica um token JWT e valida seu conteúdo.

    Args:
        token: O token JWT string.

    Returns:
        Um objeto TokenPayload com os dados do token se válido, None caso contrário.
    """
    try:
        # Decodifica o token
        payload = jwt.decode(
            token,
            settings.JWT_SECRET_KEY,
            algorithms=[ALGORITHM]
        )

        # Extrai os dados esperados (subject/user_id)
        # subject = payload.get("sub") # 'sub' é o id do usuário (UUID string)
        # username = payload.get("username") # Se incluímos o username no token

        # if subject is None: # or username is None:
        #     return None

        # Valida os dados do payload com o modelo Pydantic
        # Isso garante que os tipos e campos esperados estejam presentes
        token_data = TokenPayload.model_validate(payload)

        # Verifica se o token expirou (embora jwt.decode geralmente faça isso)
        if token_data.exp is not None:
             if datetime.now(timezone.utc) > datetime.fromtimestamp(token_data.exp, tz=timezone.utc):
                 # Poderia levantar uma exceção específica de expiração aqui
                 return None # Ou trate como inválido

        # Aqui poderíamos converter o 'sub' (string UUID) de volta para UUID se necessário
        # try:
        #     token_data.sub = uuid.UUID(token_data.sub)
        # except ValueError:
        #     return None # ID inválido no token

        return token_data

    except (JWTError, ValidationError, KeyError) as e:
        # Logar o erro `e` aqui seria útil para depuração
        print(f"Erro ao decodificar token: {e}") # Log de erro simples
        return None--- Fim de core/security.py ---

--- Início de core/utils.py (154 linhas) ---
# app/core/utils.py
from datetime import date, datetime, timezone
from typing import Any, Dict, Optional, TYPE_CHECKING
import math
from app.core.config import settings 
from app.models.task import Task
import httpx 
import json  
import logging 
import hmac   
import hashlib 

logger = logging.getLogger(__name__)

# --- Função de cálculo de prioridade ---
def calculate_priority_score(
    importance: int,
    due_date: Optional[date]
    ) -> Optional[float]:
    """
    Calcula a pontuação de prioridade de uma tarefa.

    Args:
        importance: Nível de importância da tarefa (ex: 1-5).
        due_date: Data de vencimento da tarefa (opcional).

    Returns:
        A pontuação de prioridade calculada, ou None se não aplicável.
        Retornaremos float para permitir scores não inteiros.
    """
    if not 1 <= importance <= 5:
         return None 

    # --- Importância
    importance_score = importance * settings.PRIORITY_WEIGHT_IMPORTANCE

    # --- Prazo
    due_date_score = 0.0 
    if due_date:
        today = date.today() 

        days_remaining = (due_date - today).days

        if days_remaining < 0: 
            due_date_score = settings.PRIORITY_SCORE_IF_OVERDUE

        elif days_remaining == 0: 
             due_date_score = settings.PRIORITY_WEIGHT_DUE_DATE / 1.0 

        elif days_remaining > 0:
            effective_days = max(1, days_remaining) 
            due_date_score = settings.PRIORITY_WEIGHT_DUE_DATE / effective_days
            importance_score = importance * settings.PRIORITY_WEIGHT_IMPORTANCE 

        else:
             due_date_score = 0.0

    elif settings.PRIORITY_DEFAULT_SCORE_NO_DUE_DATE is not None:
         due_date_score = settings.PRIORITY_DEFAULT_SCORE_NO_DUE_DATE

    # --- Combinar Scores
    total_score = round(due_date_score + importance_score, 2) 

    return total_score

# --- Função de tarefa urgente ---
def is_task_urgent(task: Task) -> bool:
    """Verifica se uma tarefa atende aos critérios de urgência para notificação."""
    # --- Critério 0: Tarefa deve ter um score ou prazo
    if task.priority_score is None and task.due_date is None:
         return False 

    # --- Critério 1: Score acima do limiar (e não None)
    if task.priority_score is not None and task.priority_score > settings.EMAIL_URGENCY_THRESHOLD:
        return True

    # --- Critério 2: Vence hoje ou está atrasada
    if task.due_date:
        today = date.today()
        days_remaining = (task.due_date - today).days
        if days_remaining <= 0:
            return True

    return False

# --- Função de Webhook ---
async def send_webhook_notification(
    event_type: str,
    task_data: Dict[str, Any] 
    ):
    """
    Envia uma notificação via webhook para a URL configurada (se houver).
    Executada em background.

    Args:
        event_type: Tipo do evento (ex: 'task.created', 'task.updated').
        task_data: Dados da tarefa como um dicionário Python.
    """
    if not settings.WEBHOOK_URL:
        logger.debug("Webhook URL não configurada, pulando envio.") 
        return 

    # Converter URL Pydantic para string
    webhook_url_str = str(settings.WEBHOOK_URL)

    payload = {
        "event": event_type,
        "task": task_data,
        "timestamp": datetime.now(timezone.utc).isoformat() 
    }

    headers = {
        "Content-Type": "application/json",
        "User-Agent": "SmartTask-Webhook-Client/1.0" 
    }

    # --- Segurança de Assinatura ---
    if settings.WEBHOOK_SECRET:
        try:
            payload_bytes = json.dumps(payload, separators=(',', ':'), sort_keys=True).encode('utf-8')
            secret_bytes = settings.WEBHOOK_SECRET.encode('utf-8')

            signature = hmac.new(secret_bytes, payload_bytes, hashlib.sha256).hexdigest()
            headers["X-SmartTask-Signature"] = f"sha256={signature}"
        except Exception as e:
             logger.error(f"Erro ao gerar assinatura HMAC para webhook: {e}")
             return 

    # --- Envio da Requisição HTTP ---
    try:
         async with httpx.AsyncClient() as client:
            logger.info(f"Enviando webhook evento '{event_type}' para {webhook_url_str}")
            response = await client.post(
                webhook_url_str,
                json=payload, 
                headers=headers,
                timeout=10.0 
            )

            response.raise_for_status()

            logger.info(f"Webhook enviado com sucesso para {webhook_url_str}. Status: {response.status_code}")

    except httpx.TimeoutException:
         logger.error(f"Timeout ao enviar webhook para {webhook_url_str}")
    except httpx.RequestError as exc:
         logger.error(f"Erro na requisição ao enviar webhook para {webhook_url_str}: {exc}")
    except httpx.HTTPStatusError as exc:
         logger.error(
             f"Erro no servidor do webhook ({webhook_url_str}). "
             f"Status: {exc.response.status_code}. Resposta: {exc.response.text[:200]}..." 
         )
    except Exception as e:
         logger.exception(f"Erro inesperado ao enviar webhook para {webhook_url_str}: {e}")--- Fim de core/utils.py ---

--- Início de db/mongodb_utils.py (61 linhas) ---
# app/db/mongodb_utils.py
from typing import Optional
import motor.motor_asyncio
from app.core.config import settings 
import logging
from motor.motor_asyncio import AsyncIOMotorDatabase

logger = logging.getLogger(__name__)

# Variáveis globais para o cliente e banco de dados
db_client: motor.motor_asyncio.AsyncIOMotorClient | None = None
db_instance: motor.motor_asyncio.AsyncIOMotorDatabase | None = None

async def connect_to_mongo() -> Optional[AsyncIOMotorDatabase]:
    """
    Conecta-se ao MongoDB na inicialização da aplicação.
    """
    global db_client, db_instance

    try:

        db_client = motor.motor_asyncio.AsyncIOMotorClient(
            settings.MONGODB_URL,
            serverSelectionTimeoutMS=5000 
        )
        await db_client.admin.command('ping')

        db_instance = db_client[settings.DATABASE_NAME]

        return db_instance
    
    except Exception as e:
        logger.error(f"Não foi possível conectar ao MongoDB: {e}")
        db_client = None
        db_instance = None
        return None

async def close_mongo_connection():
    """
    Fecha a conexão com o MongoDB no encerramento da aplicação.
    """
    global db_client
    if db_client:
        db_client.close()
    else:
        logger.warning("Tentativa de fechar conexão com MongoDB, mas cliente não estava inicializado.")

def get_database() -> motor.motor_asyncio.AsyncIOMotorDatabase:
    """
    Retorna a instância do banco de dados MongoDB.
    Pode ser usada como uma dependência FastAPI ou chamada diretamente.
    """
    if db_instance is None:
        logger.error("Tentativa de obter instância do DB antes da inicialização!")
        raise RuntimeError("A conexão com o banco de dados não foi inicializada.")
    return db_instance

# Você pode também querer uma função para obter coleções específicas:
# def get_task_collection() -> motor.motor_asyncio.AsyncIOMotorCollection:
#     db = get_database()
#     return db.get_collection("tasks") # Nome da coleção de tarefas--- Fim de db/mongodb_utils.py ---

--- Início de db/task_crud.py (7 linhas) ---
# app/db/task_crud.py

# Nome da coleção no MongoDB para tarefas
TASKS_COLLECTION = "tasks"

# Futuramente, podemos adicionar funções CRUD específicas para tarefas aqui,
# se quisermos centralizá-las como fizemos com os usuários.
--- Fim de db/task_crud.py ---

--- Início de db/user_crud.py (111 linhas) ---
# app/db/user_crud.py
import logging
from motor.motor_asyncio import AsyncIOMotorDatabase, AsyncIOMotorCollection
from typing import Optional, List
import uuid
from datetime import datetime, timezone
from pymongo.errors import DuplicateKeyError

from app.models.user import UserCreate, UserInDB, UserUpdate
from app.core.security import get_password_hash

from motor.motor_asyncio import AsyncIOMotorDatabase

# Nome da coleção de usuários
USERS_COLLECTION = "users"

# --- Funções CRUD para Usuários ---

async def get_user_by_id(db: AsyncIOMotorDatabase, user_id: uuid.UUID) -> Optional[UserInDB]:
    """Busca um usuário pelo seu ID (UUID)."""
    user_dict = await db[USERS_COLLECTION].find_one({"id": str(user_id)})
    if user_dict:
        user_dict.pop('_id', None) # Remove _id do mongo
        try:
             return UserInDB.model_validate(user_dict)
        except Exception: # Tratamento básico de erro de validação
             return None
    return None

async def get_user_by_username(db: AsyncIOMotorDatabase, username: str) -> Optional[UserInDB]:
    """Busca um usuário pelo seu nome de usuário."""
    # Index no 'username' é recomendado para performance
    user_dict = await db[USERS_COLLECTION].find_one({"username": username})
    if user_dict:
         user_dict.pop('_id', None)
         try:
            return UserInDB.model_validate(user_dict)
         except Exception:
            return None
    return None

async def get_user_by_email(db: AsyncIOMotorDatabase, email: str) -> Optional[UserInDB]:
    """Busca um usuário pelo seu e-mail."""
     # Index no 'email' é recomendado para performance e unicidade
    user_dict = await db[USERS_COLLECTION].find_one({"email": email})
    if user_dict:
        user_dict.pop('_id', None)
        try:
            return UserInDB.model_validate(user_dict)
        except Exception:
            return None
    return None

async def create_user(db: AsyncIOMotorDatabase, user_in: UserCreate) -> Optional[UserInDB]:
    """Cria um novo usuário no banco de dados."""
    hashed_password = get_password_hash(user_in.password)

    user_db_data = {
        "id": uuid.uuid4(),
        "username": user_in.username,
        "email": user_in.email,
        "hashed_password": hashed_password,
        "full_name": user_in.full_name,
        "disabled": False, # Novo usuário começa ativo
        "created_at": datetime.now(timezone.utc),
        "updated_at": None
    }
    # Tenta validar antes de inserir (boa prática)
    try:
        user_db_obj = UserInDB.model_validate(user_db_data)
    except Exception as validation_error:
        # Logar validation_error seria importante
        print(f"Erro de validação Pydantic ao criar user_db_obj: {validation_error}")
        return None # Ou levantar uma exceção customizada

    # Converte para dicionário para inserir no Mongo
    user_db_dict = user_db_obj.model_dump(mode="json")

    try:
        insert_result = await db[USERS_COLLECTION].insert_one(user_db_dict)
        if not insert_result.acknowledged:
             # Logar erro
             return None
         # Retorna o objeto UserInDB validado (não o dict)
        return user_db_obj
    except DuplicateKeyError:
        # Este erro ocorreria se tivéssemos índices únicos no Mongo
        # Vamos tratar isso no endpoint que chama esta função
        raise # Re-lança a exceção para ser tratada na rota
    except Exception as e:
         # Logar erro 'e'
         print(f"Erro inesperado ao inserir usuário no DB: {e}")
         return None


# Adicionar funções de update e delete se necessário
# async def update_user(...)
# async def delete_user(...)

# --- Configuração de Índices MongoDB (Importante!) ---
# Esta função pode ser chamada uma vez na inicialização da aplicação
# ou você pode criar os índices manualmente no Atlas/Mongo Shell.
async def create_user_indexes(db: AsyncIOMotorDatabase):
    """Cria índices únicos para username e email se não existirem."""
    collection = db[USERS_COLLECTION]
    try:
        await collection.create_index("username", unique=True, name="username_unique_idx")
        await collection.create_index("email", unique=True, name="email_unique_idx")
        logging.info("Índices de usuário ('username', 'email') verificados/criados.")
    except Exception as e:
        logging.error(f"Erro ao criar índices de usuário: {e}")--- Fim de db/user_crud.py ---

--- Início de main.py (66 linhas) ---
# app/main.py

# Importações
import logging
from fastapi import FastAPI
from fastapi.concurrency import asynccontextmanager
from app.routers import tasks
from app.routers import auth
from app.db.mongodb_utils import connect_to_mongo, close_mongo_connection
from app.db.user_crud import create_user_indexes
from app.core.config import settings

# Configuração básica de logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Gerenciador de contexto de vida útil (eventos startup/shutdown)
# Docs: https://fastapi.tiangolo.com/advanced/events/#lifespan
@asynccontextmanager
async def lifespan(app: FastAPI):
    db = await connect_to_mongo()
    app.state.db = db
    if app.state.db is not None:
         await create_user_indexes(app.state.db)

    yield
    
    await close_mongo_connection()
    
# Instância FastAPI
app = FastAPI(
    title="SmartTask API",
    description="API RESTful para gerenciamento de tarefas com prioridade inteligente.",
    version="0.1.0",
    contact={
        "name": "Eng. Soft. Cláudio",
        "url": "https://www.linkedin.com/in/claudiodelimatosta/", 
        "email": "claudiodelimatosta@gmail.com", 
    },
    license_info={
        "name": "MIT License",
        "url": "https://opensource.org/licenses/MIT",
    },
    lifespan=lifespan
)

# Inclusões
app.include_router(auth.router, prefix=f"{settings.API_V1_STR}/auth")
app.include_router(tasks.router, prefix=settings.API_V1_STR)


# Endpoint Raiz
@app.get("/", tags=["Root"]) 
async def read_root():
    return {"message": "Bem-vindo à {settings.PROJECT_NAME}!"}

# Adicione aqui mais endpoints e lógica da aplicação futuramente...

# (Para rodar localmente com Uvicorn, você usará o comando no terminal,
#  mas esta seção é útil se você fosse rodar o script diretamente)
if __name__ == "__main__":
    import uvicorn
    # Roda a aplicação usando o Uvicorn
    # host="0.0.0.0" permite acesso de fora do container/máquina local
    reload=True # reinicia o servidor automaticamente ao salvar alterações 
    uvicorn.run("main:app", host="0.0.0.0", port=8000, reload=True)--- Fim de main.py ---

--- Início de models/task.py (98 linhas) ---
# app/models/task.py

from pydantic import BaseModel, Field
from typing import Optional, List 
from datetime import date, datetime, timezone
import uuid 
from enum import Enum
from pydantic import ConfigDict

class TaskStatus(str, Enum):
    PENDING = "pendente"
    IN_PROGRESS = "em_progresso"
    COMPLETED = "concluída"
    CANCELLED = "cancelada"

# Modelo base para os campos comuns de uma tarefa
class TaskBase(BaseModel):
    title: str = Field(..., title="Título da Tarefa", min_length=3, max_length=100)
    description: Optional[str] = Field(None, title="Descrição Detalhada", max_length=500)
    importance: int = Field(..., ge=1, le=5, title="Importância (1-5)")
    due_date: Optional[date] = Field(None, title="Data de Vencimento")
    status: TaskStatus = Field(default=TaskStatus.PENDING, title="Status da Tarefa")
    tags: Optional[List[str]] = Field(None, title="Etiquetas/Tags")
    project: Optional[str] = Field(None, title="Projeto Associado")
    # owner_id: Optional[uuid.UUID] = Field(None, title="ID do Proprietário da Tarefa")
    model_config = {
        "json_schema_extra": {
            "examples": [
                {
                    "title": "Finalizar relatório mensal",
                    "description": "Compilar dados e escrever o relatório final.",
                    "importance": 4,
                    "due_date": "2024-08-15",
                    "status": "pendente",
                    "tags": ["relatorios", "financeiro"],
                    "project": "Relatórios Q3"
                    # owner_id não precisa estar no exemplo de criação base
                }
            ]
        }
    }

class TaskCreate(TaskBase):
    pass

class TaskUpdate(BaseModel):
    title: Optional[str] = Field(None, title="Título da Tarefa", min_length=3, max_length=100)
    description: Optional[str] = Field(None, title="Descrição Detalhada", max_length=500)
    importance: Optional[int] = Field(None, ge=1, le=5, title="Importância (1-5)")
    due_date: Optional[date] = Field(None, title="Data de Vencimento")
    status: Optional[TaskStatus] = Field(None, title="Status da Tarefa")
    tags: Optional[List[str]] = Field(None, title="Etiquetas/Tags")
    project: Optional[str] = Field(None, title="Projeto Associado")
    priority_score: Optional[float] = Field(None, title="Pontuação de Prioridade (para ajustes manuais, talvez?)")

    model_config = {
         "json_schema_extra": {
            "examples": [
                {
                    "title": "Revisar relatório mensal v2",
                    "status": TaskStatus.IN_PROGRESS,
                    "importance": 5
                }
            ]
        }
    }


class TaskInDBBase(TaskBase):
    id: uuid.UUID = Field(..., title="ID Único da Tarefa")
    owner_id: uuid.UUID = Field(..., title="ID do Proprietário da Tarefa")
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc), title="Data de Criação")
    updated_at: Optional[datetime] = Field(None, title="Data da Última Atualização")
    priority_score: Optional[float] = Field(None, title="Pontuação de Prioridade Calculada") 
    model_config = ConfigDict(from_attributes=True)

class Task(TaskInDBBase):
    model_config = ConfigDict(
         from_attributes=True, 
         json_schema_extra={ 
             "examples": [
                {
                    "id": "f47ac10b-58cc-4372-a567-0e02b2c3d479",
                    "owner_id": "a1b2c3d4-e5f6-7890-1234-567890abcdef", 
                    "title": "Finalizar relatório mensal",
                    "description": "Compilar dados e escrever o relatório final.",
                    "importance": 4,
                    "due_date": "2024-08-15",
                    "status": "pendente",
                    "tags": ["relatorios", "financeiro"],
                    "project": "Relatórios Q3",
                    "created_at": "2024-07-28T10:00:00Z",
                    "updated_at": None,
                    "priority_score": None 
                }
            ]
         }
     )--- Fim de models/task.py ---

--- Início de models/token.py (15 linhas) ---
# app/models/token.py
from pydantic import BaseModel, Field
from typing import Optional
import uuid

class Token(BaseModel):
    """Modelo para a resposta do token JWT."""
    access_token: str = Field(..., title="Token de Acesso JWT")
    token_type: str = Field(default="bearer", title="Tipo do Token")

class TokenPayload(BaseModel):
    """Modelo para os dados contidos no payload do JWT."""
    sub: uuid.UUID = Field(..., title="ID do Usuário (Subject)")
    username: str = Field(..., title="Nome de Usuário")
    exp: Optional[int] = Field(None, title="Timestamp de Expiração")
--- Fim de models/token.py ---

--- Início de models/user.py (63 linhas) ---
# app/models/user.py
from pydantic import BaseModel, Field, EmailStr, ConfigDict
from typing import Optional
import uuid
from datetime import datetime, timezone

class UserBase(BaseModel):
    """Campos base para um usuário."""
    email: EmailStr = Field(..., title="Endereço de E-mail", description="Deve ser um e-mail válido e único.")
    username: str = Field(..., title="Nome de Usuário", min_length=3, max_length=50, pattern="^[a-zA-Z0-9_]+$", description="Nome de usuário único (letras, números, underscore).")
    full_name: Optional[str] = Field(None, title="Nome Completo", max_length=100)
    disabled: bool = Field(default=False, title="Status Desativado", description="Indica se o usuário está desativado.")

class UserCreate(BaseModel):
    """Campos necessários para criar um novo usuário (recebido pela API)."""
    email: EmailStr = Field(..., title="Endereço de E-mail")
    username: str = Field(..., title="Nome de Usuário", min_length=3, max_length=50, pattern="^[a-zA-Z0-9_]+$")
    password: str = Field(..., title="Senha", min_length=8, description="Senha (será hasheada antes de salvar).")
    full_name: Optional[str] = Field(None, title="Nome Completo", max_length=100)

    model_config = {
        "json_schema_extra": {
            "examples": [
                {
                    "email": "johndoe@example.com",
                    "username": "johndoe",
                    "password": "averysecurepassword",
                    "full_name": "John Doe"
                }
            ]
        }
    }

class UserUpdate(BaseModel):
    """Campos que podem ser atualizados para um usuário."""
    email: Optional[EmailStr] = Field(None, title="Endereço de E-mail")
    full_name: Optional[str] = Field(None, title="Nome Completo", max_length=100)
    disabled: Optional[bool] = Field(None, title="Status Desativado")
    # Não permitimos atualizar username ou senha por este modelo geralmente
    # Senha teria um endpoint/processo separado

class UserInDBBase(UserBase):
    """Modelo de usuário como armazenado no banco, incluindo ID e senha hasheada."""
    id: uuid.UUID = Field(..., title="ID Único do Usuário")
    hashed_password: str = Field(..., title="Senha Hasheada")
    created_at: datetime = Field(default_factory=datetime.now(timezone.utc), title="Data de Criação")
    updated_at: Optional[datetime] = Field(None, title="Data da Última Atualização")

    # Configuração Pydantic v2 para permitir criação a partir de atributos de objeto (ex: do MongoDB)
    model_config = ConfigDict(from_attributes=True)

# Modelo que será retornado pela API (não inclui senha hasheada)
class User(UserBase):
    """Modelo de usuário para respostas da API (sem senha)."""
    id: uuid.UUID = Field(..., title="ID Único do Usuário")
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc), title="Data de Criação")
    updated_at: Optional[datetime] = Field(None, title="Data da Última Atualização")

    model_config = ConfigDict(from_attributes=True)

# Modelo para representar o usuário armazenado completamente no DB (para uso interno)
class UserInDB(UserInDBBase):
   pass--- Fim de models/user.py ---

--- Início de routers/auth.py (102 linhas) ---
# app/routers/auth.py
from fastapi import APIRouter, Depends, HTTPException, status, Body
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from motor.motor_asyncio import AsyncIOMotorDatabase
from pymongo.errors import DuplicateKeyError
from typing import Annotated
from app.db.mongodb_utils import get_database
from app.db import user_crud 
from app.models.user import User, UserCreate
from app.models.token import Token
from app.core.security import verify_password, create_access_token

router = APIRouter(
    tags=["Authentication"],
)

DbDep = Annotated[AsyncIOMotorDatabase, Depends(get_database)]

@router.post(
    "/register",
    response_model=User, 
    status_code=status.HTTP_201_CREATED,
    summary="Registra um novo usuário",
    response_description="O usuário recém-registrado.",
)
async def register_user(
    db: DbDep,
    user_in: Annotated[UserCreate, Body(description="Dados do novo usuário")]):
    """
    Registra um novo usuário no sistema:
    - Verifica se o username ou email já existem.
    - Hasheia a senha.
    - Salva o usuário no banco de dados.
    - Retorna os dados do usuário criado (sem a senha).
    """
    existing_user = await user_crud.get_user_by_username(db, user_in.username)
    if existing_user:
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=f"Usuário '{user_in.username}' já existe.",
        )
    existing_email = await user_crud.get_user_by_email(db, user_in.email)
    if existing_email:
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=f"E-mail '{user_in.email}' já registrado.",
        )

    try:
        created_user_db = await user_crud.create_user(db=db, user_in=user_in)
        if created_user_db is None:
            raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                                detail="Não foi possível criar o usuário.")
        return User.model_validate(created_user_db)
    except DuplicateKeyError:
         raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail="Usuário ou e-mail já registrado (conflito de índice único).",
         )
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                            detail="Ocorreu um erro inesperado durante o registro.")


@router.post(
    "/login/access-token",
    response_model=Token,
    summary="Obtém um token de acesso JWT",
    description="Autentica o usuário com username e senha (form data) e retorna um token JWT.",
)
async def login_for_access_token(
    db: DbDep,
    form_data: Annotated[OAuth2PasswordRequestForm, Depends()]
):
    """
    Endpoint de login padrão OAuth2:
    - Recebe `username` e `password` via form-data.
    - Busca o usuário pelo username.
    - Verifica se o usuário existe e se a senha está correta.
    - Verifica se o usuário não está desativado.
    - Cria e retorna um token de acesso JWT.
    """
    user = await user_crud.get_user_by_username(db, form_data.username)

    if not user or not verify_password(form_data.password, user.hashed_password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Usuário ou senha incorretos.",
            headers={"WWW-Authenticate": "Bearer"},
        )
    if user.disabled:
         raise HTTPException(
             status_code=status.HTTP_400_BAD_REQUEST,
             detail="Usuário inativo."
         )

    access_token = create_access_token(
        subject=user.id,
        username=user.username
        )

    return Token(access_token=access_token, token_type="bearer")--- Fim de routers/auth.py ---

--- Início de routers/tasks.py (434 linhas) ---
# app/routers/tasks.py

# --- Importações Essenciais ---
import logging
from typing import List, Optional, Annotated 
import uuid 
from datetime import date, datetime, timezone 

# --- Imports do FastAPI ---
from fastapi import (
    APIRouter, HTTPException, Body, status, Depends, Response, Query,
    BackgroundTasks
)

# --- Imports do MongoDB/Motor ---
from motor.motor_asyncio import AsyncIOMotorDatabase, AsyncIOMotorCollection
from pymongo import DESCENDING, ASCENDING
from pymongo.errors import DuplicateKeyError
from pydantic import ValidationError 

# --- Imports da Nossa Aplicação ---
from app.models.task import Task, TaskCreate, TaskUpdate, TaskStatus 
from app.db import task_crud 
from app.db.mongodb_utils import get_database 
from app.core.dependencies import CurrentUser
from app.models.user import UserInDB 
from app.core.utils import calculate_priority_score, is_task_urgent, send_webhook_notification 

# --- Instanciar Logger ---
logger = logging.getLogger(__name__)

# --- Configuração do Roteador ---
router = APIRouter(
    prefix="/tasks", 
    tags=["Tasks"], 
    responses={ 
        status.HTTP_404_NOT_FOUND: {"description": "Tarefa não encontrada"},
        status.HTTP_401_UNAUTHORIZED: {"description": "Não autorizado (Token inválido ou ausente)"},
        status.HTTP_403_FORBIDDEN: {"description": "Proibido (Usuário não tem permissão para este recurso)"}
    },
)

# --- Dependências Tipadas para Melhor Legibilidade ---
DbDep = Annotated[AsyncIOMotorDatabase, Depends(get_database)]

# Função auxiliar para obter a coleção de tarefas (simplifica injeção)
async def get_task_collection(db: DbDep) -> AsyncIOMotorCollection:
    """Retorna a coleção MongoDB 'tasks'."""
    return db[task_crud.TASKS_COLLECTION]
TaskCollectionDep = Annotated[AsyncIOMotorCollection, Depends(get_task_collection)]


# ==============================================================================
# --- ROTAS CRUD PROTEGIDAS PARA TAREFAS ---
# ==============================================================================

@router.post(
    "/",
    response_model=Task, 
    status_code=status.HTTP_201_CREATED, 
    summary="Cria uma nova tarefa",
    description="Cria uma nova tarefa associada ao usuário autenticado. A prioridade e owner_id são definidos automaticamente.",
    response_description="A tarefa recém-criada com todos os seus detalhes.",
)
async def create_task(
    task_in: Annotated[TaskCreate, Body(description="Dados da nova tarefa a ser criada")], 
    collection: TaskCollectionDep, 
    current_user: CurrentUser, 
    background_tasks: BackgroundTasks 
):
    """
    Endpoint para criar uma nova tarefa.

    - Recebe dados validados pelo modelo `TaskCreate`.
    - Calcula a `priority_score`.
    - Associa a tarefa ao `owner_id` do usuário logado.
    - Salva no MongoDB.
    - Envia notificações (e-mail, webhook) em background se necessário.
    - Retorna a tarefa criada.
    """
    # Converte dados de entrada Pydantic para dicionário, excluindo campos não enviados
    task_data = task_in.model_dump(exclude_unset=True)

    # --- Calcular Prioridade ---
    # Usa a função utilitária com os dados recebidos
    priority = calculate_priority_score(
        importance=task_in.importance,
        due_date=task_in.due_date
    )

    # --- Criar o objeto Tarefa completo para o DB ---
    task_db = Task(
        id=uuid.uuid4(),                  
        owner_id=current_user.id,          
        created_at=datetime.now(timezone.utc), 
        priority_score=priority,           
        **task_data                        
    )

    # Converte o objeto Pydantic para dicionário antes de inserir no MongoDB
    task_db_dict = task_db.model_dump(mode="json")

    try:
        # --- Inserir no Banco de Dados ---
        insert_result = await collection.insert_one(task_db_dict)
        if not insert_result.acknowledged:
             logger.error("Falha no ACK ao inserir tarefa no MongoDB.")
             raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                                detail="Falha ao salvar a tarefa no banco de dados.")

        # --- Disparar Tarefas em Background (Após Sucesso no DB) ---

        # 1. Webhook 
        task_dict_for_webhook = task_db.model_dump(mode="json") 
        background_tasks.add_task( 
             send_webhook_notification, 
             event_type="task.created",
             task_data=task_dict_for_webhook 
        )
        logger.info(f"Tarefa de webhook 'task.created' para {task_db.id} adicionada ao background.")

        # 2. Notificação por E-mail (se urgente e usuário configurado)
        # A lógica de envio de email em si não está implementada aqui, assumindo
        # que o worker ARQ cuida disso periodicamente.
        # Se quiséssemos enviar email *imediatamente* na criação/update:
        # if is_task_urgent(task_db):
        #     if current_user.email and current_user.full_name:
        #          background_tasks.add_task( # Também rodaria em background
        #              send_urgent_task_notification,
        #              user_email=current_user.email,
        #              # ... outros args ...
        #          )
        #          logger.info(f"Tarefa de email urgente para {task_db.id} adicionada ao background.")
        #     else:
        #          logger.warning(f"Usuário {current_user.id} sem e-mail/nome para notificação IMEDIATA da tarefa urgente {task_db.id}.")


    except DuplicateKeyError:
        logger.warning(f"Tentativa de criar tarefa duplicada para user {current_user.id}")
        raise HTTPException(status_code=status.HTTP_409_CONFLICT,
                            detail="Uma tarefa com identificador semelhante já existe para este usuário.")
    except Exception as e: 
        logger.exception(f"Erro inesperado ao criar tarefa ou agendar background tasks para user {current_user.id}: {e}")
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                            detail="Ocorreu um erro interno ao processar a criação da tarefa.")

    return task_db


@router.get(
    "/",
    response_model=List[Task],
    summary="Lista as tarefas do usuário autenticado",
    description="""Recupera uma lista de tarefas pertencentes ao usuário autenticado.
    Permite filtros por status, prazo (até uma data), projeto e tags (contendo todas).
    Permite ordenação por 'priority_score', 'due_date', 'created_at' ou 'importance'.""",
    response_description="Uma lista (possivelmente vazia) contendo as tarefas filtradas e ordenadas do usuário.",
)
async def list_tasks(
    collection: TaskCollectionDep,
    current_user: CurrentUser, 
    # --- Parâmetros de Filtro ---
    status_filter: Annotated[Optional[TaskStatus], Query(
        alias="status", title="Filtro por Status",
        description="Filtrar tarefas por um status específico."
    )] = None,
    due_before: Annotated[Optional[date], Query(
        title="Vencimento Antes De",
        description="Filtrar tarefas com prazo de vencimento até esta data (inclusive)."
    )] = None,
    project_filter: Annotated[Optional[str], Query(
        alias="project", title="Filtro por Projeto",
        description="Filtrar tarefas por nome exato do projeto.", min_length=1
    )] = None,
    tags_filter: Annotated[Optional[List[str]], Query(
        alias="tag", title="Filtro por Tags (AND)",
        description="Filtrar tarefas que contenham TODAS as tags especificadas (usar ?tag=t1&tag=t2).", min_length=1
    )] = None,
    # --- Parâmetros de Ordenação ---
    sort_by: Annotated[Optional[str], Query(
        title="Ordenar Por",
        description="Campo para ordenar: 'priority_score', 'due_date', 'created_at', 'importance'.",
        enum=["priority_score", "due_date", "created_at", "importance"] 
    )] = None,
    sort_order: Annotated[Optional[str], Query(
        title="Ordem",
        description="Ordem da ordenação: 'asc' ou 'desc'.",
        enum=["asc", "desc"] 
    )] = "desc", 
    # --- Parâmetros de Paginação ---
    limit: Annotated[int, Query(ge=1, le=1000, title="Limite de Resultados", description="Número máximo de tarefas a retornar.")] = 100,
    skip: Annotated[int, Query(ge=0, title="Pular Resultados", description="Número de tarefas a pular (para paginação).")] = 0,
):
    """
    Endpoint para listar tarefas do usuário autenticado com filtros, ordenação e paginação.
    """
    query = {"owner_id": str(current_user.id)}

    # --- Adicionar Filtros Opcionais à Query MongoDB ---
    if status_filter:
        query["status"] = status_filter.value 
    if due_before:
        query["due_date"] = {"$lte": datetime.combine(due_before, datetime.min.time(), tzinfo=timezone.utc)} 
    if project_filter:
        query["project"] = project_filter 
    if tags_filter:
        query["tags"] = {"$all": tags_filter}

    # --- Determinar Campo e Ordem de Ordenação ---
    sort_tuple = None
    if sort_by in ["priority_score", "due_date", "created_at", "importance"]:
        mongo_order = DESCENDING if sort_order.lower() == "desc" else ASCENDING
        sort_tuple = (sort_by, mongo_order)

    # --- Executar Query com Paginação e Ordenação ---
    try:
        tasks_cursor = collection.find(query).skip(skip).limit(limit)
        if sort_tuple:
            tasks_cursor = tasks_cursor.sort([sort_tuple]) 

        # --- Processar e Validar Resultados ---
        validated_tasks = []
        async for task_dict in tasks_cursor:
            task_dict.pop('_id', None) 
            try:
                # Valida cada dicionário retornado com o modelo Pydantic Task
                validated_tasks.append(Task.model_validate(task_dict))
            except (ValidationError, Exception) as e:
                logger.error(f"Erro ao validar tarefa do DB (list {current_user.id}): {task_dict} - Erro: {e}")
                # Em produção, decidir se continua ou retorna erro parcial
                continue # Pula tarefa inválida por enquanto

        return validated_tasks

    except Exception as e: 
        logger.exception(f"Erro ao buscar/processar tarefas para user {current_user.id} com query {query}: {e}")
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                            detail="Ocorreu um erro interno ao buscar as tarefas.")


@router.get(
    "/{task_id}",
    response_model=Task,
    summary="Busca uma tarefa específica por ID",
    description="Recupera os detalhes de uma tarefa específica, **se** ela pertencer ao usuário autenticado.",
    response_description="Os detalhes completos da tarefa encontrada.",
    responses={status.HTTP_403_FORBIDDEN: {"description": "Acesso negado a esta tarefa"}}
)
async def get_task(
    task_id: uuid.UUID, 
    collection: TaskCollectionDep,
    current_user: CurrentUser 
):
    """
    Endpoint para buscar uma única tarefa pelo seu ID (UUID).
    Apenas retorna a tarefa se o ID for encontrado E pertencer ao usuário logado.
    """
    # Busca no MongoDB usando o ID da tarefa e o ID do usuário logado
    task_dict = await collection.find_one({
        "id": str(task_id),          
        "owner_id": str(current_user.id) 
    })

    if task_dict:
        task_dict.pop('_id', None) 
        try:
            # Valida os dados do DB com o modelo Pydantic Task
            return Task.model_validate(task_dict)
        except (ValidationError, Exception) as e:
            logger.error(f"Erro ao validar tarefa {task_id} do DB para user {current_user.id}: {e}")
            # Pode indicar inconsistência de dados no DB
            raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                                detail="Erro ao processar dados da tarefa encontrada.")
    else:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND,
                            detail=f"Tarefa com ID {task_id} não encontrada.")


@router.put(
    "/{task_id}",
    response_model=Task,
    summary="Atualiza uma tarefa existente",
    description="Atualiza os campos de uma tarefa existente, **se** ela pertencer ao usuário autenticado. A prioridade é recalculada se necessário.",
    response_description="Os detalhes completos da tarefa atualizada.",
    responses={status.HTTP_403_FORBIDDEN: {"description": "Acesso negado a esta tarefa"}}
)
async def update_task(
    task_id: uuid.UUID, 
    task_update: Annotated[TaskUpdate, Body(description="Campos da tarefa a serem atualizados")], 
    collection: TaskCollectionDep,
    current_user: CurrentUser,
    background_tasks: BackgroundTasks 
):
    """
    Endpoint para atualizar campos específicos de uma tarefa.

    - Verifica se a tarefa pertence ao usuário.
    - Recebe dados validados pelo modelo `TaskUpdate`.
    - Recalcula `priority_score` se `importance` ou `due_date` mudarem.
    - Atualiza o campo `updated_at`.
    - Salva as alterações no MongoDB.
    - Envia webhook em background.
    - Retorna a tarefa completa e atualizada.
    """
    # --- Garantir que a tarefa existe e pertence ao usuário antes de prosseguir ---
    existing_task_dict = await collection.find_one({
        "id": str(task_id),
        "owner_id": str(current_user.id)
    })
    if not existing_task_dict:
        # Levanta 404 (ou 403 se preferíssemos verificar a existência geral)
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND,
                             detail=f"Tarefa {task_id} não encontrada ou não pertence a você.")

    # Validar tarefa existente para fácil acesso aos campos com tipos corretos
    try:
         existing_task = Task.model_validate(existing_task_dict)
    except Exception:
        logger.exception(f"Erro ao validar dados da tarefa existente {task_id} antes do update.")
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                                detail="Erro interno ao processar dados da tarefa existente.")

    # --- Preparar Dados para Atualização ---
    # Pega apenas os campos que foram explicitamente enviados no request 
    update_data = task_update.model_dump(exclude_unset=True, exclude={"owner_id"}) 

    # Se nenhum campo válido foi enviado para atualização
    if not update_data:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST,
                            detail="Nenhum campo válido fornecido para atualização.")

    # --- Recalcular Prioridade (se necessário) ---
    should_recalculate_priority = False
    current_importance = existing_task.importance
    current_due_date = existing_task.due_date

    # Verifica se os campos relevantes para prioridade foram enviados na atualização
    if "importance" in update_data and update_data["importance"] != current_importance:
        current_importance = update_data["importance"] 
        should_recalculate_priority = True
    if "due_date" in update_data:
        new_due_date_obj = update_data["due_date"] 
        if new_due_date_obj != current_due_date:
            current_due_date = new_due_date_obj 
            should_recalculate_priority = True

    # Recalcula se algum dos campos chave mudou
    if should_recalculate_priority:
         priority = calculate_priority_score(
            importance=current_importance,
            due_date=current_due_date     
         )
         update_data["priority_score"] = priority 
         logger.info(f"Recalculada prioridade para tarefa {task_id} para: {priority}")

    # --- Definir Timestamp de Atualização ---
    update_data["updated_at"] = datetime.now(timezone.utc)

    # --- Executar Atualização Atômica no Banco de Dados ---
    try:
        updated_task_dict_raw = await collection.find_one_and_update(
            {"id": str(task_id), "owner_id": str(current_user.id)}, 
            {"$set": update_data}, 
            return_document=True 
        )

        if not updated_task_dict_raw:
             logger.error(f"Falha ao encontrar a tarefa {task_id} durante find_one_and_update, após verificação inicial.")
             raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f"Tarefa {task_id} não encontrada durante a atualização.")

        # --- Processar Resultado e Enviar Webhook ---
        updated_task_dict_raw.pop('_id', None)
        try:
            updated_task = Task.model_validate(updated_task_dict_raw) 

            # Enviar Webhook em Background
            task_dict_for_webhook = updated_task.model_dump(mode="json")
            background_tasks.add_task(
                send_webhook_notification,
                event_type="task.updated",
                task_data=task_dict_for_webhook
            )
            logger.info(f"Tarefa de webhook 'task.updated' para {updated_task.id} adicionada ao background.")

            # Notificação por e-mail imediata poderia ser adicionada aqui também (via background_tasks) se necessário

            return updated_task 

        except (ValidationError, Exception) as e:
             logger.error(f"Erro ao validar tarefa atualizada do DB (ID: {task_id}) para user {current_user.id}: {e}")
             # Se a validação falhar após o update, indica um problema sério
             raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                                 detail="Erro ao processar dados da tarefa após atualização.")

    except Exception as e: 
         logger.exception(f"Erro ao atualizar tarefa {task_id} ou agendar background tasks: {e}")
         raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                             detail="Erro interno ao processar atualização da tarefa.")



@router.delete(
    "/{task_id}",
    status_code=status.HTTP_204_NO_CONTENT, 
    summary="Deleta uma tarefa",
    description="Remove permanentemente uma tarefa do banco de dados, **se** ela pertencer ao usuário autenticado.",
    # Documenta explicitamente os erros além dos globais
    responses={
        status.HTTP_404_NOT_FOUND: {"description": "Tarefa não encontrada ou não pertence a você"},
        status.HTTP_403_FORBIDDEN: {"description": "Acesso negado a esta tarefa"},
        status.HTTP_204_NO_CONTENT: {"description": "Tarefa deletada com sucesso (sem corpo de resposta)"},
    }
)
async def delete_task(
    task_id: uuid.UUID,
    collection: TaskCollectionDep,
    current_user: CurrentUser 
    # Nota: Não precisamos de BackgroundTasks aqui, mas poderia ter para um evento 'task.deleted'
):
    """
    Endpoint para deletar uma tarefa.
    Só permite deletar tarefas que pertencem ao usuário logado.
    """
    # Tenta deletar o documento que combina ID da tarefa E ID do usuário
    delete_result = await collection.delete_one({
        "id": str(task_id),
        "owner_id": str(current_user.id) 
    })

    # Verifica se algum documento foi realmente deletado
    if delete_result.deleted_count == 0:
         raise HTTPException(status_code=status.HTTP_404_NOT_FOUND,
                            detail=f"Tarefa com ID {task_id} não encontrada ou não pertence a você.")
    return Response(status_code=status.HTTP_204_NO_CONTENT)--- Fim de routers/tasks.py ---

--- Início de worker.py (133 linhas) ---
# app/worker.py
import asyncio
import logging
from datetime import date, datetime
from typing import Dict, Any, Optional
from motor.motor_asyncio import AsyncIOMotorDatabase 
from arq import cron
from arq.connections import RedisSettings
from redis.asyncio import Redis
from app.core.config import settings
from app.db.mongodb_utils import connect_to_mongo, close_mongo_connection, get_database 
from app.db import user_crud, task_crud 
from app.core.email import send_urgent_task_notification
from app.core.utils import is_task_urgent
from app.models.task import Task, TaskStatus 

logger = logging.getLogger("arq.worker")

# === FUNÇÃO DA TAREFA PERIÓDICA ===
# Será chamada pelo scheduler do ARQ
async def check_and_notify_urgent_tasks(ctx: Dict[str, Any]):
    """
    Tarefa periódica que busca tarefas urgentes e notifica os usuários.
    'ctx' é um dicionário passado pelo worker ARQ, contém recursos como conexão DB.
    """
    logger.info("Executando verificação de tarefas urgentes...")
    db: Optional[AsyncIOMotorDatabase] = ctx.get("db")

    if db is None:
         logger.error("Conexão com o banco de dados não disponível no contexto ARQ.")
         return

    tasks_collection = db[task_crud.TASKS_COLLECTION] 
    users_collection = db[user_crud.USERS_COLLECTION] 

    # --- Critérios de Busca no MongoDB ---
    # 1. Tarefas não concluídas ou canceladas
    # 2. Com priority_score > threshold OU com due_date <= hoje
    today_start = datetime.combine(date.today(), datetime.min.time()) 

    query = {
        "status": {"$nin": [TaskStatus.COMPLETED.value, TaskStatus.CANCELLED.value]},
        "$or": [
            {"priority_score": {"$gt": settings.EMAIL_URGENCY_THRESHOLD}},
            {"due_date": {"$lte": today_start}} 
        ]
    }

    urgent_tasks_cursor = tasks_collection.find(query)
    count = 0

    async for task_dict in urgent_tasks_cursor:
        task_dict.pop('_id', None)
        try:
             task = Task.model_validate(task_dict) 

             user = await user_crud.get_user_by_id(db, task.owner_id)

             if user and user.email and user.full_name and not user.disabled:
                logger.info(f"Tarefa urgente encontrada ({task.id}), notificando usuário {user.email}...")

                await send_urgent_task_notification(
                     user_email=user.email,
                     user_name=user.full_name,
                     task_title=task.title,
                     task_id=str(task.id),
                     task_due_date=str(task.due_date) if task.due_date else None,
                     priority_score=task.priority_score or 0.0
                 )
                count += 1
             elif not user:
                logger.warning(f"Usuário {task.owner_id} da tarefa urgente {task.id} não encontrado.")
             elif user and user.disabled:
                 logger.info(f"Usuário {user.username} da tarefa urgente {task.id} está desabilitado. Notificação não enviada.")
             else: 
                 logger.warning(f"Usuário {user.username} da tarefa urgente {task.id} sem e-mail ou nome completo. Notificação não enviada.")

        except Exception as e:
            logger.exception(f"Erro ao processar tarefa urgente {task_dict.get('id')}: {e}")
            continue 

    logger.info(f"Verificação de tarefas urgentes concluída. {count} notificações enviadas.")


# === CONFIGURAÇÕES DO WORKER ARQ ===
async def startup(ctx: Dict[str, Any]):
    """Função executada quando o worker ARQ inicia."""
    logger.info("Iniciando worker ARQ...")
    db_instance = await connect_to_mongo()
    if db_instance is not None:
         ctx["db"] = db_instance 
         logger.info("Conexão MongoDB estabelecida para o worker ARQ.")
    else:
         logger.error("Falha ao conectar ao MongoDB no startup do worker ARQ.")
         ctx["db"] = None


async def shutdown(ctx: Dict[str, Any]):
    """Função executada quando o worker ARQ termina."""
    logger.info("Encerrando worker ARQ...")
    if ctx.get("db")is not None:
        await close_mongo_connection() 
        logger.info("Conexão MongoDB fechada pelo worker ARQ.")

# Classe de configurações do worker para ARQ
# ARQ procurará por esta classe quando executarmos o worker
class WorkerSettings:
    on_startup = startup
    on_shutdown = shutdown

    # --- Consulta à lista de tarefas agendadas ---
    cron_jobs = [
        cron(check_and_notify_urgent_tasks, minute={*range(0, 60, 1)}, run_at_startup=True),
        cron(check_and_notify_urgent_tasks, hour=8, minute=0),
    ]

    # --- Configurações do Redis ---
    if settings.REDIS_URL:
        try:
             redis_settings: RedisSettings = RedisSettings(
                 host=settings.REDIS_URL.host or 'localhost', 
                 port=int(settings.REDIS_URL.port) if settings.REDIS_URL.port else 6379,
                 database=int(settings.REDIS_URL.path[1:]) if settings.REDIS_URL.path and settings.REDIS_URL.path != '/' else 0, 
                 password=settings.REDIS_URL.password, 
                 # conn_timeout=10,
                 # conn_retries=5,
                 # conn_retry_delay=1,
            )
        except Exception as e:
             logger.exception(f"Erro ao configurar RedisSettings a partir da URL: {settings.REDIS_URL} - Erro: {e}")
             raise ValueError(f"Erro ao processar REDIS_URL: {e}")
    else:
         raise ValueError("REDIS_URL não está definida nas configurações, worker ARQ não pode iniciar.")--- Fim de worker.py ---
