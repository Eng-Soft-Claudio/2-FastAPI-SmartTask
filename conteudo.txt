
--- In√≠cio de core/config.py (140 linhas) ---
# app/core/config.py
import os
from pydantic_settings import BaseSettings
from pydantic import EmailStr, Field, RedisDsn, model_validator, HttpUrl
from typing import Optional
from dotenv import load_dotenv
import logging

logger = logging.getLogger(__name__)

# --- Carrega vari√°veis do .env ---
dotenv_path = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), '.env')
loaded = load_dotenv(dotenv_path=dotenv_path)

class Settings(BaseSettings):
    """
    Configura√ß√µes da aplica√ß√£o lidas do ambiente.
    Docs Pydantic Settings: https://docs.pydantic.dev/latest/concepts/pydantic_settings/
    """
    PROJECT_NAME: str = Field("SmartTask API", description="Nome do Projeto")
    API_V1_STR: str = Field("/api/v1", description="Prefixo para a vers√£o 1 da API")

    # --- Configura√ß√µes MongoDB ---
    MONGODB_URL: str = Field(..., env="MONGODB_URL", description="URL de conex√£o do MongoDB")
    DATABASE_NAME: str = Field("smarttask_db", description="Nome do banco de dados MongoDB")

     # --- Configura√ß√µes JWT ---
    JWT_SECRET_KEY: str = Field(..., env="JWT_SECRET_KEY", description="Chave secreta para assinar tokens JWT")
    JWT_ALGORITHM: str = Field("HS256", env="JWT_ALGORITHM", description="Algoritmo de assinatura JWT")
    ACCESS_TOKEN_EXPIRE_MINUTES: int = Field(60 * 24 * 7, env="ACCESS_TOKEN_EXPIRE_MINUTES", description="Validade do token de acesso (minutos)") # Ex: 7 dias

    # --- Configura√ß√µes de Prioridade ---
    PRIORITY_WEIGHT_DUE_DATE: float = Field(
        100.0, 
        env="PRIORITY_WEIGHT_DUE_DATE",
        description="Peso para o componente de prazo no c√°lculo de prioridade."
    )
    PRIORITY_WEIGHT_IMPORTANCE: float = Field(
        10.0, 
        env="PRIORITY_WEIGHT_IMPORTANCE",
        description="Peso (multiplicador) para o componente de import√¢ncia no c√°lculo de prioridade."
    )
    PRIORITY_DEFAULT_SCORE_NO_DUE_DATE: Optional[float] = Field(
        0.0, 
        env="PRIORITY_DEFAULT_SCORE_NO_DUE_DATE",
        description="Pontua√ß√£o base de prazo para tarefas sem data de vencimento (pode ser None ou 0)."
    )
    PRIORITY_SCORE_IF_OVERDUE: float = Field(
        1000.0, 
        env="PRIORITY_SCORE_IF_OVERDUE",
        description="Pontua√ß√£o (ou fator aditivo/multiplicativo) especial para tarefas atrasadas."
    )

    # --- Configura√ß√£o Webhook ---
    WEBHOOK_URL: Optional[HttpUrl] = Field(
        None,
        env="WEBHOOK_URL",
        description="URL opcional para enviar notifica√ß√µes de eventos de tarefas (webhooks)."
    )
    # Segredo para assinar requests de webhook (HMAC)
    WEBHOOK_SECRET: Optional[str] = Field(
        None,
        env="WEBHOOK_SECRET",
        description="Segredo opcional usado para assinar payloads de webhook para verifica√ß√£o."
    )

    # --- Configura√ß√µes de E-mail ---
    MAIL_ENABLED: bool = Field(
            default=True,
            env="MAIL_ENABLED",
            description="Flag para habilitar/desabilitar envio de e-mails globalmente."
        )
    MAIL_USERNAME: Optional[str] = Field(None, env="MAIL_USERNAME", description="Usu√°rio do servidor SMTP.")
    MAIL_PASSWORD: Optional[str] = Field(None, env="MAIL_PASSWORD", description="Senha do servidor SMTP.")
    MAIL_FROM: Optional[EmailStr] = Field(
        None,
        env="MAIL_FROM",
        description="Endere√ßo de e-mail remetente."
        )
    MAIL_FROM_NAME: Optional[str] = Field(
        "SmartTask Notifica√ß√µes", 
        env="MAIL_FROM_NAME",
        description="Nome do remetente exibido no e-mail."
        )
    MAIL_PORT: int = Field(
        587,
        env="MAIL_PORT",
        description="Porta do servidor SMTP."
        )
    MAIL_SERVER: Optional[str] = Field(
        None,
        env="MAIL_SERVER",
        description="Endere√ßo do servidor SMTP."
        )
    # Configura√ß√µes para fastapi-mail
    MAIL_STARTTLS: bool = Field(True, env="MAIL_STARTTLS") 
    MAIL_SSL_TLS: bool = Field(False, env="MAIL_SSL_TLS") 
    USE_CREDENTIALS: bool = Field(True, env="USE_CREDENTIALS")
    VALIDATE_CERTS: bool = Field(True, env="VALIDATE_CERTS") 

    # --- Configura√ß√µes Adicionais (Templates, Limiar) ---
    EMAIL_TEMPLATES_DIR: str = Field("app/email-templates/build", description="Diret√≥rio de templates de e-mail compilados.") # Definiremos isso
    EMAIL_URGENCY_THRESHOLD: float = Field(
        100.0, 
        env="EMAIL_URGENCY_THRESHOLD",
        description="Limiar de priority_score para considerar uma tarefa urgente para notifica√ß√£o."
        )
    FRONTEND_URL: Optional[str] = Field(None, env="FRONTEND_URL", description="URL base do frontend para links no e-mail (se houver).") # Ex: http://localhost:3000

     # --- Configura√ß√£o Redis ---
    REDIS_URL: Optional[RedisDsn] = Field(
        None, 
        env="REDIS_URL",
        description="URL de conex√£o do Redis para filas de tarefas (ARQ)."
    )

    # --- Configura√ß√µes CORS ---

    # --- Configura√ß√£o Pydantic (case-insensitive)---
    model_config = {
        "case_sensitive": False,
    }

# --- Valida√ß√£o ---
    @model_validator(mode='after')
    def check_mail_config(self) -> 'Settings':
        if self.MAIL_ENABLED and not all([self.MAIL_USERNAME, self.MAIL_PASSWORD, self.MAIL_FROM, self.MAIL_SERVER]):
            raise ValueError(
                "Se MAIL_ENABLED for True, MAIL_USERNAME, MAIL_PASSWORD, MAIL_FROM e MAIL_SERVER devem ser definidos."
            )
        return self

# --- Cria a inst√¢ncia ---
try:
    settings = Settings()
except ValueError as e:
     raise e 
# Valida√ß√£o extra da inst√¢ncia
if settings.WEBHOOK_URL and not isinstance(settings.WEBHOOK_URL, HttpUrl):
     logger.warning(f"WEBHOOK_URL '{settings.WEBHOOK_URL}' n√£o parece ser uma URL v√°lida.")
--- Fim de core/config.py ---

--- In√≠cio de core/dependencies.py (84 linhas) ---
# app/core/dependencies.py
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from motor.motor_asyncio import AsyncIOMotorDatabase
from typing import Annotated # Python 3.9+
import uuid

from app.db.mongodb_utils import get_database
from app.core.security import decode_token
from app.db import user_crud
from app.models.user import UserInDB, User # Import User para retorno

# Define o esquema OAuth2 para obter o token do header Authorization: Bearer <token>
# tokenUrl aponta para o nosso endpoint de login que gera o token
# O path relativo deve ser o correto AP√ìS o prefixo da API
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/v1/auth/login/access-token") # Ajuste se seu prefixo/rota for diferente

# Tipos anotados para depend√™ncias (mais leg√≠vel)
DbDep = Annotated[AsyncIOMotorDatabase, Depends(get_database)]
TokenDep = Annotated[str, Depends(oauth2_scheme)]

async def get_current_user(
    db: DbDep,
    token: TokenDep # Obt√©m o token do header usando OAuth2PasswordBearer
) -> UserInDB: # Retorna o usu√°rio completo do DB (incluindo senha hasheada)
               # Mude para 'User' se preferir retornar o modelo sem senha hasheada
    """
    Depend√™ncia para obter o usu√°rio atual com base no token JWT:
    - Extrai e valida o token do header 'Authorization: Bearer <token>'.
    - Decodifica o token e obt√©m o ID do usu√°rio ('sub').
    - Busca o usu√°rio no banco de dados pelo ID.
    - Levanta exce√ß√£o se o token for inv√°lido, expirado ou o usu√°rio n√£o existir/estiver desativado.
    - Retorna o objeto do usu√°rio encontrado.
    """
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="N√£o foi poss√≠vel validar as credenciais",
        headers={"WWW-Authenticate": "Bearer"},
    )

    # Decodifica o token JWT
    token_payload = decode_token(token)

    if token_payload is None or token_payload.sub is None:
         # Se decode_token retornou None, o token √© inv√°lido ou expirou
        raise credentials_exception

    # Tenta converter o 'sub' (subject/ID do usu√°rio) para UUID
    try:
        user_id = uuid.UUID(str(token_payload.sub)) # Garante que sub seja tratado como string
    except ValueError:
         # O 'sub' no token n√£o √© um UUID v√°lido
         raise credentials_exception

    # Busca o usu√°rio no banco de dados usando o ID do token
    user = await user_crud.get_user_by_id(db=db, user_id=user_id)
    if user is None:
         # Usu√°rio referenciado no token n√£o existe mais no DB
         raise credentials_exception

    # Opcional: Poderia retornar o modelo User (sem hash de senha) aqui se preferir
    # return User.model_validate(user)
    return user # Retorna UserInDB (√∫til se precisarmos da info completa internamente)


async def get_current_active_user(
     # Esta depend√™ncia *reutiliza* a anterior
    current_user: Annotated[UserInDB, Depends(get_current_user)]
) -> UserInDB: # Mude para User se get_current_user retornar User
    """
    Depend√™ncia que garante que o usu√°rio obtido de get_current_user
    n√£o est√° desativado.
    """
    if current_user.disabled:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Usu√°rio inativo")
    # Se passou, retorna o mesmo usu√°rio validado
    # Poderia retornar User aqui tamb√©m: User.model_validate(current_user)
    return current_user

# --- Tipos Anotados para Inje√ß√£o ---
# Define tipos curtos para usar nos endpoints protegidos
CurrentUser = Annotated[UserInDB, Depends(get_current_active_user)]
# Use este se preferir retornar o modelo User sem a senha hasheada:
# CurrentUser = Annotated[User, Depends(get_current_active_user)] # Se get_current_active_user retornar User--- Fim de core/dependencies.py ---

--- In√≠cio de core/email.py (107 linhas) ---
# app/core/email.py
import logging
from pathlib import Path
from typing import List, Optional, Dict, Any
from fastapi_mail import FastMail, MessageSchema, ConnectionConfig, MessageType
from pydantic import EmailStr, BaseModel
from app.core.config import settings 

logger = logging.getLogger(__name__)

# --- Configura√ß√£o da conex√£o ---
conf = ConnectionConfig(
    MAIL_USERNAME=settings.MAIL_USERNAME or "", 
    MAIL_PASSWORD=settings.MAIL_PASSWORD or "",
    MAIL_FROM=settings.MAIL_FROM or EmailStr("default@example.com"), 
    MAIL_PORT=settings.MAIL_PORT,
    MAIL_SERVER=settings.MAIL_SERVER or "",
    MAIL_FROM_NAME=settings.MAIL_FROM_NAME or "Default Sender",
    MAIL_STARTTLS=settings.MAIL_STARTTLS,
    MAIL_SSL_TLS=settings.MAIL_SSL_TLS,
    USE_CREDENTIALS=settings.USE_CREDENTIALS,
    VALIDATE_CERTS=settings.VALIDATE_CERTS,
    TEMPLATE_FOLDER=Path(settings.EMAIL_TEMPLATES_DIR) if settings.EMAIL_TEMPLATES_DIR else None, 
)

# Inst√¢ncia principal do FastMail
fm = FastMail(conf)

async def send_email_async(
    subject: str,
    recipient_to: List[EmailStr],
    body: Dict[str, Any], 
    template_name: Optional[str] = None, 
    plain_text_body: Optional[str] = None 
):
    """
    Envia um e-mail de forma ass√≠ncrona.

    Args:
        subject: Assunto do e-mail.
        recipient_to: Lista de destinat√°rios.
        body: Dicion√°rio com vari√°veis para preencher o template HTML.
        template_name: Nome do arquivo do template HTML (sem extens√£o, deve estar em EMAIL_TEMPLATES_DIR).
        plain_text_body: Conte√∫do alternativo em texto puro.
    """
    if not settings.MAIL_ENABLED:
        logger.warning("Envio de e-mail desabilitado nas configura√ß√µes (MAIL_ENABLED=false).")
        return

    if not all([settings.MAIL_USERNAME, settings.MAIL_PASSWORD, settings.MAIL_FROM, settings.MAIL_SERVER]):
        logger.error("Configura√ß√µes essenciais de e-mail ausentes (USERNAME, PASSWORD, FROM, SERVER). N√£o foi poss√≠vel enviar.")
        return

    message = MessageSchema(
        subject=subject,
        recipients=recipient_to,
        template_body=body if template_name else None, 
        body=plain_text_body if not template_name else None, 
        subtype=MessageType.html if template_name else MessageType.plain, 
    )

    try:
        logger.info(f"Tentando enviar e-mail para {recipient_to} com assunto '{subject}'...")
        await fm.send_message(message, template_name=template_name)
        logger.info(f"E-mail enviado com sucesso para {recipient_to}.")
    except Exception as e:
        logger.exception(f"Erro ao enviar e-mail para {recipient_to}: {e}")

# --- Fun√ß√µes utilit√°rias ---

async def send_urgent_task_notification(
    user_email: EmailStr,
    user_name: str,
    task_title: str,
    task_id: str,
    task_due_date: Optional[str],
    priority_score: float
):
    """Envia notifica√ß√£o de tarefa urgente."""

    subject = f"üö® Tarefa Urgente no SmartTask: {task_title}"

    # Link para a tarefa
    task_link = f"{settings.FRONTEND_URL}/tasks/{task_id}" if settings.FRONTEND_URL else None

    # Corpo/Contexto para o template
    email_body_data = {
        "task_title": task_title,
        "user_name": user_name,
        "due_date": task_due_date or "N/A",
        "priority_score": f"{priority_score:.2f}", 
        "task_link": task_link,
        "project_name": settings.PROJECT_NAME
    }

    # Nome do template HTML (criaremos abaixo)
    template_name = "urgent_task.html"

    await send_email_async(
        subject=subject,
        recipient_to=[user_email],
        body=email_body_data,
        template_name=template_name,
        plain_text_body=f"Ol√° {user_name},\nA tarefa '{task_title}' no {settings.PROJECT_NAME} √© considerada urgente.\n"
                       f"Prioridade: {priority_score:.2f}, Vencimento: {task_due_date or 'N/A'}.\n"
                       f"{'Acesse a tarefa aqui: ' + task_link if task_link else ''}"
    )--- Fim de core/email.py ---

--- In√≠cio de core/security.py (113 linhas) ---
# app/core/security.py
from datetime import datetime, timedelta, timezone
from typing import Any, Union, Optional
from passlib.context import CryptContext
from jose import jwt, JWTError
from pydantic import ValidationError # Para erros de valida√ß√£o de token

from app.core.config import settings # Importa configura√ß√µes (SECRET_KEY, etc.)
from app.models.token import TokenPayload # Modelo para dados do payload

# --- Configura√ß√£o do Hashing de Senha ---
# Define o contexto do passlib, especificando os esquemas de hash permitidos
# 'bcrypt' ser√° o padr√£o para novas senhas. Outros s√£o para senhas legadas (se houver)
# 'deprecated="auto"' significa que senhas com esquemas antigos ser√£o automaticamente atualizadas para bcrypt no login
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

ALGORITHM = settings.JWT_ALGORITHM
ACCESS_TOKEN_EXPIRE_MINUTES = settings.ACCESS_TOKEN_EXPIRE_MINUTES

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """Verifica se a senha fornecida corresponde √† senha hasheada."""
    try:
        return pwd_context.verify(plain_password, hashed_password)
    except ValueError: # Pode ocorrer se o hash n√£o for reconhecido
         return False


def get_password_hash(password: str) -> str:
    """Gera o hash de uma senha usando bcrypt."""
    return pwd_context.hash(password)

# --- Fun√ß√µes JWT ---

def create_access_token(subject: Union[str, Any],username: str, expires_delta: Optional[timedelta] = None) -> str:
    """
    Cria um novo token de acesso JWT.

    Args:
        subject: O identificador √∫nico do sujeito do token (ex: user ID ou username).
        expires_delta: Tempo de vida do token. Se None, usa o padr√£o das configura√ß√µes.

    Returns:
        O token JWT codificado como string.
    """
    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)

    # Garante que o subject (ID do usu√°rio) seja uma string para o JWT
    # Embora Any seja aceito, geralmente √© um ID (UUID, int, str)
    subject_str = str(subject)

    to_encode = {
        "exp": expire,
        "sub": subject_str, # User ID
        "username": username # Username
    }

    # Adicione outros dados ao payload se necess√°rio (cuidado com o tamanho do token)
    # to_encode.update({"username": username_do_subject})

    encoded_jwt = jwt.encode(to_encode, settings.JWT_SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt


def decode_token(token: str) -> Optional[TokenPayload]:
    """
    Decodifica um token JWT e valida seu conte√∫do.

    Args:
        token: O token JWT string.

    Returns:
        Um objeto TokenPayload com os dados do token se v√°lido, None caso contr√°rio.
    """
    try:
        # Decodifica o token
        payload = jwt.decode(
            token,
            settings.JWT_SECRET_KEY,
            algorithms=[ALGORITHM]
        )

        # Extrai os dados esperados (subject/user_id)
        # subject = payload.get("sub") # 'sub' √© o id do usu√°rio (UUID string)
        # username = payload.get("username") # Se inclu√≠mos o username no token

        # if subject is None: # or username is None:
        #     return None

        # Valida os dados do payload com o modelo Pydantic
        # Isso garante que os tipos e campos esperados estejam presentes
        token_data = TokenPayload.model_validate(payload)

        # Verifica se o token expirou (embora jwt.decode geralmente fa√ßa isso)
        if token_data.exp is not None:
             if datetime.now(timezone.utc) > datetime.fromtimestamp(token_data.exp, tz=timezone.utc):
                 # Poderia levantar uma exce√ß√£o espec√≠fica de expira√ß√£o aqui
                 return None # Ou trate como inv√°lido

        # Aqui poder√≠amos converter o 'sub' (string UUID) de volta para UUID se necess√°rio
        # try:
        #     token_data.sub = uuid.UUID(token_data.sub)
        # except ValueError:
        #     return None # ID inv√°lido no token

        return token_data

    except (JWTError, ValidationError, KeyError) as e:
        # Logar o erro `e` aqui seria √∫til para depura√ß√£o
        print(f"Erro ao decodificar token: {e}") # Log de erro simples
        return None--- Fim de core/security.py ---

--- In√≠cio de core/utils.py (154 linhas) ---
# app/core/utils.py
from datetime import date, datetime, timezone
from typing import Any, Dict, Optional, TYPE_CHECKING
import math
from app.core.config import settings 
from app.models.task import Task
import httpx 
import json  
import logging 
import hmac   
import hashlib 

logger = logging.getLogger(__name__)

# --- Fun√ß√£o de c√°lculo de prioridade ---
def calculate_priority_score(
    importance: int,
    due_date: Optional[date]
    ) -> Optional[float]:
    """
    Calcula a pontua√ß√£o de prioridade de uma tarefa.

    Args:
        importance: N√≠vel de import√¢ncia da tarefa (ex: 1-5).
        due_date: Data de vencimento da tarefa (opcional).

    Returns:
        A pontua√ß√£o de prioridade calculada, ou None se n√£o aplic√°vel.
        Retornaremos float para permitir scores n√£o inteiros.
    """
    if not 1 <= importance <= 5:
         return None 

    # --- Import√¢ncia
    importance_score = importance * settings.PRIORITY_WEIGHT_IMPORTANCE

    # --- Prazo
    due_date_score = 0.0 
    if due_date:
        today = date.today() 

        days_remaining = (due_date - today).days

        if days_remaining < 0: 
            due_date_score = settings.PRIORITY_SCORE_IF_OVERDUE

        elif days_remaining == 0: 
             due_date_score = settings.PRIORITY_WEIGHT_DUE_DATE / 1.0 

        elif days_remaining > 0:
            effective_days = max(1, days_remaining) 
            due_date_score = settings.PRIORITY_WEIGHT_DUE_DATE / effective_days
            importance_score = importance * settings.PRIORITY_WEIGHT_IMPORTANCE 

        else:
             due_date_score = 0.0

    elif settings.PRIORITY_DEFAULT_SCORE_NO_DUE_DATE is not None:
         due_date_score = settings.PRIORITY_DEFAULT_SCORE_NO_DUE_DATE

    # --- Combinar Scores
    total_score = round(due_date_score + importance_score, 2) 

    return total_score

# --- Fun√ß√£o de tarefa urgente ---
def is_task_urgent(task: Task) -> bool:
    """Verifica se uma tarefa atende aos crit√©rios de urg√™ncia para notifica√ß√£o."""
    # --- Crit√©rio 0: Tarefa deve ter um score ou prazo
    if task.priority_score is None and task.due_date is None:
         return False 

    # --- Crit√©rio 1: Score acima do limiar (e n√£o None)
    if task.priority_score is not None and task.priority_score > settings.EMAIL_URGENCY_THRESHOLD:
        return True

    # --- Crit√©rio 2: Vence hoje ou est√° atrasada
    if task.due_date:
        today = date.today()
        days_remaining = (task.due_date - today).days
        if days_remaining <= 0:
            return True

    return False

# --- Fun√ß√£o de Webhook ---
async def send_webhook_notification(
    event_type: str,
    task_data: Dict[str, Any] 
    ):
    """
    Envia uma notifica√ß√£o via webhook para a URL configurada (se houver).
    Executada em background.

    Args:
        event_type: Tipo do evento (ex: 'task.created', 'task.updated').
        task_data: Dados da tarefa como um dicion√°rio Python.
    """
    if not settings.WEBHOOK_URL:
        logger.debug("Webhook URL n√£o configurada, pulando envio.") 
        return 

    # Converter URL Pydantic para string
    webhook_url_str = str(settings.WEBHOOK_URL)

    payload = {
        "event": event_type,
        "task": task_data,
        "timestamp": datetime.now(timezone.utc).isoformat() 
    }

    headers = {
        "Content-Type": "application/json",
        "User-Agent": "SmartTask-Webhook-Client/1.0" 
    }

    # --- Seguran√ßa de Assinatura ---
    if settings.WEBHOOK_SECRET:
        try:
            payload_bytes = json.dumps(payload, separators=(',', ':'), sort_keys=True).encode('utf-8')
            secret_bytes = settings.WEBHOOK_SECRET.encode('utf-8')

            signature = hmac.new(secret_bytes, payload_bytes, hashlib.sha256).hexdigest()
            headers["X-SmartTask-Signature"] = f"sha256={signature}"
        except Exception as e:
             logger.error(f"Erro ao gerar assinatura HMAC para webhook: {e}")
             return 

    # --- Envio da Requisi√ß√£o HTTP ---
    try:
         async with httpx.AsyncClient() as client:
            logger.info(f"Enviando webhook evento '{event_type}' para {webhook_url_str}")
            response = await client.post(
                webhook_url_str,
                json=payload, 
                headers=headers,
                timeout=10.0 
            )

            response.raise_for_status()

            logger.info(f"Webhook enviado com sucesso para {webhook_url_str}. Status: {response.status_code}")

    except httpx.TimeoutException:
         logger.error(f"Timeout ao enviar webhook para {webhook_url_str}")
    except httpx.RequestError as exc:
         logger.error(f"Erro na requisi√ß√£o ao enviar webhook para {webhook_url_str}: {exc}")
    except httpx.HTTPStatusError as exc:
         logger.error(
             f"Erro no servidor do webhook ({webhook_url_str}). "
             f"Status: {exc.response.status_code}. Resposta: {exc.response.text[:200]}..." 
         )
    except Exception as e:
         logger.exception(f"Erro inesperado ao enviar webhook para {webhook_url_str}: {e}")--- Fim de core/utils.py ---

--- In√≠cio de db/mongodb_utils.py (61 linhas) ---
# app/db/mongodb_utils.py
from typing import Optional
import motor.motor_asyncio
from app.core.config import settings 
import logging
from motor.motor_asyncio import AsyncIOMotorDatabase

logger = logging.getLogger(__name__)

# Vari√°veis globais para o cliente e banco de dados
db_client: motor.motor_asyncio.AsyncIOMotorClient | None = None
db_instance: motor.motor_asyncio.AsyncIOMotorDatabase | None = None

async def connect_to_mongo() -> Optional[AsyncIOMotorDatabase]:
    """
    Conecta-se ao MongoDB na inicializa√ß√£o da aplica√ß√£o.
    """
    global db_client, db_instance

    try:

        db_client = motor.motor_asyncio.AsyncIOMotorClient(
            settings.MONGODB_URL,
            serverSelectionTimeoutMS=5000 
        )
        await db_client.admin.command('ping')

        db_instance = db_client[settings.DATABASE_NAME]

        return db_instance
    
    except Exception as e:
        logger.error(f"N√£o foi poss√≠vel conectar ao MongoDB: {e}")
        db_client = None
        db_instance = None
        return None

async def close_mongo_connection():
    """
    Fecha a conex√£o com o MongoDB no encerramento da aplica√ß√£o.
    """
    global db_client
    if db_client:
        db_client.close()
    else:
        logger.warning("Tentativa de fechar conex√£o com MongoDB, mas cliente n√£o estava inicializado.")

def get_database() -> motor.motor_asyncio.AsyncIOMotorDatabase:
    """
    Retorna a inst√¢ncia do banco de dados MongoDB.
    Pode ser usada como uma depend√™ncia FastAPI ou chamada diretamente.
    """
    if db_instance is None:
        logger.error("Tentativa de obter inst√¢ncia do DB antes da inicializa√ß√£o!")
        raise RuntimeError("A conex√£o com o banco de dados n√£o foi inicializada.")
    return db_instance

# Voc√™ pode tamb√©m querer uma fun√ß√£o para obter cole√ß√µes espec√≠ficas:
# def get_task_collection() -> motor.motor_asyncio.AsyncIOMotorCollection:
#     db = get_database()
#     return db.get_collection("tasks") # Nome da cole√ß√£o de tarefas--- Fim de db/mongodb_utils.py ---

--- In√≠cio de db/task_crud.py (7 linhas) ---
# app/db/task_crud.py

# Nome da cole√ß√£o no MongoDB para tarefas
TASKS_COLLECTION = "tasks"

# Futuramente, podemos adicionar fun√ß√µes CRUD espec√≠ficas para tarefas aqui,
# se quisermos centraliz√°-las como fizemos com os usu√°rios.
--- Fim de db/task_crud.py ---

--- In√≠cio de db/user_crud.py (111 linhas) ---
# app/db/user_crud.py
import logging
from motor.motor_asyncio import AsyncIOMotorDatabase, AsyncIOMotorCollection
from typing import Optional, List
import uuid
from datetime import datetime, timezone
from pymongo.errors import DuplicateKeyError

from app.models.user import UserCreate, UserInDB, UserUpdate
from app.core.security import get_password_hash

from motor.motor_asyncio import AsyncIOMotorDatabase

# Nome da cole√ß√£o de usu√°rios
USERS_COLLECTION = "users"

# --- Fun√ß√µes CRUD para Usu√°rios ---

async def get_user_by_id(db: AsyncIOMotorDatabase, user_id: uuid.UUID) -> Optional[UserInDB]:
    """Busca um usu√°rio pelo seu ID (UUID)."""
    user_dict = await db[USERS_COLLECTION].find_one({"id": str(user_id)})
    if user_dict:
        user_dict.pop('_id', None) # Remove _id do mongo
        try:
             return UserInDB.model_validate(user_dict)
        except Exception: # Tratamento b√°sico de erro de valida√ß√£o
             return None
    return None

async def get_user_by_username(db: AsyncIOMotorDatabase, username: str) -> Optional[UserInDB]:
    """Busca um usu√°rio pelo seu nome de usu√°rio."""
    # Index no 'username' √© recomendado para performance
    user_dict = await db[USERS_COLLECTION].find_one({"username": username})
    if user_dict:
         user_dict.pop('_id', None)
         try:
            return UserInDB.model_validate(user_dict)
         except Exception:
            return None
    return None

async def get_user_by_email(db: AsyncIOMotorDatabase, email: str) -> Optional[UserInDB]:
    """Busca um usu√°rio pelo seu e-mail."""
     # Index no 'email' √© recomendado para performance e unicidade
    user_dict = await db[USERS_COLLECTION].find_one({"email": email})
    if user_dict:
        user_dict.pop('_id', None)
        try:
            return UserInDB.model_validate(user_dict)
        except Exception:
            return None
    return None

async def create_user(db: AsyncIOMotorDatabase, user_in: UserCreate) -> Optional[UserInDB]:
    """Cria um novo usu√°rio no banco de dados."""
    hashed_password = get_password_hash(user_in.password)

    user_db_data = {
        "id": uuid.uuid4(),
        "username": user_in.username,
        "email": user_in.email,
        "hashed_password": hashed_password,
        "full_name": user_in.full_name,
        "disabled": False, # Novo usu√°rio come√ßa ativo
        "created_at": datetime.now(timezone.utc),
        "updated_at": None
    }
    # Tenta validar antes de inserir (boa pr√°tica)
    try:
        user_db_obj = UserInDB.model_validate(user_db_data)
    except Exception as validation_error:
        # Logar validation_error seria importante
        print(f"Erro de valida√ß√£o Pydantic ao criar user_db_obj: {validation_error}")
        return None # Ou levantar uma exce√ß√£o customizada

    # Converte para dicion√°rio para inserir no Mongo
    user_db_dict = user_db_obj.model_dump(mode="json")

    try:
        insert_result = await db[USERS_COLLECTION].insert_one(user_db_dict)
        if not insert_result.acknowledged:
             # Logar erro
             return None
         # Retorna o objeto UserInDB validado (n√£o o dict)
        return user_db_obj
    except DuplicateKeyError:
        # Este erro ocorreria se tiv√©ssemos √≠ndices √∫nicos no Mongo
        # Vamos tratar isso no endpoint que chama esta fun√ß√£o
        raise # Re-lan√ßa a exce√ß√£o para ser tratada na rota
    except Exception as e:
         # Logar erro 'e'
         print(f"Erro inesperado ao inserir usu√°rio no DB: {e}")
         return None


# Adicionar fun√ß√µes de update e delete se necess√°rio
# async def update_user(...)
# async def delete_user(...)

# --- Configura√ß√£o de √çndices MongoDB (Importante!) ---
# Esta fun√ß√£o pode ser chamada uma vez na inicializa√ß√£o da aplica√ß√£o
# ou voc√™ pode criar os √≠ndices manualmente no Atlas/Mongo Shell.
async def create_user_indexes(db: AsyncIOMotorDatabase):
    """Cria √≠ndices √∫nicos para username e email se n√£o existirem."""
    collection = db[USERS_COLLECTION]
    try:
        await collection.create_index("username", unique=True, name="username_unique_idx")
        await collection.create_index("email", unique=True, name="email_unique_idx")
        logging.info("√çndices de usu√°rio ('username', 'email') verificados/criados.")
    except Exception as e:
        logging.error(f"Erro ao criar √≠ndices de usu√°rio: {e}")--- Fim de db/user_crud.py ---

--- In√≠cio de main.py (66 linhas) ---
# app/main.py

# Importa√ß√µes
import logging
from fastapi import FastAPI
from fastapi.concurrency import asynccontextmanager
from app.routers import tasks
from app.routers import auth
from app.db.mongodb_utils import connect_to_mongo, close_mongo_connection
from app.db.user_crud import create_user_indexes
from app.core.config import settings

# Configura√ß√£o b√°sica de logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Gerenciador de contexto de vida √∫til (eventos startup/shutdown)
# Docs: https://fastapi.tiangolo.com/advanced/events/#lifespan
@asynccontextmanager
async def lifespan(app: FastAPI):
    db = await connect_to_mongo()
    app.state.db = db
    if app.state.db is not None:
         await create_user_indexes(app.state.db)

    yield
    
    await close_mongo_connection()
    
# Inst√¢ncia FastAPI
app = FastAPI(
    title="SmartTask API",
    description="API RESTful para gerenciamento de tarefas com prioridade inteligente.",
    version="0.1.0",
    contact={
        "name": "Eng. Soft. Cl√°udio",
        "url": "https://www.linkedin.com/in/claudiodelimatosta/", 
        "email": "claudiodelimatosta@gmail.com", 
    },
    license_info={
        "name": "MIT License",
        "url": "https://opensource.org/licenses/MIT",
    },
    lifespan=lifespan
)

# Inclus√µes
app.include_router(auth.router, prefix=f"{settings.API_V1_STR}/auth")
app.include_router(tasks.router, prefix=settings.API_V1_STR)


# Endpoint Raiz
@app.get("/", tags=["Root"]) 
async def read_root():
    return {"message": "Bem-vindo √† {settings.PROJECT_NAME}!"}

# Adicione aqui mais endpoints e l√≥gica da aplica√ß√£o futuramente...

# (Para rodar localmente com Uvicorn, voc√™ usar√° o comando no terminal,
#  mas esta se√ß√£o √© √∫til se voc√™ fosse rodar o script diretamente)
if __name__ == "__main__":
    import uvicorn
    # Roda a aplica√ß√£o usando o Uvicorn
    # host="0.0.0.0" permite acesso de fora do container/m√°quina local
    reload=True # reinicia o servidor automaticamente ao salvar altera√ß√µes 
    uvicorn.run("main:app", host="0.0.0.0", port=8000, reload=True)--- Fim de main.py ---

--- In√≠cio de models/task.py (98 linhas) ---
# app/models/task.py

from pydantic import BaseModel, Field
from typing import Optional, List 
from datetime import date, datetime, timezone
import uuid 
from enum import Enum
from pydantic import ConfigDict

class TaskStatus(str, Enum):
    PENDING = "pendente"
    IN_PROGRESS = "em_progresso"
    COMPLETED = "conclu√≠da"
    CANCELLED = "cancelada"

# Modelo base para os campos comuns de uma tarefa
class TaskBase(BaseModel):
    title: str = Field(..., title="T√≠tulo da Tarefa", min_length=3, max_length=100)
    description: Optional[str] = Field(None, title="Descri√ß√£o Detalhada", max_length=500)
    importance: int = Field(..., ge=1, le=5, title="Import√¢ncia (1-5)")
    due_date: Optional[date] = Field(None, title="Data de Vencimento")
    status: TaskStatus = Field(default=TaskStatus.PENDING, title="Status da Tarefa")
    tags: Optional[List[str]] = Field(None, title="Etiquetas/Tags")
    project: Optional[str] = Field(None, title="Projeto Associado")
    # owner_id: Optional[uuid.UUID] = Field(None, title="ID do Propriet√°rio da Tarefa")
    model_config = {
        "json_schema_extra": {
            "examples": [
                {
                    "title": "Finalizar relat√≥rio mensal",
                    "description": "Compilar dados e escrever o relat√≥rio final.",
                    "importance": 4,
                    "due_date": "2024-08-15",
                    "status": "pendente",
                    "tags": ["relatorios", "financeiro"],
                    "project": "Relat√≥rios Q3"
                    # owner_id n√£o precisa estar no exemplo de cria√ß√£o base
                }
            ]
        }
    }

class TaskCreate(TaskBase):
    pass

class TaskUpdate(BaseModel):
    title: Optional[str] = Field(None, title="T√≠tulo da Tarefa", min_length=3, max_length=100)
    description: Optional[str] = Field(None, title="Descri√ß√£o Detalhada", max_length=500)
    importance: Optional[int] = Field(None, ge=1, le=5, title="Import√¢ncia (1-5)")
    due_date: Optional[date] = Field(None, title="Data de Vencimento")
    status: Optional[TaskStatus] = Field(None, title="Status da Tarefa")
    tags: Optional[List[str]] = Field(None, title="Etiquetas/Tags")
    project: Optional[str] = Field(None, title="Projeto Associado")
    priority_score: Optional[float] = Field(None, title="Pontua√ß√£o de Prioridade (para ajustes manuais, talvez?)")

    model_config = {
         "json_schema_extra": {
            "examples": [
                {
                    "title": "Revisar relat√≥rio mensal v2",
                    "status": TaskStatus.IN_PROGRESS,
                    "importance": 5
                }
            ]
        }
    }


class TaskInDBBase(TaskBase):
    id: uuid.UUID = Field(..., title="ID √önico da Tarefa")
    owner_id: uuid.UUID = Field(..., title="ID do Propriet√°rio da Tarefa")
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc), title="Data de Cria√ß√£o")
    updated_at: Optional[datetime] = Field(None, title="Data da √öltima Atualiza√ß√£o")
    priority_score: Optional[float] = Field(None, title="Pontua√ß√£o de Prioridade Calculada") 
    model_config = ConfigDict(from_attributes=True)

class Task(TaskInDBBase):
    model_config = ConfigDict(
         from_attributes=True, 
         json_schema_extra={ 
             "examples": [
                {
                    "id": "f47ac10b-58cc-4372-a567-0e02b2c3d479",
                    "owner_id": "a1b2c3d4-e5f6-7890-1234-567890abcdef", 
                    "title": "Finalizar relat√≥rio mensal",
                    "description": "Compilar dados e escrever o relat√≥rio final.",
                    "importance": 4,
                    "due_date": "2024-08-15",
                    "status": "pendente",
                    "tags": ["relatorios", "financeiro"],
                    "project": "Relat√≥rios Q3",
                    "created_at": "2024-07-28T10:00:00Z",
                    "updated_at": None,
                    "priority_score": None 
                }
            ]
         }
     )--- Fim de models/task.py ---

--- In√≠cio de models/token.py (15 linhas) ---
# app/models/token.py
from pydantic import BaseModel, Field
from typing import Optional
import uuid

class Token(BaseModel):
    """Modelo para a resposta do token JWT."""
    access_token: str = Field(..., title="Token de Acesso JWT")
    token_type: str = Field(default="bearer", title="Tipo do Token")

class TokenPayload(BaseModel):
    """Modelo para os dados contidos no payload do JWT."""
    sub: uuid.UUID = Field(..., title="ID do Usu√°rio (Subject)")
    username: str = Field(..., title="Nome de Usu√°rio")
    exp: Optional[int] = Field(None, title="Timestamp de Expira√ß√£o")
--- Fim de models/token.py ---

--- In√≠cio de models/user.py (63 linhas) ---
# app/models/user.py
from pydantic import BaseModel, Field, EmailStr, ConfigDict
from typing import Optional
import uuid
from datetime import datetime, timezone

class UserBase(BaseModel):
    """Campos base para um usu√°rio."""
    email: EmailStr = Field(..., title="Endere√ßo de E-mail", description="Deve ser um e-mail v√°lido e √∫nico.")
    username: str = Field(..., title="Nome de Usu√°rio", min_length=3, max_length=50, pattern="^[a-zA-Z0-9_]+$", description="Nome de usu√°rio √∫nico (letras, n√∫meros, underscore).")
    full_name: Optional[str] = Field(None, title="Nome Completo", max_length=100)
    disabled: bool = Field(default=False, title="Status Desativado", description="Indica se o usu√°rio est√° desativado.")

class UserCreate(BaseModel):
    """Campos necess√°rios para criar um novo usu√°rio (recebido pela API)."""
    email: EmailStr = Field(..., title="Endere√ßo de E-mail")
    username: str = Field(..., title="Nome de Usu√°rio", min_length=3, max_length=50, pattern="^[a-zA-Z0-9_]+$")
    password: str = Field(..., title="Senha", min_length=8, description="Senha (ser√° hasheada antes de salvar).")
    full_name: Optional[str] = Field(None, title="Nome Completo", max_length=100)

    model_config = {
        "json_schema_extra": {
            "examples": [
                {
                    "email": "johndoe@example.com",
                    "username": "johndoe",
                    "password": "averysecurepassword",
                    "full_name": "John Doe"
                }
            ]
        }
    }

class UserUpdate(BaseModel):
    """Campos que podem ser atualizados para um usu√°rio."""
    email: Optional[EmailStr] = Field(None, title="Endere√ßo de E-mail")
    full_name: Optional[str] = Field(None, title="Nome Completo", max_length=100)
    disabled: Optional[bool] = Field(None, title="Status Desativado")
    # N√£o permitimos atualizar username ou senha por este modelo geralmente
    # Senha teria um endpoint/processo separado

class UserInDBBase(UserBase):
    """Modelo de usu√°rio como armazenado no banco, incluindo ID e senha hasheada."""
    id: uuid.UUID = Field(..., title="ID √önico do Usu√°rio")
    hashed_password: str = Field(..., title="Senha Hasheada")
    created_at: datetime = Field(default_factory=datetime.now(timezone.utc), title="Data de Cria√ß√£o")
    updated_at: Optional[datetime] = Field(None, title="Data da √öltima Atualiza√ß√£o")

    # Configura√ß√£o Pydantic v2 para permitir cria√ß√£o a partir de atributos de objeto (ex: do MongoDB)
    model_config = ConfigDict(from_attributes=True)

# Modelo que ser√° retornado pela API (n√£o inclui senha hasheada)
class User(UserBase):
    """Modelo de usu√°rio para respostas da API (sem senha)."""
    id: uuid.UUID = Field(..., title="ID √önico do Usu√°rio")
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc), title="Data de Cria√ß√£o")
    updated_at: Optional[datetime] = Field(None, title="Data da √öltima Atualiza√ß√£o")

    model_config = ConfigDict(from_attributes=True)

# Modelo para representar o usu√°rio armazenado completamente no DB (para uso interno)
class UserInDB(UserInDBBase):
   pass--- Fim de models/user.py ---

--- In√≠cio de routers/auth.py (102 linhas) ---
# app/routers/auth.py
from fastapi import APIRouter, Depends, HTTPException, status, Body
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from motor.motor_asyncio import AsyncIOMotorDatabase
from pymongo.errors import DuplicateKeyError
from typing import Annotated
from app.db.mongodb_utils import get_database
from app.db import user_crud 
from app.models.user import User, UserCreate
from app.models.token import Token
from app.core.security import verify_password, create_access_token

router = APIRouter(
    tags=["Authentication"],
)

DbDep = Annotated[AsyncIOMotorDatabase, Depends(get_database)]

@router.post(
    "/register",
    response_model=User, 
    status_code=status.HTTP_201_CREATED,
    summary="Registra um novo usu√°rio",
    response_description="O usu√°rio rec√©m-registrado.",
)
async def register_user(
    db: DbDep,
    user_in: Annotated[UserCreate, Body(description="Dados do novo usu√°rio")]):
    """
    Registra um novo usu√°rio no sistema:
    - Verifica se o username ou email j√° existem.
    - Hasheia a senha.
    - Salva o usu√°rio no banco de dados.
    - Retorna os dados do usu√°rio criado (sem a senha).
    """
    existing_user = await user_crud.get_user_by_username(db, user_in.username)
    if existing_user:
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=f"Usu√°rio '{user_in.username}' j√° existe.",
        )
    existing_email = await user_crud.get_user_by_email(db, user_in.email)
    if existing_email:
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=f"E-mail '{user_in.email}' j√° registrado.",
        )

    try:
        created_user_db = await user_crud.create_user(db=db, user_in=user_in)
        if created_user_db is None:
            raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                                detail="N√£o foi poss√≠vel criar o usu√°rio.")
        return User.model_validate(created_user_db)
    except DuplicateKeyError:
         raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail="Usu√°rio ou e-mail j√° registrado (conflito de √≠ndice √∫nico).",
         )
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                            detail="Ocorreu um erro inesperado durante o registro.")


@router.post(
    "/login/access-token",
    response_model=Token,
    summary="Obt√©m um token de acesso JWT",
    description="Autentica o usu√°rio com username e senha (form data) e retorna um token JWT.",
)
async def login_for_access_token(
    db: DbDep,
    form_data: Annotated[OAuth2PasswordRequestForm, Depends()]
):
    """
    Endpoint de login padr√£o OAuth2:
    - Recebe `username` e `password` via form-data.
    - Busca o usu√°rio pelo username.
    - Verifica se o usu√°rio existe e se a senha est√° correta.
    - Verifica se o usu√°rio n√£o est√° desativado.
    - Cria e retorna um token de acesso JWT.
    """
    user = await user_crud.get_user_by_username(db, form_data.username)

    if not user or not verify_password(form_data.password, user.hashed_password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Usu√°rio ou senha incorretos.",
            headers={"WWW-Authenticate": "Bearer"},
        )
    if user.disabled:
         raise HTTPException(
             status_code=status.HTTP_400_BAD_REQUEST,
             detail="Usu√°rio inativo."
         )

    access_token = create_access_token(
        subject=user.id,
        username=user.username
        )

    return Token(access_token=access_token, token_type="bearer")--- Fim de routers/auth.py ---

--- In√≠cio de routers/tasks.py (434 linhas) ---
# app/routers/tasks.py

# --- Importa√ß√µes Essenciais ---
import logging
from typing import List, Optional, Annotated 
import uuid 
from datetime import date, datetime, timezone 

# --- Imports do FastAPI ---
from fastapi import (
    APIRouter, HTTPException, Body, status, Depends, Response, Query,
    BackgroundTasks
)

# --- Imports do MongoDB/Motor ---
from motor.motor_asyncio import AsyncIOMotorDatabase, AsyncIOMotorCollection
from pymongo import DESCENDING, ASCENDING
from pymongo.errors import DuplicateKeyError
from pydantic import ValidationError 

# --- Imports da Nossa Aplica√ß√£o ---
from app.models.task import Task, TaskCreate, TaskUpdate, TaskStatus 
from app.db import task_crud 
from app.db.mongodb_utils import get_database 
from app.core.dependencies import CurrentUser
from app.models.user import UserInDB 
from app.core.utils import calculate_priority_score, is_task_urgent, send_webhook_notification 

# --- Instanciar Logger ---
logger = logging.getLogger(__name__)

# --- Configura√ß√£o do Roteador ---
router = APIRouter(
    prefix="/tasks", 
    tags=["Tasks"], 
    responses={ 
        status.HTTP_404_NOT_FOUND: {"description": "Tarefa n√£o encontrada"},
        status.HTTP_401_UNAUTHORIZED: {"description": "N√£o autorizado (Token inv√°lido ou ausente)"},
        status.HTTP_403_FORBIDDEN: {"description": "Proibido (Usu√°rio n√£o tem permiss√£o para este recurso)"}
    },
)

# --- Depend√™ncias Tipadas para Melhor Legibilidade ---
DbDep = Annotated[AsyncIOMotorDatabase, Depends(get_database)]

# Fun√ß√£o auxiliar para obter a cole√ß√£o de tarefas (simplifica inje√ß√£o)
async def get_task_collection(db: DbDep) -> AsyncIOMotorCollection:
    """Retorna a cole√ß√£o MongoDB 'tasks'."""
    return db[task_crud.TASKS_COLLECTION]
TaskCollectionDep = Annotated[AsyncIOMotorCollection, Depends(get_task_collection)]


# ==============================================================================
# --- ROTAS CRUD PROTEGIDAS PARA TAREFAS ---
# ==============================================================================

@router.post(
    "/",
    response_model=Task, 
    status_code=status.HTTP_201_CREATED, 
    summary="Cria uma nova tarefa",
    description="Cria uma nova tarefa associada ao usu√°rio autenticado. A prioridade e owner_id s√£o definidos automaticamente.",
    response_description="A tarefa rec√©m-criada com todos os seus detalhes.",
)
async def create_task(
    task_in: Annotated[TaskCreate, Body(description="Dados da nova tarefa a ser criada")], 
    collection: TaskCollectionDep, 
    current_user: CurrentUser, 
    background_tasks: BackgroundTasks 
):
    """
    Endpoint para criar uma nova tarefa.

    - Recebe dados validados pelo modelo `TaskCreate`.
    - Calcula a `priority_score`.
    - Associa a tarefa ao `owner_id` do usu√°rio logado.
    - Salva no MongoDB.
    - Envia notifica√ß√µes (e-mail, webhook) em background se necess√°rio.
    - Retorna a tarefa criada.
    """
    # Converte dados de entrada Pydantic para dicion√°rio, excluindo campos n√£o enviados
    task_data = task_in.model_dump(exclude_unset=True)

    # --- Calcular Prioridade ---
    # Usa a fun√ß√£o utilit√°ria com os dados recebidos
    priority = calculate_priority_score(
        importance=task_in.importance,
        due_date=task_in.due_date
    )

    # --- Criar o objeto Tarefa completo para o DB ---
    task_db = Task(
        id=uuid.uuid4(),                  
        owner_id=current_user.id,          
        created_at=datetime.now(timezone.utc), 
        priority_score=priority,           
        **task_data                        
    )

    # Converte o objeto Pydantic para dicion√°rio antes de inserir no MongoDB
    task_db_dict = task_db.model_dump(mode="json")

    try:
        # --- Inserir no Banco de Dados ---
        insert_result = await collection.insert_one(task_db_dict)
        if not insert_result.acknowledged:
             logger.error("Falha no ACK ao inserir tarefa no MongoDB.")
             raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                                detail="Falha ao salvar a tarefa no banco de dados.")

        # --- Disparar Tarefas em Background (Ap√≥s Sucesso no DB) ---

        # 1. Webhook 
        task_dict_for_webhook = task_db.model_dump(mode="json") 
        background_tasks.add_task( 
             send_webhook_notification, 
             event_type="task.created",
             task_data=task_dict_for_webhook 
        )
        logger.info(f"Tarefa de webhook 'task.created' para {task_db.id} adicionada ao background.")

        # 2. Notifica√ß√£o por E-mail (se urgente e usu√°rio configurado)
        # A l√≥gica de envio de email em si n√£o est√° implementada aqui, assumindo
        # que o worker ARQ cuida disso periodicamente.
        # Se quis√©ssemos enviar email *imediatamente* na cria√ß√£o/update:
        # if is_task_urgent(task_db):
        #     if current_user.email and current_user.full_name:
        #          background_tasks.add_task( # Tamb√©m rodaria em background
        #              send_urgent_task_notification,
        #              user_email=current_user.email,
        #              # ... outros args ...
        #          )
        #          logger.info(f"Tarefa de email urgente para {task_db.id} adicionada ao background.")
        #     else:
        #          logger.warning(f"Usu√°rio {current_user.id} sem e-mail/nome para notifica√ß√£o IMEDIATA da tarefa urgente {task_db.id}.")


    except DuplicateKeyError:
        logger.warning(f"Tentativa de criar tarefa duplicada para user {current_user.id}")
        raise HTTPException(status_code=status.HTTP_409_CONFLICT,
                            detail="Uma tarefa com identificador semelhante j√° existe para este usu√°rio.")
    except Exception as e: 
        logger.exception(f"Erro inesperado ao criar tarefa ou agendar background tasks para user {current_user.id}: {e}")
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                            detail="Ocorreu um erro interno ao processar a cria√ß√£o da tarefa.")

    return task_db


@router.get(
    "/",
    response_model=List[Task],
    summary="Lista as tarefas do usu√°rio autenticado",
    description="""Recupera uma lista de tarefas pertencentes ao usu√°rio autenticado.
    Permite filtros por status, prazo (at√© uma data), projeto e tags (contendo todas).
    Permite ordena√ß√£o por 'priority_score', 'due_date', 'created_at' ou 'importance'.""",
    response_description="Uma lista (possivelmente vazia) contendo as tarefas filtradas e ordenadas do usu√°rio.",
)
async def list_tasks(
    collection: TaskCollectionDep,
    current_user: CurrentUser, 
    # --- Par√¢metros de Filtro ---
    status_filter: Annotated[Optional[TaskStatus], Query(
        alias="status", title="Filtro por Status",
        description="Filtrar tarefas por um status espec√≠fico."
    )] = None,
    due_before: Annotated[Optional[date], Query(
        title="Vencimento Antes De",
        description="Filtrar tarefas com prazo de vencimento at√© esta data (inclusive)."
    )] = None,
    project_filter: Annotated[Optional[str], Query(
        alias="project", title="Filtro por Projeto",
        description="Filtrar tarefas por nome exato do projeto.", min_length=1
    )] = None,
    tags_filter: Annotated[Optional[List[str]], Query(
        alias="tag", title="Filtro por Tags (AND)",
        description="Filtrar tarefas que contenham TODAS as tags especificadas (usar ?tag=t1&tag=t2).", min_length=1
    )] = None,
    # --- Par√¢metros de Ordena√ß√£o ---
    sort_by: Annotated[Optional[str], Query(
        title="Ordenar Por",
        description="Campo para ordenar: 'priority_score', 'due_date', 'created_at', 'importance'.",
        enum=["priority_score", "due_date", "created_at", "importance"] 
    )] = None,
    sort_order: Annotated[Optional[str], Query(
        title="Ordem",
        description="Ordem da ordena√ß√£o: 'asc' ou 'desc'.",
        enum=["asc", "desc"] 
    )] = "desc", 
    # --- Par√¢metros de Pagina√ß√£o ---
    limit: Annotated[int, Query(ge=1, le=1000, title="Limite de Resultados", description="N√∫mero m√°ximo de tarefas a retornar.")] = 100,
    skip: Annotated[int, Query(ge=0, title="Pular Resultados", description="N√∫mero de tarefas a pular (para pagina√ß√£o).")] = 0,
):
    """
    Endpoint para listar tarefas do usu√°rio autenticado com filtros, ordena√ß√£o e pagina√ß√£o.
    """
    query = {"owner_id": str(current_user.id)}

    # --- Adicionar Filtros Opcionais √† Query MongoDB ---
    if status_filter:
        query["status"] = status_filter.value 
    if due_before:
        query["due_date"] = {"$lte": datetime.combine(due_before, datetime.min.time(), tzinfo=timezone.utc)} 
    if project_filter:
        query["project"] = project_filter 
    if tags_filter:
        query["tags"] = {"$all": tags_filter}

    # --- Determinar Campo e Ordem de Ordena√ß√£o ---
    sort_tuple = None
    if sort_by in ["priority_score", "due_date", "created_at", "importance"]:
        mongo_order = DESCENDING if sort_order.lower() == "desc" else ASCENDING
        sort_tuple = (sort_by, mongo_order)

    # --- Executar Query com Pagina√ß√£o e Ordena√ß√£o ---
    try:
        tasks_cursor = collection.find(query).skip(skip).limit(limit)
        if sort_tuple:
            tasks_cursor = tasks_cursor.sort([sort_tuple]) 

        # --- Processar e Validar Resultados ---
        validated_tasks = []
        async for task_dict in tasks_cursor:
            task_dict.pop('_id', None) 
            try:
                # Valida cada dicion√°rio retornado com o modelo Pydantic Task
                validated_tasks.append(Task.model_validate(task_dict))
            except (ValidationError, Exception) as e:
                logger.error(f"Erro ao validar tarefa do DB (list {current_user.id}): {task_dict} - Erro: {e}")
                # Em produ√ß√£o, decidir se continua ou retorna erro parcial
                continue # Pula tarefa inv√°lida por enquanto

        return validated_tasks

    except Exception as e: 
        logger.exception(f"Erro ao buscar/processar tarefas para user {current_user.id} com query {query}: {e}")
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                            detail="Ocorreu um erro interno ao buscar as tarefas.")


@router.get(
    "/{task_id}",
    response_model=Task,
    summary="Busca uma tarefa espec√≠fica por ID",
    description="Recupera os detalhes de uma tarefa espec√≠fica, **se** ela pertencer ao usu√°rio autenticado.",
    response_description="Os detalhes completos da tarefa encontrada.",
    responses={status.HTTP_403_FORBIDDEN: {"description": "Acesso negado a esta tarefa"}}
)
async def get_task(
    task_id: uuid.UUID, 
    collection: TaskCollectionDep,
    current_user: CurrentUser 
):
    """
    Endpoint para buscar uma √∫nica tarefa pelo seu ID (UUID).
    Apenas retorna a tarefa se o ID for encontrado E pertencer ao usu√°rio logado.
    """
    # Busca no MongoDB usando o ID da tarefa e o ID do usu√°rio logado
    task_dict = await collection.find_one({
        "id": str(task_id),          
        "owner_id": str(current_user.id) 
    })

    if task_dict:
        task_dict.pop('_id', None) 
        try:
            # Valida os dados do DB com o modelo Pydantic Task
            return Task.model_validate(task_dict)
        except (ValidationError, Exception) as e:
            logger.error(f"Erro ao validar tarefa {task_id} do DB para user {current_user.id}: {e}")
            # Pode indicar inconsist√™ncia de dados no DB
            raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                                detail="Erro ao processar dados da tarefa encontrada.")
    else:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND,
                            detail=f"Tarefa com ID {task_id} n√£o encontrada.")


@router.put(
    "/{task_id}",
    response_model=Task,
    summary="Atualiza uma tarefa existente",
    description="Atualiza os campos de uma tarefa existente, **se** ela pertencer ao usu√°rio autenticado. A prioridade √© recalculada se necess√°rio.",
    response_description="Os detalhes completos da tarefa atualizada.",
    responses={status.HTTP_403_FORBIDDEN: {"description": "Acesso negado a esta tarefa"}}
)
async def update_task(
    task_id: uuid.UUID, 
    task_update: Annotated[TaskUpdate, Body(description="Campos da tarefa a serem atualizados")], 
    collection: TaskCollectionDep,
    current_user: CurrentUser,
    background_tasks: BackgroundTasks 
):
    """
    Endpoint para atualizar campos espec√≠ficos de uma tarefa.

    - Verifica se a tarefa pertence ao usu√°rio.
    - Recebe dados validados pelo modelo `TaskUpdate`.
    - Recalcula `priority_score` se `importance` ou `due_date` mudarem.
    - Atualiza o campo `updated_at`.
    - Salva as altera√ß√µes no MongoDB.
    - Envia webhook em background.
    - Retorna a tarefa completa e atualizada.
    """
    # --- Garantir que a tarefa existe e pertence ao usu√°rio antes de prosseguir ---
    existing_task_dict = await collection.find_one({
        "id": str(task_id),
        "owner_id": str(current_user.id)
    })
    if not existing_task_dict:
        # Levanta 404 (ou 403 se prefer√≠ssemos verificar a exist√™ncia geral)
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND,
                             detail=f"Tarefa {task_id} n√£o encontrada ou n√£o pertence a voc√™.")

    # Validar tarefa existente para f√°cil acesso aos campos com tipos corretos
    try:
         existing_task = Task.model_validate(existing_task_dict)
    except Exception:
        logger.exception(f"Erro ao validar dados da tarefa existente {task_id} antes do update.")
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                                detail="Erro interno ao processar dados da tarefa existente.")

    # --- Preparar Dados para Atualiza√ß√£o ---
    # Pega apenas os campos que foram explicitamente enviados no request 
    update_data = task_update.model_dump(exclude_unset=True, exclude={"owner_id"}) 

    # Se nenhum campo v√°lido foi enviado para atualiza√ß√£o
    if not update_data:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST,
                            detail="Nenhum campo v√°lido fornecido para atualiza√ß√£o.")

    # --- Recalcular Prioridade (se necess√°rio) ---
    should_recalculate_priority = False
    current_importance = existing_task.importance
    current_due_date = existing_task.due_date

    # Verifica se os campos relevantes para prioridade foram enviados na atualiza√ß√£o
    if "importance" in update_data and update_data["importance"] != current_importance:
        current_importance = update_data["importance"] 
        should_recalculate_priority = True
    if "due_date" in update_data:
        new_due_date_obj = update_data["due_date"] 
        if new_due_date_obj != current_due_date:
            current_due_date = new_due_date_obj 
            should_recalculate_priority = True

    # Recalcula se algum dos campos chave mudou
    if should_recalculate_priority:
         priority = calculate_priority_score(
            importance=current_importance,
            due_date=current_due_date     
         )
         update_data["priority_score"] = priority 
         logger.info(f"Recalculada prioridade para tarefa {task_id} para: {priority}")

    # --- Definir Timestamp de Atualiza√ß√£o ---
    update_data["updated_at"] = datetime.now(timezone.utc)

    # --- Executar Atualiza√ß√£o At√¥mica no Banco de Dados ---
    try:
        updated_task_dict_raw = await collection.find_one_and_update(
            {"id": str(task_id), "owner_id": str(current_user.id)}, 
            {"$set": update_data}, 
            return_document=True 
        )

        if not updated_task_dict_raw:
             logger.error(f"Falha ao encontrar a tarefa {task_id} durante find_one_and_update, ap√≥s verifica√ß√£o inicial.")
             raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f"Tarefa {task_id} n√£o encontrada durante a atualiza√ß√£o.")

        # --- Processar Resultado e Enviar Webhook ---
        updated_task_dict_raw.pop('_id', None)
        try:
            updated_task = Task.model_validate(updated_task_dict_raw) 

            # Enviar Webhook em Background
            task_dict_for_webhook = updated_task.model_dump(mode="json")
            background_tasks.add_task(
                send_webhook_notification,
                event_type="task.updated",
                task_data=task_dict_for_webhook
            )
            logger.info(f"Tarefa de webhook 'task.updated' para {updated_task.id} adicionada ao background.")

            # Notifica√ß√£o por e-mail imediata poderia ser adicionada aqui tamb√©m (via background_tasks) se necess√°rio

            return updated_task 

        except (ValidationError, Exception) as e:
             logger.error(f"Erro ao validar tarefa atualizada do DB (ID: {task_id}) para user {current_user.id}: {e}")
             # Se a valida√ß√£o falhar ap√≥s o update, indica um problema s√©rio
             raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                                 detail="Erro ao processar dados da tarefa ap√≥s atualiza√ß√£o.")

    except Exception as e: 
         logger.exception(f"Erro ao atualizar tarefa {task_id} ou agendar background tasks: {e}")
         raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                             detail="Erro interno ao processar atualiza√ß√£o da tarefa.")



@router.delete(
    "/{task_id}",
    status_code=status.HTTP_204_NO_CONTENT, 
    summary="Deleta uma tarefa",
    description="Remove permanentemente uma tarefa do banco de dados, **se** ela pertencer ao usu√°rio autenticado.",
    # Documenta explicitamente os erros al√©m dos globais
    responses={
        status.HTTP_404_NOT_FOUND: {"description": "Tarefa n√£o encontrada ou n√£o pertence a voc√™"},
        status.HTTP_403_FORBIDDEN: {"description": "Acesso negado a esta tarefa"},
        status.HTTP_204_NO_CONTENT: {"description": "Tarefa deletada com sucesso (sem corpo de resposta)"},
    }
)
async def delete_task(
    task_id: uuid.UUID,
    collection: TaskCollectionDep,
    current_user: CurrentUser 
    # Nota: N√£o precisamos de BackgroundTasks aqui, mas poderia ter para um evento 'task.deleted'
):
    """
    Endpoint para deletar uma tarefa.
    S√≥ permite deletar tarefas que pertencem ao usu√°rio logado.
    """
    # Tenta deletar o documento que combina ID da tarefa E ID do usu√°rio
    delete_result = await collection.delete_one({
        "id": str(task_id),
        "owner_id": str(current_user.id) 
    })

    # Verifica se algum documento foi realmente deletado
    if delete_result.deleted_count == 0:
         raise HTTPException(status_code=status.HTTP_404_NOT_FOUND,
                            detail=f"Tarefa com ID {task_id} n√£o encontrada ou n√£o pertence a voc√™.")
    return Response(status_code=status.HTTP_204_NO_CONTENT)--- Fim de routers/tasks.py ---

--- In√≠cio de worker.py (133 linhas) ---
# app/worker.py
import asyncio
import logging
from datetime import date, datetime
from typing import Dict, Any, Optional
from motor.motor_asyncio import AsyncIOMotorDatabase 
from arq import cron
from arq.connections import RedisSettings
from redis.asyncio import Redis
from app.core.config import settings
from app.db.mongodb_utils import connect_to_mongo, close_mongo_connection, get_database 
from app.db import user_crud, task_crud 
from app.core.email import send_urgent_task_notification
from app.core.utils import is_task_urgent
from app.models.task import Task, TaskStatus 

logger = logging.getLogger("arq.worker")

# === FUN√á√ÉO DA TAREFA PERI√ìDICA ===
# Ser√° chamada pelo scheduler do ARQ
async def check_and_notify_urgent_tasks(ctx: Dict[str, Any]):
    """
    Tarefa peri√≥dica que busca tarefas urgentes e notifica os usu√°rios.
    'ctx' √© um dicion√°rio passado pelo worker ARQ, cont√©m recursos como conex√£o DB.
    """
    logger.info("Executando verifica√ß√£o de tarefas urgentes...")
    db: Optional[AsyncIOMotorDatabase] = ctx.get("db")

    if db is None:
         logger.error("Conex√£o com o banco de dados n√£o dispon√≠vel no contexto ARQ.")
         return

    tasks_collection = db[task_crud.TASKS_COLLECTION] 
    users_collection = db[user_crud.USERS_COLLECTION] 

    # --- Crit√©rios de Busca no MongoDB ---
    # 1. Tarefas n√£o conclu√≠das ou canceladas
    # 2. Com priority_score > threshold OU com due_date <= hoje
    today_start = datetime.combine(date.today(), datetime.min.time()) 

    query = {
        "status": {"$nin": [TaskStatus.COMPLETED.value, TaskStatus.CANCELLED.value]},
        "$or": [
            {"priority_score": {"$gt": settings.EMAIL_URGENCY_THRESHOLD}},
            {"due_date": {"$lte": today_start}} 
        ]
    }

    urgent_tasks_cursor = tasks_collection.find(query)
    count = 0

    async for task_dict in urgent_tasks_cursor:
        task_dict.pop('_id', None)
        try:
             task = Task.model_validate(task_dict) 

             user = await user_crud.get_user_by_id(db, task.owner_id)

             if user and user.email and user.full_name and not user.disabled:
                logger.info(f"Tarefa urgente encontrada ({task.id}), notificando usu√°rio {user.email}...")

                await send_urgent_task_notification(
                     user_email=user.email,
                     user_name=user.full_name,
                     task_title=task.title,
                     task_id=str(task.id),
                     task_due_date=str(task.due_date) if task.due_date else None,
                     priority_score=task.priority_score or 0.0
                 )
                count += 1
             elif not user:
                logger.warning(f"Usu√°rio {task.owner_id} da tarefa urgente {task.id} n√£o encontrado.")
             elif user and user.disabled:
                 logger.info(f"Usu√°rio {user.username} da tarefa urgente {task.id} est√° desabilitado. Notifica√ß√£o n√£o enviada.")
             else: 
                 logger.warning(f"Usu√°rio {user.username} da tarefa urgente {task.id} sem e-mail ou nome completo. Notifica√ß√£o n√£o enviada.")

        except Exception as e:
            logger.exception(f"Erro ao processar tarefa urgente {task_dict.get('id')}: {e}")
            continue 

    logger.info(f"Verifica√ß√£o de tarefas urgentes conclu√≠da. {count} notifica√ß√µes enviadas.")


# === CONFIGURA√á√ïES DO WORKER ARQ ===
async def startup(ctx: Dict[str, Any]):
    """Fun√ß√£o executada quando o worker ARQ inicia."""
    logger.info("Iniciando worker ARQ...")
    db_instance = await connect_to_mongo()
    if db_instance is not None:
         ctx["db"] = db_instance 
         logger.info("Conex√£o MongoDB estabelecida para o worker ARQ.")
    else:
         logger.error("Falha ao conectar ao MongoDB no startup do worker ARQ.")
         ctx["db"] = None


async def shutdown(ctx: Dict[str, Any]):
    """Fun√ß√£o executada quando o worker ARQ termina."""
    logger.info("Encerrando worker ARQ...")
    if ctx.get("db")is not None:
        await close_mongo_connection() 
        logger.info("Conex√£o MongoDB fechada pelo worker ARQ.")

# Classe de configura√ß√µes do worker para ARQ
# ARQ procurar√° por esta classe quando executarmos o worker
class WorkerSettings:
    on_startup = startup
    on_shutdown = shutdown

    # --- Consulta √† lista de tarefas agendadas ---
    cron_jobs = [
        cron(check_and_notify_urgent_tasks, minute={*range(0, 60, 1)}, run_at_startup=True),
        cron(check_and_notify_urgent_tasks, hour=8, minute=0),
    ]

    # --- Configura√ß√µes do Redis ---
    if settings.REDIS_URL:
        try:
             redis_settings: RedisSettings = RedisSettings(
                 host=settings.REDIS_URL.host or 'localhost', 
                 port=int(settings.REDIS_URL.port) if settings.REDIS_URL.port else 6379,
                 database=int(settings.REDIS_URL.path[1:]) if settings.REDIS_URL.path and settings.REDIS_URL.path != '/' else 0, 
                 password=settings.REDIS_URL.password, 
                 # conn_timeout=10,
                 # conn_retries=5,
                 # conn_retry_delay=1,
            )
        except Exception as e:
             logger.exception(f"Erro ao configurar RedisSettings a partir da URL: {settings.REDIS_URL} - Erro: {e}")
             raise ValueError(f"Erro ao processar REDIS_URL: {e}")
    else:
         raise ValueError("REDIS_URL n√£o est√° definida nas configura√ß√µes, worker ARQ n√£o pode iniciar.")--- Fim de worker.py ---
