
--- Início de app/core/config.py (127 linhas) ---
# app/core/config.py
import os
from pydantic_settings import BaseSettings
from pydantic import EmailStr, Field, RedisDsn, model_validator, HttpUrl
from typing import Optional
from dotenv import load_dotenv
import logging

logger = logging.getLogger(__name__)

# --- Carrega variáveis do .env ---
dotenv_path = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), '.env')
loaded = load_dotenv(dotenv_path=dotenv_path)

class Settings(BaseSettings):
    """
    Configurações da aplicação lidas do ambiente.
    Docs Pydantic Settings: https://docs.pydantic.dev/latest/concepts/pydantic_settings/
    """
    PROJECT_NAME: str = Field("SmartTask API", description="Nome do Projeto")
    API_V1_STR: str = Field("/api/v1", description="Prefixo para a versão 1 da API")

    # --- Configurações MongoDB ---
    MONGODB_URL: str = Field(..., description="URL de conexão do MongoDB")
    DATABASE_NAME: str = Field("smarttask_db", description="Nome do banco de dados MongoDB")

     # --- Configurações JWT ---
    JWT_SECRET_KEY: str = Field(..., description="Chave secreta para assinar tokens JWT")
    JWT_ALGORITHM: str = Field("HS256", description="Algoritmo de assinatura JWT")
    ACCESS_TOKEN_EXPIRE_MINUTES: int = Field(60 * 24 * 7, description="Validade do token de acesso (minutos)") # Ex: 7 dias

    # --- Configurações de Prioridade ---
    PRIORITY_WEIGHT_DUE_DATE: float = Field(
        100.0, 
        description="Peso para o componente de prazo no cálculo de prioridade."
    )
    PRIORITY_WEIGHT_IMPORTANCE: float = Field(
        10.0, 
        description="Peso (multiplicador) para o componente de importância no cálculo de prioridade."
    )
    PRIORITY_DEFAULT_SCORE_NO_DUE_DATE: Optional[float] = Field(
        0.0, 
        description="Pontuação base de prazo para tarefas sem data de vencimento (pode ser None ou 0)."
    )
    PRIORITY_SCORE_IF_OVERDUE: float = Field(
        1000.0, 
        description="Pontuação (ou fator aditivo/multiplicativo) especial para tarefas atrasadas."
    )

    # --- Configuração Webhook ---
    WEBHOOK_URL: Optional[HttpUrl] = Field(
        None,
        description="URL opcional para enviar notificações de eventos de tarefas (webhooks)."
    )
    # Segredo para assinar requests de webhook (HMAC)
    WEBHOOK_SECRET: Optional[str] = Field(
        None,
        description="Segredo opcional usado para assinar payloads de webhook para verificação."
    )

    # --- Configurações de E-mail ---
    MAIL_ENABLED: bool = Field(
            default=True,
            description="Flag para habilitar/desabilitar envio de e-mails globalmente."
    )
    MAIL_USERNAME: Optional[str] = Field(None, description="Usuário do servidor SMTP.")
    MAIL_PASSWORD: Optional[str] = Field(None, description="Senha do servidor SMTP.")
    MAIL_FROM: Optional[EmailStr] = Field(
        None,
        description="Endereço de e-mail remetente."
    )
    MAIL_FROM_NAME: Optional[str] = Field(
        "SmartTask Notificações", 
        description="Nome do remetente exibido no e-mail."
    )
    MAIL_PORT: int = Field(
        587,
        description="Porta do servidor SMTP."
    )
    MAIL_SERVER: Optional[str] = Field(
        None,
        description="Endereço do servidor SMTP."
    )
    # Configurações para fastapi-mail
    MAIL_STARTTLS: bool = Field(True) 
    MAIL_SSL_TLS: bool = Field(False) 
    USE_CREDENTIALS: bool = Field(True)
    VALIDATE_CERTS: bool = Field(True) 

    # --- Configurações Adicionais (Templates, Limiar) ---
    EMAIL_TEMPLATES_DIR: str = Field("app/email-templates/build", description="Diretório de templates de e-mail compilados.") # Definiremos isso
    EMAIL_URGENCY_THRESHOLD: float = Field(
        100.0, 
        description="Limiar de priority_score para considerar uma tarefa urgente para notificação."
    )
    FRONTEND_URL: Optional[str] = Field(None, description="URL base do frontend para links no e-mail (se houver).") # Ex: http://localhost:3000

     # --- Configuração Redis ---
    REDIS_URL: Optional[RedisDsn] = Field(
        None, 
        description="URL de conexão do Redis para filas de tarefas (ARQ)."
    )

    # --- Configurações CORS ---

    # --- Configuração Pydantic (case-insensitive)---
    model_config = {
        "case_sensitive": False,
    }

# --- Validação ---
    @model_validator(mode='after')
    def check_mail_config(self) -> 'Settings':
        if self.MAIL_ENABLED and not all([self.MAIL_USERNAME, self.MAIL_PASSWORD, self.MAIL_FROM, self.MAIL_SERVER]):
            raise ValueError(
                "Se MAIL_ENABLED for True, MAIL_USERNAME, MAIL_PASSWORD, MAIL_FROM e MAIL_SERVER devem ser definidos."
            )
        return self

# --- Cria a instância ---
try:
    settings = Settings()
except ValueError as e:
     raise e 
# Validação extra da instância
if settings.WEBHOOK_URL and not isinstance(settings.WEBHOOK_URL, HttpUrl):
     logger.warning(f"WEBHOOK_URL '{settings.WEBHOOK_URL}' não parece ser uma URL válida.")
--- Fim de app/core/config.py ---

--- Início de app/core/dependencies.py (84 linhas) ---
# app/core/dependencies.py
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from motor.motor_asyncio import AsyncIOMotorDatabase
from typing import Annotated # Python 3.9+
import uuid

from app.db.mongodb_utils import get_database
from app.core.security import decode_token
from app.db import user_crud
from app.models.user import UserInDB, User # Import User para retorno

# Define o esquema OAuth2 para obter o token do header Authorization: Bearer <token>
# tokenUrl aponta para o nosso endpoint de login que gera o token
# O path relativo deve ser o correto APÓS o prefixo da API
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/v1/auth/login/access-token") # Ajuste se seu prefixo/rota for diferente

# Tipos anotados para dependências (mais legível)
DbDep = Annotated[AsyncIOMotorDatabase, Depends(get_database)]
TokenDep = Annotated[str, Depends(oauth2_scheme)]

async def get_current_user(
    db: DbDep,
    token: TokenDep # Obtém o token do header usando OAuth2PasswordBearer
) -> UserInDB: # Retorna o usuário completo do DB (incluindo senha hasheada)
               # Mude para 'User' se preferir retornar o modelo sem senha hasheada
    """
    Dependência para obter o usuário atual com base no token JWT:
    - Extrai e valida o token do header 'Authorization: Bearer <token>'.
    - Decodifica o token e obtém o ID do usuário ('sub').
    - Busca o usuário no banco de dados pelo ID.
    - Levanta exceção se o token for inválido, expirado ou o usuário não existir/estiver desativado.
    - Retorna o objeto do usuário encontrado.
    """
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Não foi possível validar as credenciais",
        headers={"WWW-Authenticate": "Bearer"},
    )

    # Decodifica o token JWT
    token_payload = decode_token(token)

    if token_payload is None or token_payload.sub is None:
         # Se decode_token retornou None, o token é inválido ou expirou
        raise credentials_exception

    # Tenta converter o 'sub' (subject/ID do usuário) para UUID
    try:
        user_id = uuid.UUID(str(token_payload.sub)) # Garante que sub seja tratado como string
    except ValueError:
         # O 'sub' no token não é um UUID válido
         raise credentials_exception

    # Busca o usuário no banco de dados usando o ID do token
    user = await user_crud.get_user_by_id(db=db, user_id=user_id)
    if user is None:
         # Usuário referenciado no token não existe mais no DB
         raise credentials_exception

    # Opcional: Poderia retornar o modelo User (sem hash de senha) aqui se preferir
    # return User.model_validate(user)
    return user # Retorna UserInDB (útil se precisarmos da info completa internamente)


async def get_current_active_user(
     # Esta dependência *reutiliza* a anterior
    current_user: Annotated[UserInDB, Depends(get_current_user)]
) -> UserInDB: # Mude para User se get_current_user retornar User
    """
    Dependência que garante que o usuário obtido de get_current_user
    não está desativado.
    """
    if current_user.disabled:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Usuário inativo")
    # Se passou, retorna o mesmo usuário validado
    # Poderia retornar User aqui também: User.model_validate(current_user)
    return current_user

# --- Tipos Anotados para Injeção ---
# Define tipos curtos para usar nos endpoints protegidos
CurrentUser = Annotated[UserInDB, Depends(get_current_active_user)]
# Use este se preferir retornar o modelo User sem a senha hasheada:
# CurrentUser = Annotated[User, Depends(get_current_active_user)] # Se get_current_active_user retornar User--- Fim de app/core/dependencies.py ---

--- Início de app/core/email.py (107 linhas) ---
# app/core/email.py
import logging
from pathlib import Path
from typing import List, Optional, Dict, Any
from fastapi_mail import FastMail, MessageSchema, ConnectionConfig, MessageType
from pydantic import EmailStr, BaseModel
from app.core.config import settings 

logger = logging.getLogger(__name__)

# --- Configuração da conexão ---
conf = ConnectionConfig(
    MAIL_USERNAME=settings.MAIL_USERNAME or "", 
    MAIL_PASSWORD=settings.MAIL_PASSWORD or "",
    MAIL_FROM=settings.MAIL_FROM or EmailStr("default@example.com"), 
    MAIL_PORT=settings.MAIL_PORT,
    MAIL_SERVER=settings.MAIL_SERVER or "",
    MAIL_FROM_NAME=settings.MAIL_FROM_NAME or "Default Sender",
    MAIL_STARTTLS=settings.MAIL_STARTTLS,
    MAIL_SSL_TLS=settings.MAIL_SSL_TLS,
    USE_CREDENTIALS=settings.USE_CREDENTIALS,
    VALIDATE_CERTS=settings.VALIDATE_CERTS,
    TEMPLATE_FOLDER=Path(settings.EMAIL_TEMPLATES_DIR) if settings.EMAIL_TEMPLATES_DIR else None, 
)

# Instância principal do FastMail
fm = FastMail(conf)

async def send_email_async(
    subject: str,
    recipient_to: List[EmailStr],
    body: Dict[str, Any], 
    template_name: Optional[str] = None, 
    plain_text_body: Optional[str] = None 
):
    """
    Envia um e-mail de forma assíncrona.

    Args:
        subject: Assunto do e-mail.
        recipient_to: Lista de destinatários.
        body: Dicionário com variáveis para preencher o template HTML.
        template_name: Nome do arquivo do template HTML (sem extensão, deve estar em EMAIL_TEMPLATES_DIR).
        plain_text_body: Conteúdo alternativo em texto puro.
    """
    if not settings.MAIL_ENABLED:
        logger.warning("Envio de e-mail desabilitado nas configurações (MAIL_ENABLED=false).")
        return

    if not all([settings.MAIL_USERNAME, settings.MAIL_PASSWORD, settings.MAIL_FROM, settings.MAIL_SERVER]):
        logger.error("Configurações essenciais de e-mail ausentes (USERNAME, PASSWORD, FROM, SERVER). Não foi possível enviar.")
        return

    message = MessageSchema(
        subject=subject,
        recipients=recipient_to,
        template_body=body if template_name else None, 
        body=plain_text_body if not template_name else None, 
        subtype=MessageType.html if template_name else MessageType.plain, 
    )

    try:
        logger.info(f"Tentando enviar e-mail para {recipient_to} com assunto '{subject}'...")
        await fm.send_message(message, template_name=template_name)
        logger.info(f"E-mail enviado com sucesso para {recipient_to}.")
    except Exception as e:
        logger.exception(f"Erro ao enviar e-mail para {recipient_to}: {e}")

# --- Funções utilitárias ---

async def send_urgent_task_notification(
    user_email: EmailStr,
    user_name: str,
    task_title: str,
    task_id: str,
    task_due_date: Optional[str],
    priority_score: float
):
    """Envia notificação de tarefa urgente."""

    subject = f"🚨 Tarefa Urgente no SmartTask: {task_title}"

    # Link para a tarefa
    task_link = f"{settings.FRONTEND_URL}/tasks/{task_id}" if settings.FRONTEND_URL else None

    # Corpo/Contexto para o template
    email_body_data = {
        "task_title": task_title,
        "user_name": user_name,
        "due_date": task_due_date or "N/A",
        "priority_score": f"{priority_score:.2f}", 
        "task_link": task_link,
        "project_name": settings.PROJECT_NAME
    }

    # Nome do template HTML (criaremos abaixo)
    template_name = "urgent_task.html"

    await send_email_async(
        subject=subject,
        recipient_to=[user_email],
        body=email_body_data,
        template_name=template_name,
        plain_text_body=f"Olá {user_name},\nA tarefa '{task_title}' no {settings.PROJECT_NAME} é considerada urgente.\n"
                       f"Prioridade: {priority_score:.2f}, Vencimento: {task_due_date or 'N/A'}.\n"
                       f"{'Acesse a tarefa aqui: ' + task_link if task_link else ''}"
    )--- Fim de app/core/email.py ---

--- Início de app/core/security.py (113 linhas) ---
# app/core/security.py
from datetime import datetime, timedelta, timezone
from typing import Any, Union, Optional
from passlib.context import CryptContext
from jose import jwt, JWTError
from pydantic import ValidationError # Para erros de validação de token

from app.core.config import settings # Importa configurações (SECRET_KEY, etc.)
from app.models.token import TokenPayload # Modelo para dados do payload

# --- Configuração do Hashing de Senha ---
# Define o contexto do passlib, especificando os esquemas de hash permitidos
# 'bcrypt' será o padrão para novas senhas. Outros são para senhas legadas (se houver)
# 'deprecated="auto"' significa que senhas com esquemas antigos serão automaticamente atualizadas para bcrypt no login
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

ALGORITHM = settings.JWT_ALGORITHM
ACCESS_TOKEN_EXPIRE_MINUTES = settings.ACCESS_TOKEN_EXPIRE_MINUTES

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """Verifica se a senha fornecida corresponde à senha hasheada."""
    try:
        return pwd_context.verify(plain_password, hashed_password)
    except ValueError: # Pode ocorrer se o hash não for reconhecido
         return False


def get_password_hash(password: str) -> str:
    """Gera o hash de uma senha usando bcrypt."""
    return pwd_context.hash(password)

# --- Funções JWT ---

def create_access_token(subject: Union[str, Any],username: str, expires_delta: Optional[timedelta] = None) -> str:
    """
    Cria um novo token de acesso JWT.

    Args:
        subject: O identificador único do sujeito do token (ex: user ID ou username).
        expires_delta: Tempo de vida do token. Se None, usa o padrão das configurações.

    Returns:
        O token JWT codificado como string.
    """
    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)

    # Garante que o subject (ID do usuário) seja uma string para o JWT
    # Embora Any seja aceito, geralmente é um ID (UUID, int, str)
    subject_str = str(subject)

    to_encode = {
        "exp": expire,
        "sub": subject_str, # User ID
        "username": username # Username
    }

    # Adicione outros dados ao payload se necessário (cuidado com o tamanho do token)
    # to_encode.update({"username": username_do_subject})

    encoded_jwt = jwt.encode(to_encode, settings.JWT_SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt


def decode_token(token: str) -> Optional[TokenPayload]:
    """
    Decodifica um token JWT e valida seu conteúdo.

    Args:
        token: O token JWT string.

    Returns:
        Um objeto TokenPayload com os dados do token se válido, None caso contrário.
    """
    try:
        # Decodifica o token
        payload = jwt.decode(
            token,
            settings.JWT_SECRET_KEY,
            algorithms=[ALGORITHM]
        )

        # Extrai os dados esperados (subject/user_id)
        # subject = payload.get("sub") # 'sub' é o id do usuário (UUID string)
        # username = payload.get("username") # Se incluímos o username no token

        # if subject is None: # or username is None:
        #     return None

        # Valida os dados do payload com o modelo Pydantic
        # Isso garante que os tipos e campos esperados estejam presentes
        token_data = TokenPayload.model_validate(payload)

        # Verifica se o token expirou (embora jwt.decode geralmente faça isso)
        if token_data.exp is not None:
             if datetime.now(timezone.utc) > datetime.fromtimestamp(token_data.exp, tz=timezone.utc):
                 # Poderia levantar uma exceção específica de expiração aqui
                 return None # Ou trate como inválido

        # Aqui poderíamos converter o 'sub' (string UUID) de volta para UUID se necessário
        # try:
        #     token_data.sub = uuid.UUID(token_data.sub)
        # except ValueError:
        #     return None # ID inválido no token

        return token_data

    except (JWTError, ValidationError, KeyError) as e:
        # Logar o erro `e` aqui seria útil para depuração
        print(f"Erro ao decodificar token: {e}") # Log de erro simples
        return None--- Fim de app/core/security.py ---

--- Início de app/core/utils.py (154 linhas) ---
# app/core/utils.py
from datetime import date, datetime, timezone
from typing import Any, Dict, Optional, TYPE_CHECKING
import math
from app.core.config import settings 
from app.models.task import Task
import httpx 
import json  
import logging 
import hmac   
import hashlib 

logger = logging.getLogger(__name__)

# --- Função de cálculo de prioridade ---
def calculate_priority_score(
    importance: int,
    due_date: Optional[date]
    ) -> Optional[float]:
    """
    Calcula a pontuação de prioridade de uma tarefa.

    Args:
        importance: Nível de importância da tarefa (ex: 1-5).
        due_date: Data de vencimento da tarefa (opcional).

    Returns:
        A pontuação de prioridade calculada, ou None se não aplicável.
        Retornaremos float para permitir scores não inteiros.
    """
    if not 1 <= importance <= 5:
         return None 

    # --- Importância
    importance_score = importance * settings.PRIORITY_WEIGHT_IMPORTANCE

    # --- Prazo
    due_date_score = 0.0 
    if due_date:
        today = date.today() 

        days_remaining = (due_date - today).days

        if days_remaining < 0: 
            due_date_score = settings.PRIORITY_SCORE_IF_OVERDUE

        elif days_remaining == 0: 
             due_date_score = settings.PRIORITY_WEIGHT_DUE_DATE / 1.0 

        elif days_remaining > 0:
            effective_days = max(1, days_remaining) 
            due_date_score = settings.PRIORITY_WEIGHT_DUE_DATE / effective_days
            importance_score = importance * settings.PRIORITY_WEIGHT_IMPORTANCE 

        else:
             due_date_score = 0.0

    elif settings.PRIORITY_DEFAULT_SCORE_NO_DUE_DATE is not None:
         due_date_score = settings.PRIORITY_DEFAULT_SCORE_NO_DUE_DATE

    # --- Combinar Scores
    total_score = round(due_date_score + importance_score, 2) 

    return total_score

# --- Função de tarefa urgente ---
def is_task_urgent(task: Task) -> bool:
    """Verifica se uma tarefa atende aos critérios de urgência para notificação."""
    # --- Critério 0: Tarefa deve ter um score ou prazo
    if task.priority_score is None and task.due_date is None:
         return False 

    # --- Critério 1: Score acima do limiar (e não None)
    if task.priority_score is not None and task.priority_score > settings.EMAIL_URGENCY_THRESHOLD:
        return True

    # --- Critério 2: Vence hoje ou está atrasada
    if task.due_date:
        today = date.today()
        days_remaining = (task.due_date - today).days
        if days_remaining <= 0:
            return True

    return False

# --- Função de Webhook ---
async def send_webhook_notification(
    event_type: str,
    task_data: Dict[str, Any] 
    ):
    """
    Envia uma notificação via webhook para a URL configurada (se houver).
    Executada em background.

    Args:
        event_type: Tipo do evento (ex: 'task.created', 'task.updated').
        task_data: Dados da tarefa como um dicionário Python.
    """
    if not settings.WEBHOOK_URL:
        logger.debug("Webhook URL não configurada, pulando envio.") 
        return 

    # Converter URL Pydantic para string
    webhook_url_str = str(settings.WEBHOOK_URL)

    payload = {
        "event": event_type,
        "task": task_data,
        "timestamp": datetime.now(timezone.utc).isoformat() 
    }

    headers = {
        "Content-Type": "application/json",
        "User-Agent": "SmartTask-Webhook-Client/1.0" 
    }

    # --- Segurança de Assinatura ---
    if settings.WEBHOOK_SECRET:
        try:
            payload_bytes = json.dumps(payload, separators=(',', ':'), sort_keys=True).encode('utf-8')
            secret_bytes = settings.WEBHOOK_SECRET.encode('utf-8')

            signature = hmac.new(secret_bytes, payload_bytes, hashlib.sha256).hexdigest()
            headers["X-SmartTask-Signature"] = f"sha256={signature}"
        except Exception as e:
             logger.error(f"Erro ao gerar assinatura HMAC para webhook: {e}")
             return 

    # --- Envio da Requisição HTTP ---
    try:
         async with httpx.AsyncClient() as client:
            logger.info(f"Enviando webhook evento '{event_type}' para {webhook_url_str}")
            response = await client.post(
                webhook_url_str,
                json=payload, 
                headers=headers,
                timeout=10.0 
            )

            response.raise_for_status()

            logger.info(f"Webhook enviado com sucesso para {webhook_url_str}. Status: {response.status_code}")

    except httpx.TimeoutException:
         logger.error(f"Timeout ao enviar webhook para {webhook_url_str}")
    except httpx.RequestError as exc:
         logger.error(f"Erro na requisição ao enviar webhook para {webhook_url_str}: {exc}")
    except httpx.HTTPStatusError as exc:
         logger.error(
             f"Erro no servidor do webhook ({webhook_url_str}). "
             f"Status: {exc.response.status_code}. Resposta: {exc.response.text[:200]}..." 
         )
    except Exception as e:
         logger.exception(f"Erro inesperado ao enviar webhook para {webhook_url_str}: {e}")--- Fim de app/core/utils.py ---

--- Início de app/db/mongodb_utils.py (61 linhas) ---
# app/db/mongodb_utils.py
from typing import Optional
import motor.motor_asyncio
from app.core.config import settings 
import logging
from motor.motor_asyncio import AsyncIOMotorDatabase

logger = logging.getLogger(__name__)

# Variáveis globais para o cliente e banco de dados
db_client: motor.motor_asyncio.AsyncIOMotorClient | None = None
db_instance: motor.motor_asyncio.AsyncIOMotorDatabase | None = None

async def connect_to_mongo() -> Optional[AsyncIOMotorDatabase]:
    """
    Conecta-se ao MongoDB na inicialização da aplicação.
    """
    global db_client, db_instance

    try:

        db_client = motor.motor_asyncio.AsyncIOMotorClient(
            settings.MONGODB_URL,
            serverSelectionTimeoutMS=5000 
        )
        await db_client.admin.command('ping')

        db_instance = db_client[settings.DATABASE_NAME]

        return db_instance
    
    except Exception as e:
        logger.error(f"Não foi possível conectar ao MongoDB: {e}")
        db_client = None
        db_instance = None
        return None

async def close_mongo_connection():
    """
    Fecha a conexão com o MongoDB no encerramento da aplicação.
    """
    global db_client
    if db_client:
        db_client.close()
    else:
        logger.warning("Tentativa de fechar conexão com MongoDB, mas cliente não estava inicializado.")

def get_database() -> motor.motor_asyncio.AsyncIOMotorDatabase:
    """
    Retorna a instância do banco de dados MongoDB.
    Pode ser usada como uma dependência FastAPI ou chamada diretamente.
    """
    if db_instance is None:
        logger.error("Tentativa de obter instância do DB antes da inicialização!")
        raise RuntimeError("A conexão com o banco de dados não foi inicializada.")
    return db_instance

# Você pode também querer uma função para obter coleções específicas:
# def get_task_collection() -> motor.motor_asyncio.AsyncIOMotorCollection:
#     db = get_database()
#     return db.get_collection("tasks") # Nome da coleção de tarefas--- Fim de app/db/mongodb_utils.py ---

--- Início de app/db/task_crud.py (7 linhas) ---
# app/db/task_crud.py

# Nome da coleção no MongoDB para tarefas
TASKS_COLLECTION = "tasks"

# Futuramente, podemos adicionar funções CRUD específicas para tarefas aqui,
# se quisermos centralizá-las como fizemos com os usuários.
--- Fim de app/db/task_crud.py ---

--- Início de app/db/user_crud.py (111 linhas) ---
# app/db/user_crud.py
import logging
from motor.motor_asyncio import AsyncIOMotorDatabase, AsyncIOMotorCollection
from typing import Optional, List
import uuid
from datetime import datetime, timezone
from pymongo.errors import DuplicateKeyError

from app.models.user import UserCreate, UserInDB, UserUpdate
from app.core.security import get_password_hash

from motor.motor_asyncio import AsyncIOMotorDatabase

# Nome da coleção de usuários
USERS_COLLECTION = "users"

# --- Funções CRUD para Usuários ---

async def get_user_by_id(db: AsyncIOMotorDatabase, user_id: uuid.UUID) -> Optional[UserInDB]:
    """Busca um usuário pelo seu ID (UUID)."""
    user_dict = await db[USERS_COLLECTION].find_one({"id": str(user_id)})
    if user_dict:
        user_dict.pop('_id', None) # Remove _id do mongo
        try:
             return UserInDB.model_validate(user_dict)
        except Exception: # Tratamento básico de erro de validação
             return None
    return None

async def get_user_by_username(db: AsyncIOMotorDatabase, username: str) -> Optional[UserInDB]:
    """Busca um usuário pelo seu nome de usuário."""
    # Index no 'username' é recomendado para performance
    user_dict = await db[USERS_COLLECTION].find_one({"username": username})
    if user_dict:
         user_dict.pop('_id', None)
         try:
            return UserInDB.model_validate(user_dict)
         except Exception:
            return None
    return None

async def get_user_by_email(db: AsyncIOMotorDatabase, email: str) -> Optional[UserInDB]:
    """Busca um usuário pelo seu e-mail."""
     # Index no 'email' é recomendado para performance e unicidade
    user_dict = await db[USERS_COLLECTION].find_one({"email": email})
    if user_dict:
        user_dict.pop('_id', None)
        try:
            return UserInDB.model_validate(user_dict)
        except Exception:
            return None
    return None

async def create_user(db: AsyncIOMotorDatabase, user_in: UserCreate) -> Optional[UserInDB]:
    """Cria um novo usuário no banco de dados."""
    hashed_password = get_password_hash(user_in.password)

    user_db_data = {
        "id": uuid.uuid4(),
        "username": user_in.username,
        "email": user_in.email,
        "hashed_password": hashed_password,
        "full_name": user_in.full_name,
        "disabled": False, # Novo usuário começa ativo
        "created_at": datetime.now(timezone.utc),
        "updated_at": None
    }
    # Tenta validar antes de inserir (boa prática)
    try:
        user_db_obj = UserInDB.model_validate(user_db_data)
    except Exception as validation_error:
        # Logar validation_error seria importante
        print(f"Erro de validação Pydantic ao criar user_db_obj: {validation_error}")
        return None # Ou levantar uma exceção customizada

    # Converte para dicionário para inserir no Mongo
    user_db_dict = user_db_obj.model_dump(mode="json")

    try:
        insert_result = await db[USERS_COLLECTION].insert_one(user_db_dict)
        if not insert_result.acknowledged:
             # Logar erro
             return None
         # Retorna o objeto UserInDB validado (não o dict)
        return user_db_obj
    except DuplicateKeyError:
        # Este erro ocorreria se tivéssemos índices únicos no Mongo
        # Vamos tratar isso no endpoint que chama esta função
        raise # Re-lança a exceção para ser tratada na rota
    except Exception as e:
         # Logar erro 'e'
         print(f"Erro inesperado ao inserir usuário no DB: {e}")
         return None


# Adicionar funções de update e delete se necessário
# async def update_user(...)
# async def delete_user(...)

# --- Configuração de Índices MongoDB (Importante!) ---
# Esta função pode ser chamada uma vez na inicialização da aplicação
# ou você pode criar os índices manualmente no Atlas/Mongo Shell.
async def create_user_indexes(db: AsyncIOMotorDatabase):
    """Cria índices únicos para username e email se não existirem."""
    collection = db[USERS_COLLECTION]
    try:
        await collection.create_index("username", unique=True, name="username_unique_idx")
        await collection.create_index("email", unique=True, name="email_unique_idx")
        logging.info("Índices de usuário ('username', 'email') verificados/criados.")
    except Exception as e:
        logging.error(f"Erro ao criar índices de usuário: {e}")--- Fim de app/db/user_crud.py ---

--- Início de app/main.py (66 linhas) ---
# app/main.py

# Importações
import logging
from fastapi import FastAPI
from fastapi.concurrency import asynccontextmanager
from app.routers import tasks
from app.routers import auth
from app.db.mongodb_utils import connect_to_mongo, close_mongo_connection
from app.db.user_crud import create_user_indexes
from app.core.config import settings

# Configuração básica de logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Gerenciador de contexto de vida útil (eventos startup/shutdown)
# Docs: https://fastapi.tiangolo.com/advanced/events/#lifespan
@asynccontextmanager
async def lifespan(app: FastAPI):
    db = await connect_to_mongo()
    app.state.db = db
    if app.state.db is not None:
         await create_user_indexes(app.state.db)

    yield
    
    await close_mongo_connection()
    
# Instância FastAPI
app = FastAPI(
    title="SmartTask API",
    description="API RESTful para gerenciamento de tarefas com prioridade inteligente.",
    version="0.1.0",
    contact={
        "name": "Eng. Soft. Cláudio",
        "url": "https://www.linkedin.com/in/claudiodelimatosta/", 
        "email": "claudiodelimatosta@gmail.com", 
    },
    license_info={
        "name": "MIT License",
        "url": "https://opensource.org/licenses/MIT",
    },
    lifespan=lifespan
)

# Inclusões
app.include_router(auth.router, prefix=f"{settings.API_V1_STR}/auth")
app.include_router(tasks.router, prefix=settings.API_V1_STR)


# Endpoint Raiz
@app.get("/", tags=["Root"]) 
async def read_root():
    return {"message": "Bem-vindo à {settings.PROJECT_NAME}!"}

# Adicione aqui mais endpoints e lógica da aplicação futuramente...

# (Para rodar localmente com Uvicorn, você usará o comando no terminal,
#  mas esta seção é útil se você fosse rodar o script diretamente)
if __name__ == "__main__":
    import uvicorn
    # Roda a aplicação usando o Uvicorn
    # host="0.0.0.0" permite acesso de fora do container/máquina local
    reload=True # reinicia o servidor automaticamente ao salvar alterações 
    uvicorn.run("main:app", host="0.0.0.0", port=8000, reload=True)--- Fim de app/main.py ---

--- Início de app/models/task.py (98 linhas) ---
# app/models/task.py

from pydantic import BaseModel, Field
from typing import Optional, List 
from datetime import date, datetime, timezone
import uuid 
from enum import Enum
from pydantic import ConfigDict

class TaskStatus(str, Enum):
    PENDING = "pendente"
    IN_PROGRESS = "em_progresso"
    COMPLETED = "concluída"
    CANCELLED = "cancelada"

# Modelo base para os campos comuns de uma tarefa
class TaskBase(BaseModel):
    title: str = Field(..., title="Título da Tarefa", min_length=3, max_length=100)
    description: Optional[str] = Field(None, title="Descrição Detalhada", max_length=500)
    importance: int = Field(..., ge=1, le=5, title="Importância (1-5)")
    due_date: Optional[date] = Field(None, title="Data de Vencimento")
    status: TaskStatus = Field(default=TaskStatus.PENDING, title="Status da Tarefa")
    tags: Optional[List[str]] = Field(None, title="Etiquetas/Tags")
    project: Optional[str] = Field(None, title="Projeto Associado")
    # owner_id: Optional[uuid.UUID] = Field(None, title="ID do Proprietário da Tarefa")
    model_config = {
        "json_schema_extra": {
            "examples": [
                {
                    "title": "Finalizar relatório mensal",
                    "description": "Compilar dados e escrever o relatório final.",
                    "importance": 4,
                    "due_date": "2024-08-15",
                    "status": "pendente",
                    "tags": ["relatorios", "financeiro"],
                    "project": "Relatórios Q3"
                    # owner_id não precisa estar no exemplo de criação base
                }
            ]
        }
    }

class TaskCreate(TaskBase):
    pass

class TaskUpdate(BaseModel):
    title: Optional[str] = Field(None, title="Título da Tarefa", min_length=3, max_length=100)
    description: Optional[str] = Field(None, title="Descrição Detalhada", max_length=500)
    importance: Optional[int] = Field(None, ge=1, le=5, title="Importância (1-5)")
    due_date: Optional[date] = Field(None, title="Data de Vencimento")
    status: Optional[TaskStatus] = Field(None, title="Status da Tarefa")
    tags: Optional[List[str]] = Field(None, title="Etiquetas/Tags")
    project: Optional[str] = Field(None, title="Projeto Associado")
    priority_score: Optional[float] = Field(None, title="Pontuação de Prioridade (para ajustes manuais, talvez?)")

    model_config = {
         "json_schema_extra": {
            "examples": [
                {
                    "title": "Revisar relatório mensal v2",
                    "status": TaskStatus.IN_PROGRESS,
                    "importance": 5
                }
            ]
        }
    }


class TaskInDBBase(TaskBase):
    id: uuid.UUID = Field(..., title="ID Único da Tarefa")
    owner_id: uuid.UUID = Field(..., title="ID do Proprietário da Tarefa")
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc), title="Data de Criação")
    updated_at: Optional[datetime] = Field(None, title="Data da Última Atualização")
    priority_score: Optional[float] = Field(None, title="Pontuação de Prioridade Calculada") 
    model_config = ConfigDict(from_attributes=True)

class Task(TaskInDBBase):
    model_config = ConfigDict(
         from_attributes=True, 
         json_schema_extra={ 
             "examples": [
                {
                    "id": "f47ac10b-58cc-4372-a567-0e02b2c3d479",
                    "owner_id": "a1b2c3d4-e5f6-7890-1234-567890abcdef", 
                    "title": "Finalizar relatório mensal",
                    "description": "Compilar dados e escrever o relatório final.",
                    "importance": 4,
                    "due_date": "2024-08-15",
                    "status": "pendente",
                    "tags": ["relatorios", "financeiro"],
                    "project": "Relatórios Q3",
                    "created_at": "2024-07-28T10:00:00Z",
                    "updated_at": None,
                    "priority_score": None 
                }
            ]
         }
     )--- Fim de app/models/task.py ---

--- Início de app/models/token.py (15 linhas) ---
# app/models/token.py
from pydantic import BaseModel, Field
from typing import Optional
import uuid

class Token(BaseModel):
    """Modelo para a resposta do token JWT."""
    access_token: str = Field(..., title="Token de Acesso JWT")
    token_type: str = Field(default="bearer", title="Tipo do Token")

class TokenPayload(BaseModel):
    """Modelo para os dados contidos no payload do JWT."""
    sub: uuid.UUID = Field(..., title="ID do Usuário (Subject)")
    username: str = Field(..., title="Nome de Usuário")
    exp: Optional[int] = Field(None, title="Timestamp de Expiração")
--- Fim de app/models/token.py ---

--- Início de app/models/user.py (56 linhas) ---
# app/models/user.py
from pydantic import BaseModel, Field, EmailStr, ConfigDict
from typing import Optional
import uuid
from datetime import datetime, timezone

class UserBase(BaseModel):
    """Campos base para um usuário."""
    email: EmailStr = Field(..., title="Endereço de E-mail", description="Deve ser um e-mail válido e único.")
    username: str = Field(..., title="Nome de Usuário", min_length=3, max_length=50, pattern="^[a-zA-Z0-9_]+$", description="Nome de usuário único (letras, números, underscore).")
    full_name: Optional[str] = Field(None, title="Nome Completo", max_length=100)
    disabled: bool = Field(default=False, title="Status Desativado", description="Indica se o usuário está desativado.")

class UserCreate(BaseModel):
    """Campos necessários para criar um novo usuário (recebido pela API)."""
    email: EmailStr = Field(..., title="Endereço de E-mail")
    username: str = Field(..., title="Nome de Usuário", min_length=3, max_length=50, pattern="^[a-zA-Z0-9_]+$")
    password: str = Field(..., title="Senha", min_length=8, description="Senha (será hasheada antes de salvar).")
    full_name: Optional[str] = Field(None, title="Nome Completo", max_length=100)

    model_config = {
        "json_schema_extra": {
            "examples": [
                {
                    "email": "userTest@example.com",
                    "username": "userTest",
                    "password": "averysecurepassword",
                    "full_name": "User Test"
                }
            ]
        }
    }

class UserUpdate(BaseModel):
    """Campos que podem ser atualizados para um usuário."""
    email: Optional[EmailStr] = Field(None, title="Endereço de E-mail")
    full_name: Optional[str] = Field(None, title="Nome Completo", max_length=100)
    disabled: Optional[bool] = Field(None, title="Status Desativado")

class UserInDBBase(UserBase):
    """Modelo de usuário como armazenado no banco, incluindo ID e senha hasheada."""
    id: uuid.UUID = Field(..., title="ID Único do Usuário")
    hashed_password: str = Field(..., title="Senha Hasheada")
    created_at: datetime = Field(default_factory=datetime.now(timezone.utc), title="Data de Criação")
    updated_at: Optional[datetime] = Field(None, title="Data da Última Atualização")
    model_config = ConfigDict(from_attributes=True)

class User(UserBase):
    """Modelo de usuário para respostas da API (sem senha)."""
    id: uuid.UUID = Field(..., title="ID Único do Usuário")
    created_at: datetime
    updated_at: Optional[datetime] = None
    model_config = ConfigDict(from_attributes=True)

class UserInDB(UserInDBBase):
   pass--- Fim de app/models/user.py ---

--- Início de app/routers/auth.py (102 linhas) ---
# app/routers/auth.py
from fastapi import APIRouter, Depends, HTTPException, status, Body
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from motor.motor_asyncio import AsyncIOMotorDatabase
from pymongo.errors import DuplicateKeyError
from typing import Annotated
from app.db.mongodb_utils import get_database
from app.db import user_crud 
from app.models.user import User, UserCreate
from app.models.token import Token
from app.core.security import verify_password, create_access_token

router = APIRouter(
    tags=["Authentication"],
)

DbDep = Annotated[AsyncIOMotorDatabase, Depends(get_database)]

@router.post(
    "/register",
    response_model=User, 
    status_code=status.HTTP_201_CREATED,
    summary="Registra um novo usuário",
    response_description="O usuário recém-registrado.",
)
async def register_user(
    db: DbDep,
    user_in: Annotated[UserCreate, Body(description="Dados do novo usuário")]):
    """
    Registra um novo usuário no sistema:
    - Verifica se o username ou email já existem.
    - Hasheia a senha.
    - Salva o usuário no banco de dados.
    - Retorna os dados do usuário criado (sem a senha).
    """
    existing_user = await user_crud.get_user_by_username(db, user_in.username)
    if existing_user:
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=f"Usuário '{user_in.username}' já existe.",
        )
    existing_email = await user_crud.get_user_by_email(db, user_in.email)
    if existing_email:
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=f"E-mail '{user_in.email}' já registrado.",
        )

    try:
        created_user_db = await user_crud.create_user(db=db, user_in=user_in)
        if created_user_db is None:
            raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                                detail="Não foi possível criar o usuário.")
        return User.model_validate(created_user_db)
    except DuplicateKeyError:
         raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail="Usuário ou e-mail já registrado (conflito de índice único).",
         )
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                            detail="Ocorreu um erro inesperado durante o registro.")


@router.post(
    "/login/access-token",
    response_model=Token,
    summary="Obtém um token de acesso JWT",
    description="Autentica o usuário com username e senha (form data) e retorna um token JWT.",
)
async def login_for_access_token(
    db: DbDep,
    form_data: Annotated[OAuth2PasswordRequestForm, Depends()]
):
    """
    Endpoint de login padrão OAuth2:
    - Recebe `username` e `password` via form-data.
    - Busca o usuário pelo username.
    - Verifica se o usuário existe e se a senha está correta.
    - Verifica se o usuário não está desativado.
    - Cria e retorna um token de acesso JWT.
    """
    user = await user_crud.get_user_by_username(db, form_data.username)

    if not user or not verify_password(form_data.password, user.hashed_password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Usuário ou senha incorretos.",
            headers={"WWW-Authenticate": "Bearer"},
        )
    if user.disabled:
         raise HTTPException(
             status_code=status.HTTP_400_BAD_REQUEST,
             detail="Usuário inativo."
         )

    access_token = create_access_token(
        subject=user.id,
        username=user.username
        )

    return Token(access_token=access_token, token_type="bearer")--- Fim de app/routers/auth.py ---

--- Início de app/routers/tasks.py (434 linhas) ---
# app/routers/tasks.py

# --- Importações Essenciais ---
import logging
from typing import List, Optional, Annotated 
import uuid 
from datetime import date, datetime, timezone 

# --- Imports do FastAPI ---
from fastapi import (
    APIRouter, HTTPException, Body, status, Depends, Response, Query,
    BackgroundTasks
)

# --- Imports do MongoDB/Motor ---
from motor.motor_asyncio import AsyncIOMotorDatabase, AsyncIOMotorCollection
from pymongo import DESCENDING, ASCENDING
from pymongo.errors import DuplicateKeyError
from pydantic import ValidationError 

# --- Imports da Nossa Aplicação ---
from app.models.task import Task, TaskCreate, TaskUpdate, TaskStatus 
from app.db import task_crud 
from app.db.mongodb_utils import get_database 
from app.core.dependencies import CurrentUser
from app.models.user import UserInDB 
from app.core.utils import calculate_priority_score, is_task_urgent, send_webhook_notification 

# --- Instanciar Logger ---
logger = logging.getLogger(__name__)

# --- Configuração do Roteador ---
router = APIRouter(
    prefix="/tasks", 
    tags=["Tasks"], 
    responses={ 
        status.HTTP_404_NOT_FOUND: {"description": "Tarefa não encontrada"},
        status.HTTP_401_UNAUTHORIZED: {"description": "Não autorizado (Token inválido ou ausente)"},
        status.HTTP_403_FORBIDDEN: {"description": "Proibido (Usuário não tem permissão para este recurso)"}
    },
)

# --- Dependências Tipadas para Melhor Legibilidade ---
DbDep = Annotated[AsyncIOMotorDatabase, Depends(get_database)]

# Função auxiliar para obter a coleção de tarefas (simplifica injeção)
async def get_task_collection(db: DbDep) -> AsyncIOMotorCollection:
    """Retorna a coleção MongoDB 'tasks'."""
    return db[task_crud.TASKS_COLLECTION]
TaskCollectionDep = Annotated[AsyncIOMotorCollection, Depends(get_task_collection)]


# ==============================================================================
# --- ROTAS CRUD PROTEGIDAS PARA TAREFAS ---
# ==============================================================================

@router.post(
    "/",
    response_model=Task, 
    status_code=status.HTTP_201_CREATED, 
    summary="Cria uma nova tarefa",
    description="Cria uma nova tarefa associada ao usuário autenticado. A prioridade e owner_id são definidos automaticamente.",
    response_description="A tarefa recém-criada com todos os seus detalhes.",
)
async def create_task(
    task_in: Annotated[TaskCreate, Body(description="Dados da nova tarefa a ser criada")], 
    collection: TaskCollectionDep, 
    current_user: CurrentUser, 
    background_tasks: BackgroundTasks 
):
    """
    Endpoint para criar uma nova tarefa.

    - Recebe dados validados pelo modelo `TaskCreate`.
    - Calcula a `priority_score`.
    - Associa a tarefa ao `owner_id` do usuário logado.
    - Salva no MongoDB.
    - Envia notificações (e-mail, webhook) em background se necessário.
    - Retorna a tarefa criada.
    """
    # Converte dados de entrada Pydantic para dicionário, excluindo campos não enviados
    task_data = task_in.model_dump(exclude_unset=True)

    # --- Calcular Prioridade ---
    # Usa a função utilitária com os dados recebidos
    priority = calculate_priority_score(
        importance=task_in.importance,
        due_date=task_in.due_date
    )

    # --- Criar o objeto Tarefa completo para o DB ---
    task_db = Task(
        id=uuid.uuid4(),                  
        owner_id=current_user.id,          
        created_at=datetime.now(timezone.utc), 
        priority_score=priority,           
        **task_data                        
    )

    # Converte o objeto Pydantic para dicionário antes de inserir no MongoDB
    task_db_dict = task_db.model_dump(mode="json")

    try:
        # --- Inserir no Banco de Dados ---
        insert_result = await collection.insert_one(task_db_dict)
        if not insert_result.acknowledged:
             logger.error("Falha no ACK ao inserir tarefa no MongoDB.")
             raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                                detail="Falha ao salvar a tarefa no banco de dados.")

        # --- Disparar Tarefas em Background (Após Sucesso no DB) ---

        # 1. Webhook 
        task_dict_for_webhook = task_db.model_dump(mode="json") 
        background_tasks.add_task( 
             send_webhook_notification, 
             event_type="task.created",
             task_data=task_dict_for_webhook 
        )
        logger.info(f"Tarefa de webhook 'task.created' para {task_db.id} adicionada ao background.")

        # 2. Notificação por E-mail (se urgente e usuário configurado)
        # A lógica de envio de email em si não está implementada aqui, assumindo
        # que o worker ARQ cuida disso periodicamente.
        # Se quiséssemos enviar email *imediatamente* na criação/update:
        # if is_task_urgent(task_db):
        #     if current_user.email and current_user.full_name:
        #          background_tasks.add_task( # Também rodaria em background
        #              send_urgent_task_notification,
        #              user_email=current_user.email,
        #              # ... outros args ...
        #          )
        #          logger.info(f"Tarefa de email urgente para {task_db.id} adicionada ao background.")
        #     else:
        #          logger.warning(f"Usuário {current_user.id} sem e-mail/nome para notificação IMEDIATA da tarefa urgente {task_db.id}.")


    except DuplicateKeyError:
        logger.warning(f"Tentativa de criar tarefa duplicada para user {current_user.id}")
        raise HTTPException(status_code=status.HTTP_409_CONFLICT,
                            detail="Uma tarefa com identificador semelhante já existe para este usuário.")
    except Exception as e: 
        logger.exception(f"Erro inesperado ao criar tarefa ou agendar background tasks para user {current_user.id}: {e}")
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                            detail="Ocorreu um erro interno ao processar a criação da tarefa.")

    return task_db


@router.get(
    "/",
    response_model=List[Task],
    summary="Lista as tarefas do usuário autenticado",
    description="""Recupera uma lista de tarefas pertencentes ao usuário autenticado.
    Permite filtros por status, prazo (até uma data), projeto e tags (contendo todas).
    Permite ordenação por 'priority_score', 'due_date', 'created_at' ou 'importance'.""",
    response_description="Uma lista (possivelmente vazia) contendo as tarefas filtradas e ordenadas do usuário.",
)
async def list_tasks(
    collection: TaskCollectionDep,
    current_user: CurrentUser, 
    # --- Parâmetros de Filtro ---
    status_filter: Annotated[Optional[TaskStatus], Query(
        alias="status", title="Filtro por Status",
        description="Filtrar tarefas por um status específico."
    )] = None,
    due_before: Annotated[Optional[date], Query(
        title="Vencimento Antes De",
        description="Filtrar tarefas com prazo de vencimento até esta data (inclusive)."
    )] = None,
    project_filter: Annotated[Optional[str], Query(
        alias="project", title="Filtro por Projeto",
        description="Filtrar tarefas por nome exato do projeto.", min_length=1
    )] = None,
    tags_filter: Annotated[Optional[List[str]], Query(
        alias="tag", title="Filtro por Tags (AND)",
        description="Filtrar tarefas que contenham TODAS as tags especificadas (usar ?tag=t1&tag=t2).", min_length=1
    )] = None,
    # --- Parâmetros de Ordenação ---
    sort_by: Annotated[Optional[str], Query(
        title="Ordenar Por",
        description="Campo para ordenar: 'priority_score', 'due_date', 'created_at', 'importance'.",
        enum=["priority_score", "due_date", "created_at", "importance"] 
    )] = None,
    sort_order: Annotated[Optional[str], Query(
        title="Ordem",
        description="Ordem da ordenação: 'asc' ou 'desc'.",
        enum=["asc", "desc"] 
    )] = "desc", 
    # --- Parâmetros de Paginação ---
    limit: Annotated[int, Query(ge=1, le=1000, title="Limite de Resultados", description="Número máximo de tarefas a retornar.")] = 100,
    skip: Annotated[int, Query(ge=0, title="Pular Resultados", description="Número de tarefas a pular (para paginação).")] = 0,
):
    """
    Endpoint para listar tarefas do usuário autenticado com filtros, ordenação e paginação.
    """
    query = {"owner_id": str(current_user.id)}

    # --- Adicionar Filtros Opcionais à Query MongoDB ---
    if status_filter:
        query["status"] = status_filter.value 
    if due_before:
        query["due_date"] = {"$lte": datetime.combine(due_before, datetime.min.time(), tzinfo=timezone.utc)} 
    if project_filter:
        query["project"] = project_filter 
    if tags_filter:
        query["tags"] = {"$all": tags_filter}

    # --- Determinar Campo e Ordem de Ordenação ---
    sort_tuple = None
    if sort_by in ["priority_score", "due_date", "created_at", "importance"]:
        mongo_order = DESCENDING if sort_order.lower() == "desc" else ASCENDING
        sort_tuple = (sort_by, mongo_order)

    # --- Executar Query com Paginação e Ordenação ---
    try:
        tasks_cursor = collection.find(query).skip(skip).limit(limit)
        if sort_tuple:
            tasks_cursor = tasks_cursor.sort([sort_tuple]) 

        # --- Processar e Validar Resultados ---
        validated_tasks = []
        async for task_dict in tasks_cursor:
            task_dict.pop('_id', None) 
            try:
                # Valida cada dicionário retornado com o modelo Pydantic Task
                validated_tasks.append(Task.model_validate(task_dict))
            except (ValidationError, Exception) as e:
                logger.error(f"Erro ao validar tarefa do DB (list {current_user.id}): {task_dict} - Erro: {e}")
                # Em produção, decidir se continua ou retorna erro parcial
                continue # Pula tarefa inválida por enquanto

        return validated_tasks

    except Exception as e: 
        logger.exception(f"Erro ao buscar/processar tarefas para user {current_user.id} com query {query}: {e}")
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                            detail="Ocorreu um erro interno ao buscar as tarefas.")


@router.get(
    "/{task_id}",
    response_model=Task,
    summary="Busca uma tarefa específica por ID",
    description="Recupera os detalhes de uma tarefa específica, **se** ela pertencer ao usuário autenticado.",
    response_description="Os detalhes completos da tarefa encontrada.",
    responses={status.HTTP_403_FORBIDDEN: {"description": "Acesso negado a esta tarefa"}}
)
async def get_task(
    task_id: uuid.UUID, 
    collection: TaskCollectionDep,
    current_user: CurrentUser 
):
    """
    Endpoint para buscar uma única tarefa pelo seu ID (UUID).
    Apenas retorna a tarefa se o ID for encontrado E pertencer ao usuário logado.
    """
    # Busca no MongoDB usando o ID da tarefa e o ID do usuário logado
    task_dict = await collection.find_one({
        "id": str(task_id),          
        "owner_id": str(current_user.id) 
    })

    if task_dict:
        task_dict.pop('_id', None) 
        try:
            # Valida os dados do DB com o modelo Pydantic Task
            return Task.model_validate(task_dict)
        except (ValidationError, Exception) as e:
            logger.error(f"Erro ao validar tarefa {task_id} do DB para user {current_user.id}: {e}")
            # Pode indicar inconsistência de dados no DB
            raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                                detail="Erro ao processar dados da tarefa encontrada.")
    else:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND,
                            detail=f"Tarefa com ID {task_id} não encontrada.")


@router.put(
    "/{task_id}",
    response_model=Task,
    summary="Atualiza uma tarefa existente",
    description="Atualiza os campos de uma tarefa existente, **se** ela pertencer ao usuário autenticado. A prioridade é recalculada se necessário.",
    response_description="Os detalhes completos da tarefa atualizada.",
    responses={status.HTTP_403_FORBIDDEN: {"description": "Acesso negado a esta tarefa"}}
)
async def update_task(
    task_id: uuid.UUID, 
    task_update: Annotated[TaskUpdate, Body(description="Campos da tarefa a serem atualizados")], 
    collection: TaskCollectionDep,
    current_user: CurrentUser,
    background_tasks: BackgroundTasks 
):
    """
    Endpoint para atualizar campos específicos de uma tarefa.

    - Verifica se a tarefa pertence ao usuário.
    - Recebe dados validados pelo modelo `TaskUpdate`.
    - Recalcula `priority_score` se `importance` ou `due_date` mudarem.
    - Atualiza o campo `updated_at`.
    - Salva as alterações no MongoDB.
    - Envia webhook em background.
    - Retorna a tarefa completa e atualizada.
    """
    # --- Garantir que a tarefa existe e pertence ao usuário antes de prosseguir ---
    existing_task_dict = await collection.find_one({
        "id": str(task_id),
        "owner_id": str(current_user.id)
    })
    if not existing_task_dict:
        # Levanta 404 (ou 403 se preferíssemos verificar a existência geral)
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND,
                             detail=f"Tarefa {task_id} não encontrada ou não pertence a você.")

    # Validar tarefa existente para fácil acesso aos campos com tipos corretos
    try:
         existing_task = Task.model_validate(existing_task_dict)
    except Exception:
        logger.exception(f"Erro ao validar dados da tarefa existente {task_id} antes do update.")
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                                detail="Erro interno ao processar dados da tarefa existente.")

    # --- Preparar Dados para Atualização ---
    # Pega apenas os campos que foram explicitamente enviados no request 
    update_data = task_update.model_dump(exclude_unset=True, exclude={"owner_id"}) 

    # Se nenhum campo válido foi enviado para atualização
    if not update_data:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST,
                            detail="Nenhum campo válido fornecido para atualização.")

    # --- Recalcular Prioridade (se necessário) ---
    should_recalculate_priority = False
    current_importance = existing_task.importance
    current_due_date = existing_task.due_date

    # Verifica se os campos relevantes para prioridade foram enviados na atualização
    if "importance" in update_data and update_data["importance"] != current_importance:
        current_importance = update_data["importance"] 
        should_recalculate_priority = True
    if "due_date" in update_data:
        new_due_date_obj = update_data["due_date"] 
        if new_due_date_obj != current_due_date:
            current_due_date = new_due_date_obj 
            should_recalculate_priority = True

    # Recalcula se algum dos campos chave mudou
    if should_recalculate_priority:
         priority = calculate_priority_score(
            importance=current_importance,
            due_date=current_due_date     
         )
         update_data["priority_score"] = priority 
         logger.info(f"Recalculada prioridade para tarefa {task_id} para: {priority}")

    # --- Definir Timestamp de Atualização ---
    update_data["updated_at"] = datetime.now(timezone.utc)

    # --- Executar Atualização Atômica no Banco de Dados ---
    try:
        updated_task_dict_raw = await collection.find_one_and_update(
            {"id": str(task_id), "owner_id": str(current_user.id)}, 
            {"$set": update_data}, 
            return_document=True 
        )

        if not updated_task_dict_raw:
             logger.error(f"Falha ao encontrar a tarefa {task_id} durante find_one_and_update, após verificação inicial.")
             raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f"Tarefa {task_id} não encontrada durante a atualização.")

        # --- Processar Resultado e Enviar Webhook ---
        updated_task_dict_raw.pop('_id', None)
        try:
            updated_task = Task.model_validate(updated_task_dict_raw) 

            # Enviar Webhook em Background
            task_dict_for_webhook = updated_task.model_dump(mode="json")
            background_tasks.add_task(
                send_webhook_notification,
                event_type="task.updated",
                task_data=task_dict_for_webhook
            )
            logger.info(f"Tarefa de webhook 'task.updated' para {updated_task.id} adicionada ao background.")

            # Notificação por e-mail imediata poderia ser adicionada aqui também (via background_tasks) se necessário

            return updated_task 

        except (ValidationError, Exception) as e:
             logger.error(f"Erro ao validar tarefa atualizada do DB (ID: {task_id}) para user {current_user.id}: {e}")
             # Se a validação falhar após o update, indica um problema sério
             raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                                 detail="Erro ao processar dados da tarefa após atualização.")

    except Exception as e: 
         logger.exception(f"Erro ao atualizar tarefa {task_id} ou agendar background tasks: {e}")
         raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                             detail="Erro interno ao processar atualização da tarefa.")



@router.delete(
    "/{task_id}",
    status_code=status.HTTP_204_NO_CONTENT, 
    summary="Deleta uma tarefa",
    description="Remove permanentemente uma tarefa do banco de dados, **se** ela pertencer ao usuário autenticado.",
    # Documenta explicitamente os erros além dos globais
    responses={
        status.HTTP_404_NOT_FOUND: {"description": "Tarefa não encontrada ou não pertence a você"},
        status.HTTP_403_FORBIDDEN: {"description": "Acesso negado a esta tarefa"},
        status.HTTP_204_NO_CONTENT: {"description": "Tarefa deletada com sucesso (sem corpo de resposta)"},
    }
)
async def delete_task(
    task_id: uuid.UUID,
    collection: TaskCollectionDep,
    current_user: CurrentUser 
    # Nota: Não precisamos de BackgroundTasks aqui, mas poderia ter para um evento 'task.deleted'
):
    """
    Endpoint para deletar uma tarefa.
    Só permite deletar tarefas que pertencem ao usuário logado.
    """
    # Tenta deletar o documento que combina ID da tarefa E ID do usuário
    delete_result = await collection.delete_one({
        "id": str(task_id),
        "owner_id": str(current_user.id) 
    })

    # Verifica se algum documento foi realmente deletado
    if delete_result.deleted_count == 0:
         raise HTTPException(status_code=status.HTTP_404_NOT_FOUND,
                            detail=f"Tarefa com ID {task_id} não encontrada ou não pertence a você.")
    return Response(status_code=status.HTTP_204_NO_CONTENT)--- Fim de app/routers/tasks.py ---

--- Início de app/worker.py (133 linhas) ---
# app/worker.py
import asyncio
import logging
from datetime import date, datetime
from typing import Dict, Any, Optional
from motor.motor_asyncio import AsyncIOMotorDatabase 
from arq import cron
from arq.connections import RedisSettings
from redis.asyncio import Redis
from app.core.config import settings
from app.db.mongodb_utils import connect_to_mongo, close_mongo_connection, get_database 
from app.db import user_crud, task_crud 
from app.core.email import send_urgent_task_notification
from app.core.utils import is_task_urgent
from app.models.task import Task, TaskStatus 

logger = logging.getLogger("arq.worker")

# === FUNÇÃO DA TAREFA PERIÓDICA ===
# Será chamada pelo scheduler do ARQ
async def check_and_notify_urgent_tasks(ctx: Dict[str, Any]):
    """
    Tarefa periódica que busca tarefas urgentes e notifica os usuários.
    'ctx' é um dicionário passado pelo worker ARQ, contém recursos como conexão DB.
    """
    logger.info("Executando verificação de tarefas urgentes...")
    db: Optional[AsyncIOMotorDatabase] = ctx.get("db")

    if db is None:
         logger.error("Conexão com o banco de dados não disponível no contexto ARQ.")
         return

    tasks_collection = db[task_crud.TASKS_COLLECTION] 
    users_collection = db[user_crud.USERS_COLLECTION] 

    # --- Critérios de Busca no MongoDB ---
    # 1. Tarefas não concluídas ou canceladas
    # 2. Com priority_score > threshold OU com due_date <= hoje
    today_start = datetime.combine(date.today(), datetime.min.time()) 

    query = {
        "status": {"$nin": [TaskStatus.COMPLETED.value, TaskStatus.CANCELLED.value]},
        "$or": [
            {"priority_score": {"$gt": settings.EMAIL_URGENCY_THRESHOLD}},
            {"due_date": {"$lte": today_start}} 
        ]
    }

    urgent_tasks_cursor = tasks_collection.find(query)
    count = 0

    async for task_dict in urgent_tasks_cursor:
        task_dict.pop('_id', None)
        try:
             task = Task.model_validate(task_dict) 

             user = await user_crud.get_user_by_id(db, task.owner_id)

             if user and user.email and user.full_name and not user.disabled:
                logger.info(f"Tarefa urgente encontrada ({task.id}), notificando usuário {user.email}...")

                await send_urgent_task_notification(
                     user_email=user.email,
                     user_name=user.full_name,
                     task_title=task.title,
                     task_id=str(task.id),
                     task_due_date=str(task.due_date) if task.due_date else None,
                     priority_score=task.priority_score or 0.0
                 )
                count += 1
             elif not user:
                logger.warning(f"Usuário {task.owner_id} da tarefa urgente {task.id} não encontrado.")
             elif user and user.disabled:
                 logger.info(f"Usuário {user.username} da tarefa urgente {task.id} está desabilitado. Notificação não enviada.")
             else: 
                 logger.warning(f"Usuário {user.username} da tarefa urgente {task.id} sem e-mail ou nome completo. Notificação não enviada.")

        except Exception as e:
            logger.exception(f"Erro ao processar tarefa urgente {task_dict.get('id')}: {e}")
            continue 

    logger.info(f"Verificação de tarefas urgentes concluída. {count} notificações enviadas.")


# === CONFIGURAÇÕES DO WORKER ARQ ===
async def startup(ctx: Dict[str, Any]):
    """Função executada quando o worker ARQ inicia."""
    logger.info("Iniciando worker ARQ...")
    db_instance = await connect_to_mongo()
    if db_instance is not None:
         ctx["db"] = db_instance 
         logger.info("Conexão MongoDB estabelecida para o worker ARQ.")
    else:
         logger.error("Falha ao conectar ao MongoDB no startup do worker ARQ.")
         ctx["db"] = None


async def shutdown(ctx: Dict[str, Any]):
    """Função executada quando o worker ARQ termina."""
    logger.info("Encerrando worker ARQ...")
    if ctx.get("db")is not None:
        await close_mongo_connection() 
        logger.info("Conexão MongoDB fechada pelo worker ARQ.")

# Classe de configurações do worker para ARQ
# ARQ procurará por esta classe quando executarmos o worker
class WorkerSettings:
    on_startup = startup
    on_shutdown = shutdown

    # --- Consulta à lista de tarefas agendadas ---
    cron_jobs = [
        cron(check_and_notify_urgent_tasks, minute={*range(0, 60, 1)}, run_at_startup=True),
        cron(check_and_notify_urgent_tasks, hour=8, minute=0),
    ]

    # --- Configurações do Redis ---
    if settings.REDIS_URL:
        try:
             redis_settings: RedisSettings = RedisSettings(
                 host=settings.REDIS_URL.host or 'localhost', 
                 port=int(settings.REDIS_URL.port) if settings.REDIS_URL.port else 6379,
                 database=int(settings.REDIS_URL.path[1:]) if settings.REDIS_URL.path and settings.REDIS_URL.path != '/' else 0, 
                 password=settings.REDIS_URL.password, 
                 # conn_timeout=10,
                 # conn_retries=5,
                 # conn_retry_delay=1,
            )
        except Exception as e:
             logger.exception(f"Erro ao configurar RedisSettings a partir da URL: {settings.REDIS_URL} - Erro: {e}")
             raise ValueError(f"Erro ao processar REDIS_URL: {e}")
    else:
         raise ValueError("REDIS_URL não está definida nas configurações, worker ARQ não pode iniciar.")--- Fim de app/worker.py ---

--- Início de tests/__init__.py (97 linhas) ---
# tests/conftest.py
import pytest
import pytest_asyncio
from typing import AsyncGenerator, Dict, Generator 
import asyncio 
from httpx import AsyncClient
from app.main import app as fastapi_app 
from app.core.config import settings
from app.db.mongodb_utils import connect_to_mongo, close_mongo_connection, get_database
from motor.motor_asyncio import AsyncIOMotorClient, AsyncIOMotorDatabase
from app.db.user_crud import USERS_COLLECTION
from app.db.task_crud import TASKS_COLLECTION

# --- Configuração do Loop de Eventos ---
@pytest.fixture(scope="session")
def event_loop(request) -> Generator:
    """Cria uma instância do loop de eventos para toda a sessão de teste."""
    loop = asyncio.get_event_loop_policy().new_event_loop()
    yield loop
    loop.close()


# --- Fixture para o Cliente HTTP Async ---
@pytest_asyncio.fixture(scope="session")
async def test_async_client() -> AsyncGenerator[AsyncClient, None]:
    """
    Fixture que fornece um cliente HTTP assíncrono (httpx.AsyncClient)
    configurado para fazer requisições à nossa aplicação FastAPI.

    Este cliente interage com a app montada diretamente, sem precisar
    iniciar um servidor Uvicorn separado.
    """
    # Conecta ao banco ANTES dos testes da sessão
    await connect_to_mongo()
    db = get_database()


    # Limpa as coleções ANTES de iniciar os testes da sessão
    print(f"Limpando coleções '{USERS_COLLECTION}' e '{TASKS_COLLECTION}' antes dos testes...")
    await db[USERS_COLLECTION].delete_many({})
    await db[TASKS_COLLECTION].delete_many({})
    print("Coleções limpas.")

    # Cria e retorna o cliente de teste async
    async with AsyncClient(app=fastapi_app, base_url="http://testserver") as client:
         yield client

    # Código executado APÓS todos os testes da sessão terminarem
    await db[USERS_COLLECTION].delete_many({})
    await db[TASKS_COLLECTION].delete_many({})

    # Fecha a conexão com o banco de dados
    await close_mongo_connection()


# --- Fixture para um Token de Teste ---
@pytest_asyncio.fixture(scope="module") # Escopo de módulo: cria 1 token por arquivo de teste
async def test_user_token(test_async_client: AsyncClient) -> str:
    """
    Fixture que registra um usuário de teste e faz login para obter um token JWT.
    O token pode ser usado em testes que exigem autenticação.
    """
    user_data = {
        "email": "testuser@example.com",
        "username": "testuser",
        "password": "testpassword",
        "full_name": "Test User"
    }
    register_url = f"{settings.API_V1_STR}/auth/register"
    login_url = f"{settings.API_V1_STR}/auth/login/access-token"

    # --- Registrar (ignorando falha se já existir de um run anterior não limpo) ---
    try:
         response = await test_async_client.post(register_url, json=user_data)
         if response.status_code not in [201, 409]:
              raise Exception(f"Erro registro teste: {response.status_code}")
    except Exception as e:
        pytest.skip("Não foi possível registrar o usuário de teste, pulando testes autenticados.") 

    # --- Fazer Login ---
    login_data = {
        "username": user_data["username"],
        "password": user_data["password"]
    }
    response = await test_async_client.post(login_url, data=login_data) 

    if response.status_code != 200:
         pytest.skip("Não foi possível logar com usuário de teste, pulando testes autenticados.")

    token_data = response.json()
    return token_data["access_token"]


@pytest_asyncio.fixture(scope="module")
def auth_headers(test_user_token: str) -> Dict[str, str]:
     """Retorna headers de autenticação com o token de teste."""
     return {"Authorization": f"Bearer {test_user_token}"}--- Fim de tests/__init__.py ---

--- Início de tests/conftest.py (111 linhas) ---
# tests/conftest.py
import pytest
import pytest_asyncio
from typing import AsyncGenerator, Generator, Dict, List 
import asyncio
from httpx import AsyncClient, ASGITransport
from fastapi import status #
from app.main import app as fastapi_app
from app.core.config import settings
from app.db.mongodb_utils import connect_to_mongo, close_mongo_connection, get_database
from motor.motor_asyncio import AsyncIOMotorDatabase
from app.db.user_crud import USERS_COLLECTION
from app.db.task_crud import TASKS_COLLECTION
from app.models.task import TaskStatus 

# --- Cliente de Teste (Escopo Function) ---
@pytest_asyncio.fixture(scope="function")
async def test_async_client() -> AsyncGenerator[AsyncClient, None]:
    await connect_to_mongo()
    db = get_database()

    await db[USERS_COLLECTION].delete_many({})
    await db[TASKS_COLLECTION].delete_many({})

    transport = ASGITransport(app=fastapi_app)
    async with AsyncClient(transport=transport, base_url="http://testserver") as client:
        yield client

    # print("Limpando coleções APÓS o teste.") # Removido log repetitivo
    try:
         db_after = get_database()
         if db_after:
            await db_after[USERS_COLLECTION].delete_many({})
            await db_after[TASKS_COLLECTION].delete_many({})
    except Exception as e:
        print(f"Erro ao limpar DB após teste: {e}")

# --- Fixtures para Usuário A ---
user_a_data = {
    "email": "testuserA@example.com",
    "username": "testuserA",
    "password": "passwordA",
    "full_name": "Test User A"
}

@pytest_asyncio.fixture(scope="function")
async def test_user_a_token(test_async_client: AsyncClient) -> str:
    register_url = f"{settings.API_V1_STR}/auth/register"
    login_url = f"{settings.API_V1_STR}/auth/login/access-token"
    reg_response = await test_async_client.post(register_url, json=user_a_data)
    # --- Usando status importado ---
    if reg_response.status_code not in [status.HTTP_201_CREATED, status.HTTP_409_CONFLICT]:
        pytest.fail(f"Falha inesperada ao registrar User A: {reg_response.text}")

    login_payload = {"username": user_a_data["username"], "password": user_a_data["password"]}
    response = await test_async_client.post(login_url, data=login_payload)
    # --- Usando status importado ---
    if response.status_code != status.HTTP_200_OK:
         pytest.fail(f"Falha ao fazer login com User A: {response.text}")
    return response.json()["access_token"]

@pytest.fixture(scope="function")
def auth_headers_a(test_user_a_token: str) -> Dict[str, str]:
     return {"Authorization": f"Bearer {test_user_a_token}"}

# --- Fixtures para Usuário B ---
user_b_data = {
    "email": "testuserB@example.com",
    "username": "testuserB",
    "password": "passwordB",
    "full_name": "Test User B"
}

@pytest_asyncio.fixture(scope="function")
async def test_user_b_token(test_async_client: AsyncClient) -> str:
    register_url = f"{settings.API_V1_STR}/auth/register"
    login_url = f"{settings.API_V1_STR}/auth/login/access-token"
    reg_response = await test_async_client.post(register_url, json=user_b_data)
    # --- Usando status importado ---
    if reg_response.status_code not in [status.HTTP_201_CREATED, status.HTTP_409_CONFLICT]:
         pytest.fail(f"Falha inesperada ao registrar User B: {reg_response.text}")

    login_payload = {"username": user_b_data["username"], "password": user_b_data["password"]}
    response = await test_async_client.post(login_url, data=login_payload)
     # --- Usando status importado ---
    if response.status_code != status.HTTP_200_OK:
         pytest.fail(f"Falha ao fazer login com User B: {response.text}")
    return response.json()["access_token"]

@pytest.fixture(scope="function")
def auth_headers_b(test_user_b_token: str) -> Dict[str, str]:
     return {"Authorization": f"Bearer {test_user_b_token}"}

# Fixture de dados para testes de filtro/sort
@pytest_asyncio.fixture(scope="function")
async def create_filter_sort_tasks(test_async_client: AsyncClient, auth_headers_a: Dict[str, str]) -> List[Dict]:
    url = f"{settings.API_V1_STR}/tasks/"
    tasks_to_create = [
        {"title": "Filter Task P1 High", "importance": 5, "project": "Filtro", "status": TaskStatus.PENDING.value, "due_date": "2026-01-01", "tags": ["t1", "t2"]},
        {"title": "Filter Task P1 Low", "importance": 1, "project": "Filtro", "status": TaskStatus.PENDING.value, "due_date": "2026-02-01"},
        {"title": "Filter Task P2 Medium", "importance": 3, "project": "Outro", "status": TaskStatus.IN_PROGRESS.value, "tags": ["t2"]},
        {"title": "Filter Task P1 Medium", "importance": 3, "project": "Filtro", "status": TaskStatus.PENDING.value, "due_date": "2025-12-15", "tags": ["t3"]},
        {"title": "Filter Task P1 Done", "importance": 4, "project": "Filtro", "status": TaskStatus.COMPLETED.value},
    ]
    created_tasks = []
    for task_data in tasks_to_create:
        response = await test_async_client.post(url, json=task_data, headers=auth_headers_a)
        # --- Usando status importado ---
        assert response.status_code == status.HTTP_201_CREATED, f"Falha ao criar tarefa de teste: {task_data['title']}"
        created_tasks.append(response.json())
    return created_tasks--- Fim de tests/conftest.py ---

--- Início de tests/test_auth.py (109 linhas) ---
# tests/test_auth.py
import pytest
from httpx import AsyncClient
from fastapi import status

from app.core.config import settings # Para construir URLs
# --- IMPORTAR DADOS DE USUÁRIO DO CONFTEST ---
from tests.conftest import user_a_data

# Marca todos os testes neste módulo para usar asyncio
pytestmark = pytest.mark.asyncio

# ==============================
# --- Testes de Registro ---
# ==============================
async def test_register_user_success(test_async_client: AsyncClient):
    """Testa registro de usuário bem-sucedido."""
    # Usa dados únicos para este teste específico
    new_user_data = {
        "email": "newuniqueuser@example.com",
        "username": "newuniqueuser",
        "password": "newpassword123",
        "full_name": "New Test User"
    }
    url = f"{settings.API_V1_STR}/auth/register"

    response = await test_async_client.post(url, json=new_user_data)

    assert response.status_code == status.HTTP_201_CREATED
    response_data = response.json()
    assert response_data["email"] == new_user_data["email"]
    assert response_data["username"] == new_user_data["username"]
    assert response_data["full_name"] == new_user_data["full_name"]
    assert "id" in response_data
    assert "hashed_password" not in response_data 

async def test_register_user_duplicate_username(
    test_async_client: AsyncClient,
    test_user_a_token: str
):
    """Testa registro com username duplicado."""
    attempt_data = {
        "email": "anotherunique@example.com",
        "username": user_a_data["username"], 
        "password": "anotherpassword",
    }
    url = f"{settings.API_V1_STR}/auth/register"

    response = await test_async_client.post(url, json=attempt_data)

    assert response.status_code == status.HTTP_409_CONFLICT
    assert "já existe" in response.json()["detail"]

async def test_register_user_duplicate_email(
    test_async_client: AsyncClient,
    test_user_a_token: str # Pede a fixture correta User A
):
    """Testa registro com email duplicado."""
    attempt_data = {
        "email": user_a_data["email"], # << Usa email do User A
        "username": "anotherunique_username",
        "password": "anotherpassword",
    }
    url = f"{settings.API_V1_STR}/auth/register"

    response = await test_async_client.post(url, json=attempt_data)

    assert response.status_code == status.HTTP_409_CONFLICT
    assert "já registrado" in response.json()["detail"]

# ========================
# --- Testes de Login ---
# ========================
async def test_login_success(
    test_async_client: AsyncClient,
    test_user_a_token: str # Pede a fixture correta User A (garante que existe)
):
     """Testa login bem-sucedido do Usuário A."""
     login_data = {"username": user_a_data["username"], "password": user_a_data["password"]} # Usa dados do User A
     url = f"{settings.API_V1_STR}/auth/login/access-token"

     response = await test_async_client.post(url, data=login_data) # Form data

     assert response.status_code == status.HTTP_200_OK
     token_data = response.json()
     assert "access_token" in token_data
     assert token_data["token_type"] == "bearer"

async def test_login_wrong_password(
    test_async_client: AsyncClient,
    test_user_a_token: str # Pede a fixture correta User A (garante que existe)
):
     """Testa login com senha incorreta para o Usuário A."""
     login_data = {"username": user_a_data["username"], "password": "wrongpassword"} # Usa user A, senha errada
     url = f"{settings.API_V1_STR}/auth/login/access-token"

     response = await test_async_client.post(url, data=login_data)

     assert response.status_code == status.HTTP_401_UNAUTHORIZED
     assert "incorretos" in response.json()["detail"]

async def test_login_user_not_found(test_async_client: AsyncClient):
     """Testa login com usuário inexistente."""
     login_data = {"username": "nonexistentuser", "password": "password"}
     url = f"{settings.API_V1_STR}/auth/login/access-token"

     response = await test_async_client.post(url, data=login_data)

     assert response.status_code == status.HTTP_401_UNAUTHORIZED # Mesmo erro para user/pwd errados--- Fim de tests/test_auth.py ---

--- Início de tests/test_tasks.py (405 linhas) ---
# tests/test_tasks.py
import pytest
from httpx import AsyncClient
from fastapi import status
from typing import Dict, List, Any
import uuid

import pytest_asyncio

# Removido import desnecessário de pytest_asyncio
# import pytest_asyncio

from app.core.config import settings
from app.models.task import TaskStatus
# Importar fixtures A e B agora são usadas
# from tests.conftest import auth_headers_a, auth_headers_b

pytestmark = pytest.mark.asyncio

base_task_create_data = {
    "title": "Tarefa de Teste Padrão",
    "description": "Descrição da tarefa padrão",
    "importance": 3,
}

# ==========================================
# --- Testes de Criação ---
# ==========================================
# Pede a fixture correta: auth_headers_a
async def test_create_task_success(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str] # << CORRIGIDO para User A
):
    """Testa a criação bem-sucedida de uma tarefa."""
    url = f"{settings.API_V1_STR}/tasks/"
    response = await test_async_client.post(url, json=base_task_create_data, headers=auth_headers_a) # << CORRIGIDO

    assert response.status_code == status.HTTP_201_CREATED
    response_data = response.json()
    assert response_data["title"] == base_task_create_data["title"]
    assert response_data["importance"] == base_task_create_data["importance"]
    assert "id" in response_data
    assert "owner_id" in response_data
    assert "created_at" in response_data
    assert "priority_score" in response_data

async def test_create_task_unauthorized(test_async_client: AsyncClient):
     """Testa criar tarefa sem autenticação."""
     url = f"{settings.API_V1_STR}/tasks/"
     response = await test_async_client.post(url, json=base_task_create_data) # Não envia headers
     assert response.status_code == status.HTTP_401_UNAUTHORIZED

# ========================================
# --- Testes de Listagem ---
# ========================================
async def test_list_tasks_success(
    test_async_client: AsyncClient, auth_headers_a: Dict[str, str]
):
    """Testa se User A lista apenas suas tarefas criadas neste teste."""
    url = f"{settings.API_V1_STR}/tasks/"
    task1 = {**base_task_create_data, "title": "Task A1 List", "importance": 5, "project": "Alpha"}
    task2 = {**base_task_create_data, "title": "Task A2 List", "status": TaskStatus.IN_PROGRESS.value, "tags": ["urgent"]}
    resp1 = await test_async_client.post(url, json=task1, headers=auth_headers_a)
    assert resp1.status_code == 201
    resp2 = await test_async_client.post(url, json=task2, headers=auth_headers_a)
    assert resp2.status_code == 201

    response = await test_async_client.get(url, headers=auth_headers_a)

    assert response.status_code == status.HTTP_200_OK
    tasks = response.json()
    assert isinstance(tasks, list)
    # Com scope='function', o DB é limpo, então só essas 2 devem existir
    assert len(tasks) == 2
    titles = {task["title"] for task in tasks}
    assert task1["title"] in titles
    assert task2["title"] in titles

async def test_list_tasks_unauthorized(test_async_client: AsyncClient):
     """Testa listar tarefas sem autenticação."""
     url = f"{settings.API_V1_STR}/tasks/"
     response = await test_async_client.get(url)
     assert response.status_code == status.HTTP_401_UNAUTHORIZED

async def test_list_tasks_does_not_show_other_users_tasks(
    test_async_client: AsyncClient, auth_headers_a: Dict[str, str], auth_headers_b: Dict[str, str]
):
    """Garante que User B não vê as tarefas do User A."""
    url = f"{settings.API_V1_STR}/tasks/"
    task_a = {**base_task_create_data, "title": "Tarefa Secreta A"}
    resp_a = await test_async_client.post(url, json=task_a, headers=auth_headers_a)
    assert resp_a.status_code == 201

    response_b = await test_async_client.get(url, headers=auth_headers_b)

    assert response_b.status_code == status.HTTP_200_OK
    tasks_b = response_b.json()
    assert isinstance(tasks_b, list)
    assert len(tasks_b) == 0 # Lista de B deve estar vazia

# ========================================
# --- Testes de Filtros e Ordenação ---
# ========================================

# Criar uma fixture de dados para facilitar testes de filtro/sort
@pytest_asyncio.fixture(scope="function")
async def create_filter_sort_tasks(test_async_client: AsyncClient, auth_headers_a: Dict[str, str]) -> List[Dict]:
    """Cria um conjunto de tarefas com variações para testes."""
    url = f"{settings.API_V1_STR}/tasks/"
    tasks_to_create = [
        {"title": "Filter Task P1 High", "importance": 5, "project": "Filtro", "status": TaskStatus.PENDING.value, "due_date": "2026-01-01", "tags": ["t1", "t2"]},
        {"title": "Filter Task P1 Low", "importance": 1, "project": "Filtro", "status": TaskStatus.PENDING.value, "due_date": "2026-02-01"},
        {"title": "Filter Task P2 Medium", "importance": 3, "project": "Outro", "status": TaskStatus.IN_PROGRESS.value, "tags": ["t2"]},
        {"title": "Filter Task P1 Medium", "importance": 3, "project": "Filtro", "status": TaskStatus.PENDING.value, "due_date": "2025-12-15", "tags": ["t3"]}, 
        {"title": "Filter Task P1 Done", "importance": 4, "project": "Filtro", "status": TaskStatus.COMPLETED.value}, 
    ]
    created_tasks = []
    for task_data in tasks_to_create:
        response = await test_async_client.post(url, json=task_data, headers=auth_headers_a)
        assert response.status_code == 201
        created_tasks.append(response.json())
    return created_tasks

async def test_list_tasks_filter_by_project(
    test_async_client: AsyncClient, auth_headers_a: Dict[str, str], create_filter_sort_tasks: List[Dict]
):
    url = f"{settings.API_V1_STR}/tasks/?project=Filtro"
    response = await test_async_client.get(url, headers=auth_headers_a)
    assert response.status_code == 200
    tasks = response.json()
    assert len(tasks) == 4 
    assert all(task["project"] == "Filtro" for task in tasks)

async def test_list_tasks_filter_by_status(
    test_async_client: AsyncClient, auth_headers_a: Dict[str, str], create_filter_sort_tasks: List[Dict]
):
    url = f"{settings.API_V1_STR}/tasks/?status=pendente"
    response = await test_async_client.get(url, headers=auth_headers_a)
    assert response.status_code == 200
    tasks = response.json()
    assert len(tasks) == 3 
    assert all(task["status"] == TaskStatus.PENDING.value for task in tasks)

async def test_list_tasks_filter_by_single_tag(
    test_async_client: AsyncClient, auth_headers_a: Dict[str, str], create_filter_sort_tasks: List[Dict]
):
    url = f"{settings.API_V1_STR}/tasks/?tag=t2"
    response = await test_async_client.get(url, headers=auth_headers_a)
    assert response.status_code == 200
    tasks = response.json()
    assert len(tasks) == 2 
    titles = {task["title"] for task in tasks}
    assert "Filter Task P1 High" in titles
    assert "Filter Task P2 Medium" in titles

async def test_list_tasks_filter_by_multiple_tags(
    test_async_client: AsyncClient, auth_headers_a: Dict[str, str], create_filter_sort_tasks: List[Dict]
):
    url = f"{settings.API_V1_STR}/tasks/?tag=t1&tag=t2"
    response = await test_async_client.get(url, headers=auth_headers_a)
    assert response.status_code == 200
    tasks = response.json()
    assert len(tasks) == 1 
    assert tasks[0]["title"] == "Filter Task P1 High"

async def test_list_tasks_sort_by_priority(
    test_async_client: AsyncClient, auth_headers_a: Dict[str, str], create_filter_sort_tasks: List[Dict]
):
    url = f"{settings.API_V1_STR}/tasks/?sort_by=priority_score&sort_order=desc"
    response = await test_async_client.get(url, headers=auth_headers_a)
    assert response.status_code == 200
    tasks = response.json()
    assert len(tasks) == 5 
    scores = [task.get("priority_score") for task in tasks if task.get("priority_score") is not None]
    assert scores == sorted(scores, reverse=True)

async def test_list_tasks_sort_by_due_date_asc(
    test_async_client: AsyncClient, auth_headers_a: Dict[str, str], create_filter_sort_tasks: List[Dict]
):
    url = f"{settings.API_V1_STR}/tasks/?sort_by=due_date&sort_order=asc"
    response = await test_async_client.get(url, headers=auth_headers_a)
    assert response.status_code == 200
    tasks = response.json()
    assert len(tasks) == 5
    due_dates = [task.get("due_date") for task in tasks if task.get("due_date")]
    assert due_dates == sorted(due_dates)
    assert tasks[0]["due_date"] is None or tasks[0]["due_date"] == "2025-12-15"

# ========================================
# --- Testes GET /tasks/{id} ---
# ========================================
###################################################
# test_get_specific_task_unauthorized <<<<<FALTANDO
###################################################
async def test_get_specific_task_success(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str] 
):
    """Testa buscar uma tarefa específica do usuário."""
    # Criar uma tarefa usando User A
    url_create = f"{settings.API_V1_STR}/tasks/"
    create_response = await test_async_client.post(url_create, json=base_task_create_data, headers=auth_headers_a) 
    assert create_response.status_code == 201
    task_id = create_response.json()["id"]

    # Buscar a tarefa criada usando User A
    url_get = f"{settings.API_V1_STR}/tasks/{task_id}"
    get_response = await test_async_client.get(url_get, headers=auth_headers_a) 

    assert get_response.status_code == status.HTTP_200_OK
    response_data = get_response.json()
    assert response_data["id"] == task_id
    assert response_data["title"] == base_task_create_data["title"] 


# Usa a fixture correta: auth_headers_a
async def test_get_specific_task_not_found(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str] 
):
    """Testa buscar uma tarefa com ID inexistente."""
    non_existent_id = uuid.uuid4()
    url = f"{settings.API_V1_STR}/tasks/{non_existent_id}"
    response = await test_async_client.get(url, headers=auth_headers_a)
    assert response.status_code == status.HTTP_404_NOT_FOUND

async def test_get_other_user_task_forbidden(
    test_async_client: AsyncClient, auth_headers_a: Dict[str, str], auth_headers_b: Dict[str, str]
):
    """Garante que User B não consegue obter a tarefa do User A por ID."""
    # Arrange: User A cria tarefa
    url = f"{settings.API_V1_STR}/tasks/"
    task_a_data = {**base_task_create_data, "title": "Task A para GET"}
    resp_a = await test_async_client.post(url, json=task_a_data, headers=auth_headers_a)
    assert resp_a.status_code == 201
    task_a_id = resp_a.json()["id"]

    # Act: User B tenta obter a tarefa de User A
    url_get = f"{settings.API_V1_STR}/tasks/{task_a_id}"
    response_b = await test_async_client.get(url_get, headers=auth_headers_b)

    # Assert: Deve falhar com 404 (pois o findOne combina id E owner_id)
    assert response_b.status_code == status.HTTP_404_NOT_FOUND

# ========================================
# --- Testes PUT /tasks/{id} (NOVOS) ---
# ========================================
async def test_update_task_success(
    test_async_client: AsyncClient, auth_headers_a: Dict[str, str]
):
    """Testa atualizar uma tarefa com sucesso."""
    # Arrange: Criar tarefa
    url = f"{settings.API_V1_STR}/tasks/"
    create_resp = await test_async_client.post(url, json=base_task_create_data, headers=auth_headers_a)
    assert create_resp.status_code == 201
    task_id = create_resp.json()["id"]
    original_score = create_resp.json()["priority_score"]

    # Act: Atualizar a tarefa
    url_put = f"{settings.API_V1_STR}/tasks/{task_id}"
    update_payload = {"title": "Título Atualizado", "status": TaskStatus.COMPLETED.value, "importance": 5} 
    response = await test_async_client.put(url_put, json=update_payload, headers=auth_headers_a)

    # Assert
    assert response.status_code == status.HTTP_200_OK
    data = response.json()
    assert data["id"] == task_id
    assert data["title"] == update_payload["title"]
    assert data["status"] == update_payload["status"]
    assert data["importance"] == update_payload["importance"]
    assert "updated_at" in data and data["updated_at"] is not None
    assert "priority_score" in data
    # Verificar se score mudou (importância 3 -> 5)
    assert data["priority_score"] != original_score

async def test_update_task_not_found(
    test_async_client: AsyncClient, auth_headers_a: Dict[str, str]
):
    """Testa atualizar tarefa inexistente."""
    url = f"{settings.API_V1_STR}/tasks/{uuid.uuid4()}" 
    response = await test_async_client.put(url, json={"title": "Inexistente"}, headers=auth_headers_a)
    assert response.status_code == status.HTTP_404_NOT_FOUND

async def test_update_other_user_task_forbidden(
    test_async_client: AsyncClient, auth_headers_a: Dict[str, str], auth_headers_b: Dict[str, str]
):
    """Testa se User B não pode atualizar tarefa do User A."""
    # Arrange: User A cria tarefa
    url = f"{settings.API_V1_STR}/tasks/"
    resp_a = await test_async_client.post(url, json=base_task_create_data, headers=auth_headers_a)
    assert resp_a.status_code == 201
    task_a_id = resp_a.json()["id"]

    # Act: User B tenta atualizar
    url_put = f"{settings.API_V1_STR}/tasks/{task_a_id}"
    response_b = await test_async_client.put(url_put, json={"title": "Hackeado?"}, headers=auth_headers_b)

    # Assert: Falha com 404
    assert response_b.status_code == status.HTTP_404_NOT_FOUND

async def test_get_specific_task_success(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str] # << CORRIGIDO para User A
):
    """Testa buscar uma tarefa específica do usuário A."""
    url_create = f"{settings.API_V1_STR}/tasks/"
    create_response = await test_async_client.post(url_create, json=base_task_create_data, headers=auth_headers_a) # << CORRIGIDO
    assert create_response.status_code == 201
    task_id = create_response.json()["id"]

    url_get = f"{settings.API_V1_STR}/tasks/{task_id}"
    get_response = await test_async_client.get(url_get, headers=auth_headers_a) # << CORRIGIDO

    assert get_response.status_code == status.HTTP_200_OK
    response_data = get_response.json()
    assert response_data["id"] == task_id
    assert response_data["title"] == base_task_create_data["title"]


# Pede a fixture correta: auth_headers_a
async def test_get_specific_task_not_found(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str] # << CORRIGIDO para User A
):
    """Testa buscar uma tarefa com ID inexistente."""
    non_existent_id = uuid.uuid4()
    url = f"{settings.API_V1_STR}/tasks/{non_existent_id}"
    response = await test_async_client.get(url, headers=auth_headers_a) # << CORRIGIDO
    assert response.status_code == status.HTTP_404_NOT_FOUND

# Nenhuma mudança necessária
async def test_get_specific_task_unauthorized(test_async_client: AsyncClient):
     """Testa buscar tarefa sem autenticação."""
     some_valid_id_placeholder = uuid.uuid4()
     url = f"{settings.API_V1_STR}/tasks/{some_valid_id_placeholder}"
     response = await test_async_client.get(url)
     assert response.status_code == status.HTTP_401_UNAUTHORIZED

# Nenhuma mudança necessária
async def test_get_other_user_task_forbidden(
    test_async_client: AsyncClient, auth_headers_a: Dict[str, str], auth_headers_b: Dict[str, str]
):
    """Garante que User B não consegue obter a tarefa do User A por ID."""
    url = f"{settings.API_V1_STR}/tasks/"
    task_a_data = {**base_task_create_data, "title": "Task A para GET"}
    resp_a = await test_async_client.post(url, json=task_a_data, headers=auth_headers_a)
    assert resp_a.status_code == 201
    task_a_id = resp_a.json()["id"]

    url_get = f"{settings.API_V1_STR}/tasks/{task_a_id}"
    response_b = await test_async_client.get(url_get, headers=auth_headers_b)

    assert response_b.status_code == status.HTTP_404_NOT_FOUN

# ==========================================
# --- Testes DELETE /tasks/{id} (NOVOS) ---
# ==========================================
async def test_delete_task_success(
    test_async_client: AsyncClient, auth_headers_a: Dict[str, str]
):
    """Testa deletar uma tarefa com sucesso."""
    # Arrange: Criar tarefa
    url = f"{settings.API_V1_STR}/tasks/"
    create_resp = await test_async_client.post(url, json=base_task_create_data, headers=auth_headers_a)
    assert create_resp.status_code == 201
    task_id = create_resp.json()["id"]

    # Act: Deletar a tarefa
    url_delete = f"{settings.API_V1_STR}/tasks/{task_id}"
    delete_response = await test_async_client.delete(url_delete, headers=auth_headers_a)

    # Assert (Delete)
    assert delete_response.status_code == status.HTTP_204_NO_CONTENT

    # Assert (Verificar Get posterior falha)
    url_get = f"{settings.API_V1_STR}/tasks/{task_id}"
    get_response = await test_async_client.get(url_get, headers=auth_headers_a)
    assert get_response.status_code == status.HTTP_404_NOT_FOUND


async def test_delete_task_not_found(
    test_async_client: AsyncClient, auth_headers_a: Dict[str, str]
):
    """Testa deletar tarefa inexistente."""
    url = f"{settings.API_V1_STR}/tasks/{uuid.uuid4()}" # ID aleatório
    response = await test_async_client.delete(url, headers=auth_headers_a)
    assert response.status_code == status.HTTP_404_NOT_FOUND


async def test_delete_other_user_task_forbidden(
    test_async_client: AsyncClient, auth_headers_a: Dict[str, str], auth_headers_b: Dict[str, str]
):
    """Testa se User B não pode deletar tarefa do User A."""
    # Arrange: User A cria tarefa
    url = f"{settings.API_V1_STR}/tasks/"
    resp_a = await test_async_client.post(url, json=base_task_create_data, headers=auth_headers_a)
    assert resp_a.status_code == 201
    task_a_id = resp_a.json()["id"]

    # Act: User B tenta deletar
    url_delete = f"{settings.API_V1_STR}/tasks/{task_a_id}"
    response_b = await test_async_client.delete(url_delete, headers=auth_headers_b)

    # Assert: Falha com 404
    assert response_b.status_code == status.HTTP_404_NOT_FOUND--- Fim de tests/test_tasks.py ---
