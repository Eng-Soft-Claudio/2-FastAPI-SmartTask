================================================================================
LIVRO DO C√ìDIGO-FONTE DO PROJETO
================================================================================

SUM√ÅRIO
--------------------------------------------------------------------------------
Cap√≠tulo 1: app/core/config.py
Cap√≠tulo 2: app/core/dependencies.py
Cap√≠tulo 3: app/core/email.py
Cap√≠tulo 4: app/core/logging_config.py
Cap√≠tulo 5: app/core/security.py
Cap√≠tulo 6: app/core/utils.py
Cap√≠tulo 7: app/db/mongodb_utils.py
Cap√≠tulo 8: app/db/task_crud.py
Cap√≠tulo 9: app/db/user_crud.py
Cap√≠tulo 10: app/main.py
Cap√≠tulo 11: app/models/task.py
Cap√≠tulo 12: app/models/token.py
Cap√≠tulo 13: app/models/user.py
Cap√≠tulo 14: app/routers/auth.py
Cap√≠tulo 15: app/routers/tasks.py
Cap√≠tulo 16: app/worker.py
Cap√≠tulo 17: tests/conftest.py
Cap√≠tulo 18: tests/test_auth.py
Cap√≠tulo 19: tests/test_core_config.py
Cap√≠tulo 20: tests/test_core_dependencies.py
Cap√≠tulo 21: tests/test_core_email.py
Cap√≠tulo 22: tests/test_core_security.py
Cap√≠tulo 23: tests/test_core_utils.py
Cap√≠tulo 24: tests/test_core_utils_webhooks.py
Cap√≠tulo 25: tests/test_db_mongodb_utils.py
Cap√≠tulo 26: tests/test_db_task_crud.py
Cap√≠tulo 27: tests/test_db_user_crud.py
Cap√≠tulo 28: tests/test_main.py
Cap√≠tulo 29: tests/test_tasks.py
Cap√≠tulo 30: tests/test_worker.py


================================================================================
Cap√≠tulo 1: app/core/config.py
================================================================================

# app/core/config.py

# ========================
# --- Importa√ß√µes ---
# ========================
import os
import logging
from typing import Optional, List 
from pydantic_settings import BaseSettings
from pydantic import EmailStr, Field, RedisDsn, ValidationError, model_validator, HttpUrl
from dotenv import load_dotenv

# ===============================
# --- Configura√ß√£o do Logger ---
# ===============================
logger = logging.getLogger(__name__)

# ===============================
# --- Carregamento do .env ---
# ===============================
# Define o caminho para o arquivo .env na raiz do projeto
dotenv_path = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), '.env')
# Carrega as vari√°veis do arquivo .env para o ambiente, se o arquivo existir
loaded = load_dotenv(dotenv_path=dotenv_path)

# ======================================
# --- Defini√ß√£o das Configura√ß√µes ---
# ======================================
class Settings(BaseSettings):
    """
    Configura√ß√µes da aplica√ß√£o lidas do ambiente usando Pydantic BaseSettings.
    Procura vari√°veis de ambiente ou vari√°veis em um arquivo .env.
    Docs Pydantic Settings: https://docs.pydantic.dev/latest/concepts/pydantic_settings/
    """
    # =========================
    # --- Config Gerais ---
    # =========================
    PROJECT_NAME: str = Field("SmartTask API", description="Nome do Projeto")
    API_V1_STR: str = Field("/api/v1", description="Prefixo para a vers√£o 1 da API")

    # =============================
    # --- Configura√ß√µes MongoDB ---
    # =============================
    MONGODB_URL: str = Field(..., description="URL de conex√£o completa do MongoDB (obrigat√≥ria)")
    DATABASE_NAME: str = Field("smarttask_db", description="Nome do banco de dados MongoDB")

    # ===========================
    # --- Configura√ß√µes JWT ---
    # ===========================
    JWT_SECRET_KEY: str = Field(..., description="Chave secreta forte para assinar tokens JWT (obrigat√≥ria)")
    JWT_ALGORITHM: str = Field("HS256", description="Algoritmo de assinatura JWT")
    ACCESS_TOKEN_EXPIRE_MINUTES: int = Field(60 * 24 * 7, description="Validade do token de acesso em minutos (padr√£o: 7 dias)")

    # =======================================
    # --- Configura√ß√µes de Prioridade ---
    # =======================================
    PRIORITY_WEIGHT_DUE_DATE: float = Field(
        100.0,
        description="Peso para o componente de prazo no c√°lculo de prioridade."
    )
    PRIORITY_WEIGHT_IMPORTANCE: float = Field(
        10.0,
        description="Peso (multiplicador) para o componente de import√¢ncia no c√°lculo de prioridade."
    )
    PRIORITY_DEFAULT_SCORE_NO_DUE_DATE: Optional[float] = Field(
        0.0,
        description="Pontua√ß√£o base de prazo para tarefas sem data de vencimento (pode ser None ou 0.0)."
    )
    PRIORITY_SCORE_IF_OVERDUE: float = Field(
        1000.0,
        description="Pontua√ß√£o (ou fator aditivo/multiplicativo) especial para tarefas atrasadas."
    )

    # ==============================
    # --- Configura√ß√£o Webhook ---
    # ==============================
    WEBHOOK_URL: Optional[HttpUrl] = Field(
        default=None,
        description="URL opcional para enviar notifica√ß√µes de eventos de tarefas (webhooks)."
    )
    WEBHOOK_SECRET: Optional[str] = Field(
        default=None,
        description="Segredo opcional usado para assinar payloads de webhook para verifica√ß√£o (HMAC-SHA256)."
    )

    # ================================
    # --- Configura√ß√µes de E-mail ---
    # ================================
    MAIL_ENABLED: bool = Field(
            default=False, 
            description="Flag para habilitar/desabilitar envio de e-mails globalmente."
    )
    MAIL_USERNAME: Optional[str] = Field(default=None, description="Usu√°rio do servidor SMTP.")
    MAIL_PASSWORD: Optional[str] = Field(default=None, description="Senha do servidor SMTP.")
    MAIL_FROM: Optional[EmailStr] = Field(
        default=None,
        description="Endere√ßo de e-mail remetente."
    )
    MAIL_FROM_NAME: Optional[str] = Field(
        default="SmartTask Notifica√ß√µes",
        description="Nome do remetente exibido no e-mail."
    )
    MAIL_PORT: int = Field(
        default=587,
        description="Porta do servidor SMTP."
    )
    MAIL_SERVER: Optional[str] = Field(
        default=None,
        description="Endere√ßo do servidor SMTP."
    )
    MAIL_STARTTLS: bool = Field(default=True, description="Usar STARTTLS para conex√£o SMTP.")
    MAIL_SSL_TLS: bool = Field(default=False, description="Usar SSL/TLS direto para conex√£o SMTP.")
    USE_CREDENTIALS: bool = Field(default=True, description="Usar credenciais (username/password) para SMTP.")
    VALIDATE_CERTS: bool = Field(default=True, description="Validar certificados SSL/TLS do servidor SMTP.")

    # ==============================================
    # --- Configura√ß√µes Adicionais Espec√≠ficas ---
    # ==============================================
    EMAIL_TEMPLATES_DIR: str = Field(default="app/email-templates/build", description="Diret√≥rio de templates de e-mail compilados.")
    EMAIL_URGENCY_THRESHOLD: float = Field(
        default=100.0,
        description="Limiar de priority_score para considerar uma tarefa urgente para notifica√ß√£o por e-mail."
    )
    FRONTEND_URL: Optional[str] = Field(default=None, description="URL base do frontend para links no e-mail (se houver).")

    # ==============================
    # --- Configura√ß√£o Redis ---
    # ==============================
    REDIS_URL: Optional[RedisDsn] = Field(
        default=None,
        description="URL de conex√£o do Redis para filas de tarefas (ARQ)."
    )

    # ===============================
    # --- Configura√ß√£o de Logging ---
    # ===============================
    LOG_LEVEL: str = Field(default="INFO", description="N√≠vel de log (DEBUG, INFO, WARNING, ERROR, CRITICAL)")

    # ===================================
    # --- Configura√ß√µes CORS ---
    # ===================================
    # A convers√£o de string separada por v√≠rgula para List[str] √© feita automaticamente pelo Pydantic v2
    CORS_ALLOWED_ORIGINS: List[str] = Field(default=[], description="Lista de origens CORS permitidas (separadas por v√≠rgula no .env)")


    # ====================================================
    # --- Configura√ß√£o do Modelo Pydantic BaseSettings ---
    # ====================================================
    model_config = {
        "case_sensitive": False, 
    }

    # ===============================
    # --- Validadores ---
    # ===============================
    @model_validator(mode='after')
    def check_mail_config(self) -> 'Settings':
        """Valida se as credenciais de e-mail est√£o presentes quando habilitado."""
        if self.MAIL_ENABLED and not all([self.MAIL_USERNAME, self.MAIL_PASSWORD, self.MAIL_FROM, self.MAIL_SERVER]):
            raise ValueError(
                "Se MAIL_ENABLED for True, MAIL_USERNAME, MAIL_PASSWORD, MAIL_FROM e MAIL_SERVER devem ser definidos."
            )
        return self

    @model_validator(mode='after')
    def check_webhook_config(self) -> 'Settings':
        """Valida a configura√ß√£o do webhook se URL for fornecida."""         
        return self

# ================================
# --- Cria√ß√£o da Inst√¢ncia ---
# ================================
try:
    settings = Settings()
except ValidationError as e:# pragma: no cover
    logger.critical(f"Erro fatal de valida√ß√£o ao carregar configura√ß√µes: {e}") # pragma: no cover
    raise e # pragma: no cover
except ValueError as e:# pragma: no cover
    logger.critical(f"Erro fatal de valida√ß√£o na configura√ß√£o (check_mail_config?): {e}") # pragma: no cover
    raise e # pragma: no cover
except Exception as e:# pragma: no cover
    logger.critical(f"Erro inesperado ao carregar configura√ß√µes: {e}", exc_info=True) # pragma: no cover
    raise e # pragma: no cover

================================================================================
Cap√≠tulo 2: app/core/dependencies.py
================================================================================

# app/core/dependencies.py

# ========================
# --- Importa√ß√µes ---
# ========================
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from motor.motor_asyncio import AsyncIOMotorDatabase
from typing import Annotated
import uuid

# --- M√≥dulos da Aplica√ß√£o ---
from app.db.mongodb_utils import get_database
from app.core.security import decode_token
from app.db import user_crud
from app.models.user import UserInDB

# ==========================
# --- Esquema OAuth2 ---
# ==========================
# Define o esquema OAuth2 para obter o token do header 'Authorization: Bearer <token>'.
# O tokenUrl aponta para o endpoint de login que gera o token.
# O path relativo deve ser o correto AP√ìS o prefixo da API (settings.API_V1_STR).
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/v1/auth/login/access-token")

# ================================
# --- Tipos de Depend√™ncia ---
# ================================
# Tipos anotados para depend√™ncias, melhorando legibilidade nas rotas.
DbDep = Annotated[AsyncIOMotorDatabase, Depends(get_database)]
TokenDep = Annotated[str, Depends(oauth2_scheme)]

# ==================================
# --- Depend√™ncia: Usu√°rio Atual ---
# ==================================
async def get_current_user(
    db: DbDep,
    token: TokenDep
) -> UserInDB:
    """
    Depend√™ncia para obter o usu√°rio atual com base no token JWT fornecido.

    Processo:
    1. Extrai e valida o token do header 'Authorization: Bearer <token>'.
    2. Decodifica o token usando `decode_token` e obt√©m o payload.
    3. Verifica se o payload √© v√°lido e cont√©m o 'sub' (ID do usu√°rio).
    4. Converte o 'sub' para um objeto UUID.
    5. Busca o usu√°rio no banco de dados pelo ID extra√≠do.
    6. Levanta HTTPException 401 se o token for inv√°lido, expirado,
       o 'sub' n√£o for UUID, ou o usu√°rio n√£o existir no banco de dados.
    7. Retorna o objeto `UserInDB` completo encontrado.

    Args:
        db: Inst√¢ncia do banco de dados injetada.
        token: Token JWT extra√≠do do header pela depend√™ncia `oauth2_scheme`.

    Returns:
        O objeto `UserInDB` correspondente ao token, se v√°lido e encontrado.

    Raises:
        HTTPException: Com status 401 se as credenciais n√£o puderem ser validadas.
    """
    # Exce√ß√£o padr√£o para falhas de autentica√ß√£o
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="N√£o foi poss√≠vel validar as credenciais",
        headers={"WWW-Authenticate": "Bearer"},
    )

    # Decodifica o token JWT via fun√ß√£o em core.security
    token_payload = decode_token(token)

    # Verifica se a decodifica√ß√£o foi bem-sucedida e se temos o 'sub'
    if token_payload is None or token_payload.sub is None:
        raise credentials_exception

    # Tenta converter o 'sub' (ID do usu√°rio) para UUID
    try:
        # Garante que sub seja tratado como string antes de converter
        user_id = uuid.UUID(str(token_payload.sub))
    except ValueError:
        # O 'sub' no token n√£o √© um UUID v√°lido
        raise credentials_exception

    # Busca o usu√°rio no banco de dados usando a fun√ß√£o CRUD
    user = await user_crud.get_user_by_id(db=db, user_id=user_id)
    if user is None:
        # Usu√°rio referenciado no token n√£o existe mais no DB
        raise credentials_exception

    # Retorna o objeto UserInDB completo (inclui senha hasheada, √∫til internamente)
    # Para retornar o modelo User (sem senha) √† API, a rota faria a convers√£o/valida√ß√£o.
    return user

# =========================================
# --- Depend√™ncia: Usu√°rio Ativo Atual ---
# =========================================
async def get_current_active_user(
    current_user: Annotated[UserInDB, Depends(get_current_user)]
) -> UserInDB:
    """
    Depend√™ncia que reutiliza `get_current_user` e adicionalmente garante
    que o usu√°rio obtido n√£o est√° desativado (campo `disabled` √© False).

    Args:
        current_user: O objeto `UserInDB` retornado pela depend√™ncia `get_current_user`.

    Returns:
        O mesmo objeto `UserInDB` se o usu√°rio estiver ativo.

    Raises:
        HTTPException: Com status 400 se o usu√°rio estiver desativado.
    """
    if current_user.disabled:
        # Levanta erro espec√≠fico se o usu√°rio estiver marcado como inativo
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Usu√°rio inativo")

    # Se chegou aqui, o usu√°rio est√° ativo; retorna o objeto recebido
    return current_user

# ==========================================
# --- Tipos Anotados para Uso em Rotas ---
# ==========================================
# Define tipos curtos e mais expressivos para usar como depend√™ncias
# nos endpoints protegidos, melhorando a leitura do c√≥digo das rotas.

# Injeta um usu√°rio ativo validado (UserInDB)
CurrentUser = Annotated[UserInDB, Depends(get_current_active_user)]


================================================================================
Cap√≠tulo 3: app/core/email.py
================================================================================

# app/core/email.py

# ========================
# --- Importa√ß√µes ---
# ========================
import logging
from pathlib import Path
from typing import List, Optional, Dict, Any
from fastapi_mail import FastMail, MessageSchema, ConnectionConfig, MessageType
from pydantic import EmailStr, BaseModel
from app.core.config import settings

# ===============================
# --- Configura√ß√£o do Logger ---
# ===============================
logger = logging.getLogger(__name__)

# ==================================
# --- Configura√ß√£o FastMail ---
# ==================================
# Cria a configura√ß√£o de conex√£o para o FastMail, lendo das settings.
# Utiliza valores padr√£o seguros ou "" caso as settings n√£o definam alguns campos opcionais.
conf = ConnectionConfig(
    MAIL_USERNAME=settings.MAIL_USERNAME or "",
    MAIL_PASSWORD=settings.MAIL_PASSWORD or "",
    MAIL_FROM=settings.MAIL_FROM or "default@example.com", 
    MAIL_PORT=settings.MAIL_PORT,
    MAIL_SERVER=settings.MAIL_SERVER or "",
    MAIL_FROM_NAME=settings.MAIL_FROM_NAME or "Default Sender",
    MAIL_STARTTLS=settings.MAIL_STARTTLS,
    MAIL_SSL_TLS=settings.MAIL_SSL_TLS,
    USE_CREDENTIALS=settings.USE_CREDENTIALS,
    VALIDATE_CERTS=settings.VALIDATE_CERTS,
    TEMPLATE_FOLDER=Path(settings.EMAIL_TEMPLATES_DIR) if settings.EMAIL_TEMPLATES_DIR else None,
)

# ================================
# --- Inst√¢ncia do FastMail ---
# ================================
# Inst√¢ncia principal usada para enviar e-mails.
fm = FastMail(conf)

# ===============================
# --- Fun√ß√£o Principal Envio ---
# ===============================
async def send_email_async(
    subject: str,
    recipient_to: List[EmailStr], # A valida√ß√£o Pydantic ocorre na assinatura
    body: Dict[str, Any],
    template_name: Optional[str] = None,
    plain_text_body: Optional[str] = None
):
    """
    Envia um e-mail de forma ass√≠ncrona usando FastMail.

    Verifica se o envio de e-mail est√° habilitado e se as credenciais
    necess√°rias est√£o configuradas antes de tentar enviar.

    Args:
        subject: Assunto do e-mail.
        recipient_to: Lista de endere√ßos de e-mail dos destinat√°rios.
        body: Dicion√°rio com vari√°veis para preencher o template HTML.
              Usado se 'template_name' for fornecido.
        template_name: Nome do arquivo do template HTML (sem extens√£o).
                       Define o modo de envio como HTML.
        plain_text_body: Conte√∫do alternativo em texto puro. Usado se
                         'template_name' n√£o for fornecido. Define o modo
                         de envio como texto plano.
    """
    # Verifica se o envio global de emails est√° habilitado
    if not settings.MAIL_ENABLED:
        logger.warning("Envio de e-mail desabilitado nas configura√ß√µes (MAIL_ENABLED=false).")
        return

    # Verifica se todas as configura√ß√µes essenciais de SMTP est√£o presentes
    if not all([settings.MAIL_USERNAME, settings.MAIL_PASSWORD, settings.MAIL_FROM, settings.MAIL_SERVER]):
        logger.error("Configura√ß√µes essenciais de e-mail ausentes (USERNAME, PASSWORD, FROM, SERVER). N√£o foi poss√≠vel enviar.")
        return

    # Cria o objeto de mensagem do FastMail
    message = MessageSchema(
        subject=subject,
        recipients=recipient_to,
        # Usa o body dict se template for fornecido, sen√£o espera texto puro
        template_body=body if template_name else None,
        body=plain_text_body if not template_name else None,
        # Define o subtipo (HTML ou Plain) com base na presen√ßa do template
        subtype=MessageType.html if template_name else MessageType.plain,
    )

    # Tenta enviar a mensagem e trata exce√ß√µes
    try:
        logger.info(f"Tentando enviar e-mail para {recipient_to} com assunto '{subject}'...")
        # Chama o m√©todo de envio do FastMail
        await fm.send_message(message, template_name=template_name)
        logger.info(f"E-mail enviado com sucesso para {recipient_to}.")
    except Exception as e:
        # Loga a exce√ß√£o completa em caso de falha no envio
        logger.exception(f"Erro ao enviar e-mail para {recipient_to}: {e}")


# =========================================
# --- Fun√ß√µes Utilit√°rias Espec√≠ficas ---
# =========================================

async def send_urgent_task_notification(
    user_email: EmailStr,
    user_name: str,
    task_title: str,
    task_id: str,
    task_due_date: Optional[str],
    priority_score: float
):
    """
    Prepara e envia uma notifica√ß√£o espec√≠fica para tarefas urgentes.

    Re√∫ne os dados necess√°rios, formata o assunto, corpo e link,
    e chama a fun√ß√£o gen√©rica `send_email_async` para realizar o envio
    usando um template HTML espec√≠fico ('urgent_task.html').

    Args:
        user_email: Email do destinat√°rio.
        user_name: Nome do destinat√°rio.
        task_title: T√≠tulo da tarefa urgente.
        task_id: ID da tarefa urgente (para link).
        task_due_date: Data de vencimento formatada como string (ou None).
        priority_score: Pontua√ß√£o de prioridade calculada.
    """
    # Define o assunto do e-mail
    subject = f"üö® Tarefa Urgente no SmartTask: {task_title}"

    # Monta o link para a tarefa, se FRONTEND_URL estiver configurado
    task_link = f"{settings.FRONTEND_URL}/tasks/{task_id}" if settings.FRONTEND_URL else None

    # Prepara o dicion√°rio 'body' com os dados para o template HTML
    email_body_data = {
        "task_title": task_title,
        "user_name": user_name,
        "due_date": task_due_date or "N/A", 
        "priority_score": f"{priority_score:.2f}", 
        "task_link": task_link,
        "project_name": settings.PROJECT_NAME
    }

    # Define o nome do template HTML a ser usado
    template_name = "urgent_task.html"

    # Monta o corpo em texto puro como fallback
    plain_text_body = (
        f"Ol√° {user_name},\n"
        f"A tarefa '{task_title}' no {settings.PROJECT_NAME} √© considerada urgente.\n"
        f"Prioridade: {priority_score:.2f}, Vencimento: {task_due_date or 'N/A'}.\n"
    )
    if task_link:
        plain_text_body += f"Acesse a tarefa aqui: {task_link}"

    # Chama a fun√ß√£o gen√©rica de envio
    await send_email_async(
        subject=subject,
        recipient_to=[user_email], 
        body=email_body_data,
        template_name=template_name,
        plain_text_body=plain_text_body
    )

================================================================================
Cap√≠tulo 4: app/core/logging_config.py
================================================================================

# app/core/logging_config.py

# ========================
# --- Importa√ß√µes ---
# ========================
import logging
import sys
from loguru import logger as loguru_logger 

# ============================
# --- Handler de Intercep√ß√£o ---
# ============================
class InterceptHandler(logging.Handler):
    """
    Handler do logging que redireciona mensagens para o Loguru.
    """
    def emit(self, record: logging.LogRecord) -> None:
        """
        Recebe um registro de log padr√£o e o envia para o Loguru.
        """
        try:
            level = loguru_logger.level(record.levelname).name
        except ValueError:
            level = record.levelno 

        frame, depth = logging.currentframe(), 2
        while hasattr(frame, "f_code") and frame.f_code.co_filename == logging.__file__:
            frame = frame.f_back
            if frame is None: # pragma: no cover
                break # pragma: no cover
            depth += 1

        loguru_logger.opt(depth=depth, exception=record.exc_info).log(level, record.getMessage())


# ============================
# --- Fun√ß√£o de Setup ---
# ============================
def setup_logging(log_level: str = "INFO"):
    """
    Configura o sistema de logging usando Loguru.

    - Remove handlers padr√£o do Loguru.
    - Adiciona um handler para stderr com n√≠vel e formato configur√°veis.
    - Configura o logging padr√£o do Python para usar o InterceptHandler.

    Args:
        log_level: O n√≠vel m√≠nimo de log a ser exibido (ex: "DEBUG", "INFO").
    """
    log_level = log_level.upper()

    loguru_logger.remove()

    loguru_logger.add(
        sys.stderr,
        level=log_level,              
        format="<green>{time:YYYY-MM-DD HH:mm:ss}</green> | <level>{level: <8}</level> | <cyan>{name}</cyan>:<cyan>{function}</cyan>:<cyan>{line}</cyan> - <level>{message}</level>",
        enqueue=True,
        diagnose=False                
    )

    logging.basicConfig(handlers=[InterceptHandler()], level=0, force=True)
    logging.getLogger("uvicorn.access").disabled = True
    logging.getLogger("uvicorn.error").propagate = False
    loguru_logger.disable("httpx")

================================================================================
Cap√≠tulo 5: app/core/security.py
================================================================================

# app/core/security.py

# ========================
# --- Importa√ß√µes ---
# ========================
import logging
from datetime import datetime, timedelta, timezone
from typing import Any, Union, Optional
from passlib.context import CryptContext 
from jose import ExpiredSignatureError, jwt, JWTError 
from pydantic import ValidationError 

# --- M√≥dulos da Aplica√ß√£o ---
from app.core.config import settings 
from app.models.token import TokenPayload 

# ===============================
# --- Configura√ß√£o do Logger ---
# ===============================
logger = logging.getLogger(__name__)

# ==========================================
# --- Configura√ß√£o Hashing de Senha ---
# ==========================================
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

# =========================
# --- Constantes JWT ---
# =========================
ALGORITHM = settings.JWT_ALGORITHM
ACCESS_TOKEN_EXPIRE_MINUTES = settings.ACCESS_TOKEN_EXPIRE_MINUTES

# ================================
# --- Fun√ß√µes de Senha ---
# ================================
def verify_password(plain_password: str, hashed_password: str) -> bool:
    """
    Verifica se uma senha em texto plano corresponde a um hash armazenado.

    Usa o contexto do passlib (`pwd_context`) para comparar a senha
    com o hash de forma segura.

    Args:
        plain_password: A senha fornecida pelo usu√°rio.
        hashed_password: O hash da senha armazenado no banco de dados.

    Returns:
        True se a senha corresponder ao hash, False caso contr√°rio (incluindo
        se o formato do hash for inv√°lido).
    """
    try:
        return pwd_context.verify(plain_password, hashed_password)
    except ValueError:
        logger.warning("Tentativa de verificar senha com hash em formato inv√°lido.")
        return False

def get_password_hash(password: str) -> str:
    """
    Gera um hash seguro (bcrypt) para uma senha fornecida.

    Args:
        password: A senha em texto plano a ser hasheada.

    Returns:
        A string do hash bcrypt gerado (incluindo salt e metadados).
    """
    return pwd_context.hash(password)

# =========================
# --- Fun√ß√µes JWT ---
# =========================

def create_access_token(
    subject: Union[str, Any], 
    username: str,
    expires_delta: Optional[timedelta] = None 
) -> str:
    """
    Cria um novo token de acesso JWT, codificando 'subject' (ID do usu√°rio)
    e 'username' no payload, com um tempo de expira√ß√£o definido.

    Args:
        subject: O identificador √∫nico do usu√°rio (convertido para string).
                 Normalmente o ID do usu√°rio (ex: UUID).
        username: O nome de usu√°rio, inclu√≠do no payload.
        expires_delta: Dura√ß√£o opcional para a validade do token.
                       Se None, usa o padr√£o `ACCESS_TOKEN_EXPIRE_MINUTES`.

    Returns:
        O token JWT codificado como uma string.
    """
    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)

    subject_str = str(subject)

    to_encode = {
        "exp": expire,     
        "sub": subject_str,
        "username": username 
    }

    encoded_jwt = jwt.encode(to_encode, settings.JWT_SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

def decode_token(token: str) -> Optional[TokenPayload]:
    """
    Decodifica e valida um token JWT.

    Verifica a assinatura, a expira√ß√£o e a estrutura do payload usando o modelo Pydantic.
    A verifica√ß√£o de expira√ß√£o padr√£o do jwt.decode √© desabilitada para que
    a l√≥gica de verifica√ß√£o dupla de expira√ß√£o seja testada e executada.
    """
    try:
        payload = jwt.decode(
            token,
            settings.JWT_SECRET_KEY,
            algorithms=[ALGORITHM],
            options={"verify_exp": False}  
        )
        token_data = TokenPayload.model_validate(payload) 
        if token_data.exp is not None:
            token_expiration_time = datetime.fromtimestamp(token_data.exp, tz=timezone.utc)
            if datetime.now(timezone.utc) > token_expiration_time:
                logger.info("Token JWT expirado (verifica√ß√£o dupla).") 
                return None
        else:
            pass
        return token_data
    except ExpiredSignatureError: 
        logger.warning("Token JWT detectado como expirado pela biblioteca JOSE antes da verifica√ß√£o dupla.") 
        return None 
    except (JWTError, ValidationError, KeyError) as e: 
        logger.error(f"Erro ao decodificar/validar token: {e}", exc_info=True)
        return None

================================================================================
Cap√≠tulo 6: app/core/utils.py
================================================================================

# app/core/utils.py

# ========================
# --- Importa√ß√µes ---
# ========================
import json
import hmac
import hashlib
import math
import logging
from datetime import date, datetime, timezone
from typing import Any, Dict, Optional, TYPE_CHECKING
from app.models.task import Task
import httpx 

# --- M√≥dulos da Aplica√ß√£o ---
from app.core.config import settings

# ===============================
# --- Configura√ß√£o do Logger ---
# ===============================
logger = logging.getLogger(__name__)

# =============================================
# --- Fun√ß√£o de C√°lculo de Prioridade ---
# =============================================
def calculate_priority_score(
    importance: int,
    due_date: Optional[date]
    ) -> Optional[float]:
    """
    Calcula a pontua√ß√£o de prioridade de uma tarefa com base na import√¢ncia
    e na data de vencimento, utilizando pesos definidos nas configura√ß√µes.

    Args:
        importance: N√≠vel de import√¢ncia da tarefa (inteiro, esperado 1-5).
        due_date: Data de vencimento da tarefa (objeto date ou None).

    Returns:
        A pontua√ß√£o de prioridade calculada (float) ou None se a import√¢ncia for inv√°lida.
    """
    # Valida√ß√£o b√°sica da import√¢ncia
    if not 1 <= importance <= 5:
         logger.warning(f"C√°lculo de prioridade recebido com import√¢ncia inv√°lida: {importance}")
         return None

    # =======================
    # --- Score Import√¢ncia ---
    # =======================
    # Calcula a parte do score referente √† import√¢ncia
    importance_score = importance * settings.PRIORITY_WEIGHT_IMPORTANCE

    # ==================
    # --- Score Prazo ---
    # ==================
    # Inicializa o score de prazo
    due_date_score = 0.0
    if due_date:
        # Se h√° data de vencimento, calcula dias restantes
        today = date.today()
        days_remaining = (due_date - today).days

        if days_remaining < 0:
            # Tarefa atrasada recebe score m√°ximo definido
            due_date_score = settings.PRIORITY_SCORE_IF_OVERDUE
            logger.debug(f"Tarefa atrasada ({days_remaining} dias), aplicando score de overdue: {due_date_score}")
        elif days_remaining == 0:
            # Tarefa vence hoje, score alto (inverso de 1 dia)
             due_date_score = settings.PRIORITY_WEIGHT_DUE_DATE / 1.0
             logger.debug(f"Tarefa vence hoje, aplicando score de prazo: {due_date_score}")
        elif days_remaining > 0:
            # Tarefa vence no futuro, score inversamente proporcional aos dias
            effective_days = max(1, days_remaining)
            due_date_score = settings.PRIORITY_WEIGHT_DUE_DATE / effective_days
            logger.debug(f"Tarefa vence em {days_remaining} dias, aplicando score de prazo: {due_date_score}")

    elif settings.PRIORITY_DEFAULT_SCORE_NO_DUE_DATE is not None:
         # Tarefa sem data de vencimento, usa score padr√£o (se definido)
         due_date_score = settings.PRIORITY_DEFAULT_SCORE_NO_DUE_DATE
         logger.debug(f"Tarefa sem prazo, aplicando score default de prazo: {due_date_score}")

    # =========================
    # --- Combinar Scores ---
    # =========================
    # Soma os scores de import√¢ncia e prazo e arredonda
    total_score = round(due_date_score + importance_score, 2)
    logger.debug(f"Score final calculado: {total_score} (prazo={due_date_score}, importancia={importance_score})")

    return total_score

# ===================================
# --- Fun√ß√£o de Tarefa Urgente ---
# ===================================
def is_task_urgent(task: Task) -> bool:
    """
    Verifica se uma tarefa √© considerada urgente para fins de notifica√ß√£o.

    Crit√©rios de Urg√™ncia:
    1. A pontua√ß√£o de prioridade (`priority_score`) √© maior que o limiar
       `EMAIL_URGENCY_THRESHOLD` definido nas configura√ß√µes.
    OU
    2. A tarefa tem uma `due_date` definida e essa data √© hoje ou j√° passou.

    Args:
        task: O objeto Task a ser verificado.

    Returns:
        True se a tarefa for considerada urgente, False caso contr√°rio.
    """
    # Condi√ß√£o inicial: tarefa precisa ter score ou prazo para ser potencialmente urgente
    if task.priority_score is None and task.due_date is None:
         return False

    # Crit√©rio 1: Score acima do limiar
    if task.priority_score is not None and task.priority_score > settings.EMAIL_URGENCY_THRESHOLD:
        return True

    # Crit√©rio 2: Vence hoje ou est√° atrasada
    if task.due_date:
        today = date.today()
        days_remaining = (task.due_date - today).days
        if days_remaining <= 0: 
            return True

    # Se nenhum crit√©rio foi atendido
    return False

# =====================================
# --- Fun√ß√£o de Envio de Webhook ---
# =====================================
async def send_webhook_notification(
    event_type: str,
    task_data: Dict[str, Any]
    ):
    """
    Envia uma notifica√ß√£o via webhook para a URL configurada (se houver).

    Constr√≥i o payload JSON com tipo de evento, dados da tarefa e timestamp.
    Se um `WEBHOOK_SECRET` estiver configurado, calcula e adiciona uma assinatura
    HMAC-SHA256 ao cabe√ßalho `X-SmartTask-Signature`.
    Realiza a requisi√ß√£o POST usando `httpx` e trata exce√ß√µes comuns.

    Args:
        event_type: String identificando o tipo do evento (ex: 'task.created').
        task_data: Dicion√°rio contendo os dados da tarefa a serem enviados.
    """
    # Retorna cedo se a URL do webhook n√£o estiver configurada
    if not settings.WEBHOOK_URL:
        logger.debug("Webhook URL n√£o configurada, pulando envio.")
        return

    # Converte a URL (que pode ser um objeto HttpUrl Pydantic) para string
    webhook_url_str = str(settings.WEBHOOK_URL)

    # Monta o payload da notifica√ß√£o
    payload = {
        "event": event_type,
        "task": task_data,
        "timestamp": datetime.now(timezone.utc).isoformat() # Timestamp UTC em ISO format
    }

    # Cabe√ßalhos padr√£o da requisi√ß√£o
    headers = {
        "Content-Type": "application/json",
        "User-Agent": "SmartTask-Webhook-Client/1.0" # Identifica nosso cliente
    }

    # =============================
    # --- Seguran√ßa: Assinatura ---
    # =============================
    # Adiciona assinatura HMAC se um segredo estiver configurado
    if settings.WEBHOOK_SECRET:
        try:
            # Serializa o payload JSON de forma consistente (ordenado, sem espa√ßos)
            payload_bytes = json.dumps(payload, separators=(',', ':'), sort_keys=True).encode('utf-8')
            secret_bytes = settings.WEBHOOK_SECRET.encode('utf-8')

            # Calcula o HMAC-SHA256
            signature = hmac.new(secret_bytes, payload_bytes, hashlib.sha256).hexdigest()
            # Adiciona ao header no formato padr√£o 'schema=signature'
            headers["X-SmartTask-Signature"] = f"sha256={signature}"
        except Exception as e:
             # Loga erro e n√£o envia se a assinatura falhar
             logger.error(f"Erro ao gerar assinatura HMAC para webhook: {e}", exc_info=True)
             return

    # =================================
    # --- Envio da Requisi√ß√£o HTTP ---
    # =================================
    try:
         # Usa um cliente HTTP ass√≠ncrono para enviar a requisi√ß√£o
         async with httpx.AsyncClient() as client:
            logger.info(f"Enviando webhook evento '{event_type}' para {webhook_url_str}")
            response = await client.post(
                webhook_url_str,
                json=payload, 
                headers=headers,
                timeout=10.0 
            )

            # Levanta uma exce√ß√£o para respostas com status de erro (4xx ou 5xx)
            response.raise_for_status()

            logger.info(f"Webhook enviado com sucesso para {webhook_url_str}. Status: {response.status_code}")

    # --- Tratamento de Erros Espec√≠ficos ---
    except httpx.TimeoutException:
         logger.error(f"Timeout ao enviar webhook para {webhook_url_str}")
    except httpx.RequestError as exc:
         # Erros relacionados √† conex√£o ou requisi√ß√£o (DNS, conex√£o recusada, etc.)
         logger.error(f"Erro na requisi√ß√£o ao enviar webhook para {webhook_url_str}: {exc}")
    except httpx.HTTPStatusError as exc:
         # Erros retornados pelo servidor do webhook (4xx, 5xx)
         logger.error(
             f"Erro no servidor do webhook ({webhook_url_str}). "
             f"Status: {exc.response.status_code}. Resposta: {exc.response.text[:200]}..."
         )
    # --- Tratamento de Erro Gen√©rico ---
    except Exception as e:
         # Captura qualquer outra exce√ß√£o inesperada
         logger.exception(f"Erro inesperado ao enviar webhook para {webhook_url_str}: {e}")

================================================================================
Cap√≠tulo 7: app/db/mongodb_utils.py
================================================================================

# app/db/mongodb_utils.py

# ========================
# --- Importa√ß√µes ---
# ========================
import logging
from typing import Optional
import motor.motor_asyncio 
from motor.motor_asyncio import AsyncIOMotorDatabase 

# --- M√≥dulos da Aplica√ß√£o ---
from app.core.config import settings 

# ===============================
# --- Configura√ß√£o do Logger ---
# ===============================
logger = logging.getLogger(__name__)

# ====================================
# --- Vari√°veis Globais de Conex√£o ---
# ====================================
db_client: Optional[motor.motor_asyncio.AsyncIOMotorClient] = None
db_instance: Optional[AsyncIOMotorDatabase] = None

# ==============================
# --- Fun√ß√£o de Conex√£o ---
# ==============================
async def connect_to_mongo() -> Optional[AsyncIOMotorDatabase]:
    """
    Estabelece a conex√£o com o MongoDB na inicializa√ß√£o da aplica√ß√£o.

    - Cria um cliente AsyncIOMotorClient usando a MONGODB_URL das configura√ß√µes.
    - Define um timeout para sele√ß√£o do servidor.
    - Envia um comando 'ping' para verificar a conex√£o.
    - Define as vari√°veis globais `db_client` e `db_instance`.
    - Trata exce√ß√µes de conex√£o e loga erros.

    Returns:
        A inst√¢ncia do banco de dados (AsyncIOMotorDatabase) se a conex√£o for bem-sucedida,
        ou None em caso de falha.
    """
    global db_client, db_instance
    logger.info("Tentando conectar ao MongoDB...")
    try:
        db_client = motor.motor_asyncio.AsyncIOMotorClient(
            settings.MONGODB_URL,
            serverSelectionTimeoutMS=5000 
        )
        await db_client.admin.command('ping')
        logger.info("Comando ping para MongoDB bem-sucedido.")

        db_instance = db_client[settings.DATABASE_NAME]
        logger.info(f"Conectado com sucesso ao banco de dados: {settings.DATABASE_NAME}")
        return db_instance

    except Exception as e:
        logger.error(f"N√£o foi poss√≠vel conectar ao MongoDB: {e}", exc_info=True)
        db_client = None
        db_instance = None
        return None

# ==============================
# --- Fun√ß√£o de Fechamento ---
# ==============================
async def close_mongo_connection():
    """
    Fecha a conex√£o com o MongoDB durante o encerramento da aplica√ß√£o.

    Verifica se o cliente global `db_client` foi inicializado antes de tentar fechar.
    """
    global db_client
    logger.info("Tentando fechar conex√£o com MongoDB...")
    if db_client:
        db_client.close()
        logger.info("Conex√£o com MongoDB fechada.")
    else:
        logger.warning("Tentativa de fechar conex√£o com MongoDB, mas cliente n√£o estava inicializado.")

# =============================
# --- Fun√ß√£o de Acesso DB ---
# =============================
def get_database() -> AsyncIOMotorDatabase:
    """
    Retorna a inst√¢ncia global do banco de dados MongoDB.

    Fun√ß√£o utilit√°ria para ser usada como depend√™ncia FastAPI ou chamada
    diretamente por outras partes da aplica√ß√£o que precisam acessar o DB.

    Raises:
        RuntimeError: Se a fun√ß√£o for chamada antes de `connect_to_mongo`
                      ter inicializado `db_instance` com sucesso.

    Returns:
        A inst√¢ncia `AsyncIOMotorDatabase` global.
    """
    if db_instance is None:
        logger.error("Tentativa de obter inst√¢ncia do DB antes da inicializa√ß√£o!")
        raise RuntimeError("A conex√£o com o banco de dados n√£o foi inicializada.")
    return db_instance

================================================================================
Cap√≠tulo 8: app/db/task_crud.py
================================================================================

# app/db/task_crud.py
"""
M√≥dulo contendo as fun√ß√µes CRUD (Create, Read, Update, Delete)
para interagir com a cole√ß√£o de tarefas no MongoDB.
Inclui tamb√©m fun√ß√µes auxiliares e para cria√ß√£o de √≠ndices.
"""

# ========================
# --- Importa√ß√µes ---
# ========================
import logging
import uuid
from datetime import date, datetime, timezone
from typing import List, Optional, Dict, Any, Tuple
from motor.motor_asyncio import AsyncIOMotorDatabase, AsyncIOMotorCollection
from pymongo import ASCENDING, DESCENDING
from pydantic import ValidationError

# --- M√≥dulos da Aplica√ß√£o ---
from app.models.task import Task, TaskCreate, TaskUpdate, TaskStatus

# =====================================
# --- Configura√ß√µes e Constantes ---
# =====================================

logger = logging.getLogger(__name__)

TASKS_COLLECTION = "tasks"

# =========================================
# --- Fun√ß√µes Auxiliares (Internas) ---
# =========================================

def _get_tasks_collection(db: AsyncIOMotorDatabase) -> AsyncIOMotorCollection:
    """Retorna a cole√ß√£o de tarefas do banco de dados."""
    return db[TASKS_COLLECTION]

def _parse_sort_params(sort_by: Optional[str], sort_order: str) -> Optional[List[Tuple[str, int]]]:
    """
    Converte os par√¢metros de ordena√ß√£o de string para o formato do PyMongo.

    Args:
        sort_by: Campo pelo qual ordenar.
        sort_order: Ordem da ordena√ß√£o ("asc" ou "desc").

    Returns:
        Lista de tuplas para ordena√ß√£o do PyMongo ou None se o campo n√£o for v√°lido.
    """
    if sort_order.lower() == "asc":
        mongo_order = ASCENDING
    else:
        mongo_order = DESCENDING

    if sort_by in ["priority_score", "due_date", "created_at", "importance"]:
        return [(sort_by, mongo_order)]
    return None

# =======================================
# --- Opera√ß√µes CRUD para Tarefas ---
# =======================================

async def create_task(db: AsyncIOMotorDatabase, task_db: Task) -> Optional[Task]:
    """
    Cria uma nova tarefa no banco de dados.

    A tarefa j√° deve chegar validada e com campos como ID e owner_id preenchidos.

    Args:
        db: Inst√¢ncia da conex√£o com o banco de dados.
        task_db: Objeto Task contendo os dados da tarefa a ser criada.

    Returns:
        O objeto Task criado se sucesso, None caso contr√°rio.
    """
    collection = _get_tasks_collection(db)
    task_db_dict = task_db.model_dump(mode="json")
    try:
        insert_result = await collection.insert_one(task_db_dict)
        if insert_result.acknowledged:
            return task_db
        else:
            logger.warning(f"Cria√ß√£o da tarefa para owner {task_db.owner_id} n√£o foi reconhecida pelo DB (acknowledged=False).")
            return None
    except Exception as e:
        logger.exception(f"DB Error creating task for owner {task_db.owner_id}: {e}")
        return None

async def get_task_by_id(db: AsyncIOMotorDatabase, task_id: uuid.UUID, owner_id: uuid.UUID) -> Optional[Task]:
    """
    Busca uma tarefa espec√≠fica pelo seu ID e pelo ID do propriet√°rio.

    Args:
        db: Inst√¢ncia da conex√£o com o banco de dados.
        task_id: ID da tarefa a ser buscada.
        owner_id: ID do propriet√°rio da tarefa.

    Returns:
        O objeto Task encontrado ou None se a tarefa n√£o existir ou erro de valida√ß√£o.
    """
    collection = _get_tasks_collection(db)
    task_dict = await collection.find_one({"id": str(task_id), "owner_id": str(owner_id)})
    if task_dict:
        task_dict.pop('_id', None)
        try:
            return Task.model_validate(task_dict)
        except (ValidationError, Exception) as e:
            logger.error(f"DB Validation error get_task_by_id {task_id} for owner {owner_id}: {e}")
            return None
    return None

async def get_tasks_by_owner(
    db: AsyncIOMotorDatabase,
    owner_id: uuid.UUID,
    *,
    status_filter: Optional[TaskStatus] = None,
    due_before: Optional[date] = None,
    project_filter: Optional[str] = None,
    tags_filter: Optional[List[str]] = None,
    sort_by: Optional[str] = None,
    sort_order: str = "desc",
    limit: int = 100,
    skip: int = 0
) -> List[Task]:
    """
    Busca tarefas de um propriet√°rio com filtros, ordena√ß√£o e pagina√ß√£o.

    Args:
        db: Inst√¢ncia da conex√£o com o banco de dados.
        owner_id: ID do propriet√°rio das tarefas.
        status_filter: Filtra tarefas pelo status.
        due_before: Filtra tarefas com data de entrega anterior ou igual √† data fornecida.
        project_filter: Filtra tarefas por nome do projeto.
        tags_filter: Filtra tarefas que contenham todas as tags listadas.
        sort_by: Campo para ordena√ß√£o.
        sort_order: Ordem da ordena√ß√£o ("asc" ou "desc").
        limit: N√∫mero m√°ximo de tarefas a retornar.
        skip: N√∫mero de tarefas a pular (para pagina√ß√£o).

    Returns:
        Uma lista de objetos Task. Retorna lista vazia em caso de erro ou nenhuma tarefa encontrada.
    """
    collection = _get_tasks_collection(db)
    query: Dict[str, Any] = {"owner_id": str(owner_id)}

    if status_filter:
        query["status"] = status_filter.value
    if due_before:
        due_before_dt = datetime.combine(due_before, datetime.min.time(), tzinfo=timezone.utc)
        query["due_date"] = {"$lte": due_before_dt}
    if project_filter:
        query["project"] = project_filter
    if tags_filter:
        query["tags"] = {"$all": tags_filter}

    sort_list = _parse_sort_params(sort_by, sort_order)

    validated_tasks = []
    try:
        tasks_cursor = collection.find(query).skip(skip).limit(limit)
        if sort_list:
            tasks_cursor = tasks_cursor.sort(sort_list)

        async for task_dict in tasks_cursor:
            task_dict.pop('_id', None)
            try:
                validated_tasks.append(Task.model_validate(task_dict))
            except (ValidationError, Exception) as e:
                logger.error(f"DB Validation error list_tasks owner {owner_id} task {task_dict.get('id', 'N/A')}: {e}")
                continue
        return validated_tasks
    except Exception as e:
        logger.exception(f"DB Error listing tasks for owner {owner_id}: {e}")
        return []


async def update_task(
    db: AsyncIOMotorDatabase,
    task_id: uuid.UUID,
    owner_id: uuid.UUID,
    update_data: Dict[str, Any]
) -> Optional[Task]:
    """
    Atualiza uma tarefa existente de um propriet√°rio espec√≠fico.

    Os dados de atualiza√ß√£o devem ser fornecidos em um dicion√°rio pronto para o
    operador '$set' do MongoDB. O campo 'updated_at' √© automaticamente atualizado.

    Args:
        db: Inst√¢ncia da conex√£o com o banco de dados.
        task_id: ID da tarefa a ser atualizada.
        owner_id: ID do propriet√°rio da tarefa.
        update_data: Dicion√°rio com os campos a serem atualizados.

    Returns:
        O objeto Task atualizado ou None se a tarefa n√£o for encontrada ou ocorrer um erro.
    """
    collection = _get_tasks_collection(db)
    update_data["updated_at"] = datetime.now(timezone.utc)

    try:
        updated_task_dict_raw = await collection.find_one_and_update(
            {"id": str(task_id), "owner_id": str(owner_id)},
            {"$set": update_data},
            return_document=True
        )

        if updated_task_dict_raw:
            updated_task_dict_raw.pop('_id', None)
            try:
                return Task.model_validate(updated_task_dict_raw)
            except (ValidationError, Exception) as e:
                logger.error(f"DB Validation error update_task {task_id} owner {owner_id}: {e}")
                return None
        else:
            logger.warning(f"Tentativa de atualizar tarefa n√£o encontrada: ID {task_id}, Owner ID {owner_id}")
            return None
    except Exception as e:
        logger.exception(f"DB Error updating task {task_id} owner {owner_id}: {e}")
        return None


async def delete_task(db: AsyncIOMotorDatabase, task_id: uuid.UUID, owner_id: uuid.UUID) -> bool:
    """
    Deleta uma tarefa espec√≠fica pelo seu ID e pelo ID do propriet√°rio.

    Args:
        db: Inst√¢ncia da conex√£o com o banco de dados.
        task_id: ID da tarefa a ser deletada.
        owner_id: ID do propriet√°rio da tarefa.

    Returns:
        True se a tarefa foi deletada com sucesso (1 documento afetado), False caso contr√°rio.
    """
    collection = _get_tasks_collection(db)
    try:
        delete_result = await collection.delete_one({"id": str(task_id), "owner_id": str(owner_id)})
        return delete_result.deleted_count == 1
    except Exception as e:
        logger.exception(f"DB Error deleting task {task_id} owner {owner_id}: {e}")
        return False

# ===================================================
# --- Cria√ß√£o de √çndices do Banco de Dados ---
# ===================================================

async def create_task_indexes(db: AsyncIOMotorDatabase):
    """
    Cria os √≠ndices necess√°rios na cole√ß√£o de tarefas para otimizar consultas.

    Os √≠ndices s√£o criados apenas se ainda n√£o existirem.
    Esta fun√ß√£o √© tipicamente chamada durante a inicializa√ß√£o da aplica√ß√£o.

    Args:
        db: Inst√¢ncia da conex√£o com o banco de dados.
    """
    collection = _get_tasks_collection(db)
    try:
        await collection.create_index("id", unique=True, name="task_id_unique_idx")
        await collection.create_index("owner_id", name="task_owner_idx")
        await collection.create_index(
            [("owner_id", ASCENDING), ("due_date", DESCENDING)],
            name="task_owner_due_date_idx"
        )
        await collection.create_index(
            [("owner_id", ASCENDING), ("priority_score", DESCENDING)],
            name="task_owner_priority_idx"
        )
        await collection.create_index("tags", name="task_tags_idx")
        logging.info("√çndices da cole√ß√£o 'tasks' verificados/criados.")
    except Exception as e:
        logging.error(f"Erro ao criar √≠ndices da cole√ß√£o 'tasks': {e}", exc_info=True)

================================================================================
Cap√≠tulo 9: app/db/user_crud.py
================================================================================

# app/db/user_crud.py
"""
M√≥dulo contendo as fun√ß√µes CRUD (Create, Read, Update, Delete)
para interagir com a cole√ß√£o de usu√°rios no MongoDB.
Inclui tamb√©m fun√ß√µes para cria√ß√£o de √≠ndices.
"""

# ========================
# --- Importa√ß√µes ---
# ========================
import logging
import uuid
from datetime import datetime, timezone
from typing import Optional
from motor.motor_asyncio import AsyncIOMotorDatabase, AsyncIOMotorCollection
from pydantic import ValidationError
from pymongo.errors import DuplicateKeyError

# --- M√≥dulos da Aplica√ß√£o ---
from app.models.user import UserCreate, UserInDB, UserUpdate 
from app.core.security import get_password_hash

# =====================================
# --- Configura√ß√µes e Constantes ---
# =====================================

# Obter um logger para este m√≥dulo
logger = logging.getLogger(__name__)

# Nome da cole√ß√£o no MongoDB para usu√°rios
USERS_COLLECTION = "users"

# =========================================
# --- Fun√ß√µes Auxiliares (Internas) ---
# =========================================

def _get_users_collection(db: AsyncIOMotorDatabase) -> AsyncIOMotorCollection:
    """Retorna a cole√ß√£o de usu√°rios do banco de dados."""
def _get_users_collection(db: AsyncIOMotorDatabase) -> AsyncIOMotorCollection:
    return db[USERS_COLLECTION]

# =======================================
# --- Opera√ß√µes CRUD para Usu√°rios ---
# =======================================

async def get_user_by_id(db: AsyncIOMotorDatabase, user_id: uuid.UUID) -> Optional[UserInDB]:
    """
    Busca um usu√°rio pelo seu ID (UUID).

    Args:
        db: Inst√¢ncia da conex√£o com o banco de dados.
        user_id: O ID do usu√°rio a ser buscado.

    Returns:
        Um objeto UserInDB se o usu√°rio for encontrado e v√°lido, None caso contr√°rio.
    """
    collection = _get_users_collection(db)
    user_dict = await collection.find_one({"id": str(user_id)})
    if user_dict:
        # Remove o campo '_id' do MongoDB antes de validar com Pydantic
        user_dict.pop('_id', None)
        try:
            return UserInDB.model_validate(user_dict)
        except Exception as e:
            # Log da valida√ß√£o de dados vindo do DB.
            logger.error(f"DB Validation error get_user_by_id {user_id}: {e}")
            return None
    return None

async def get_user_by_username(db: AsyncIOMotorDatabase, username: str) -> Optional[UserInDB]:
    """
    Busca um usu√°rio pelo seu nome de usu√°rio.

    Args:
        db: Inst√¢ncia da conex√£o com o banco de dados.
        username: O nome de usu√°rio a ser buscado.

    Returns:
        Um objeto UserInDB se o usu√°rio for encontrado e v√°lido, None caso contr√°rio.
    """
    collection = _get_users_collection(db)
    user_dict = await collection.find_one({"username": username})
    if user_dict:
        # Remove o campo '_id' do MongoDB antes de validar com Pydantic
        user_dict.pop('_id', None)
        try:
            return UserInDB.model_validate(user_dict)
        except Exception as e:
            # Log da valida√ß√£o de dados vindo do DB.
            logger.error(f"DB Validation error get_user_by_username {username}: {e}")
            return None
    return None

async def get_user_by_email(db: AsyncIOMotorDatabase, email: str) -> Optional[UserInDB]:
    """
    Busca um usu√°rio pelo seu endere√ßo de e-mail.

    Args:
        db: Inst√¢ncia da conex√£o com o banco de dados.
        email: O endere√ßo de e-mail a ser buscado.

    Returns:
        Um objeto UserInDB se o usu√°rio for encontrado e v√°lido, None caso contr√°rio.
    """
    collection = _get_users_collection(db)
    # Para melhor performance e garantir unicidade, um √≠ndice no campo 'email' √© altamente recomendado.
    user_dict = await collection.find_one({"email": email})
    if user_dict:
        # Remove o campo '_id' do MongoDB antes de validar com Pydantic
        user_dict.pop('_id', None)
        try:
            return UserInDB.model_validate(user_dict)
        except Exception as e:
            # Log da valida√ß√£o de dados vindo do DB.
            logger.error(f"DB Validation error get_user_by_email {email}: {e}")
            return None
    return None

async def create_user(db: AsyncIOMotorDatabase, user_in: UserCreate) -> Optional[UserInDB]:
    """
    Cria um novo usu√°rio no banco de dados.

    Gera um UUID para o usu√°rio, hasheia a senha e define campos padr√£o
    como 'disabled', 'created_at' e 'updated_at'.

    Args:
        db: Inst√¢ncia da conex√£o com o banco de dados.
        user_in: Objeto UserCreate com os dados do usu√°rio a ser criado.

    Returns:
        Um objeto UserInDB representando o usu√°rio criado se sucesso, None em caso de erro.
        Pode levantar DuplicateKeyError se username ou email j√° existirem e houver
        √≠ndices de unicidade configurados.
    """
    hashed_password = get_password_hash(user_in.password)

    # Prepara os dados do usu√°rio para inser√ß√£o no banco, incluindo campos gerados
    user_db_data = {
        "id": uuid.uuid4(), 
        "username": user_in.username,
        "email": user_in.email,
        "hashed_password": hashed_password,
        "full_name": user_in.full_name,
        "disabled": False,  
        "created_at": datetime.now(timezone.utc), 
        "updated_at": None 
    }

    # Valida os dados preparados com o modelo Pydantic UserInDB antes de tentar inserir
    # Isso ajuda a pegar erros de formata√ß√£o ou tipo de dados antes da opera√ß√£o de DB.
    try:
        user_db_obj = UserInDB.model_validate(user_db_data)
    except Exception as validation_error:
        logger.error(f"Erro de valida√ß√£o Pydantic ao preparar dados para user_db_obj (username: {user_in.username}): {validation_error}", exc_info=True)
        return None

    # Converte o objeto Pydantic validado para um dicion√°rio para inser√ß√£o no MongoDB
    # 'mode="json"' garante que tipos como UUID e datetime sejam serializados corretamente.
    user_db_dict = user_db_obj.model_dump(mode="json")
    collection = _get_users_collection(db)

    try:
        insert_result = await collection.insert_one(user_db_dict)
        if not insert_result.acknowledged:
            logger.error(f"DB Insert User Acknowledged False for username {user_in.username}")
            return None
        # Retorna o objeto UserInDB completo e validado ap√≥s a inser√ß√£o bem-sucedida
        return user_db_obj
    except DuplicateKeyError:
        # Se um DuplicateKeyError ocorrer (e.g., username ou email j√° existem),
        # ele √© relan√ßado para ser tratado por uma camada superior (provavelmente o endpoint da API),
        # que pode retornar uma resposta HTTP 400/409 apropriada.
        logger.warning(f"Tentativa de criar usu√°rio com username ou email duplicado: {user_in.username} / {user_in.email}")
        raise
    except Exception as e:
        # Captura outras exce√ß√µes inesperadas durante a inser√ß√£o.
        logger.exception(f"Erro inesperado ao inserir usu√°rio {user_in.username} no DB: {e}")
        return None

async def update_user(db: AsyncIOMotorDatabase, user_id: uuid.UUID, user_update: UserUpdate) -> Optional[UserInDB]:
    """
    Atualiza os dados de um usu√°rio existente.

    Apenas os campos fornecidos no objeto `user_update` ser√£o alterados.
    O campo `updated_at` √© automaticamente atualizado. Se a senha for
    alterada, ela ser√° hasheada.

    Args:
        db: Inst√¢ncia da conex√£o com o banco de dados.
        user_id: O ID do usu√°rio a ser atualizado.
        user_update: Objeto UserUpdate contendo os dados a serem atualizados.

    Returns:
        O objeto UserInDB atualizado se sucesso, None se o usu√°rio n√£o for encontrado ou erro.
        Pode levantar DuplicateKeyError se a atualiza√ß√£o tentar definir um username/email
        que j√° exista e perten√ßa a outro usu√°rio.
    """
    collection = _get_users_collection(db)

    # Converte o modelo Pydantic para dicion√°rio, excluindo campos n√£o definidos (unset)
    # para que apenas os campos passados sejam atualizados.
    # 'exclude_unset=True' √© crucial aqui.
    update_data = user_update.model_dump(exclude_unset=True)

    # Se a senha estiver sendo atualizada, hasheia a nova senha.
    if "password" in update_data and update_data["password"] is not None:
        update_data["hashed_password"] = get_password_hash(update_data.pop("password"))
    elif "password" in update_data and update_data["password"] is None:
        # Evitar que 'password: null' delete o hash_password. O model UserUpdate deve garantir
        # que o campo password seja uma string v√°lida se presente.
        update_data.pop("password")


    # Se n√£o houver dados para atualizar ap√≥s processamento (ex: apenas 'password: null' foi passado e removido),
    # podemos retornar o usu√°rio atual sem fazer uma chamada ao DB, ou simplesmente continuar e
    # atualizar apenas o 'updated_at'. 
    if not update_data and "hashed_password" not in update_data : 
        existing_user = await get_user_by_id(db, user_id)
        if existing_user:
            # Atualiza apenas o updated_at se nenhum outro campo for modificado
            try:
                updated_doc = await collection.find_one_and_update(
                    {"id": str(user_id)},
                    {"$set": {"updated_at": datetime.now(timezone.utc)}},
                    return_document=True
                )
                if updated_doc:
                    updated_doc.pop('_id', None)
                    return UserInDB.model_validate(updated_doc)
                return None 
            except Exception as e:
                logger.exception(f"DB Error updating user (only updated_at) {user_id}: {e}")
                return None
        return existing_user 


    # Garante que o campo 'updated_at' seja atualizado.
    update_data["updated_at"] = datetime.now(timezone.utc)

    try:
        # Executa a atualiza√ß√£o e retorna o documento modificado
        updated_user_doc = await collection.find_one_and_update(
            {"id": str(user_id)},
            {"$set": update_data},
            return_document=True  
        )

        if updated_user_doc:
            # Remove o campo '_id' do MongoDB antes de validar com Pydantic
            updated_user_doc.pop('_id', None)
            try:
                return UserInDB.model_validate(updated_user_doc)
            except ValidationError as e: 
                logger.error(f"DB Validation error after updating user {user_id}: {e}")
                return None
        else:
            # O usu√°rio n√£o foi encontrado para atualiza√ß√£o
            logger.warning(f"Attempt to update user not found: ID {user_id}")
            return None
    except DuplicateKeyError:
        # Tratar erro de chave duplicada (e.g., email ou username)
        logger.warning(f"DB Error: Attempt to update user {user_id} resulted in duplicate key for data: { {k: v for k, v in update_data.items() if k not in ['hashed_password', 'updated_at']} }")
        # Relan√ßa para ser tratado na camada de cima
        raise 
    except Exception as e:
        logger.exception(f"DB Error updating user {user_id}: {e}")
        return None
    
async def delete_user(db: AsyncIOMotorDatabase, user_id: uuid.UUID) -> bool:
    """
    Deleta um usu√°rio do banco de dados pelo seu ID.

    Args:
        db: Inst√¢ncia da conex√£o com o banco de dados.
        user_id: O ID do usu√°rio a ser deletado.

    Returns:
        True se o usu√°rio foi deletado com sucesso (1 documento afetado), False caso contr√°rio.
    """
    collection = _get_users_collection(db)
    try:
        delete_result = await collection.delete_one({"id": str(user_id)})
        # Verifica se exatamente um documento foi deletado
        if delete_result.deleted_count == 1:
            logger.info(f"User {user_id} deleted successfully.")
            return True
        else:
            logger.warning(f"Attempt to delete user {user_id}, but user was not found or not deleted (deleted_count: {delete_result.deleted_count}).")
            return False
    except Exception as e:
        logger.exception(f"DB Error deleting user {user_id}: {e}")
        return False

# ===================================================
# --- Configura√ß√£o de √çndices do Banco de Dados ---
# ===================================================
async def create_user_indexes(db: AsyncIOMotorDatabase):
    """
    Cria os √≠ndices necess√°rios na cole√ß√£o de usu√°rios para otimizar consultas
    e garantir unicidade de campos como username e email.

    Os √≠ndices s√£o criados apenas se ainda n√£o existirem.
    Esta fun√ß√£o √© tipicamente chamada durante a inicializa√ß√£o da aplica√ß√£o.

    Args:
        db: Inst√¢ncia da conex√£o com o banco de dados.
    """
    collection = _get_users_collection(db)
    try:
        # √çndice √∫nico para 'username' para buscas r√°pidas e unicidade
        await collection.create_index("username", unique=True, name="username_unique_idx")
        # √çndice √∫nico para 'email' para buscas r√°pidas e unicidade
        await collection.create_index("email", unique=True, name="email_unique_idx")
        # Adicionado log com logger do m√≥dulo
        logger.info("√çndices da cole√ß√£o 'users' ('username', 'email') verificados/criados com sucesso.")
    except Exception as e:
        # Adicionado log com logger do m√≥dulo e exc_info=True
        logger.error(f"Erro ao criar √≠ndices para a cole√ß√£o 'users': {e}", exc_info=True)

================================================================================
Cap√≠tulo 10: app/main.py
================================================================================

# app/main.py

# ========================
# --- Importa√ß√µes ---
# ========================
import logging
import sys
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from contextlib import asynccontextmanager

# --- M√≥dulos da Aplica√ß√£o ---
from app.routers import tasks
from app.routers import auth
from app.db.mongodb_utils import connect_to_mongo, close_mongo_connection
from app.db.user_crud import create_user_indexes
from app.db.task_crud import create_task_indexes
from app.core.config import Settings, settings
from app.core.logging_config import setup_logging

# ===============================
# --- Configura√ß√£o de Logging ---
# ===============================
setup_logging(log_level=settings.LOG_LEVEL)
logger = logging.getLogger(__name__)

# =======================================
# --- Fun√ß√£o de Setup do Middleware CORS ---
# =======================================
def _setup_cors_middleware(app_instance: FastAPI, current_settings: Settings):
    if current_settings.CORS_ALLOWED_ORIGINS:
        logger.info(f"Configurando CORS para origens: {current_settings.CORS_ALLOWED_ORIGINS}")
        app_instance.add_middleware(
            CORSMiddleware,
            allow_origins=current_settings.CORS_ALLOWED_ORIGINS,
            allow_credentials=True,
            allow_methods=["*"],
            allow_headers=["*"],
        )
    else:
        logger.warning(
            "Nenhuma origem CORS configurada (settings.CORS_ALLOWED_ORIGINS est√° vazia). "
            "API pode n√£o ser acess√≠vel de frontends em outros dom√≠nios."
        )

# ==================================
# --- Ciclo de Vida (Lifespan) ---
# ==================================
@asynccontextmanager
async def lifespan(app: FastAPI):
    logger.info("Iniciando ciclo de vida da aplica√ß√£o...")
    db_connection = await connect_to_mongo()

    if db_connection is None:
        logger.critical("Falha fatal ao conectar ao MongoDB na inicializa√ß√£o. App pode n√£o funcionar corretamente.")
        # O yield abaixo ainda permite que a aplica√ß√£o continue e finalize "graciosamente"
        # sem o db.state.db configurado, mas tendo logado o erro cr√≠tico.
        yield
        logger.info("Encerrando ciclo de vida (conex√£o DB falhou no in√≠cio).")
        return

    app.state.db = db_connection
    logger.info("Conectado ao MongoDB.")

    try:
        db_instance = app.state.db
        logger.info("Tentando criar/verificar √≠ndices...")
        await create_user_indexes(db_instance)
        await create_task_indexes(db_instance)
        logger.info("Cria√ß√£o/verifica√ß√£o de √≠ndices conclu√≠da.")
    except Exception as e:
        logger.error(f"Erro durante a cria√ß√£o de √≠ndices: {e}", exc_info=True)

    logger.info("Aplica√ß√£o iniciada e pronta.") # Linha para ser coberta
    yield # Linha para ser coberta

    logger.info("Iniciando processo de encerramento...")
    await close_mongo_connection()
    logger.info("Conex√£o com MongoDB fechada.")
    logger.info("Aplica√ß√£o encerrada.")

# =========================
# --- Inst√¢ncia FastAPI ---
# =========================
app = FastAPI(
    title=settings.PROJECT_NAME,
    description="API RESTful para gerenciamento de tarefas com prioridade inteligente.",
    version="0.1.0",
    contact={
        "name": "Eng. Soft. Cl√°udio",
        "url": "https://www.linkedin.com/in/claudiodelimatosta/",
        "email": "claudiodelimatosta@gmail.com",
    },
    license_info={
        "name": "MIT License",
        "url": "https://opensource.org/licenses/MIT",
    },
    lifespan=lifespan
)

# =========================
# --- Middlewares ---
# =========================
_setup_cors_middleware(app, settings)

# ======================
# --- Rotas (Routers) ---
# ======================
app.include_router(auth.router, prefix=settings.API_V1_STR + "/auth", tags=["Authentication"])
app.include_router(tasks.router, prefix=settings.API_V1_STR, tags=["Tasks"])

# =====================
# --- Endpoint Raiz ---
# =====================
@app.get("/", tags=["Root"])
async def read_root():
    return {"message": f"Bem-vindo √† {settings.PROJECT_NAME}!"}

# =============================
# --- Execu√ß√£o (Uvicorn) ---
# =============================
if __name__ == "__main__": # pragma: no cover
    import uvicorn # pragma: no cover
    logger.info("Iniciando servidor Uvicorn para desenvolvimento...") # pragma: no cover
    uvicorn.run( # pragma: no cover
        "main:app", # pragma: no cover
        host="0.0.0.0", # pragma: no cover
        port=8000, # pragma: no cover
        reload=True, # pragma: no cover
        log_level=settings.LOG_LEVEL.lower() # pragma: no cover
    )

================================================================================
Cap√≠tulo 11: app/models/task.py
================================================================================

# app/models/task.py
"""
Este m√≥dulo define os modelos Pydantic utilizados para representar Tarefas (Tasks)
na aplica√ß√£o. Inclui modelos para a cria√ß√£o, atualiza√ß√£o, e representa√ß√£o
de tarefas como armazenadas e retornadas pelo banco de dados, al√©m de
defini√ß√µes auxiliares como o status da tarefa.
"""

# ========================
# --- Importa√ß√µes ---
# ========================
import uuid
from datetime import date, datetime, timezone
from enum import Enum
from typing import List, Optional

from pydantic import BaseModel, Field, ConfigDict

# ==============================
# --- Enumera√ß√µes de Status ---
# ==============================

class TaskStatus(str, Enum):
    """Define os poss√≠veis status de uma tarefa."""
    # Tarefa est√° aguardando para ser iniciada.
    PENDING = "pendente"
    # Tarefa est√° atualmente em execu√ß√£o.
    IN_PROGRESS = "em_progresso"
    # Tarefa foi finalizada com sucesso.
    COMPLETED = "conclu√≠da"
    # Tarefa foi cancelada e n√£o ser√° mais trabalhada.
    CANCELLED = "cancelada"

# ====================================
# --- Modelos Pydantic de Tarefa ---
# ====================================

# --- Modelo Base ---

class TaskBase(BaseModel):
    """
    Modelo base contendo os campos comuns e essenciais de uma tarefa.
    Serve como funda√ß√£o para outros modelos de tarefa mais espec√≠ficos.
    """
    title: str = Field(..., title="T√≠tulo da Tarefa", min_length=3, max_length=100)
    description: Optional[str] = Field(None, title="Descri√ß√£o Detalhada", max_length=500)
    importance: int = Field(..., ge=1, le=5, title="Import√¢ncia (1-5)")
    due_date: Optional[date] = Field(None, title="Data de Vencimento")
    status: TaskStatus = Field(default=TaskStatus.PENDING, title="Status da Tarefa")
    tags: Optional[List[str]] = Field(None, title="Etiquetas/Tags")
    project: Optional[str] = Field(None, title="Projeto Associado")

    # O campo owner_id (ID do propriet√°rio) geralmente √© adicionado em est√°gios posteriores
    # da l√≥gica da aplica√ß√£o (ex: inferido a partir do token de autentica√ß√£o do usu√°rio)
    # e n√£o √© esperado como parte do payload de cria√ß√£o base de uma tarefa pelo cliente.
    # owner_id: Optional[uuid.UUID] = Field(None, title="ID do Propriet√°rio da Tarefa")

    # Configura√ß√µes do modelo Pydantic.
    # json_schema_extra √© usado para prover exemplos para a documenta√ß√£o OpenAPI.
    model_config = {
        "json_schema_extra": {
            "examples": [
                {
                    "title": "Finalizar relat√≥rio mensal",
                    "description": "Compilar dados e escrever o relat√≥rio final.",
                    "importance": 4,
                    "due_date": "2024-08-15",
                    "status": "pendente",
                    "tags": ["relatorios", "financeiro"],
                    "project": "Relat√≥rios Q3"
                    # owner_id n√£o precisa estar no exemplo de cria√ß√£o base
                }
            ]
        }
    }

# --- Modelos para Opera√ß√µes ---

class TaskCreate(TaskBase):
    """
    Modelo utilizado para a cria√ß√£o de uma nova tarefa.
    Herda todos os campos de `TaskBase`, representando os dados
    necess√°rios que o cliente deve fornecer.
    """
    pass 

class TaskUpdate(BaseModel):
    """
    Modelo utilizado para atualizar uma tarefa existente.
    Todos os campos s√£o opcionais, permitindo que o cliente envie
    apenas os dados que deseja modificar (atualiza√ß√£o parcial).
    """
    title: Optional[str] = Field(None, title="T√≠tulo da Tarefa", min_length=3, max_length=100)
    description: Optional[str] = Field(None, title="Descri√ß√£o Detalhada", max_length=500)
    importance: Optional[int] = Field(None, ge=1, le=5, title="Import√¢ncia (1-5)")
    due_date: Optional[date] = Field(None, title="Data de Vencimento")
    status: Optional[TaskStatus] = Field(None, title="Status da Tarefa")
    tags: Optional[List[str]] = Field(None, title="Etiquetas/Tags")
    project: Optional[str] = Field(None, title="Projeto Associado")
    # Campo opcional para a pontua√ß√£o de prioridade.
    # Pode ser usado para ajustes manuais ou atualiza√ß√µes espec√≠ficas da prioridade.
    priority_score: Optional[float] = Field(None, title="Pontua√ß√£o de Prioridade (Ajust√°vel)")

    # Configura√ß√µes do modelo Pydantic, incluindo exemplos para OpenAPI.
    model_config = {
         "json_schema_extra": {
            "examples": [
                {
                    "title": "Revisar relat√≥rio mensal v2",
                    "status": TaskStatus.IN_PROGRESS,
                    "importance": 5
                }
            ]
        }
    }

# --- Modelos para Representa√ß√£o no Banco de Dados ---

class TaskInDBBase(TaskBase):
    """
    Modelo base para tarefas como s√£o armazenadas e recuperadas do banco de dados.
    Estende `TaskBase` adicionando campos gerenciados pelo sistema, como IDs
    e timestamps de cria√ß√£o/atualiza√ß√£o.
    """
    id: uuid.UUID = Field(..., title="ID √önico da Tarefa")
    owner_id: uuid.UUID = Field(..., title="ID do Propriet√°rio da Tarefa")
    # Data e hora (UTC) em que a tarefa foi criada, definida automaticamente.
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc), title="Data de Cria√ß√£o")
    # Data e hora (UTC) da √∫ltima atualiza√ß√£o da tarefa. Nulo se nunca atualizada.
    updated_at: Optional[datetime] = Field(None, title="Data da √öltima Atualiza√ß√£o")
    # Pontua√ß√£o de prioridade, potencialmente calculada pela l√≥gica de neg√≥cios da aplica√ß√£o.
    priority_score: Optional[float] = Field(None, title="Pontua√ß√£o de Prioridade Calculada")

    # Configura√ß√£o Pydantic para permitir que o modelo seja instanciado a partir
    # de atributos de objetos (√∫til para mapear dados de ORMs/ODMs).
    model_config = ConfigDict(from_attributes=True)

class Task(TaskInDBBase):
    """
    Modelo completo representando uma tarefa, incluindo todos os campos
    gerenciados pelo sistema e campos de entrada do usu√°rio.
    Este √© tipicamente o modelo utilizado para retornar dados de tarefas da API.
    """
    # Configura√ß√£o do modelo Pydantic.
    # from_attributes permite carregar dados de atributos de objetos.
    # json_schema_extra fornece um exemplo detalhado para a documenta√ß√£o OpenAPI.
    model_config = ConfigDict(
         from_attributes=True,
         json_schema_extra={
             "examples": [
                {
                    "id": "f47ac10b-58cc-4372-a567-0e02b2c3d479",
                    "owner_id": "a1b2c3d4-e5f6-7890-1234-567890abcdef",
                    "title": "Finalizar relat√≥rio mensal",
                    "description": "Compilar dados e escrever o relat√≥rio final.",
                    "importance": 4,
                    "due_date": "2024-08-15",
                    "status": "pendente",
                    "tags": ["relatorios", "financeiro"],
                    "project": "Relat√≥rios Q3",
                    "created_at": "2024-07-28T10:00:00Z",
                    "updated_at": None,
                    "priority_score": None
                }
            ]
         }
     )

================================================================================
Cap√≠tulo 12: app/models/token.py
================================================================================

# app/models/token.py
"""
Este m√≥dulo define os modelos Pydantic relacionados √† autentica√ß√£o por token,
especificamente para a estrutura do token JWT retornado ao cliente e
para o payload contido dentro do token JWT.
"""

# ========================
# --- Importa√ß√µes ---
# ========================
import uuid
from typing import Optional

from pydantic import BaseModel, Field

# ===============================
# --- Modelos Pydantic Token ---
# ===============================

class Token(BaseModel):
    """
    Modelo de resposta para um token de acesso JWT.
    Este √© o formato retornado ao cliente ap√≥s uma autentica√ß√£o bem-sucedida.
    """
    # O token JWT em si, que o cliente usar√° para autenticar requisi√ß√µes subsequentes.
    access_token: str = Field(..., title="Token de Acesso JWT")
    # Indica o tipo de token; por padr√£o e comumente, "bearer".
    token_type: str = Field(default="bearer", title="Tipo do Token")

class TokenPayload(BaseModel):
    """
    Modelo para os dados (payload/claims) contidos dentro de um token JWT.
    Representa as informa√ß√µes decodificadas do token.
    """
    # O "subject" (assunto) do token, tipicamente o ID √∫nico do usu√°rio.
    sub: uuid.UUID = Field(..., title="ID do Usu√°rio (Subject)")
    # O nome de usu√°rio associado ao token, pode ser usado para display ou identifica√ß√£o.
    username: str = Field(..., title="Nome de Usu√°rio")
    # Opcional: timestamp Unix indicando o tempo de expira√ß√£o do token (claim 'exp' padr√£o do JWT).
    # Geralmente gerenciado pela biblioteca de JWT durante a cria√ß√£o e valida√ß√£o do token.
    exp: Optional[int] = Field(None, title="Timestamp de Expira√ß√£o")

================================================================================
Cap√≠tulo 13: app/models/user.py
================================================================================

# app/models/user.py
"""
Este m√≥dulo define os modelos Pydantic para a entidade Usu√°rio (User).
Inclui modelos para cria√ß√£o, atualiza√ß√£o, e diferentes representa√ß√µes
de dados do usu√°rio, como a forma como s√£o armazenados no banco de dados
e como s√£o retornados nas respostas da API.
"""

# ========================
# --- Importa√ß√µes ---
# ========================
import uuid
from datetime import datetime, timezone
from typing import Optional

from pydantic import BaseModel, EmailStr, Field, ConfigDict

# ================================
# --- Modelos Pydantic de User ---
# ================================

# --- Modelo Base ---

class UserBase(BaseModel):
    """
    Modelo base contendo os atributos comuns a todas as varia√ß√µes de usu√°rio.
    Define os campos que podem ser esperados na maioria das representa√ß√µes de um usu√°rio.
    """
    # Endere√ßo de e-mail do usu√°rio, deve ser √∫nico.
    email: EmailStr = Field(..., title="Endere√ßo de E-mail", description="Deve ser um e-mail v√°lido e √∫nico.")
    # Nome de usu√°rio √∫nico, usado para login. Restrito a caracteres alfanum√©ricos e underscore.
    username: str = Field(
        ...,
        title="Nome de Usu√°rio",
        min_length=3,
        max_length=50,
        pattern="^[a-zA-Z0-9_]+$",
        description="Nome de usu√°rio √∫nico (letras, n√∫meros, underscore)."
    )
    # Nome completo opcional do usu√°rio.
    full_name: Optional[str] = Field(None, title="Nome Completo", max_length=100)
    # Indica se a conta do usu√°rio est√° desativada. Por padr√£o, usu√°rios s√£o criados como ativos (False).
    disabled: bool = Field(default=False, title="Status Desativado", description="Indica se o usu√°rio est√° desativado.")

# --- Modelo para Cria√ß√£o de Usu√°rio ---

class UserCreate(BaseModel):
    """
    Modelo para os dados necess√°rios ao criar um novo usu√°rio.
    Este √© o formato esperado no payload da API para registro de usu√°rios.
    """
    # E-mail para o novo usu√°rio.
    email: EmailStr = Field(..., title="Endere√ßo de E-mail")
    # Nome de usu√°rio para o novo usu√°rio.
    username: str = Field(..., title="Nome de Usu√°rio", min_length=3, max_length=50, pattern="^[a-zA-Z0-9_]+$")
    # Senha para o novo usu√°rio. Ser√° hasheada antes de ser armazenada.
    password: str = Field(..., title="Senha", min_length=8, description="Senha (ser√° hasheada antes de salvar).")
    # Nome completo opcional para o novo usu√°rio.
    full_name: Optional[str] = Field(None, title="Nome Completo", max_length=100)

    # Configura√ß√µes do modelo Pydantic, incluindo exemplos para OpenAPI.
    model_config = {
        "json_schema_extra": {
            "examples": [
                {
                    "email": "userTest@example.com",
                    "username": "userTest",
                    "password": "averysecurepassword",
                    "full_name": "User Test"
                }
            ]
        }
    }

# --- Modelo para Atualiza√ß√£o de Usu√°rio ---

class UserUpdate(BaseModel):
    """
    Modelo para os dados que podem ser atualizados em um usu√°rio existente.
    Todos os campos s√£o opcionais, permitindo atualiza√ß√µes parciais.
    """
    # Novo endere√ßo de e-mail (opcional).
    email: Optional[EmailStr] = Field(None, title="Endere√ßo de E-mail")
    # Nova senha (opcional). Deve atender aos requisitos de seguran√ßa.
    password: Optional[str] = Field(None, title="Nova Senha", min_length=8, description="Nova senha (se fornecida).")
    # Novo nome completo (opcional).
    full_name: Optional[str] = Field(None, title="Nome Completo", max_length=100)
    # Novo status de desativa√ß√£o (opcional).
    disabled: Optional[bool] = Field(None, title="Status Desativado")

    # Configura√ß√µes do modelo Pydantic, incluindo exemplos para OpenAPI.
    model_config = {
        "json_schema_extra": {
            "examples": [
                {
                    "full_name": "User Test Updated Name",
                    "email": "usertest.updated@example.com",
                    "disabled": False
                },
                {
                    "password": "mynewverysecurepassword123"
                }
            ]
        }
    }

# --- Modelos para Representa√ß√£o no Banco de Dados e Respostas da API ---

class UserInDBBase(UserBase):
    """
    Modelo base para usu√°rios como s√£o armazenados e recuperados do banco de dados.
    Inclui campos gerenciados pelo sistema como ID, senha hasheada e timestamps.
    """
    # ID √∫nico universal do usu√°rio, gerado no momento da cria√ß√£o.
    id: uuid.UUID = Field(..., title="ID √önico do Usu√°rio")
    # Senha do usu√°rio armazenada de forma segura (hasheada).
    hashed_password: str = Field(..., title="Senha Hasheada")
    # Data e hora (UTC) em que o usu√°rio foi criado, definida automaticamente.
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc), title="Data de Cria√ß√£o")
    # Data e hora (UTC) da √∫ltima atualiza√ß√£o do usu√°rio. Nulo se nunca atualizado.
    updated_at: Optional[datetime] = Field(None, title="Data da √öltima Atualiza√ß√£o")

    # Configura√ß√£o Pydantic para permitir que o modelo seja instanciado a partir
    # de atributos de objetos (√∫til para mapear dados de ORMs/ODMs).
    model_config = ConfigDict(from_attributes=True)

class User(UserBase):
    """
    Modelo de usu√°rio utilizado nas respostas da API.
    Projetado para expor dados seguros do usu√°rio, omitindo informa√ß√µes sens√≠veis como a senha hasheada.
    Herda os campos base e adiciona o ID e timestamps.
    """
    # ID √∫nico universal do usu√°rio.
    id: uuid.UUID = Field(..., title="ID √önico do Usu√°rio")
    # Data e hora (UTC) de cria√ß√£o do usu√°rio.
    created_at: datetime
    # Data e hora (UTC) da √∫ltima atualiza√ß√£o do usu√°rio.
    updated_at: Optional[datetime] = None 

    # Configura√ß√£o Pydantic.
    model_config = ConfigDict(from_attributes=True)

class UserInDB(UserInDBBase):
    """
    Representa√ß√£o completa de um usu√°rio como armazenado no banco de dados.
    Este modelo inclui todos os campos, inclusive a senha hasheada, e √© tipicamente
    usado internamente pela aplica√ß√£o (camada de CRUD) e n√£o exposto diretamente pela API.
    """
    # Atualmente, n√£o adiciona campos al√©m de UserInDBBase,
    # mas serve como um tipo expl√≠cito para clareza sem√¢ntica.
    pass

================================================================================
Cap√≠tulo 14: app/routers/auth.py
================================================================================

# app/routers/auth.py
"""
Este m√≥dulo define as rotas da API relacionadas √† autentica√ß√£o de usu√°rios,
incluindo registro de novos usu√°rios, login (obten√ß√£o de token de acesso JWT)
e recupera√ß√£o de informa√ß√µes do usu√°rio autenticado.
"""

# ========================
# --- Importa√ß√µes ---
# ========================
from typing import Annotated

from fastapi import APIRouter, Body, Depends, HTTPException, Response, status
from fastapi.security import OAuth2PasswordRequestForm 
from motor.motor_asyncio import AsyncIOMotorDatabase
from pymongo.errors import DuplicateKeyError

# --- M√≥dulos da Aplica√ß√£o ---
from app.core.dependencies import CurrentUser
from app.core.security import create_access_token, verify_password
from app.db import user_crud
from app.db.mongodb_utils import get_database
from app.models.token import Token
from app.models.user import User, UserCreate, UserUpdate

# ================================
# --- Configura√ß√£o do Router ---
# ================================
router = APIRouter(
    tags=["Authentication"], 
)

# =========================================
# --- Depend√™ncias Espec√≠ficas do Roteador ---
# =========================================

DbDep = Annotated[AsyncIOMotorDatabase, Depends(get_database)]

# =====================
# --- Rotas da API ---
# =====================

@router.post(
    "/register",
    response_model=User, 
    status_code=status.HTTP_201_CREATED, 
    summary="Registra um novo usu√°rio no sistema",
    response_description="Retorna os dados do usu√°rio rec√©m-registrado (sem a senha).",
)
async def register_user(
    db: DbDep,
    user_in: Annotated[UserCreate, Body(description="Dados do novo usu√°rio para registro.")]
):
    """
    Endpoint para registrar um novo usu√°rio.

    Opera√ß√µes realizadas:
    1. Verifica se j√° existe um usu√°rio com o mesmo `username`.
    2. Verifica se j√° existe um usu√°rio com o mesmo `email`.
    3. Se n√£o houver conflitos, tenta criar o usu√°rio no banco de dados.
       A senha √© hasheada pela fun√ß√£o `user_crud.create_user`.
    4. Retorna o objeto `User` (sem a senha) em caso de sucesso.

    Exce√ß√µes poss√≠veis:
    - `HTTP 409 Conflict`: Se o `username` ou `email` j√° estiverem em uso.
    - `HTTP 500 Internal Server Error`: Se ocorrer um erro inesperado durante a cria√ß√£o.
    """
    existing_user_by_username = await user_crud.get_user_by_username(db, user_in.username)
    if existing_user_by_username:
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=f"O nome de usu√°rio '{user_in.username}' j√° existe.",
        )

    existing_user_by_email = await user_crud.get_user_by_email(db, user_in.email)
    if existing_user_by_email:
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=f"O endere√ßo de e-mail '{user_in.email}' j√° registrado.",
        )

    try:
        created_user_db_obj = await user_crud.create_user(db=db, user_in=user_in)
        if created_user_db_obj is None:
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="N√£o foi poss√≠vel criar o usu√°rio devido a um erro interno no servidor."
            )
        return User.model_validate(created_user_db_obj)
    except DuplicateKeyError:
        raise HTTPException(# pragma: no cover
            status_code=status.HTTP_409_CONFLICT,# pragma: no cover
            detail="Conflito: nome de usu√°rio ou e-mail j√° existe (detectado pelo banco de dados).",# pragma: no cover
        )
    except Exception: 
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Ocorreu um erro inesperado durante o processo de registro.",
        )


@router.post(
    "/login/access-token",
    response_model=Token, 
    summary="Autentica o usu√°rio e obt√©m um token de acesso JWT",
    description=(
        "Endpoint de login padr√£o que utiliza OAuth2PasswordRequestForm. "
        "O cliente deve enviar `username` e `password` como form data."
    ),
    response_description="Token de acesso JWT e tipo do token ('bearer')."
)
async def login_for_access_token(
    db: DbDep,
    form_data: Annotated[OAuth2PasswordRequestForm, Depends()]
):
    """
    Autentica um usu√°rio e retorna um token de acesso.

    Passos da autentica√ß√£o:
    1. Busca o usu√°rio pelo `username` fornecido.
    2. Verifica se o usu√°rio existe e se a senha fornecida corresponde √† senha hasheada armazenada.
    3. Verifica se a conta do usu√°rio n√£o est√° desativada (`disabled`).
    4. Se todas as verifica√ß√µes passarem, um novo token de acesso JWT √© gerado e retornado.

    Exce√ß√µes poss√≠veis:
    - `HTTP 401 Unauthorized`: Se o usu√°rio n√£o for encontrado ou a senha estiver incorreta.
    - `HTTP 400 Bad Request`: Se a conta do usu√°rio estiver desativada.
    """
    user = await user_crud.get_user_by_username(db, form_data.username)

    if not user or not verify_password(form_data.password, user.hashed_password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Nome de usu√°rio ou senha incorretos.",
            headers={"WWW-Authenticate": "Bearer"}, 
        )

    if user.disabled:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST, 
            detail="A conta do usu√°rio est√° inativa."
        )

    access_token = create_access_token(
        subject=user.id, 
        username=user.username
    )

    return Token(access_token=access_token, token_type="bearer")

@router.get(
    "/users/me",
    response_model=User, 
    summary="Obt√©m dados do usu√°rio atualmente autenticado",
    description=(
        "Recupera e retorna os dados do usu√°rio que est√° autenticado "
        "atrav√©s do token JWT fornecido no cabe√ßalho de Autoriza√ß√£o (Bearer Token)."
    ),
    response_description="Dados do usu√°rio autenticado (sem a senha).",
)
async def read_users_me(
    current_user: CurrentUser
) -> User:
    """
    Retorna as informa√ß√µes do usu√°rio autenticado.

    A depend√™ncia `CurrentUser` √© respons√°vel por:
    - Extrair o token JWT do cabe√ßalho de autoriza√ß√£o.
    - Validar o token.
    - Buscar o usu√°rio correspondente no banco de dados.
    - Levantar uma exce√ß√£o `HTTP 401 Unauthorized` se o token for inv√°lido ou ausente.

    Este endpoint simplesmente retorna o usu√°rio fornecido pela depend√™ncia.
    """
    return current_user

@router.put(
    "/users/me",
    response_model=User,
    summary="Atualiza os dados do usu√°rio atualmente autenticado",
    description=(
        "Permite que o usu√°rio autenticado atualize seus pr√≥prios dados, "
        "como e-mail, nome completo ou senha."
    ),
    response_description="Dados do usu√°rio atualizados (sem a senha).",
)
async def update_current_user(
    db: DbDep,
    user_update_payload: Annotated[UserUpdate, Body(description="Campos do usu√°rio a serem atualizados.")],
    current_user: CurrentUser 
):
    """
    Permite ao usu√°rio autenticado atualizar suas pr√≥prias informa√ß√µes.

    Campos que podem ser atualizados incluem: e-mail, senha, nome completo e status de desativa√ß√£o.
    Se o e-mail for atualizado, verifica-se a unicidade.
    A nova senha, se fornecida, ser√° hasheada.

    Exce√ß√µes poss√≠veis:
    - `HTTP 401 Unauthorized`: Se o token for inv√°lido.
    - `HTTP 404 Not Found`: Se, por algum motivo, o usu√°rio n√£o for encontrado para atualiza√ß√£o.
    - `HTTP 409 Conflict`: Se a tentativa de atualizar o e-mail resultar em um e-mail j√° existente.
    - `HTTP 500 Internal Server Error`: Para outros erros inesperados.
    """
    try:
        updated_user_db_obj = await user_crud.update_user(
            db=db,
            user_id=current_user.id,
            user_update=user_update_payload
        )

        if updated_user_db_obj is None:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND, 
                detail="N√£o foi poss√≠vel atualizar o usu√°rio. Usu√°rio n√£o encontrado ou erro interno."
            )
        return User.model_validate(updated_user_db_obj)
    except DuplicateKeyError:
        email_em_uso = user_update_payload.email if user_update_payload.email else "N/A"
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=f"N√£o foi poss√≠vel atualizar: o e-mail '{email_em_uso}' j√° est√° em uso por outra conta.",
        )
    except Exception:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Ocorreu um erro inesperado durante a atualiza√ß√£o do usu√°rio.",
        )


@router.delete(
    "/users/me",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Deleta a conta do usu√°rio atualmente autenticado",
    description="Permite que o usu√°rio autenticado delete sua pr√≥pria conta permanentemente.",
    response_description="Nenhum conte√∫do √© retornado em caso de sucesso.",
)
async def delete_current_user(
    db: DbDep,
    current_user: CurrentUser 
):
    """
    Permite ao usu√°rio autenticado deletar sua pr√≥pria conta.

    Esta opera√ß√£o √© permanente e n√£o pode ser desfeita.
    Retorna HTTP 204 (No Content) em caso de sucesso.

    Exce√ß√µes poss√≠veis:
    - `HTTP 401 Unauthorized`: Se o token for inv√°lido.
    - `HTTP 404 Not Found`: Se o usu√°rio n√£o for encontrado para dele√ß√£o (improv√°vel).
    - `HTTP 500 Internal Server Error`: Para outros erros inesperados.
    """
    try:
        deleted_successfully = await user_crud.delete_user(
            db=db,
            user_id=current_user.id
        )
        if not deleted_successfully:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND, 
                detail="N√£o foi poss√≠vel deletar o usu√°rio. Usu√°rio n√£o encontrado ou erro interno."
            )
        return Response(status_code=status.HTTP_204_NO_CONTENT)

    except Exception:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Ocorreu um erro inesperado durante a dele√ß√£o do usu√°rio.",
        )

================================================================================
Cap√≠tulo 15: app/routers/tasks.py
================================================================================

# app/routers/tasks.py
"""
Este m√≥dulo define as rotas da API para o gerenciamento de Tarefas (Tasks).
Inclui opera√ß√µes CRUD (Criar, Ler, Atualizar, Deletar) para tarefas,
al√©m de listagem com filtros, ordena√ß√£o e pagina√ß√£o.
As rotas s√£o protegidas e associadas ao usu√°rio autenticado.
Utiliza BackgroundTasks para opera√ß√µes que n√£o precisam bloquear a resposta,
como o envio de webhooks e notifica√ß√µes por e-mail.
"""

# ========================
# --- Importa√ß√µes ---
# ========================

# --- Bibliotecas Padr√£o/Terceiros ---
import logging
import uuid
from datetime import date, datetime, timezone
from typing import Annotated, List, Optional

# --- FastAPI ---
from fastapi import (APIRouter, BackgroundTasks, Body, Depends, HTTPException, Path,
                   Query, Response, status)
from motor.motor_asyncio import AsyncIOMotorDatabase
from pydantic import ValidationError

# --- M√≥dulos da Aplica√ß√£o ---
from app.core.dependencies import CurrentUser
from app.core.email import send_urgent_task_notification
from app.core.utils import (calculate_priority_score, is_task_urgent,
                            send_webhook_notification)
from app.db import task_crud
from app.db.mongodb_utils import get_database
from app.models.task import Task, TaskCreate, TaskStatus, TaskUpdate

# =====================================
# --- Configura√ß√µes e Constantes ---
# =====================================
logger = logging.getLogger(__name__)

# ================================
# --- Configura√ß√£o do Router ---
# ================================
router = APIRouter(
    prefix="/tasks",
    tags=["Tasks"],  
    responses={
        status.HTTP_404_NOT_FOUND: {"description": "Recurso (tarefa) n√£o encontrado."},
        status.HTTP_401_UNAUTHORIZED: {"description": "N√£o autorizado (Token JWT inv√°lido, ausente ou expirado)."},
        status.HTTP_403_FORBIDDEN: {"description": "Proibido (Usu√°rio autenticado n√£o tem permiss√£o para acessar/modificar este recurso espec√≠fico)."}
    },
)

# =========================================
# --- Depend√™ncias Espec√≠ficas do Roteador ---
# =========================================
DbDep = Annotated[AsyncIOMotorDatabase, Depends(get_database)]

# ========================
# --- ROTAS DE TAREFAS ---
# ========================

@router.post(
    "/",
    response_model=Task, 
    status_code=status.HTTP_201_CREATED, 
    summary="Cria uma nova tarefa para o usu√°rio autenticado",
    description=(
        "Cria uma nova tarefa associada ao usu√°rio atualmente autenticado. "
        "A pontua√ß√£o de prioridade √© calculada automaticamente com base na import√¢ncia e data de entrega. "
        "O ID do propriet√°rio (`owner_id`) e os timestamps (`created_at`) s√£o definidos pelo servidor."
    ),
    response_description="A tarefa rec√©m-criada, incluindo todos os seus detalhes e campos gerados.",
)
async def create_task(
    task_in: Annotated[TaskCreate, Body(description="Dados da nova tarefa a ser criada.")],
    db: DbDep,
    current_user: CurrentUser, 
    background_tasks: BackgroundTasks 
):
    """
    Endpoint para criar uma nova tarefa.

    Fluxo de execu√ß√£o:
    1. Extrai os dados da tarefa do corpo da requisi√ß√£o (`task_in`).
    2. Calcula a `priority_score` com base na import√¢ncia e data de entrega.
    3. Constr√≥i o objeto completo da tarefa (`Task`), incluindo ID, `owner_id` (do `current_user`),
       `created_at` e a `priority_score` calculada. Valida este objeto com Pydantic.
    4. Persiste a tarefa no banco de dados usando `task_crud.create_task`.
    5. Se a cria√ß√£o for bem-sucedida, agenda tarefas em segundo plano para:
        - Enviar uma notifica√ß√£o de webhook (evento `task.created`).
        - Se a tarefa for urgente, enviar uma notifica√ß√£o por e-mail para o usu√°rio.
    6. Retorna a tarefa criada.

    Levanta `HTTPException` em caso de erro de valida√ß√£o, falha na persist√™ncia ou outros problemas.
    """
    task_data_from_request = task_in.model_dump(exclude_unset=True)

    priority_score_calculated = calculate_priority_score(
        importance=task_in.importance,
        due_date=task_in.due_date
    )
    logger.info(f"Prioridade calculada para nova tarefa (T√≠tulo: '{task_in.title}'): {priority_score_calculated}")

    try:
        task_db_obj_to_create = Task(
            id=uuid.uuid4(), 
            owner_id=current_user.id, 
            created_at=datetime.now(timezone.utc), 
            priority_score=priority_score_calculated,
            **task_data_from_request
        )
    except ValidationError as e:
        logger.error(f"Erro de valida√ß√£o Pydantic ao montar objeto Task para usu√°rio {current_user.id}: {e}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=f"Erro interno na valida√ß√£o dos dados da tarefa: {e.errors()}" 
        )

    created_task_from_db = await task_crud.create_task(db=db, task_db=task_db_obj_to_create)
    if created_task_from_db is None:
        raise HTTPException( # pragma: no cover
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,# pragma: no cover
            detail="Falha ao salvar a tarefa no banco de dados."# pragma: no cover
        ) 
    logger.info(f"Tarefa {created_task_from_db.id} criada com sucesso para usu√°rio {current_user.id}.")

    task_dict_for_webhook = created_task_from_db.model_dump(mode="json")
    background_tasks.add_task(
         send_webhook_notification,
         event_type="task.created",
         task_data=task_dict_for_webhook
    )
    logger.debug(f"Tarefa de webhook 'task.created' para {created_task_from_db.id} adicionada ao background.")

    if is_task_urgent(created_task_from_db):
        if current_user.email and current_user.full_name:
            logger.info(f"Tarefa {created_task_from_db.id} √© urgente. Agendando e-mail de notifica√ß√£o para {current_user.email}.")
            background_tasks.add_task(
                send_urgent_task_notification,
                user_email=current_user.email,
                user_name=current_user.full_name,
                task_title=created_task_from_db.title,
                task_id=str(created_task_from_db.id),
                task_due_date=str(created_task_from_db.due_date) if created_task_from_db.due_date else None,
                priority_score=created_task_from_db.priority_score or 0.0
            )
        else:
             logger.warning(f"Usu√°rio {current_user.id} (username: {current_user.username}) n√£o possui e-mail ou nome completo configurado. "
                            f"Notifica√ß√£o por e-mail para tarefa urgente {created_task_from_db.id} n√£o ser√° enviada.")

    return created_task_from_db

@router.get(
    "/",
    response_model=List[Task], 
    summary="Lista as tarefas do usu√°rio autenticado com filtros e ordena√ß√£o",
    description=(
        "Recupera uma lista de tarefas pertencentes exclusivamente ao usu√°rio autenticado.\n"
        "Suporta m√∫ltiplos filtros combinados (status, data de entrega at√©, projeto, tags).\n"
        "Permite ordena√ß√£o por: `priority_score`, `due_date`, `created_at`, `importance`.\n"
        "A pagina√ß√£o √© controlada por `limit` e `skip`."
    ),
    response_description="Uma lista (potencialmente vazia) das tarefas do usu√°rio, filtradas e ordenadas conforme os par√¢metros.",
)
async def list_tasks(
    db: DbDep,
    current_user: CurrentUser,
    status_filter: Annotated[Optional[TaskStatus], Query(alias="status", description="Filtrar tarefas por status espec√≠fico.")] = None,
    due_before: Annotated[Optional[date], Query(description="Filtrar tarefas com data de entrega at√© (inclusive) esta data.")] = None,
    project_filter: Annotated[Optional[str], Query(alias="project", min_length=1, description="Filtrar tarefas por nome exato do projeto.")] = None,
    tags_filter: Annotated[Optional[List[str]], Query(alias="tag", min_length=1, description="Filtrar tarefas que contenham TODAS as tags fornecidas.")] = None,
    sort_by: Annotated[Optional[str], Query(enum=["priority_score", "due_date", "created_at", "importance"], description="Campo para ordena√ß√£o das tarefas.")] = None,
    sort_order: Annotated[str, Query(enum=["asc", "desc"], description="Ordem da ordena√ß√£o (ascendente ou descendente).")] = "desc", # Padr√£o para descendente.
    limit: Annotated[int, Query(ge=1, le=1000, description="N√∫mero m√°ximo de tarefas a retornar.")] = 100,
    skip: Annotated[int, Query(ge=0, description="N√∫mero de tarefas a pular (para pagina√ß√£o).")] = 0,
):
    """
    Endpoint para listar tarefas do usu√°rio autenticado.

    A busca √© delegada para a fun√ß√£o `task_crud.get_tasks_by_owner`, que lida com a
    constru√ß√£o da query no banco de dados com base nos filtros, ordena√ß√£o e pagina√ß√£o fornecidos.
    Todos os filtros e par√¢metros s√£o opcionais.
    """
    logger.info(f"Listando tarefas para usu√°rio {current_user.id} com filtros: status='{status_filter}', "
                f"due_before='{due_before}', project='{project_filter}', tags='{tags_filter}', "
                f"sort_by='{sort_by}', sort_order='{sort_order}', limit={limit}, skip={skip}")

    tasks = await task_crud.get_tasks_by_owner(
        db=db,
        owner_id=current_user.id,
        status_filter=status_filter,
        due_before=due_before,
        project_filter=project_filter,
        tags_filter=tags_filter,
        sort_by=sort_by,
        sort_order=sort_order, 
        limit=limit,
        skip=skip
    )
    logger.debug(f"Encontradas {len(tasks)} tarefas para usu√°rio {current_user.id} com os filtros aplicados.")
    return tasks

@router.get(
    "/{task_id}",
    response_model=Task,
    summary="Busca uma tarefa espec√≠fica pelo seu ID",
    description="Recupera os detalhes completos de uma tarefa espec√≠fica, desde que ela perten√ßa ao usu√°rio autenticado.",
    response_description="Os detalhes completos da tarefa encontrada.",
    responses={status.HTTP_403_FORBIDDEN: {"description": "Acesso negado: esta tarefa n√£o pertence a voc√™ ou n√£o existe para voc√™."}}
)
async def get_task(
    task_id: Annotated[uuid.UUID, Path(description="ID da tarefa a ser recuperada.")],
    db: DbDep,
    current_user: CurrentUser
):
    """
    Endpoint para buscar uma √∫nica tarefa pelo seu ID (UUID).

    A fun√ß√£o `task_crud.get_task_by_id` √© respons√°vel por verificar se a tarefa
    com o `task_id` fornecido pertence ao `current_user.id`.
    Se a tarefa n√£o for encontrada ou n√£o pertencer ao usu√°rio, retorna HTTP 404.
    """
    logger.info(f"Buscando tarefa {task_id} para usu√°rio {current_user.id}.")
    task = await task_crud.get_task_by_id(db=db, task_id=task_id, owner_id=current_user.id)

    if task is None:
        logger.warning(f"Tarefa {task_id} n√£o encontrada ou acesso negado para usu√°rio {current_user.id}.")
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Tarefa com ID '{task_id}' n√£o encontrada ou voc√™ n√£o tem permiss√£o para acess√°-la."
        )
    logger.debug(f"Tarefa {task_id} encontrada para usu√°rio {current_user.id}: {task.title}")
    return task

@router.put(
    "/{task_id}",
    response_model=Task,
    summary="Atualiza uma tarefa existente do usu√°rio autenticado",
    description=(
        "Atualiza campos de uma tarefa existente, desde que ela perten√ßa ao usu√°rio autenticado.\n"
        "A pontua√ß√£o de prioridade (`priority_score`) √© recalculada automaticamente se `importance` ou `due_date` forem modificados.\n"
        "O campo `updated_at` √© atualizado automaticamente."
    ),
    response_description="Os detalhes completos da tarefa ap√≥s a atualiza√ß√£o.",
    responses={status.HTTP_403_FORBIDDEN: {"description": "Acesso negado: esta tarefa n√£o pertence a voc√™."}}
)
async def update_task(
    task_id: Annotated[uuid.UUID, Path(description="ID da tarefa a ser atualizada.")],
    task_update_payload: Annotated[TaskUpdate, Body(description="Campos da tarefa a serem atualizados.")],
    db: DbDep,
    current_user: CurrentUser,
    background_tasks: BackgroundTasks
):
    """
    Endpoint para atualizar campos espec√≠ficos de uma tarefa existente.

    Fluxo de execu√ß√£o:
    1. Busca a tarefa existente para garantir que ela pertence ao usu√°rio e para obter valores atuais
       (necess√°rios caso `importance` ou `due_date` n√£o estejam no payload de atualiza√ß√£o,
       mas a prioridade precise ser recalculada).
    2. Recebe os dados de atualiza√ß√£o validados pelo modelo `TaskUpdate`.
    3. Se nenhum dado for fornecido para atualiza√ß√£o, retorna um erro HTTP 400.
    4. Prepara o dicion√°rio `update_data_for_db` apenas com os campos enviados pelo cliente.
    5. Verifica se `importance` ou `due_date` foram alterados. Se sim, recalcula a `priority_score`.
    6. Chama `task_crud.update_task` para persistir as altera√ß√µes. O CRUD se encarrega de definir `updated_at`.
    7. Agenda uma tarefa em segundo plano para enviar uma notifica√ß√£o de webhook (evento `task.updated`).
    8. Retorna a tarefa completamente atualizada.

    Levanta `HTTPException` se a tarefa n√£o for encontrada, se nenhum dado for enviado, ou em caso de outros erros.
    """
    logger.info(f"Iniciando atualiza√ß√£o da tarefa {task_id} para usu√°rio {current_user.id} com payload: {task_update_payload.model_dump(exclude_unset=True)}")
    existing_task = await task_crud.get_task_by_id(db=db, task_id=task_id, owner_id=current_user.id)
    if not existing_task:
        logger.warning(f"Tentativa de atualizar tarefa {task_id} que n√£o foi encontrada para usu√°rio {current_user.id}.")
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Tarefa com ID '{task_id}' n√£o encontrada ou voc√™ n√£o tem permiss√£o para modific√°-la."
        )

    update_data_from_request = task_update_payload.model_dump(exclude_unset=True)

    if not update_data_from_request:
        logger.info(f"Nenhum campo fornecido para atualiza√ß√£o da tarefa {task_id}.")
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Nenhum campo v√°lido fornecido para atualiza√ß√£o."
        )

    new_importance = update_data_from_request.get("importance", existing_task.importance)

    if "due_date" in update_data_from_request:
        new_due_date = update_data_from_request.get("due_date")
    else:
        new_due_date = existing_task.due_date

    should_recalculate_priority = False
    if "importance" in update_data_from_request and update_data_from_request["importance"] != existing_task.importance:
        should_recalculate_priority = True
    if "due_date" in update_data_from_request and new_due_date != existing_task.due_date: 
        should_recalculate_priority = True
    if "priority_score" in update_data_from_request:
        should_recalculate_priority = False # pragma: no cover

    update_data_for_db = update_data_from_request.copy()

    if should_recalculate_priority:
        new_priority_score = calculate_priority_score(
            importance=new_importance, 
            due_date=new_due_date    
        )
        update_data_for_db["priority_score"] = new_priority_score
        logger.info(f"Prioridade para tarefa {task_id} recalculada para: {new_priority_score}.")

    updated_task_from_db = await task_crud.update_task(
        db=db,
        task_id=task_id,
        owner_id=current_user.id,
        update_data=update_data_for_db
    )

    if updated_task_from_db is None:
        logger.error(f"Falha ao atualizar tarefa {task_id} no DB para usu√°rio {current_user.id}. CRUD retornou None.")
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"N√£o foi poss√≠vel atualizar a tarefa com ID '{task_id}'. "
                   "Pode ter sido deletada ou ocorreu um erro interno."
        )
    logger.info(f"Tarefa {updated_task_from_db.id} atualizada com sucesso para usu√°rio {current_user.id}.")

    task_dict_for_webhook = updated_task_from_db.model_dump(mode="json")
    background_tasks.add_task(
        send_webhook_notification,
        event_type="task.updated",
        task_data=task_dict_for_webhook
    )
    logger.debug(f"Tarefa de webhook 'task.updated' para {updated_task_from_db.id} adicionada ao background.")

    return updated_task_from_db

@router.delete(
    "/{task_id}",
    status_code=status.HTTP_204_NO_CONTENT, 
    summary="Deleta uma tarefa do usu√°rio autenticado",
    description="Remove permanentemente uma tarefa espec√≠fica do banco de dados, desde que ela perten√ßa ao usu√°rio autenticado.",
    responses={
        status.HTTP_204_NO_CONTENT: {"description": "Tarefa deletada com sucesso (sem corpo de resposta)."}
    }
)
async def delete_task(
    task_id: Annotated[uuid.UUID, Path(description="ID da tarefa a ser deletada.")],
    db: DbDep,
    current_user: CurrentUser
):
    """
    Endpoint para deletar uma tarefa espec√≠fica.

    Verifica se a tarefa pertence ao usu√°rio autenticado e, se sim, a remove
    permanentemente do banco de dados usando `task_crud.delete_task`.
    Retorna HTTP 204 (No Content) em caso de sucesso.

    Levanta `HTTPException` com status 404 se a tarefa n√£o for encontrada ou
    n√£o pertencer ao usu√°rio.
    """
    logger.info(f"Iniciando dele√ß√£o da tarefa {task_id} para usu√°rio {current_user.id}.")
    deleted_successfully = await task_crud.delete_task(
        db=db,
        task_id=task_id,
        owner_id=current_user.id
    )

    if not deleted_successfully:
        logger.warning(f"Falha ao deletar tarefa {task_id}. N√£o encontrada ou n√£o pertence ao usu√°rio {current_user.id}.")
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Tarefa com ID '{task_id}' n√£o encontrada ou voc√™ n√£o tem permiss√£o para delet√°-la."
        )

    logger.info(f"Tarefa {task_id} deletada com sucesso para usu√°rio {current_user.id}.")
    return Response(status_code=status.HTTP_204_NO_CONTENT)

================================================================================
Cap√≠tulo 16: app/worker.py
================================================================================

# app/worker.py
"""
Este m√≥dulo define um worker ARQ (Asynchronous Runtimes for Queueing) para executar
tarefas em segundo plano e agendadas.

Ele inclui:
- Uma tarefa peri√≥dica (`check_and_notify_urgent_tasks`) para verificar tarefas
  que se tornaram urgentes e notificar os usu√°rios correspondentes por e-mail.
- Fun√ß√µes de ciclo de vida (`startup` e `shutdown`) para gerenciar a conex√£o
  com o banco de dados MongoDB para o worker.
- A classe `WorkerSettings` que configura o comportamento do worker ARQ, incluindo
  os `cron_jobs` e as configura√ß√µes de conex√£o com o Redis (usado pelo ARQ como broker).
"""

# ========================
# --- Importa√ß√µes ---
# ========================

# --- Bibliotecas Padr√£o/Terceiros ---
import asyncio
import logging
from datetime import date, datetime, timezone 
from typing import Any, Dict, Optional

import arq.cron
from arq.connections import RedisSettings
from motor.motor_asyncio import AsyncIOMotorDatabase

# --- M√≥dulos da Aplica√ß√£o ---
from app.core.config import settings
from app.core.email import send_urgent_task_notification
from app.db import task_crud, user_crud
from app.db.mongodb_utils import (close_mongo_connection, connect_to_mongo) 
from app.models.task import Task, TaskStatus 

# =====================================
# --- Configura√ß√µes e Constantes ---
# =====================================
logger = logging.getLogger("arq.worker") 

# ==================================
# --- Fun√ß√£o de Tarefa Peri√≥dica ---
# ==================================
async def check_and_notify_urgent_tasks(ctx: Dict[str, Any]):
    """
    Tarefa peri√≥dica ARQ que varre o banco de dados em busca de tarefas
    consideradas urgentes e notifica os respectivos usu√°rios por e-mail.

    Crit√©rios de Urg√™ncia:
    - Tarefas n√£o conclu√≠das ou canceladas.
    - E que atendam a pelo menos um dos seguintes:
        - `priority_score` acima de um limiar definido (`EMAIL_URGENCY_THRESHOLD`).
        - `due_date` √© hoje ou j√° passou.

    Args:
        ctx: Dicion√°rio de contexto fornecido pelo worker ARQ. Espera-se que contenha
             uma inst√¢ncia de conex√£o com o banco de dados (`db`) injetada pela fun√ß√£o `startup`.
    """
    logger.info("Executando job: Verifica√ß√£o e notifica√ß√£o de tarefas urgentes...")
    db: Optional[AsyncIOMotorDatabase] = ctx.get("db")

    if db is None:
        logger.error("Conex√£o com o banco de dados n√£o dispon√≠vel no contexto ARQ.")
        return
    tasks_collection = db[task_crud.TASKS_COLLECTION]
    users_collection = db[user_crud.USERS_COLLECTION] 
    today_start_utc = datetime.combine(date.today(), datetime.min.time(), tzinfo=timezone.utc)
    query_urgent_tasks = {
        "status": {"$nin": [TaskStatus.COMPLETED.value, TaskStatus.CANCELLED.value]},
        "$or": [
            {"priority_score": {"$gt": settings.EMAIL_URGENCY_THRESHOLD}},
            {"due_date": {"$lte": today_start_utc}} 
        ]
    }
    logger.debug(f"Query MongoDB para tarefas urgentes: {query_urgent_tasks}")

    urgent_tasks_cursor = tasks_collection.find(query_urgent_tasks)
    notifications_sent_count = 0
    async for task_dict in urgent_tasks_cursor:
        task_dict.pop('_id', None) 
        try:
            task = Task.model_validate(task_dict)
            logger.debug(f"Processando tarefa urgente ID: {task.id}, T√≠tulo: {task.title}")
            user = await user_crud.get_user_by_id(db, task.owner_id)
            if user and user.email and user.full_name and not user.disabled:
                logger.info(f"Tarefa urgente ID '{task.id}' (T√≠tulo: '{task.title}') encontrada. "
                            f"Notificando usu√°rio: {user.username} (E-mail: {user.email}).")
                await send_urgent_task_notification(
                    user_email=user.email,
                    user_name=user.full_name,
                    task_title=task.title,
                    task_id=str(task.id),
                    task_due_date=str(task.due_date) if task.due_date else None, 
                    priority_score=task.priority_score or 0.0 
                )
                notifications_sent_count += 1
            elif not user:
                logger.warning(f"Usu√°rio com ID '{task.owner_id}' associado √† tarefa urgente '{task.id}' n√£o foi encontrado no banco de dados.")
            elif user and user.disabled:
                logger.info(f"Usu√°rio '{user.username}' (ID: {task.owner_id}) associado √† tarefa urgente '{task.id}' est√° desabilitado. "
                            "Notifica√ß√£o n√£o enviada.")
            else:
                logger.warning(f"Usu√°rio '{user.username}' (ID: {task.owner_id}) associado √† tarefa urgente '{task.id}' "
                               "n√£o possui e-mail ou nome completo configurado. Notifica√ß√£o n√£o enviada.")
        except Exception as e:
            logger.exception(f"Erro ao processar tarefa urgente (ID no dict: {task_dict.get('id', 'N/A')}): {e}")
            continue 
    logger.info(f"Verifica√ß√£o de tarefas urgentes conclu√≠da. Total de {notifications_sent_count} notifica√ß√µes enviadas.")

# ==========================================
# --- Fun√ß√µes de Ciclo de Vida do Worker ---
# ==========================================
async def startup(ctx: Dict[str, Any]):
    """
    Fun√ß√£o executada quando o worker ARQ √© iniciado.
    Respons√°vel por estabelecer conex√µes com recursos externos, como o banco de dados.

    Args:
        ctx: Dicion√°rio de contexto do ARQ, onde podemos armazenar recursos
             (como a conex√£o DB) para serem usados pelas tarefas do worker.
    """
    logger.info("Worker ARQ: Iniciando rotinas de startup...")
    db_connection_instance = await connect_to_mongo()
    if db_connection_instance is not None:
        ctx["db"] = db_connection_instance
        logger.info("Worker ARQ: Conex√£o com MongoDB estabelecida e armazenada no contexto.")
    else:
        logger.error("Worker ARQ: Falha cr√≠tica ao conectar ao MongoDB durante o startup. "
                     "A conex√£o n√£o estar√° dispon√≠vel para as tarefas.")
        ctx["db"] = None

async def shutdown(ctx: Dict[str, Any]):
    """
    Fun√ß√£o executada quando o worker ARQ est√° sendo encerrado.
    Respons√°vel por liberar recursos, como fechar a conex√£o com o banco de dados.

    Args:
        ctx: Dicion√°rio de contexto do ARQ.
    """
    logger.info("Worker ARQ: Iniciando rotinas de shutdown...")
    if ctx.get("db") is not None: 
        await close_mongo_connection()
        logger.info("Worker ARQ: Conex√£o com MongoDB fechada.")
    else:
        logger.info("Worker ARQ: Nenhuma conex√£o com MongoDB para fechar (n√£o estava dispon√≠vel ou j√° fechada).")

# =======================================
# --- Configura√ß√µes do Worker ARQ ---
# =======================================
class WorkerSettings:
    """
    Define as configura√ß√µes para o worker ARQ.
    Isso inclui fun√ß√µes de ciclo de vida (startup/shutdown),
    tarefas agendadas (`cron_jobs`) e configura√ß√µes de conex√£o com o Redis.
    """
    on_startup = startup
    on_shutdown = shutdown
    cron_jobs = [
        arq.cron(check_and_notify_urgent_tasks, minute={*range(0, 60, 15)}, run_at_startup=False), 
        arq.cron(check_and_notify_urgent_tasks, hour=8, minute=0, run_at_startup=False) 
    ]
    logger.info(f"Cron jobs configurados: {len(cron_jobs)} jobs definidos.")
    if settings.REDIS_URL:
        try:
            host = settings.REDIS_URL.host or 'localhost'
            port = int(settings.REDIS_URL.port) if settings.REDIS_URL.port else 6379
            db_num_from_path = int(settings.REDIS_URL.path.strip('/')) if settings.REDIS_URL.path and settings.REDIS_URL.path != '/' else 0
            password = settings.REDIS_URL.password

            redis_settings: RedisSettings = RedisSettings(
                host=host,
                port=port,
                database=db_num_from_path,
                password=password,
            )
            logger.info(f"RedisSettings configuradas para ARQ: host={host}, port={port}, db={db_num_from_path}")
        except Exception as e:# pragma: no cover
            logger.exception(f"Erro cr√≠tico ao configurar RedisSettings a partir da URL: '{settings.REDIS_URL}'. Erro: {e}")
            raise ValueError(f"Erro ao processar REDIS_URL para ARQ: {e}")# pragma: no cover
    else:
        logger.error("Configura√ß√£o cr√≠tica ausente: REDIS_URL n√£o est√° definida. Worker ARQ n√£o pode iniciar.")
        raise ValueError("REDIS_URL n√£o est√° definida nas configura√ß√µes. O worker ARQ requer uma URL do Redis para operar.")

================================================================================
Cap√≠tulo 17: tests/conftest.py
================================================================================

# tests/conftest.py
"""
Este m√≥dulo define fixtures do Pytest que s√£o compartilhadas entre diferentes
arquivos de teste na su√≠te de testes da aplica√ß√£o SmartTask.

Fixtures incluem:
- Cliente HTTP ass√≠ncrono (`test_async_client`) para interagir com a API FastAPI.
  Este cliente tamb√©m gerencia a conex√£o com o banco de dados de teste e realiza
  a limpeza das cole√ß√µes antes e depois de cada teste.
- Dados de teste para usu√°rios (User A e User B).
- Fixtures para registrar/logar usu√°rios de teste e obter seus tokens/IDs.
- Fixtures para gerar cabe√ßalhos de autentica√ß√£o.
- Fixtures para criar dados de exemplo (como tarefas) para testes espec√≠ficos
  de listagem, filtragem e ordena√ß√£o.

O objetivo √© prover um ambiente de teste limpo e consistente para cada caso de teste.
"""

# ========================
# --- Importa√ß√µes ---
# ========================

# --- Bibliotecas Padr√£o/Terceiros ---
import asyncio 
import logging
import uuid
from typing import AsyncGenerator, Dict, List 

import pytest
import pytest_asyncio
from fastapi import status 
from httpx import ASGITransport, AsyncClient
from motor.motor_asyncio import AsyncIOMotorDatabase

# --- M√≥dulos da Aplica√ß√£o ---
from app.core.config import settings
from app.db.mongodb_utils import (close_mongo_connection, connect_to_mongo,
                                  get_database)
from app.db.task_crud import TASKS_COLLECTION
from app.db.user_crud import USERS_COLLECTION
from app.main import app as fastapi_app 
from app.models.task import TaskStatus

# =====================================
# --- Configura√ß√µes e Constantes ---
# =====================================

# Logger para este m√≥dulo de fixtures.
logger = logging.getLogger(__name__)

# =============================================
# --- Fixture Principal: Cliente de Teste HTTP ---
# =============================================
@pytest_asyncio.fixture(scope="function")
async def test_async_client() -> AsyncGenerator[AsyncClient, None]:
    """
    Fixture ass√≠ncrona com escopo de fun√ß√£o para prover um cliente HTTP (`AsyncClient`)
    para interagir com a aplica√ß√£o FastAPI.

    Responsabilidades:
    - Estabelece e fecha a conex√£o com o MongoDB de teste.
    - **Limpa as cole√ß√µes `USERS_COLLECTION` e `TASKS_COLLECTION` antes e depois de cada teste**
      para garantir a isola√ß√£o e idempot√™ncia dos testes.
    - Emite um aviso se o nome do banco de dados n√£o contiver "test", como precau√ß√£o.
    - Fornece o `AsyncClient` configurado com `ASGITransport` para testar a aplica√ß√£o
      diretamente, sem passar por uma camada de rede real.

    Yields:
        AsyncClient: Uma inst√¢ncia do cliente HTTP ass√≠ncrona.

    Raises:
        pytest.fail: Se a conex√£o com o MongoDB falhar durante o setup.
    """
    # Vari√°vel para armazenar a inst√¢ncia do banco de dados, inicializada como None.
    db_instance: AsyncIOMotorDatabase | None = None 
    logger.debug("Fixture 'test_async_client': Iniciando setup...")

    try:
        # --- Conex√£o e Limpeza ANTES da execu√ß√£o do teste ---
        await connect_to_mongo()
        # Obt√©m a inst√¢ncia do banco de dados j√° conectada.
        db_instance = get_database() 

        if db_instance is not None:
            # Verifica√ß√£o de seguran√ßa: emite um aviso se o nome do banco de dados
            # n√£o parecer ser um banco de teste. Isso ajuda a prevenir a limpeza acidental
            # de bancos de dados de desenvolvimento ou produ√ß√£o.
            if "test" not in settings.DATABASE_NAME.lower():
                logger.warning(
                    f"ATEN√á√ÉO: Testes est√£o sendo executados no banco de dados '{settings.DATABASE_NAME}'. "
                    "As cole√ß√µes de usu√°rios e tarefas ser√£o limpas!"
                )

            logger.debug(f"Fixture 'test_async_client': Limpando cole√ß√µes ANTES do teste no DB '{settings.DATABASE_NAME}'...")
            await db_instance[USERS_COLLECTION].delete_many({})
            await db_instance[TASKS_COLLECTION].delete_many({})
            logger.info(f"Fixture 'test_async_client': Cole√ß√µes '{USERS_COLLECTION}' e '{TASKS_COLLECTION}' limpas ANTES do teste.")
        else:
            # Se a conex√£o com o DB falhar, o teste n√£o pode prosseguir de forma confi√°vel.
            logger.error("Fixture 'test_async_client': Falha cr√≠tica ao conectar ao MongoDB durante o setup.")
            pytest.fail("Falha ao obter inst√¢ncia do banco de dados na fixture test_async_client (setup).")

        # --- Cria√ß√£o e fornecimento do cliente HTTP ---
        # ASGITransport permite testar a aplica√ß√£o FastAPI diretamente, sem a necessidade de um servidor HTTP rodando.
        transport = ASGITransport(app=fastapi_app) # type: ignore[arg-type] # httpx pode ter tipagem estrita
        async with AsyncClient(transport=transport, base_url="http://testserver") as client:
            logger.debug("Fixture 'test_async_client': Cliente HTTP fornecido ao teste.")
            # Fornece o cliente para o teste. O teste √© executado aqui.
            yield client 

    finally:
        # --- Limpeza AP√ìS a execu√ß√£o do teste (executado sempre, mesmo se o teste falhar) ---
        logger.debug("Fixture 'test_async_client': Iniciando limpeza P√ìS-teste...")
        if db_instance is not None:
            try:
                logger.debug(f"Fixture 'test_async_client': Limpando cole√ß√µes AP√ìS o teste no DB '{settings.DATABASE_NAME}'...")
                await db_instance[USERS_COLLECTION].delete_many({})
                await db_instance[TASKS_COLLECTION].delete_many({})
                logger.info(f"Fixture 'test_async_client': Cole√ß√µes '{USERS_COLLECTION}' e '{TASKS_COLLECTION}' limpas AP√ìS o teste.")
            except Exception as e_cleanup:
                # Se a limpeza falhar, loga o erro, mas n√£o falha o teste em si,
                # pois o teste j√° pode ter passado ou falhado por outros motivos.
                logger.error(f"Fixture 'test_async_client': Erro durante a limpeza do DB P√ìS-teste: {e_cleanup}", exc_info=True)
        else:
            logger.warning("Fixture 'test_async_client': Limpeza P√ìS-teste pulada - conex√£o com DB n√£o estava estabelecida.")
        
        # Garante que a conex√£o MongoDB seja fechada ap√≥s os testes.
        # Se `connect_to_mongo` e `close_mongo_connection` s√£o stateful (globais),
        # a limpeza aqui assegura que a conex√£o √© fechada ao final da fun√ß√£o do client.
        logger.debug("Fixture 'test_async_client': Fechando conex√£o MongoDB principal (se houver)...")
        await close_mongo_connection() 
        logger.debug("Fixture 'test_async_client': Setup e teardown conclu√≠dos.")


# =========================================
# --- Fixtures para Usu√°rio de Teste A ---
# =========================================

# Dados brutos para o Usu√°rio A, usados para registro e login.
user_a_data: Dict[str, str] = {
    "email": "testuserA@example.com",
    "username": "testuserA",
    "password": "passwordA",
    "full_name": "Test User A"
}

@pytest_asyncio.fixture(scope="function")
async def test_user_a_token_and_id(test_async_client: AsyncClient) -> tuple[str, uuid.UUID]:
    """
    Fixture para registrar e logar o Usu√°rio A.

    Esta fixture garante que o Usu√°rio A exista no banco de dados de teste
    (criando-o se necess√°rio, ou tolerando se j√° existir devido a um registro anterior
    que n√£o foi limpo ou se a pol√≠tica √© de n√£o falhar em conflito aqui).
    Em seguida, realiza o login para obter um token de acesso e o ID do usu√°rio.

    Depende de:
        - `test_async_client`: Para fazer requisi√ß√µes HTTP √† API.

    Returns:
        tuple[str, uuid.UUID]: Uma tupla contendo (access_token, user_id) para o Usu√°rio A.

    Raises:
        pytest.fail: Se o registro (se n√£o for conflito) ou login falharem inesperadamente,
                     ou se n√£o for poss√≠vel obter o ID do usu√°rio.
    """
    logger.debug("Fixture 'test_user_a_token_and_id': Configurando Usu√°rio A...")
    register_url = f"{settings.API_V1_STR}/auth/register"
    login_url = f"{settings.API_V1_STR}/auth/login/access-token"
    users_me_url = f"{settings.API_V1_STR}/auth/users/me"

    # --- Etapa de Registro ---
    # Tenta registrar o usu√°rio. Tolera HTTP 409 (Conflict) caso o usu√°rio j√° exista
    # (por exemplo, de um teste anterior que falhou antes da limpeza).
    reg_response = await test_async_client.post(register_url, json=user_a_data)
    if reg_response.status_code == status.HTTP_201_CREATED:
        logger.info(f"Usu√°rio A ('{user_a_data['username']}') registrado com sucesso para o teste.")
    elif reg_response.status_code == status.HTTP_409_CONFLICT:
        logger.warning(f"Registro do Usu√°rio A ('{user_a_data['username']}') resultou em conflito (j√° existe). Prosseguindo para login.")
    else:
        # Falha se o status code for inesperado (diferente de 201 ou 409).
        pytest.fail(f"Falha inesperada ao tentar registrar Usu√°rio A: {reg_response.status_code} - {reg_response.text}")

    # --- Etapa de Login ---
    # Prepara o payload para o formul√°rio de login.
    login_payload = {"username": user_a_data["username"], "password": user_a_data["password"]}
    login_response = await test_async_client.post(login_url, data=login_payload)
    if login_response.status_code != status.HTTP_200_OK:
        pytest.fail(f"Falha ao fazer login com Usu√°rio A ('{user_a_data['username']}'): {login_response.status_code} - {login_response.text}")
    
    token: str = login_response.json()["access_token"]
    logger.debug(f"Usu√°rio A ('{user_a_data['username']}') logado com sucesso. Token obtido.")

    # --- Obten√ß√£o do ID do Usu√°rio ---
    # Usa o endpoint /users/me para obter o ID do usu√°rio, garantindo que o token √© v√°lido.
    user_me_headers = {"Authorization": f"Bearer {token}"}
    user_me_response = await test_async_client.get(users_me_url, headers=user_me_headers)
    if user_me_response.status_code != status.HTTP_200_OK:
        pytest.fail(f"Falha ao obter dados do Usu√°rio A via /users/me: {user_me_response.status_code} - {user_me_response.text}")
    
    user_id_str: str = user_me_response.json()["id"]
    user_id: uuid.UUID = uuid.UUID(user_id_str) # Converte a string do ID para um objeto UUID.
    logger.info(f"ID do Usu√°rio A ({user_id}) obtido com sucesso.")

    return token, user_id

@pytest.fixture(scope="function")
def auth_headers_a(test_user_a_token_and_id: tuple[str, uuid.UUID]) -> Dict[str, str]:
    """
    Fixture s√≠ncrona que retorna um dicion√°rio de cabe√ßalhos de autentica√ß√£o
    (Authorization Bearer token) para o Usu√°rio A.

    Depende de:
        - `test_user_a_token_and_id`: Para obter o token do Usu√°rio A.

    Returns:
        Dict[str, str]: Dicion√°rio contendo o cabe√ßalho de autoriza√ß√£o.
    """
    token, _ = test_user_a_token_and_id # O ID n√£o √© usado aqui, apenas o token.
    return {"Authorization": f"Bearer {token}"}


# =========================================
# --- Fixtures para Usu√°rio de Teste B ---
# =========================================

# Dados brutos para o Usu√°rio B.
user_b_data: Dict[str, str] = {
    "email": "testuserB@example.com",
    "username": "testuserB",
    "password": "passwordB",
    "full_name": "Test User B"
}

@pytest_asyncio.fixture(scope="function")
async def test_user_b_token(test_async_client: AsyncClient) -> str:
    """
    Fixture para registrar e logar o Usu√°rio B, retornando apenas seu token de acesso.

    Similar a `test_user_a_token_and_id`, mas n√£o busca o ID do usu√°rio.
    √ötil quando apenas o token do Usu√°rio B √© necess√°rio para os testes.

    Depende de:
        - `test_async_client`.

    Returns:
        str: O token de acesso JWT para o Usu√°rio B.

    Raises:
        pytest.fail: Se o registro (se n√£o for conflito) ou login falharem inesperadamente.
    """
    logger.debug("Fixture 'test_user_b_token': Configurando Usu√°rio B...")
    register_url = f"{settings.API_V1_STR}/auth/register"
    login_url = f"{settings.API_V1_STR}/auth/login/access-token"

    # --- Registro do Usu√°rio B (similar ao Usu√°rio A) ---
    reg_response = await test_async_client.post(register_url, json=user_b_data)
    if reg_response.status_code == status.HTTP_201_CREATED:
        logger.info(f"Usu√°rio B ('{user_b_data['username']}') registrado com sucesso para o teste.")
    elif reg_response.status_code == status.HTTP_409_CONFLICT:
        logger.warning(f"Registro do Usu√°rio B ('{user_b_data['username']}') resultou em conflito (j√° existe). Prosseguindo para login.")
    else:
        pytest.fail(f"Falha inesperada ao tentar registrar Usu√°rio B: {reg_response.status_code} - {reg_response.text}")

    # --- Login do Usu√°rio B ---
    login_payload = {"username": user_b_data["username"], "password": user_b_data["password"]}
    login_response = await test_async_client.post(login_url, data=login_payload)
    if login_response.status_code != status.HTTP_200_OK:
        pytest.fail(f"Falha ao fazer login com Usu√°rio B ('{user_b_data['username']}'): {login_response.status_code} - {login_response.text}")
    
    token: str = login_response.json()["access_token"]
    logger.info(f"Usu√°rio B ('{user_b_data['username']}') logado com sucesso. Token obtido.")
    return token

@pytest.fixture(scope="function")
def auth_headers_b(test_user_b_token: str) -> Dict[str, str]:
    """
    Fixture s√≠ncrona que retorna cabe√ßalhos de autentica√ß√£o para o Usu√°rio B.

    Depende de:
        - `test_user_b_token`: Para obter o token do Usu√°rio B.

    Returns:
        Dict[str, str]: Dicion√°rio contendo o cabe√ßalho de autoriza√ß√£o.
    """
    return {"Authorization": f"Bearer {test_user_b_token}"}

# =======================================================
# --- Fixture para Cria√ß√£o de Tarefas (Filtro/Ordena√ß√£o) ---
# =======================================================
@pytest_asyncio.fixture(scope="function")
async def create_filter_sort_tasks(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str] # Tarefas ser√£o criadas pelo Usu√°rio A
) -> List[Dict]:
    """
    Cria um conjunto de tarefas de teste no banco de dados para o Usu√°rio A.

    Esta fixture √© √∫til para testes que necessitam de um conjunto pr√©-definido de tarefas
    para verificar funcionalidades de listagem, filtragem e ordena√ß√£o.

    Depende de:
        - `test_async_client`: Para enviar requisi√ß√µes de cria√ß√£o de tarefas.
        - `auth_headers_a`: Para autenticar as requisi√ß√µes como Usu√°rio A.

    Returns:
        List[Dict]: Uma lista de dicion√°rios, onde cada dicion√°rio representa
                     os dados da tarefa criada (conforme retornado pela API).
    """
    logger.info("Fixture 'create_filter_sort_tasks': Criando conjunto de tarefas de teste para Usu√°rio A...")
    tasks_creation_url = f"{settings.API_V1_STR}/tasks/"
    
    # Defini√ß√£o das tarefas a serem criadas para os testes de filtro e ordena√ß√£o.
    tasks_to_create_data: List[Dict[str, any]] = [ # Tipagem mais expl√≠cita
        {"title": "Task A Filter High Priority", "importance": 5, "project": "Projeto Filtro", "status": TaskStatus.PENDING.value, "due_date": "2026-01-01", "tags": ["importante", "relat√≥rio"]},
        {"title": "Task B Filter Low Priority", "importance": 1, "project": "Projeto Filtro", "status": TaskStatus.PENDING.value, "due_date": "2026-02-01", "tags": ["comum"]},
        {"title": "Task C Another Project InProgress", "importance": 3, "project": "Projeto Secund√°rio", "status": TaskStatus.IN_PROGRESS.value, "tags": ["desenvolvimento"]},
        {"title": "Task D Filter Medium Due Soon", "importance": 3, "project": "Projeto Filtro", "status": TaskStatus.PENDING.value, "due_date": "2025-12-15", "tags": ["urgente", "financeiro"]},
        {"title": "Task E Filter Completed", "importance": 4, "project": "Projeto Filtro", "status": TaskStatus.COMPLETED.value, "tags": ["finalizado"]},
    ]
    
    created_tasks_list: List[Dict] = []
    for task_payload in tasks_to_create_data:
        response = await test_async_client.post(tasks_creation_url, json=task_payload, headers=auth_headers_a)
        assert response.status_code == status.HTTP_201_CREATED, \
            f"Falha ao criar tarefa de teste (T√≠tulo: '{task_payload['title']}'). Resposta: {response.text}"
        created_tasks_list.append(response.json())
        logger.debug(f"Tarefa de teste criada: {task_payload['title']} (ID: {response.json()['id']})")
    
    logger.info(f"Fixture 'create_filter_sort_tasks': {len(created_tasks_list)} tarefas de teste criadas com sucesso.")
    return created_tasks_list

================================================================================
Cap√≠tulo 18: tests/test_auth.py
================================================================================

# tests/test_auth.py

# ========================
# --- Importa√ß√µes ---
# ========================
import uuid
from typing import Any, Dict 

import pytest 
from fastapi import status
from httpx import AsyncClient
from unittest.mock import MagicMock, patch
from pymongo.errors import DuplicateKeyError

# --- M√≥dulos da Aplica√ß√£o e Configs de Teste ---
from app.core.config import settings
from app.db import user_crud
from app.models.user import User, UserInDB, UserUpdate 
from app.routers import auth
from tests.conftest import user_a_data 

# ====================================
# --- Marcador Global de Teste ---
# ====================================
pytestmark = pytest.mark.asyncio

# ==============================
# --- Testes de Registro (/auth/register) ---
# ==============================
async def test_register_user_success(test_async_client: AsyncClient):
    """
    Testa o registro bem-sucedido de um novo usu√°rio com dados √∫nicos.
    """
    # ========================
    # --- Arrange ---
    # ========================
    new_user_data = {
        "email": "newuniqueuser_auth_test@example.com",
        "username": "newuniqueuser_auth_test",
        "password": "newpassword123",
        "full_name": "New Unique Test User"
    }
    register_url = f"{settings.API_V1_STR}/auth/register"

    # ========================
    # --- Act ---
    # ========================
    response = await test_async_client.post(register_url, json=new_user_data)

    # ========================
    # --- Assert ---
    # ========================
    assert response.status_code == status.HTTP_201_CREATED
    response_data = response.json()
    assert response_data["email"] == new_user_data["email"]
    assert response_data["username"] == new_user_data["username"]
    assert response_data["full_name"] == new_user_data["full_name"]
    assert "id" in response_data
    assert "hashed_password" not in response_data

async def test_register_user_duplicate_username_case_insensitive_is_actually_sensitive(
    test_async_client: AsyncClient,
):
    """
    Testa o registro com um username que difere apenas em mai√∫sculas/min√∫sculas
    de um username existente.
    """
    # ========================
    # --- Arrange ---
    # ========================
    base_url = f"{settings.API_V1_STR}/auth/register"
    unique_email_prefix = uuid.uuid4().hex[:8]

    user_initial_data = {
        "email": f"{unique_email_prefix}_initial@example.com",
        "username": "CamelCaseUser",
        "password": "password123",
    }
    response_initial = await test_async_client.post(base_url, json=user_initial_data)
    assert response_initial.status_code == status.HTTP_201_CREATED

    user_variant_case_data = {
        "email": f"{unique_email_prefix}_variant@example.com",
        "username": "camelcaseuser",
        "password": "password123",
    }

    # ========================
    # --- Act ---
    # ========================
    response_variant = await test_async_client.post(base_url, json=user_variant_case_data)

    # ========================
    # --- Assert ---
    # ========================
    assert response_variant.status_code == status.HTTP_201_CREATED

async def test_register_user_duplicate_username(
    test_async_client: AsyncClient,
    test_user_a_token_and_id: tuple[str, uuid.UUID]
):
    """
    Testa a tentativa de registro de um novo usu√°rio com um username que j√° existe.
    """
    # ========================
    # --- Arrange ---
    # ========================
    attempt_data = {
        "email": "anotherunique_email@example.com",
        "username": user_a_data["username"],
        "password": "anotherpassword",
    }
    register_url = f"{settings.API_V1_STR}/auth/register"

    # ========================
    # --- Act ---
    # ========================
    response = await test_async_client.post(register_url, json=attempt_data)

    # ========================
    # --- Assert ---
    # ========================
    assert response.status_code == status.HTTP_409_CONFLICT
    assert "j√° existe" in response.json()["detail"]

async def test_register_user_duplicate_email(
    test_async_client: AsyncClient,
    test_user_a_token_and_id: tuple[str, uuid.UUID]
):
    """
    Testa a tentativa de registro de um novo usu√°rio com um e-mail que j√° existe.
    """
    # ========================
    # --- Arrange ---
    # ========================
    attempt_data = {
        "email": user_a_data["email"],
        "username": "anotherunique_username_for_email_test",
        "password": "anotherpassword",
    }
    register_url = f"{settings.API_V1_STR}/auth/register"

    # ========================
    # --- Act ---
    # ========================
    response = await test_async_client.post(register_url, json=attempt_data)

    # ========================
    # --- Assert ---
    # ========================
    assert response.status_code == status.HTTP_409_CONFLICT
    assert "j√° registrado" in response.json()["detail"]

async def test_register_user_crud_returns_none(test_async_client: AsyncClient, mocker): # type: ignore
    """
    Testa o registro quando user_crud.create_user retorna None.
    Deve resultar em erro 500 com a mensagem gen√©rica devido √† estrutura do try/except.
    """
    # ========================
    # --- Arrange ---
    # ========================
    user_data = {
        "email": "crudnone@example.com",
        "username": "crudnoneuser",
        "password": "password123"
    }
    register_url = f"{settings.API_V1_STR}/auth/register"

    mocker.patch("app.routers.auth.user_crud.get_user_by_username", return_value=None)
    mocker.patch("app.routers.auth.user_crud.get_user_by_email", return_value=None)
    mocker.patch("app.routers.auth.user_crud.create_user", return_value=None)

    # ========================
    # --- Act ---
    # ========================
    response = await test_async_client.post(register_url, json=user_data)

    # ========================
    # --- Assert ---
    # ========================
    assert response.status_code == status.HTTP_500_INTERNAL_SERVER_ERROR
    # Espera a mensagem do except Exception gen√©rico
    assert "Ocorreu um erro inesperado" in response.json()["detail"]

async def test_register_user_crud_generic_exception(test_async_client: AsyncClient, mocker):
    """
    Testa o registro quando user_crud.create_user levanta Exception gen√©rica.
    """
    # ========================
    # --- Arrange ---
    # ========================
    user_data = {
        "email": "crudexception@example.com",
        "username": "crudexcuser",
        "password": "password123"
    }
    register_url = f"{settings.API_V1_STR}/auth/register"
    simulated_error = Exception("Erro gen√©rico simulado no CRUD")

    mocker.patch("app.routers.auth.user_crud.get_user_by_username", return_value=None)
    mocker.patch("app.routers.auth.user_crud.get_user_by_email", return_value=None)
    mocker.patch("app.routers.auth.user_crud.create_user", side_effect=simulated_error)

    # ========================
    # --- Act ---
    # ========================
    response = await test_async_client.post(register_url, json=user_data)

    # ========================
    # --- Assert ---
    # ========================
    assert response.status_code == status.HTTP_500_INTERNAL_SERVER_ERROR
    assert "Ocorreu um erro inesperado" in response.json()["detail"]

# ==================================================
# --- Testes de Valida√ß√£o de Entrada (/auth/register) ---
# ==================================================
@pytest.mark.parametrize(
    "field, value, error_type, error_msg_part",
    [
        ("email", "nao-e-um-email-valido", "value_error", "valid email address"),
        ("username", "us", "string_too_short", "String should have at least 3 characters"),
        ("username", "username com espacos", "string_pattern_mismatch", "match pattern"),
        ("username", "username!Inv√°lido", "string_pattern_mismatch", "match pattern"),
        ("password", "curta", "string_too_short", "String should have at least 8 characters"),
        ("email", None, "missing", "Field required"),
        ("username", None, "missing", "Field required"),
        ("password", None, "missing", "Field required"),
    ]
)
async def test_register_user_invalid_input(
    test_async_client: AsyncClient,
    field: str,
    value: Any,
    error_type: str,
    error_msg_part: str
):
    """
    Testa o registro de usu√°rio com dados de entrada inv√°lidos espec√≠ficos.
    """
    # ========================
    # --- Arrange ---
    # ========================
    valid_base_data = {
        "email": "valid_initial_email@example.com",
        "username": "validinitialuser",
        "password": "validinitialpassword",
        "full_name": "Valid Initial Name"
    }
    test_payload = valid_base_data.copy()
    if value is None:
        if field in test_payload:
            del test_payload[field]
    else:
        test_payload[field] = value

    register_url = f"{settings.API_V1_STR}/auth/register"

    # ========================
    # --- Act ---
    # ========================
    response = await test_async_client.post(register_url, json=test_payload)

    # ========================
    # --- Assert ---
    # ========================
    assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY
    error_details = response.json().get("detail", [])
    assert isinstance(error_details, list)
    found_expected_error = False
    for error_item in error_details:
        field_location_match = isinstance(error_item.get("loc"), list) and field in error_item["loc"]
        type_match = error_item.get("type") == error_type
        msg_match = error_msg_part.lower() in error_item.get("msg", "").lower()

        if field_location_match and type_match and msg_match:
            found_expected_error = True
            break
    assert found_expected_error

# ===============================================
# --- Testes de Login (/auth/login/access-token) ---
# ===============================================
async def test_login_success(
    test_async_client: AsyncClient,
    test_user_a_token_and_id: tuple[str, uuid.UUID]
):
    """
    Testa o login bem-sucedido do Usu√°rio A.
    """
    # ========================
    # --- Arrange ---
    # ========================
    login_payload_form_data = {
        "username": user_a_data["username"],
        "password": user_a_data["password"]
    }
    login_url = f"{settings.API_V1_STR}/auth/login/access-token"

    # ========================
    # --- Act ---
    # ========================
    response = await test_async_client.post(login_url, data=login_payload_form_data)

    # ========================
    # --- Assert ---
    # ========================
    assert response.status_code == status.HTTP_200_OK
    token_data = response.json()
    assert "access_token" in token_data
    assert token_data.get("token_type") == "bearer"

async def test_login_wrong_password(
    test_async_client: AsyncClient,
    test_user_a_token_and_id: tuple[str, uuid.UUID]
):
    """
    Testa a tentativa de login do Usu√°rio A com uma senha incorreta.
    """
    # ========================
    # --- Arrange ---
    # ========================
    login_payload_form_data = {
        "username": user_a_data["username"],
        "password": "thisisawrongpassword"
    }
    login_url = f"{settings.API_V1_STR}/auth/login/access-token"

    # ========================
    # --- Act ---
    # ========================
    response = await test_async_client.post(login_url, data=login_payload_form_data)

    # ========================
    # --- Assert ---
    # ========================
    assert response.status_code == status.HTTP_401_UNAUTHORIZED
    assert "incorretos" in response.json()["detail"].lower()

async def test_login_user_not_found(test_async_client: AsyncClient):
    """
    Testa a tentativa de login com um nome de usu√°rio que n√£o existe no sistema.
    """
    # ========================
    # --- Arrange ---
    # ========================
    login_payload_form_data = {
        "username": "nonexistent_test_user",
        "password": "any_password"
    }
    login_url = f"{settings.API_V1_STR}/auth/login/access-token"

    # ========================
    # --- Act ---
    # ========================
    response = await test_async_client.post(login_url, data=login_payload_form_data)

    # ========================
    # --- Assert ---
    # ========================
    assert response.status_code == status.HTTP_401_UNAUTHORIZED

async def test_login_disabled_user(test_async_client: AsyncClient, mocker):
    """
    Testa a tentativa de login com um usu√°rio que est√° desabilitado.
    Espera-se um erro HTTP 400 Bad Request.
    """
    # ========================
    # --- Arrange ---
    # ========================
    disabled_username = "disabled_user_login"
    password = "password_for_disabled"
    login_url = f"{settings.API_V1_STR}/auth/login/access-token"
    login_payload_form_data = {
        "username": disabled_username,
        "password": password
    }

    disabled_user_mock = MagicMock(spec=UserInDB)
    disabled_user_mock.username = disabled_username
    disabled_user_mock.hashed_password = "some_valid_hash" 
    disabled_user_mock.disabled = True 

    mock_get_user_by_username = mocker.patch("app.routers.auth.user_crud.get_user_by_username", return_value=disabled_user_mock)
    mock_verify_password = mocker.patch("app.routers.auth.verify_password", return_value=True)
    mock_create_token = mocker.patch("app.routers.auth.create_access_token")

    # ========================
    # --- Act ---
    # ========================
    response = await test_async_client.post(login_url, data=login_payload_form_data)

    # ========================
    # --- Assert ---
    # ========================
    assert response.status_code == status.HTTP_400_BAD_REQUEST
    assert "A conta do usu√°rio est√° inativa." == response.json()["detail"]
    mock_create_token.assert_not_called()
    mock_get_user_by_username.assert_called_once_with(mocker.ANY, disabled_username)
    mock_verify_password.assert_called_once_with(password, disabled_user_mock.hashed_password)

# =======================================
# --- Testes de /auth/users/me ---
# =======================================
async def test_read_users_me_success(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    test_user_a_token_and_id: tuple[str, uuid.UUID]
):
    """
    Testa o acesso bem-sucedido ao endpoint `/users/me` para obter
    os dados do usu√°rio autenticado (User A).
    """
    # ========================
    # --- Arrange ---
    # ========================
    users_me_url = f"{settings.API_V1_STR}/auth/users/me"
    _, expected_user_id = test_user_a_token_and_id

    # ========================
    # --- Act ---
    # ========================
    response = await test_async_client.get(users_me_url, headers=auth_headers_a)

    # ========================
    # --- Assert ---
    # ========================
    assert response.status_code == status.HTTP_200_OK
    user_response_data = response.json()
    assert user_response_data["id"] == str(expected_user_id)
    assert user_response_data["email"] == user_a_data["email"]
    assert user_response_data["username"] == user_a_data["username"]
    assert user_response_data["full_name"] == user_a_data["full_name"]
    assert "disabled" in user_response_data
    assert "hashed_password" not in user_response_data
    assert "created_at" in user_response_data

async def test_read_users_me_unauthorized_no_token(test_async_client: AsyncClient):
    """
    Testa o acesso ao endpoint `/users/me` sem fornecer um token de autentica√ß√£o.
    """
    # ========================
    # --- Arrange ---
    # ========================
    users_me_url = f"{settings.API_V1_STR}/auth/users/me"

    # ========================
    # --- Act ---
    # ========================
    response = await test_async_client.get(users_me_url)

    # ========================
    # --- Assert ---
    # ========================
    assert response.status_code == status.HTTP_401_UNAUTHORIZED
    assert "Not authenticated" in response.json()["detail"]

async def test_read_users_me_invalid_token(test_async_client: AsyncClient, mocker):
    """
    Testa o acesso ao endpoint `/users/me` fornecendo um token JWT inv√°lido/malformado.
    """
    # ========================
    # --- Arrange ---
    # ========================
    users_me_url = f"{settings.API_V1_STR}/auth/users/me"
    invalid_token_headers = {"Authorization": "Bearer an.invalid.jwt.token"}
    mocker.patch("app.core.security.logger")

    # ========================
    # --- Act ---
    # ========================
    response = await test_async_client.get(users_me_url, headers=invalid_token_headers)

    # ========================
    # --- Assert ---
    # ========================
    assert response.status_code == status.HTTP_401_UNAUTHORIZED
    error_detail = response.json()["detail"]
    expected_error_message_part_pt = "n√£o foi poss√≠vel validar as credenciais"
    assert expected_error_message_part_pt.lower() in error_detail.lower()

async def test_update_me_success(test_async_client: AsyncClient, mocker, auth_headers_a, test_user_a_token_and_id): 
    """
    Testa a atualiza√ß√£o bem-sucedida dos dados do usu√°rio autenticado.
    """
    # ========================
    # --- Arrange ---
    # ========================
    token, user_id_a = test_user_a_token_and_id
    url = f"{settings.API_V1_STR}/auth/users/me"
    update_payload = {"full_name": "User A Updated Name"}

    mock_updated_user = MagicMock(spec=UserInDB)
    mock_api_user_return = MagicMock(spec=User)
    mock_api_user_return.id = user_id_a
    mock_api_user_return.username = user_a_data["username"]
    mock_api_user_return.email = user_a_data["email"] 
    mock_api_user_return.full_name = update_payload["full_name"]
    mock_api_user_return.disabled = False
    mock_crud_update = mocker.patch("app.routers.auth.user_crud.update_user", return_value=mock_updated_user)
    mocker.patch("app.routers.auth.User.model_validate", return_value=mock_api_user_return) 

    # ========================
    # --- Act ---
    # ========================
    response = await test_async_client.put(url, json=update_payload, headers=auth_headers_a)

    # ========================
    # --- Assert ---
    # ========================
    assert response.status_code == status.HTTP_200_OK
    response_data = response.json()
    assert response_data["full_name"] == update_payload["full_name"]
    assert response_data["id"] == str(user_id_a)

    mock_crud_update.assert_called_once()
    call_args, call_kwargs = mock_crud_update.call_args
    assert call_kwargs['user_id'] == user_id_a
    crud_update_payload_arg = None
    if 'user_update' in call_kwargs:
        crud_update_payload_arg = call_kwargs['user_update']
    else:
         pytest.fail("Argumento 'user_update' n√£o encontrado na chamada mockada do CRUD.")

    assert isinstance(crud_update_payload_arg, UserUpdate)
    assert crud_update_payload_arg.full_name == update_payload["full_name"]
    assert crud_update_payload_arg.email is None

async def test_update_me_password_success(test_async_client: AsyncClient, mocker, auth_headers_a, test_user_a_token_and_id): 
    """
    Testa a atualiza√ß√£o bem-sucedida da senha do usu√°rio autenticado.
    """
    # ========================
    # --- Arrange ---
    # ========================
    token, user_id_a = test_user_a_token_and_id
    url = f"{settings.API_V1_STR}/auth/users/me"
    new_password = "newpassword123!"
    update_payload = {"password": new_password}

    mock_updated_user = MagicMock(spec=UserInDB)
    mock_api_user_return = MagicMock(spec=User)
    mock_api_user_return.id = user_id_a
    mock_api_user_return.username = user_a_data["username"]
    mock_api_user_return.email = user_a_data["email"]
    mock_api_user_return.full_name = user_a_data["full_name"]
    mock_api_user_return.disabled = False
    mock_crud_update = mocker.patch("app.routers.auth.user_crud.update_user", return_value=mock_updated_user)
    mocker.patch("app.routers.auth.User.model_validate", return_value=mock_api_user_return)

    # ========================
    # --- Act ---
    # ========================
    response = await test_async_client.put(url, json=update_payload, headers=auth_headers_a)

    # ========================
    # --- Assert ---
    # ========================
    assert response.status_code == status.HTTP_200_OK

    mock_crud_update.assert_called_once()
    call_args, call_kwargs = mock_crud_update.call_args
    assert call_kwargs['user_id'] == user_id_a

    crud_update_payload_arg = call_kwargs.get('user_update')
    assert crud_update_payload_arg is not None
    assert isinstance(crud_update_payload_arg, UserUpdate)
    assert crud_update_payload_arg.password == new_password
    assert crud_update_payload_arg.full_name is None

async def test_update_me_user_crud_returns_none(test_async_client: AsyncClient, mocker, auth_headers_a, test_user_a_token_and_id): 
    """
    Testa o comportamento da rota PUT /users/me quando
    user_crud.update_user retorna None (resultando em 500 devido ao except gen√©rico).
    """
    # ========================
    # --- Arrange ---
    # ========================
    token, user_id_a = test_user_a_token_and_id
    url = f"{settings.API_V1_STR}/auth/users/me"
    update_payload = {"full_name": "Nome Nao Aplicado"}
    mock_crud_update = mocker.patch("app.routers.auth.user_crud.update_user", return_value=None)

    # ========================
    # --- Act ---
    # ========================
    response = await test_async_client.put(url, json=update_payload, headers=auth_headers_a)

    # ========================
    # --- Assert ---
    # ========================
    assert response.status_code == status.HTTP_500_INTERNAL_SERVER_ERROR
    assert "Ocorreu um erro inesperado durante a atualiza√ß√£o do usu√°rio." in response.json()["detail"]

    mock_crud_update.assert_called_once()
    call_args, call_kwargs = mock_crud_update.call_args
    assert call_kwargs['user_id'] == user_id_a
    crud_update_payload_arg = call_kwargs.get('user_update')
    assert isinstance(crud_update_payload_arg, UserUpdate)
    assert crud_update_payload_arg.full_name == update_payload["full_name"]

async def test_update_me_duplicate_key_error(test_async_client: AsyncClient, mocker, auth_headers_a, test_user_a_token_and_id): 
    """
    Testa o tratamento de DuplicateKeyError na rota PUT /users/me.
    """
    # ========================
    # --- Arrange ---
    # ========================
    token, user_id_a = test_user_a_token_and_id
    url = f"{settings.API_V1_STR}/auth/users/me"
    duplicate_email = "email.duplicado@teste.com"
    update_payload = {"email": duplicate_email}

    simulated_error = DuplicateKeyError("Erro de chave duplicada simulado")
    mock_crud_update = mocker.patch("app.routers.auth.user_crud.update_user", side_effect=simulated_error)

    # ========================
    # --- Act ---
    # ========================
    response = await test_async_client.put(url, json=update_payload, headers=auth_headers_a)

    # ========================
    # --- Assert ---
    # ========================
    assert response.status_code == status.HTTP_409_CONFLICT
    assert f"o e-mail '{duplicate_email}' j√° est√° em uso" in response.json()["detail"]

    mock_crud_update.assert_called_once()
    call_args, call_kwargs = mock_crud_update.call_args
    assert call_kwargs['user_id'] == user_id_a
    crud_update_payload_arg = call_kwargs.get('user_update')
    assert isinstance(crud_update_payload_arg, UserUpdate)
    assert crud_update_payload_arg.email == update_payload["email"]

async def test_update_me_generic_exception(test_async_client: AsyncClient, mocker, auth_headers_a, test_user_a_token_and_id): 
    """
    Testa o tratamento de exce√ß√£o gen√©rica na rota PUT /users/me.
    """
    # ========================
    # --- Arrange ---
    # ========================
    token, user_id_a = test_user_a_token_and_id
    url = f"{settings.API_V1_STR}/auth/users/me"
    update_payload = {"full_name": "Nome Inalterado"}

    simulated_error = Exception("Erro gen√©rico simulado no update do CRUD")
    mock_crud_update = mocker.patch("app.routers.auth.user_crud.update_user", side_effect=simulated_error)

    # ========================
    # --- Act ---
    # ========================
    response = await test_async_client.put(url, json=update_payload, headers=auth_headers_a)

    # ========================
    # --- Assert ---
    # ========================
    assert response.status_code == status.HTTP_500_INTERNAL_SERVER_ERROR
    assert "Ocorreu um erro inesperado durante a atualiza√ß√£o do usu√°rio." in response.json()["detail"]

    mock_crud_update.assert_called_once()
    call_args, call_kwargs = mock_crud_update.call_args
    assert call_kwargs['user_id'] == user_id_a
    crud_update_payload_arg = call_kwargs.get('user_update')
    assert isinstance(crud_update_payload_arg, UserUpdate)
    assert crud_update_payload_arg.full_name == update_payload["full_name"]

async def test_delete_me_success(test_async_client: AsyncClient, mocker, auth_headers_a, test_user_a_token_and_id): 
    """
    Testa a dele√ß√£o bem-sucedida da conta do usu√°rio autenticado.
    """
    # ========================
    # --- Arrange ---
    # ========================
    token, user_id_a = test_user_a_token_and_id
    url = f"{settings.API_V1_STR}/auth/users/me"

    mock_crud_delete = mocker.patch("app.routers.auth.user_crud.delete_user", return_value=True)

    # ========================
    # --- Act ---
    # ========================
    response = await test_async_client.delete(url, headers=auth_headers_a)

    # ========================
    # --- Assert ---
    # ========================
    assert response.status_code == status.HTTP_204_NO_CONTENT

    mock_crud_delete.assert_called_once()
    call_args, call_kwargs = mock_crud_delete.call_args
    found_user_id_arg = False
    if len(call_args) > 1 and call_args[1] == user_id_a:
         found_user_id_arg = True
    elif call_kwargs.get('user_id') == user_id_a:
         found_user_id_arg = True
    assert found_user_id_arg is True

async def test_delete_me_crud_returns_false(test_async_client: AsyncClient, mocker, auth_headers_a, test_user_a_token_and_id): 
    """
    Testa o comportamento de DELETE /users/me quando
    user_crud.delete_user retorna False (resultando em 500 devido ao except gen√©rico).
    """
    # ========================
    # --- Arrange ---
    # ========================
    token, user_id_a = test_user_a_token_and_id
    url = f"{settings.API_V1_STR}/auth/users/me"

    mock_crud_delete = mocker.patch("app.routers.auth.user_crud.delete_user", return_value=False)

    # ========================
    # --- Act ---
    # ========================
    response = await test_async_client.delete(url, headers=auth_headers_a)

    # ========================
    # --- Assert ---
    # ========================
    assert response.status_code == status.HTTP_500_INTERNAL_SERVER_ERROR
    assert "Ocorreu um erro inesperado durante a dele√ß√£o do usu√°rio." in response.json()["detail"]

    mock_crud_delete.assert_called_once()
    call_args, call_kwargs = mock_crud_delete.call_args
    found_user_id_arg = False
    if len(call_args) > 1 and call_args[1] == user_id_a:
         found_user_id_arg = True
    elif call_kwargs.get('user_id') == user_id_a:
         found_user_id_arg = True
    assert found_user_id_arg is True

async def test_delete_me_crud_generic_exception(test_async_client: AsyncClient, mocker, auth_headers_a, test_user_a_token_and_id): # type: ignore
    """
    Testa o tratamento de exce√ß√£o gen√©rica na rota DELETE /users/me
    quando o CRUD levanta um erro.
    """
    # ========================
    # --- Arrange ---
    # ========================
    token, user_id_a = test_user_a_token_and_id
    url = f"{settings.API_V1_STR}/auth/users/me"

    # Mock user_crud.delete_user para levantar Exception gen√©rica
    simulated_error = Exception("Erro gen√©rico simulado no delete do CRUD")
    mock_crud_delete = mocker.patch("app.routers.auth.user_crud.delete_user", side_effect=simulated_error)

    # ========================
    # --- Act ---
    # ========================
    response = await test_async_client.delete(url, headers=auth_headers_a)

    # ========================
    # --- Assert ---
    # ========================
    assert response.status_code == status.HTTP_500_INTERNAL_SERVER_ERROR
    assert "Ocorreu um erro inesperado durante a dele√ß√£o do usu√°rio." in response.json()["detail"]

    # Verificar se user_crud.delete_user foi chamado
    mock_crud_delete.assert_called_once()
    call_args, call_kwargs = mock_crud_delete.call_args
    found_user_id_arg = False
    if len(call_args) > 1 and call_args[1] == user_id_a:
         found_user_id_arg = True
    elif call_kwargs.get('user_id') == user_id_a:
         found_user_id_arg = True
    assert found_user_id_arg is True



================================================================================
Cap√≠tulo 19: tests/test_core_config.py
================================================================================

# tests/test_core_config.py
"""
Este m√≥dulo cont√©m testes para a classe de configura√ß√µes da aplica√ß√£o (`app.core.config.Settings`).
O foco principal √© validar a l√≥gica condicional relacionada √†s configura√ß√µes de e-mail,
garantindo que as credenciais de e-mail sejam obrigat√≥rias apenas quando
a funcionalidade de e-mail est√° explicitamente habilitada (`MAIL_ENABLED=True`).
"""

# ========================
# --- Importa√ß√µes ---
# ========================
from logging import config
import os 
from unittest.mock import patch 
import pytest
from pydantic import ValidationError
import importlib

# --- M√≥dulo da Aplica√ß√£o ---
from app.core.config import Settings
import app.core.config as config_module

# ================================================
# --- Testes de Valida√ß√£o de Configura√ß√µes de E-mail ---
# ================================================

def test_settings_mail_enabled_and_missing_credentials_fails_validation(monkeypatch):
    """
    Testa se a instancia√ß√£o de `Settings` falha com `ValidationError` (ou `ValueError`)
    quando `MAIL_ENABLED` √© True, mas uma ou mais credenciais de e-mail
    (MAIL_USERNAME, MAIL_PASSWORD, MAIL_FROM, MAIL_SERVER) est√£o ausentes.

    Cen√°rio: MAIL_ENABLED=True, MAIL_USERNAME n√£o definido.
    """
    print("\nTeste: MAIL_ENABLED=True e falta MAIL_USERNAME -> Deve falhar a valida√ß√£o.")

    # --- Arrange: Configurar vari√°veis de ambiente ---
    # 1. Limpar quaisquer vari√°veis de ambiente de e-mail preexistentes para isolamento do teste.
    print("  Limpando vari√°veis de ambiente de e-mail...")
    monkeypatch.delenv("MAIL_ENABLED", raising=False)
    monkeypatch.delenv("MAIL_USERNAME", raising=False)
    monkeypatch.delenv("MAIL_PASSWORD", raising=False)
    monkeypatch.delenv("MAIL_FROM", raising=False)
    monkeypatch.delenv("MAIL_PORT", raising=False) 
    monkeypatch.delenv("MAIL_SERVER", raising=False)
    monkeypatch.delenv("MAIL_TLS", raising=False) 
    monkeypatch.delenv("MAIL_SSL", raising=False) 
    # Adicione outras vari√°veis de e-mail que seu Settings possa ter.

    # 2. Definir vari√°veis de ambiente obrigat√≥rias n√£o relacionadas a e-mail.
    #    (ex: JWT_SECRET_KEY, MONGODB_URL) para que Settings possa ser instanciado.
    print("  Definindo vari√°veis de ambiente obrigat√≥rias (n√£o-email)...")
    monkeypatch.setenv("PROJECT_NAME", "Test Project")
    monkeypatch.setenv("API_V1_STR", "/api/v1")
    monkeypatch.setenv("ENVIRONMENT", "test")
    monkeypatch.setenv("JWT_SECRET_KEY", "test_jwt_secret_key_for_config_test")
    monkeypatch.setenv("ACCESS_TOKEN_EXPIRE_MINUTES", "30")
    monkeypatch.setenv("REFRESH_TOKEN_EXPIRE_DAYS", "7") 
    monkeypatch.setenv("MONGODB_URL", "mongodb://localhost:27017/test_config_db")
    monkeypatch.setenv("DATABASE_NAME", "test_config_db")
    # Adicione quaisquer outras vari√°veis que `Settings` sempre espera.

    # 3. Definir o cen√°rio de teste espec√≠fico: E-mail habilitado, mas falta MAIL_USERNAME.
    print("  Definindo cen√°rio de teste: MAIL_ENABLED=True, MAIL_USERNAME ausente.")
    monkeypatch.setenv("MAIL_ENABLED", "True")
    # monkeypatch.setenv("MAIL_USERNAME", "user") # MAIL_USERNAME √© omitido intencionalmente
    monkeypatch.setenv("MAIL_PASSWORD", "secretpassword")
    monkeypatch.setenv("MAIL_FROM", "tests@example.com")
    monkeypatch.setenv("MAIL_SERVER", "smtp.example.com")
    monkeypatch.setenv("MAIL_PORT", "587")
    monkeypatch.setenv("MAIL_TLS", "True")


    # --- Act & Assert: Tentar instanciar Settings e verificar a exce√ß√£o ---
    # Pydantic v2 levanta ValidationError. ValueError pode ser de validadores customizados.
    print("  Tentando instanciar Settings, esperando exce√ß√£o...")
    with pytest.raises((ValueError, ValidationError)) as exc_info:
        # `_env_file=None` garante que Pydantic n√£o tente carregar um arquivo .env real.
        Settings(_env_file=None) 

    # Verifica se a mensagem de erro da exce√ß√£o cont√©m o texto esperado.
    expected_error_message_part = "MAIL_USERNAME, MAIL_PASSWORD, MAIL_FROM e MAIL_SERVER devem ser definidos"
    print(f"  Exce√ß√£o recebida: {exc_info.value}")
    assert expected_error_message_part in str(exc_info.value), \
        f"A mensagem de erro n√£o cont√©m '{expected_error_message_part}'. Erro: {str(exc_info.value)}"
    print("  Valida√ß√£o falhou como esperado.")

def test_settings_mail_disabled_and_credentials_not_needed_passes_validation(monkeypatch):
    """
    Testa se a instancia√ß√£o de `Settings` √© bem-sucedida quando `MAIL_ENABLED`
    √© False, mesmo que as credenciais de e-mail estejam ausentes.

    Neste cen√°rio, os campos de credenciais de e-mail devem ser opcionais
    e podem ser None.
    """
    print("\nTeste: MAIL_ENABLED=False, credenciais ausentes -> Deve passar a valida√ß√£o.")

    # --- Arrange: Configurar vari√°veis de ambiente ---
    # 1. Limpar vari√°veis de e-mail.
    print("  Limpando vari√°veis de ambiente de e-mail...")
    monkeypatch.delenv("MAIL_ENABLED", raising=False)
    monkeypatch.delenv("MAIL_USERNAME", raising=False)
    monkeypatch.delenv("MAIL_PASSWORD", raising=False)
    monkeypatch.delenv("MAIL_FROM", raising=False)
    monkeypatch.delenv("MAIL_PORT", raising=False)
    monkeypatch.delenv("MAIL_SERVER", raising=False)
    monkeypatch.delenv("MAIL_TLS", raising=False)
    monkeypatch.delenv("MAIL_SSL", raising=False)

    # 2. Definir vari√°veis obrigat√≥rias n√£o relacionadas a e-mail.
    print("  Definindo vari√°veis de ambiente obrigat√≥rias (n√£o-email)...")
    monkeypatch.setenv("PROJECT_NAME", "Test Project Disabled Mail")
    monkeypatch.setenv("API_V1_STR", "/api/v1")
    monkeypatch.setenv("ENVIRONMENT", "test")
    monkeypatch.setenv("JWT_SECRET_KEY", "test_jwt_secret_for_disabled_mail")
    monkeypatch.setenv("ACCESS_TOKEN_EXPIRE_MINUTES", "60")
    monkeypatch.setenv("REFRESH_TOKEN_EXPIRE_DAYS", "14")
    monkeypatch.setenv("MONGODB_URL", "mongodb://localhost:27017/test_disabled_mail_db")
    monkeypatch.setenv("DATABASE_NAME", "test_disabled_mail_db")


    # 3. Definir o cen√°rio: MAIL_ENABLED=False, outras credenciais de e-mail ausentes.
    print("  Definindo cen√°rio de teste: MAIL_ENABLED=False.")
    monkeypatch.setenv("MAIL_ENABLED", "False")

    # --- Act & Assert: Tentar instanciar Settings e verificar se N√ÉO levanta exce√ß√£o ---
    print("  Tentando instanciar Settings, esperando sucesso...")
    try:
        
        settings_instance = Settings(_env_file=None) 
        
        print(f"  Settings instanciado com sucesso: MAIL_ENABLED={settings_instance.MAIL_ENABLED}")
        assert not settings_instance.MAIL_ENABLED, "MAIL_ENABLED deveria ser False."
        assert settings_instance.MAIL_USERNAME is None, "MAIL_USERNAME deveria ser None."
        assert settings_instance.MAIL_PASSWORD is None, "MAIL_PASSWORD deveria ser None."
        assert settings_instance.MAIL_FROM is None, "MAIL_FROM deveria ser None."
        assert settings_instance.MAIL_SERVER is None, "MAIL_SERVER deveria ser None."
        assert settings_instance.MAIL_PORT == 587, "MAIL_PORT deveria ter seu valor default (e.g., 587)." 

    except (ValueError, ValidationError) as e:
        pytest.fail(
            f"A valida√ß√£o de Settings falhou inesperadamente quando MAIL_ENABLED=False. Erro: {e}\n"
            f"Vari√°veis de ambiente configuradas: {dict(os.environ)}"
        )
    print("  Valida√ß√£o passou como esperado com MAIL_ENABLED=False.")

def test_settings_mail_enabled_and_all_credentials_provided_passes_validation(monkeypatch):
    """
    Testa se a instancia√ß√£o de `Settings` √© bem-sucedida quando `MAIL_ENABLED`
    √© True e TODAS as credenciais de e-mail necess√°rias est√£o definidas.
    """
    print("\nTeste: MAIL_ENABLED=True e todas credenciais de e-mail fornecidas -> Deve passar a valida√ß√£o.")

    # --- Arrange: Configurar vari√°veis de ambiente ---
    # 1. Limpar vari√°veis de e-mail.
    print("  Limpando vari√°veis de ambiente de e-mail...")
    monkeypatch.delenv("MAIL_ENABLED", raising=False)
    monkeypatch.delenv("MAIL_USERNAME", raising=False)
    monkeypatch.delenv("MAIL_PASSWORD", raising=False)
    monkeypatch.delenv("MAIL_FROM", raising=False)
    monkeypatch.delenv("MAIL_PORT", raising=False)
    monkeypatch.delenv("MAIL_SERVER", raising=False)
    monkeypatch.delenv("MAIL_TLS", raising=False)
    monkeypatch.delenv("MAIL_SSL", raising=False)

    # 2. Definir vari√°veis obrigat√≥rias n√£o relacionadas a e-mail.
    print("  Definindo vari√°veis de ambiente obrigat√≥rias (n√£o-email)...")
    monkeypatch.setenv("PROJECT_NAME", "Test Project All Mail")
    monkeypatch.setenv("API_V1_STR", "/api/v1")
    monkeypatch.setenv("ENVIRONMENT", "test")
    monkeypatch.setenv("JWT_SECRET_KEY", "test_jwt_secret_for_all_mail")
    monkeypatch.setenv("ACCESS_TOKEN_EXPIRE_MINUTES", "15")
    monkeypatch.setenv("REFRESH_TOKEN_EXPIRE_DAYS", "3")
    monkeypatch.setenv("MONGODB_URL", "mongodb://localhost:27017/test_all_mail_db")
    monkeypatch.setenv("DATABASE_NAME", "test_all_mail_db")


    # 3. Definir o cen√°rio: MAIL_ENABLED=True e todas as credenciais de e-mail fornecidas.
    print("  Definindo cen√°rio de teste: MAIL_ENABLED=True e todas credenciais de e-mail presentes.")
    monkeypatch.setenv("MAIL_ENABLED", "True")
    monkeypatch.setenv("MAIL_USERNAME", "test_mailer_user")
    monkeypatch.setenv("MAIL_PASSWORD", "supersecretmailerpassword")
    monkeypatch.setenv("MAIL_FROM", "noreply_tests@example.com")
    monkeypatch.setenv("MAIL_SERVER", "smtp.mailservice.example.com")
    monkeypatch.setenv("MAIL_PORT", "465") # Exemplo para SSL
    monkeypatch.setenv("MAIL_SSL", "True") # Exemplo com SSL
    monkeypatch.setenv("MAIL_TLS", "False")# Exemplo com SSL


    # --- Act & Assert: Tentar instanciar Settings e verificar se N√ÉO levanta exce√ß√£o ---
    print("  Tentando instanciar Settings, esperando sucesso...")
    try:
        settings_instance = Settings(_env_file=None)

        print(f"  Settings instanciado com sucesso: MAIL_ENABLED={settings_instance.MAIL_ENABLED}, MAIL_USERNAME='{settings_instance.MAIL_USERNAME}'")
        assert settings_instance.MAIL_ENABLED, "MAIL_ENABLED deveria ser True."
        assert settings_instance.MAIL_USERNAME == "test_mailer_user", "MAIL_USERNAME n√£o corresponde."
        assert settings_instance.MAIL_PASSWORD == "supersecretmailerpassword"
        assert settings_instance.MAIL_FROM == "noreply_tests@example.com"
        assert settings_instance.MAIL_SERVER == "smtp.mailservice.example.com"
        assert settings_instance.MAIL_PORT == 465

    except (ValueError, ValidationError) as e:
        pytest.fail(
            "A valida√ß√£o de Settings falhou inesperadamente quando MAIL_ENABLED=True e todas as credenciais "
            f"de e-mail foram fornecidas. Erro: {e}\n"
            f"Vari√°veis de ambiente configuradas: {dict(os.environ)}"
        )
    print("  Valida√ß√£o passou como esperado com MAIL_ENABLED=True e todas credenciais de e-mail presentes.")

def test_settings_missing_required_pydantic_field_fails(monkeypatch):
    print("\nTeste: Campo Pydantic obrigat√≥rio ausente -> Deve falhar a valida√ß√£o.")
    monkeypatch.delenv("JWT_SECRET_KEY", raising=False) # Ou MONGODB_URL
    # Certifique-se que MONGODB_URL est√° definido se voc√™ est√° testando a falta de JWT_SECRET_KEY, etc.
    monkeypatch.setenv("MONGODB_URL", "mongodb://localhost:27017/test_config_db")

    # Definir MAIL_ENABLED como False para que check_mail_config n√£o interfira
    monkeypatch.setenv("MAIL_ENABLED", "False")

    with pytest.raises(ValidationError) as exc_info:
        Settings(_env_file=None)
    
    assert "JWT_SECRET_KEY" in str(exc_info.value).upper() or "FIELD REQUIRED" in str(exc_info.value).upper()
    print(f"  Pydantic ValidationError capturada como esperado: {exc_info.value}")

================================================================================
Cap√≠tulo 20: tests/test_core_dependencies.py
================================================================================

# tests/test_core_dependencies.py
"""
Este m√≥dulo cont√©m testes unit√°rios para as depend√™ncias de seguran√ßa
definidas em `app.core.dependencies`.

As depend√™ncias testadas s√£o:
- `get_current_user`: Respons√°vel por decodificar o token JWT, validar o payload
  e buscar o usu√°rio correspondente no banco de dados.
- `get_current_active_user`: Uma depend√™ncia que consome o resultado de
  `get_current_user` e verifica se o usu√°rio n√£o est√° desativado.

Os testes utilizam mocks para isolar as depend√™ncias de chamadas reais
ao banco de dados ou fun√ß√µes de decodifica√ß√£o de token.
"""

# ========================
# --- Importa√ß√µes ---
# ========================
import uuid
from datetime import datetime, timezone
from unittest.mock import AsyncMock, MagicMock, patch 
import pytest
from fastapi import HTTPException, status

# --- M√≥dulos da Aplica√ß√£o ---
from app.core.dependencies import (get_current_active_user, get_current_user,
                                   oauth2_scheme)
from app.models.token import TokenPayload
from app.models.user import UserInDB

# ====================================
# --- Marcador Global de Teste ---
# ====================================
pytestmark = pytest.mark.asyncio

# ========================================
# --- Fixtures para Mocks Comuns ---
# ========================================
@pytest.fixture
def mock_db() -> AsyncMock:
    """
    Fixture que retorna um `AsyncMock` para simular a depend√™ncia do banco de dados (`DbDep`).
    Isso permite testar as fun√ß√µes de depend√™ncia sem uma conex√£o real com o banco.
    """
    return AsyncMock()

@pytest.fixture
def mock_valid_token_str() -> str:
    """
    Fixture que retorna uma string de token JWT mockada e v√°lida.
    O conte√∫do real do token n√£o importa aqui, pois `decode_token` ser√° mockado.
    """
    return "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c"

# ===================================================
# --- Testes para a depend√™ncia `get_current_user` ---
# ===================================================
async def test_get_current_user_success(
    mock_db: AsyncMock, 
    mock_valid_token_str: str 
):
    """
    Testa o cen√°rio de sucesso para `get_current_user`.

    Verifica se:
    - `decode_token` √© chamado corretamente com o token fornecido.
    - `user_crud.get_user_by_id` √© chamado com o ID do usu√°rio do payload do token.
    - A fun√ß√£o retorna o objeto `UserInDB` esperado.
    """
    test_user_id = uuid.uuid4()
    test_username = "test_active_user"
    expected_user_obj = UserInDB(
        id=test_user_id,
        username=test_username,
        email="testuser@example.com",
        hashed_password="fake_hashed_password",
        disabled=False,
        created_at=datetime.now(timezone.utc)
    )
    mock_token_payload = TokenPayload(sub=test_user_id, username=test_username)
    

    
    with patch("app.core.dependencies.decode_token", return_value=mock_token_payload) as mock_decode_jwt, \
         patch("app.core.dependencies.user_crud.get_user_by_id", return_value=expected_user_obj) as mock_get_user:

       
        retrieved_user = await get_current_user(db=mock_db, token=mock_valid_token_str)

        # --- Assert: Verificar chamadas e resultado ---
        mock_decode_jwt.assert_called_once_with(mock_valid_token_str)
        mock_get_user.assert_awaited_once_with(db=mock_db, user_id=test_user_id)
        assert retrieved_user == expected_user_obj, "Usu√°rio retornado n√£o √© o esperado."


async def test_get_current_user_invalid_or_expired_token(
    mock_db: AsyncMock,
    mock_valid_token_str: str 
):
    """
    Testa `get_current_user` quando `decode_token` falha (retorna None),
    simulando um token JWT inv√°lido, malformado ou expirado.

    Verifica se:
    - Uma `HTTPException` com status 401 √© levantada.
    - A mensagem de detalhe da exce√ß√£o √© a esperada.
    """

    # --- Arrange: Mockar `decode_token` para simular falha na decodifica√ß√£o ---
    with patch("app.core.dependencies.decode_token", return_value=None) as mock_decode_jwt:

        # --- Act & Assert: Chamar a depend√™ncia e verificar a exce√ß√£o ---
        with pytest.raises(HTTPException) as exc_info:
            await get_current_user(db=mock_db, token=mock_valid_token_str)
        
        assert exc_info.value.status_code == status.HTTP_401_UNAUTHORIZED, "Status code n√£o √© 401."
        assert "N√£o foi poss√≠vel validar as credenciais" in exc_info.value.detail, \
            "Mensagem de detalhe da exce√ß√£o n√£o √© a esperada."
        mock_decode_jwt.assert_called_once_with(mock_valid_token_str)

async def test_get_current_user_user_not_found_in_db(
    mock_db: AsyncMock,
    mock_valid_token_str: str
):
    """
    Testa `get_current_user` quando o token √© v√°lido e decodificado com sucesso,
    mas o ID de usu√°rio (sub) contido no payload do token n√£o corresponde
    a nenhum usu√°rio no banco de dados.

    Verifica se:
    - Uma `HTTPException` com status 401 √© levantada.
    - A mensagem de detalhe da exce√ß√£o √© a esperada.
    - `user_crud.get_user_by_id` √© chamado.
    """
    test_user_id_not_in_db = uuid.uuid4()
    mock_token_payload = TokenPayload(sub=test_user_id_not_in_db, username="ghost_user")

    # --- Arrange: Mockar `decode_token` para retornar um payload v√°lido,
    with patch("app.core.dependencies.decode_token", return_value=mock_token_payload) as mock_decode_jwt, \
         patch("app.core.dependencies.user_crud.get_user_by_id", return_value=None) as mock_get_user:
        
        # --- Act & Assert: Chamar a depend√™ncia e verificar a exce√ß√£o ---
        with pytest.raises(HTTPException) as exc_info:
            await get_current_user(db=mock_db, token=mock_valid_token_str)

        assert exc_info.value.status_code == status.HTTP_401_UNAUTHORIZED, "Status code n√£o √© 401."
        assert "N√£o foi poss√≠vel validar as credenciais" in exc_info.value.detail, \
            "Mensagem de detalhe da exce√ß√£o n√£o √© a esperada para usu√°rio n√£o encontrado."
        mock_decode_jwt.assert_called_once_with(mock_valid_token_str)
        mock_get_user.assert_awaited_once_with(db=mock_db, user_id=test_user_id_not_in_db)

# =========================================================
# --- Testes para a depend√™ncia `get_current_active_user` ---
# =========================================================

async def test_get_current_active_user_when_user_is_disabled():
    """
    Testa `get_current_active_user` passando um objeto `UserInDB`
    que representa um usu√°rio desativado (`disabled=True`).

    Verifica se:
    - Uma `HTTPException` com status 400 Bad Request √© levantada.
    - A mensagem de detalhe da exce√ß√£o indica "Usu√°rio inativo".
    """
    
    # ========================
    # --- Arrange ---
    # ========================
    disabled_user_mock = UserInDB(
        id=uuid.uuid4(),
        username="inactive_user",
        email="inactive@example.com",
        hashed_password="fake_hashed_password",
        disabled=True, # Usu√°rio est√° desativado.
        created_at=datetime.now(timezone.utc)
    )

    # ========================
    # --- Act ---
    # ========================
    with pytest.raises(HTTPException) as exc_info:
        await get_current_active_user(current_user=disabled_user_mock) 
    
    # ========================
    # --- Assert ---
    # ========================
    assert exc_info.value.status_code == status.HTTP_400_BAD_REQUEST, "Status code n√£o √© 400."
    assert "Usu√°rio inativo" in exc_info.value.detail, "Mensagem de detalhe da exce√ß√£o n√£o √© 'Usu√°rio inativo'."


async def test_get_current_active_user_when_user_is_active():
    """
    Testa `get_current_active_user` passando um objeto `UserInDB`
    que representa um usu√°rio ativo (`disabled=False`).

    Verifica se:
    - A fun√ß√£o retorna o mesmo objeto de usu√°rio que foi passado.
    - Nenhuma exce√ß√£o √© levantada.
    """

    # ========================
    # --- Arrange ---
    # ========================
    active_user_mock = UserInDB(
        id=uuid.uuid4(),
        username="active_user",
        email="active_user@example.com",
        hashed_password="fake_hashed_password",
        disabled=False, 
        created_at=datetime.now(timezone.utc)
    )

    # ========================
    # --- Act ---
    # ========================
    returned_user = await get_current_active_user(current_user=active_user_mock)

    # ========================
    # --- Assert ---
    # ========================
    assert returned_user == active_user_mock, "Usu√°rio ativo retornado n√£o √© o mesmo que foi passado."


async def test_get_current_user_invalid_sub_uuid_format(mock_db, mock_valid_token_str, mocker): # type: ignore
    """
    Testa get_current_user quando o 'sub' no token n√£o √© um UUID v√°lido.
    """
    # ========================
    # --- Arrange ---
    # ========================
    invalid_sub_str = "not-a-uuid-at-all"
    mock_payload_dict = {"sub": invalid_sub_str, "username": "invalidsubuser"}

    # Mock decode_token para retornar o *dicion√°rio* inv√°lido
    # Precisamos mockar `TokenPayload.model_validate` dentro de decode_token
    # OU, mais simples, mockar diretamente `decode_token` para retornar algo
    # que passe as primeiras checagens mas falhe no UUID().
    # Vamos usar um MagicMock para simular o TokenPayload retornado por decode_token
    mock_token_payload_obj = MagicMock()
    mock_token_payload_obj.sub = invalid_sub_str # O atributo 'sub' tem a string inv√°lida

    mock_decode = mocker.patch("app.core.dependencies.decode_token", return_value=mock_token_payload_obj)
    mock_get_user = mocker.patch("app.core.dependencies.user_crud.get_user_by_id", new_callable=AsyncMock)

    # ========================
    # --- Act & Assert ---
    # ========================
    with pytest.raises(HTTPException) as exc_info:
        await get_current_user(db=mock_db, token=mock_valid_token_str)

    assert exc_info.value.status_code == status.HTTP_401_UNAUTHORIZED
    assert "N√£o foi poss√≠vel validar as credenciais" in exc_info.value.detail

    mock_decode.assert_called_once_with(mock_valid_token_str)
    mock_get_user.assert_not_called()

================================================================================
Cap√≠tulo 21: tests/test_core_email.py
================================================================================

# tests/test_core_email.py
"""
Este m√≥dulo cont√©m testes unit√°rios para as fun√ß√µes de envio de e-mail
definidas em `app.core.email`.

Os testes verificam:
- Comportamento quando o envio de e-mail est√° desabilitado (`MAIL_ENABLED=False`).
- Comportamento quando faltam credenciais de e-mail obrigat√≥rias.
- Chamada correta √† biblioteca `fastapi-mail` (mockada) para envio de e-mails
  com templates HTML e em texto puro.
- Tratamento de exce√ß√µes durante o envio de e-mails.
- A l√≥gica espec√≠fica da fun√ß√£o `send_urgent_task_notification`, verificando
  os argumentos passados para a fun√ß√£o de envio gen√©rica `send_email_async`.

Todos os envios reais de e-mail s√£o mockados para evitar efeitos colaterais
e depend√™ncias externas durante os testes.
"""

# ========================
# --- Importa√ß√µes ---
# ========================
import uuid
import logging
from unittest.mock import AsyncMock, patch, ANY 

import pytest
from fastapi_mail import MessageSchema, MessageType 

# --- M√≥dulos da Aplica√ß√£o ---
from app.core.config import settings
from app.core.email import (conf, send_email_async, send_urgent_task_notification)
from app.core import email as email_module 

# ====================================
# --- Marcador Global de Teste ---
# ====================================
pytestmark = pytest.mark.asyncio

# ===========================================================
# --- Testes de Condi√ß√µes de Guarda para `send_email_async` ---
# ===========================================================
# Testes que verificam se `send_email_async` se comporta corretamente
# sob diferentes condi√ß√µes de configura√ß√£o (e-mail desabilitado, credenciais ausentes).

async def test_send_email_async_when_mail_is_disabled(mocker, caplog):
    """
    Testa se `send_email_async` N√ÉO tenta enviar um e-mail e loga uma mensagem informativa
    quando a configura√ß√£o `settings.MAIL_ENABLED` √© `False`.
    """
    print("\nTeste: send_email_async com MAIL_ENABLED=False.")
    # Arrange: Mockar `fm.send_message` para garantir que n√£o seja chamado.
    #          Mockar `settings.MAIL_ENABLED` para ser False.
    mock_fastapi_mail_send_message = mocker.patch("app.core.email.fm.send_message", new_callable=AsyncMock)
    mocker.patch.object(settings, 'MAIL_ENABLED', False)
    print("  Mock: fm.send_message e settings.MAIL_ENABLED=False.")

    # Act: Chamar a fun√ß√£o de envio de e-mail.
    print("  Atuando: Chamando send_email_async...")
    await send_email_async(
        subject="E-mail de Teste (Desabilitado)",
        recipient_to=["test_disabled@example.com"],
        body={"info": "Este e-mail n√£o deve ser enviado."},
        template_name="dummy_template_desabilitado.html"
    )

    # Assert: Verificar que `fm.send_message` n√£o foi chamado e que um log apropriado foi gerado.
    mock_fastapi_mail_send_message.assert_not_called()
    found_log = False
    expected_message = "Envio de e-mail desabilitado nas configura√ß√µes" 
    for record in caplog.records:
        if expected_message in record.message:
            assert record.levelname == "WARNING" 
            found_log = True
            break
    assert found_log, f"Log esperado contendo '{expected_message}' n√£o encontrado. Logs: {caplog.text}"
    print("  Sucesso: E-mail n√£o enviado e log de desativa√ß√£o presente.")


async def test_send_email_async_when_essential_credentials_are_missing(mocker):
    """
    Testa se `send_email_async` N√ÉO tenta enviar um e-mail e loga um erro
    quando `settings.MAIL_ENABLED` √© `True`, mas faltam credenciais essenciais
    (como MAIL_USERNAME, MAIL_PASSWORD, etc.).

    O teste √© parametrizado implicitamente por um loop para verificar a aus√™ncia
    de cada credencial essencial individualmente.
    """
    print("\nTeste: send_email_async com MAIL_ENABLED=True, mas faltando credenciais.")
    mock_fastapi_mail_send_message = mocker.patch("app.core.email.fm.send_message", new_callable=AsyncMock)
    mocker.patch.object(settings, 'MAIL_ENABLED', True)
    mock_email_module_logger = mocker.patch("app.core.email.logger")
    essential_mail_fields = ['MAIL_USERNAME', 'MAIL_PASSWORD', 'MAIL_FROM', 'MAIL_SERVER']

    for missing_field in essential_mail_fields:
        print(f"  Testando cen√°rio: Faltando '{missing_field}'...")
        # Define todas as credenciais, depois remove uma
        mocker.patch.object(settings, 'MAIL_USERNAME', 'test_user')
        mocker.patch.object(settings, 'MAIL_PASSWORD', 'test_password')
        mocker.patch.object(settings, 'MAIL_FROM', 'test_from@example.com') 
        mocker.patch.object(settings, 'MAIL_SERVER', 'smtp.example.com')
        mocker.patch.object(settings, 'MAIL_PORT', 587)
        mocker.patch.object(settings, 'MAIL_STARTTLS', True)
        mocker.patch.object(settings, 'MAIL_SSL_TLS', False)
        
        mocker.patch.object(settings, missing_field, None) 
        print(f"    Mock: {missing_field}=None, outras credenciais definidas.")

        mock_fastapi_mail_send_message.reset_mock()
        mock_email_module_logger.reset_mock()

        await send_email_async(
            subject=f"Teste de Credenciais (Falta {missing_field})",
            recipient_to=["test_cred_missing@example.com"], 
            body={"info": f"Teste com {missing_field} ausente."}
        )

        mock_fastapi_mail_send_message.assert_not_called()
        mock_email_module_logger.error.assert_called_once()
        log_call_args = mock_email_module_logger.error.call_args[0]
        assert "Configura√ß√µes essenciais de e-mail ausentes" in log_call_args[0], \
            f"Log de erro para '{missing_field}' ausente n√£o correspondeu. Log: {log_call_args[0]}"
        print(f"    Sucesso para '{missing_field}' ausente: E-mail n√£o enviado e erro logado.")
    print("  Todos os cen√°rios de credenciais ausentes verificados.")

# =========================================================
# --- Testes de Funcionalidade para `send_email_async` ---
# =========================================================
# Testes que verificam se `send_email_async` chama `fastapi-mail` corretamente
# quando as configura√ß√µes est√£o v√°lidas.

async def test_send_email_async_with_html_template_calls_fastapi_mail_correctly(mocker):
    """
    Testa se `send_email_async` chama `fm.send_message` (de `fastapi-mail`)
    corretamente quando um template HTML √© especificado.

    Verifica:
    - Se `fm.send_message` √© chamado uma vez.
    - Se o objeto `MessageSchema` passado para `fm.send_message` tem os atributos corretos
      (assunto, destinat√°rios, corpo do template, tipo HTML).
    - Se `template_name` √© passado corretamente como kwarg.
    - Se logs informativos s√£o gerados.
    """
    print("\nTeste: send_email_async com template HTML.")
    mock_fastapi_mail_send_message = mocker.patch("app.core.email.fm.send_message", new_callable=AsyncMock)
    mocker.patch.object(settings, 'MAIL_ENABLED', True)
    mocker.patch.object(settings, 'MAIL_USERNAME', 'test_user_template')
    mocker.patch.object(settings, 'MAIL_PASSWORD', 'test_pass_template')
    mocker.patch.object(settings, 'MAIL_FROM', 'sender_template@example.com') 
    mocker.patch.object(settings, 'MAIL_SERVER', 'smtp.template.example.com')
    mocker.patch.object(settings, 'MAIL_PORT', 587)
    mock_email_module_logger_info = mocker.patch("app.core.email.logger.info")
    print("  Mock: fm.send_message, settings de e-mail (habilitado), logger.info.")

    test_subject = "Assunto do E-mail com Template HTML"
    test_recipient = "recipient_html@example.com"
    test_body_dict_for_template = {"user_name": "Claudio", "item_name": "SmartTask"}
    test_template_file_name = "meu_template_email.html"

    print(f"  Atuando: Chamando send_email_async com template '{test_template_file_name}'...")
    await send_email_async(
        subject=test_subject,
        recipient_to=[test_recipient],
        body=test_body_dict_for_template,
        template_name=test_template_file_name
    )

    mock_fastapi_mail_send_message.assert_called_once()
    message_arg_schema: MessageSchema = mock_fastapi_mail_send_message.call_args[0][0]
    template_arg_name_from_kwargs = mock_fastapi_mail_send_message.call_args.kwargs.get('template_name')

    assert isinstance(message_arg_schema, MessageSchema)
    assert message_arg_schema.subject == test_subject
    assert message_arg_schema.recipients == [test_recipient]
    assert message_arg_schema.template_body == test_body_dict_for_template
    assert message_arg_schema.body is None
    assert message_arg_schema.subtype == MessageType.html
    assert template_arg_name_from_kwargs == test_template_file_name
    assert mock_email_module_logger_info.call_count >= 2
    print(f"  Sucesso: fm.send_message chamado corretamente para template HTML.")


async def test_send_email_async_with_plain_text_calls_fastapi_mail_correctly(mocker):
    """
    Testa se `send_email_async` chama `fm.send_message` (de `fastapi-mail`)
    corretamente quando um corpo de e-mail em texto puro √© especificado.

    Verifica:
    - Se `fm.send_message` √© chamado uma vez.
    - Se o objeto `MessageSchema` passado tem os atributos corretos
      (assunto, destinat√°rios, corpo de texto puro, tipo PLAIN).
    - Se `template_name` N√ÉO √© passado.
    - Se logs informativos s√£o gerados.
    """
    print("\nTeste: send_email_async com texto puro.")
    # Arrange: Configurar mocks e settings.
    mock_fastapi_mail_send_message = mocker.patch("app.core.email.fm.send_message", new_callable=AsyncMock)
    mocker.patch.object(settings, 'MAIL_ENABLED', True)
    # Reutilizando settings dos testes anteriores para simplicidade, ajuste se necess√°rio.
    mocker.patch.object(settings, 'MAIL_USERNAME', 'test_user_plain')
    mocker.patch.object(settings, 'MAIL_PASSWORD', 'test_pass_plain')
    mocker.patch.object(settings, 'MAIL_FROM', 'sender_plain@example.com')
    mocker.patch.object(settings, 'MAIL_SERVER', 'smtp.plain.example.com')
    mocker.patch.object(settings, 'MAIL_PORT', 587)
    mock_email_module_logger_info = mocker.patch("app.core.email.logger.info")
    print("  Mock: fm.send_message, settings de e-mail (habilitado), logger.info.")

    # Dados de teste.
    test_subject = "Assunto do E-mail em Texto Puro"
    test_recipient = "recipient_plain@example.com"
    test_plain_body_content = "Este √© o corpo do e-mail em texto puro.\nCom m√∫ltiplas linhas."

    # Act: Chamar a fun√ß√£o de envio.
    print(f"  Atuando: Chamando send_email_async com texto puro...")
    await send_email_async(
        subject=test_subject,
        recipient_to=[test_recipient],
        body=None, # `body` (para template) deve ser None.
        plain_text_body=test_plain_body_content 
    )

    # Assert: Verificar a chamada e seus argumentos.
    mock_fastapi_mail_send_message.assert_called_once()
    message_arg_schema: MessageSchema = mock_fastapi_mail_send_message.call_args[0][0]
    template_arg_name_from_kwargs = mock_fastapi_mail_send_message.call_args.kwargs.get('template_name')

    assert isinstance(message_arg_schema, MessageSchema), "Argumento n√£o √© MessageSchema."
    assert message_arg_schema.subject == test_subject, "Assunto n√£o corresponde."
    assert message_arg_schema.recipients == [test_recipient], "Destinat√°rios n√£o correspondem."
    assert message_arg_schema.template_body is None, "Corpo do template deveria ser None."
    assert message_arg_schema.body == test_plain_body_content, "Corpo de texto puro n√£o corresponde."
    assert message_arg_schema.subtype == MessageType.plain, "Subtipo n√£o √© PLAIN."
    assert template_arg_name_from_kwargs is None, "Nome do template deveria ser None para e-mail de texto puro."
    assert mock_email_module_logger_info.call_count >= 2, "Logs informativos n√£o foram chamados."
    print(f"  Sucesso: fm.send_message chamado corretamente para texto puro.")


async def test_send_email_async_handles_exception_from_fastapi_mail(mocker):
    """
    Testa o tratamento de erro em `send_email_async` quando a chamada
    a `fm.send_message` (de `fastapi-mail`) levanta uma exce√ß√£o (ex: erro SMTP).

    Verifica:
    - Se `fm.send_message` √© chamado.
    - Se `logger.exception` √© chamado para logar o erro.
    - Se a mensagem de log de exce√ß√£o cont√©m informa√ß√µes √∫teis.
    """
    print("\nTeste: send_email_async tratando exce√ß√£o do fm.send_message.")
    # Arrange: Configurar settings para permitir envio e mockar fm.send_message para levantar erro.
    simulated_smtp_error_message = "Simulated SMTP Connection Error (535 Authentication credentials invalid)"
    mock_fastapi_mail_send_message = mocker.patch(
        "app.core.email.fm.send_message",
        new_callable=AsyncMock,
        side_effect=Exception(simulated_smtp_error_message) 
    )
    mocker.patch.object(settings, 'MAIL_ENABLED', True)
    mocker.patch.object(settings, 'MAIL_USERNAME', 'user_excp')
    mocker.patch.object(settings, 'MAIL_PASSWORD', 'pass_excp')
    mocker.patch.object(settings, 'MAIL_FROM', 'sender_excp@example.com')
    mocker.patch.object(settings, 'MAIL_SERVER', 'smtp.excp.example.com')
    mocker.patch.object(settings, 'MAIL_PORT', 587)
    mock_email_module_logger_exception = mocker.patch("app.core.email.logger.exception")
    print("  Mock: fm.send_message (para levantar erro), settings, logger.exception.")

    test_recipient_list = ["recipient_error@example.com"]
    # Act: Chamar a fun√ß√£o de envio.
    print(f"  Atuando: Chamando send_email_async (esperando que fm.send_message falhe)...")
    await send_email_async(
        subject="E-mail de Teste de Erro de Envio",
        recipient_to=test_recipient_list,
        body={"info": "Este envio deve falhar e ser logado."}
    )

    # Assert: Verificar mocks.
    mock_fastapi_mail_send_message.assert_called_once()
    mock_email_module_logger_exception.assert_called_once()
    
    # Verifica a mensagem logada por logger.exception.
    log_message_args = mock_email_module_logger_exception.call_args[0] # (args, kwargs)
    logged_error_message_str = log_message_args[0]
    
    assert f"Erro ao enviar e-mail para {test_recipient_list}" in logged_error_message_str, \
        "Mensagem de log de exce√ß√£o n√£o cont√©m os destinat√°rios."
    # A exce√ß√£o original (`side_effect`) deve estar na mensagem de log tamb√©m (via f-string ou %s).
    assert simulated_smtp_error_message in logged_error_message_str or \
           simulated_smtp_error_message in str(mock_email_module_logger_exception.call_args.kwargs.get('exc_info')), \
        "A mensagem de erro original do SMTP n√£o foi inclu√≠da no log de exce√ß√£o."
    print("  Sucesso: Exce√ß√£o do fm.send_message tratada e logada corretamente.")


# ================================================================
# --- Testes Unit√°rios para `send_urgent_task_notification` ---
# ================================================================
# Estes testes focam na l√≥gica espec√≠fica de `send_urgent_task_notification`,
# mockando a fun√ß√£o gen√©rica `send_email_async` que ela chama.

@pytest.fixture(autouse=True) # `autouse=True` aplica este mock a todos os testes *neste escopo/m√≥dulo* (se n√£o estiver em uma classe).
                              # Para maior controle, poderia ser passado explicitamente para cada teste.
def auto_mock_send_email_async_for_urgent_tests(mocker) -> AsyncMock:
    """
    Fixture que mocka automaticamente `app.core.email.send_email_async`
    para todos os testes de `send_urgent_task_notification` neste arquivo.
    Retorna o mock para que possa ser usado nas asser√ß√µes.
    """
    print("  Fixture (autouse): Mockando app.core.email.send_email_async.")
    mocked_function = mocker.patch("app.core.email.send_email_async", new_callable=AsyncMock)
    return mocked_function


async def test_send_urgent_task_notification_constructs_correct_arguments(
    auto_mock_send_email_async_for_urgent_tests: AsyncMock, 
    mocker
):
    """
    Verifica se `send_urgent_task_notification` chama `send_email_async`
    com os argumentos corretos (assunto, destinat√°rio, nome do template, e corpo do template)
    quando todos os dados de entrada s√£o fornecidos.
    """
    print("\nTeste: send_urgent_task_notification com todos os dados e FRONTEND_URL.")
    # Arrange: Definir dados de teste e mockar settings.FRONTEND_URL.
    test_frontend_base_url = "http://smarttask.dev"
    mocker.patch.object(settings, 'FRONTEND_URL', test_frontend_base_url)
    print(f"  Mock: settings.FRONTEND_URL='{test_frontend_base_url}'.")

    user_email_addr = "urgent_user@example.com"
    user_full_name = "Urgent User Name"
    task_display_title = "URGENT: Resolver bug cr√≠tico na API!"
    task_unique_id = str(uuid.uuid4())
    task_due_date_str = "2025-01-01"
    task_priority_score_float = 123.456

    # Act: Chamar a fun√ß√£o a ser testada.
    print("  Atuando: Chamando send_urgent_task_notification...")
    await email_module.send_urgent_task_notification(
        user_email=user_email_addr,
        user_name=user_full_name,
        task_title=task_display_title,
        task_id=task_unique_id,
        task_due_date=task_due_date_str,
        priority_score=task_priority_score_float
    )

    # Assert: Verificar se `send_email_async` foi chamado uma vez com os argumentos corretos.
    auto_mock_send_email_async_for_urgent_tests.assert_awaited_once() 
    
    # `call_args.kwargs` cont√©m os argumentos nomeados passados para o mock.
    called_with_kwargs = auto_mock_send_email_async_for_urgent_tests.call_args.kwargs
    print(f"  Argumentos passados para send_email_async (mock): {called_with_kwargs}")

    assert called_with_kwargs.get("subject") == f"üö® Tarefa Urgente no SmartTask: {task_display_title}", "Assunto do e-mail incorreto."
    assert called_with_kwargs.get("recipient_to") == [user_email_addr], "Destinat√°rio incorreto."
    assert called_with_kwargs.get("template_name") == "urgent_task.html", "Nome do template incorreto."
    assert called_with_kwargs.get("plain_text_body") is not None, "Corpo de texto puro alternativo deveria ser gerado."

    # Verifica o conte√∫do do dicion√°rio `body` passado para o template.
    template_body_dict = called_with_kwargs.get("body")
    assert isinstance(template_body_dict, dict), "Corpo do template n√£o √© um dicion√°rio."
    assert template_body_dict.get("task_title") == task_display_title
    assert template_body_dict.get("user_name") == user_full_name
    assert template_body_dict.get("due_date") == task_due_date_str
    # Verifica se a pontua√ß√£o de prioridade foi formatada para duas casas decimais.
    assert template_body_dict.get("priority_score") == f"{task_priority_score_float:.2f}"
    assert template_body_dict.get("task_link") == f"{test_frontend_base_url}/tasks/{task_unique_id}"
    assert template_body_dict.get("project_name") == settings.PROJECT_NAME
    print("  Sucesso: send_urgent_task_notification passou os argumentos corretos para send_email_async.")


async def test_send_urgent_task_notification_handles_no_due_date_and_no_frontend_url(
    auto_mock_send_email_async_for_urgent_tests: AsyncMock,
    mocker
):
    """
    Verifica se `send_urgent_task_notification` lida corretamente com cen√°rios
    onde `task_due_date` √© None e `settings.FRONTEND_URL` n√£o est√° definida.
    O `due_date` no corpo do template deve ser "N/A" e `task_link` deve ser None.
    """
    print("\nTeste: send_urgent_task_notification sem due_date e sem FRONTEND_URL.")
    # Arrange: Mockar settings.FRONTEND_URL para ser None.
    mocker.patch.object(settings, 'FRONTEND_URL', None)
    print("  Mock: settings.FRONTEND_URL=None.")

    user_email_addr = "nodate_nolink_user@example.com"
    user_full_name = "User Without Due Date"
    task_display_title = "Tarefa Opcional Sem Prazo ou Link"
    task_unique_id = str(uuid.uuid4())
    task_priority_score_float = 500.0

    # Act: Chamar a fun√ß√£o.
    print("  Atuando: Chamando send_urgent_task_notification com task_due_date=None...")
    await email_module.send_urgent_task_notification(
        user_email=user_email_addr,
        user_name=user_full_name,
        task_title=task_display_title,
        task_id=task_unique_id,
        task_due_date=None, 
        priority_score=task_priority_score_float
    )

    # Assert: Verificar argumentos, focando em `due_date` e `task_link`.
    auto_mock_send_email_async_for_urgent_tests.assert_awaited_once()
    called_with_kwargs = auto_mock_send_email_async_for_urgent_tests.call_args.kwargs
    print(f"  Argumentos passados (body): {called_with_kwargs.get('body')}")

    assert called_with_kwargs.get("recipient_to") == [user_email_addr]
    template_body_dict = called_with_kwargs.get("body")
    assert isinstance(template_body_dict, dict)
    assert template_body_dict.get("due_date") == "N/A", "due_date no template deveria ser 'N/A'."
    assert template_body_dict.get("task_link") is None, "task_link no template deveria ser None."
    print("  Sucesso: Cen√°rio sem due_date e FRONTEND_URL tratado corretamente.")

================================================================================
Cap√≠tulo 22: tests/test_core_security.py
================================================================================

# tests/test_core_security.py
"""
Este m√≥dulo cont√©m testes unit√°rios para as fun√ß√µes de seguran√ßa relacionadas
a senhas, definidas em `app.core.security`.

As fun√ß√µes testadas s√£o:
- `get_password_hash`: Para gerar o hash de uma senha.
- `verify_password`: Para verificar uma senha em texto puro contra um hash existente.

Os testes cobrem cen√°rios de sucesso, falha (senha incorreta, hash inv√°lido)
e a propriedade de que hashes diferentes s√£o gerados para a mesma senha
devido ao uso de "salt".
"""

# ========================
# --- Importa√ß√µes ---
# ========================
from typing import Optional
from venv import logger
import pytest
from datetime import datetime, timedelta, timezone
from jose import ExpiredSignatureError, jwt
import uuid


# --- M√≥dulos da Aplica√ß√£o ---
from app.core.config import settings
from app.core.security import  ALGORITHM, decode_token, get_password_hash, verify_password, create_access_token

# =====================================
# --- Constantes de Teste ---
# =====================================
TEST_PLAIN_PASSWORD = "!@#$_uma_SENHA_extremamente_SEGURA_para_TESTES_!@#$"
TEST_USER_ID_JWT = str(uuid.uuid4())
TEST_USERNAME_JWT = "test_jwt_user"
CUSTOM_EXPIRATION_MINUTES = 15

# =================================================
# --- Testes para `get_password_hash` ---
# =================================================

def test_get_password_hash_returns_non_empty_string_different_from_plain_password():
    """
    Testa se a fun√ß√£o `get_password_hash`:
    1. Retorna uma string.
    2. A string n√£o √© vazia.
    3. O hash retornado √© diferente da senha original em texto puro.
    """
    print(f"\nTeste: get_password_hash com senha: '{TEST_PLAIN_PASSWORD}'")

    # --- Act: Gerar o hash da senha ---
    generated_hash = get_password_hash(TEST_PLAIN_PASSWORD)
    print(f"  Hash gerado: '{generated_hash[:20]}...' (parcial para brevidade)")

    # --- Assert: Verificar as propriedades do hash ---
    assert isinstance(generated_hash, str), "O hash retornado n√£o √© uma string."
    assert len(generated_hash) > 0, "O hash retornado est√° vazio."
    assert generated_hash != TEST_PLAIN_PASSWORD, "O hash retornado √© igual √† senha original (n√£o deveria)."
    print("  Sucesso: Hash gerado √© uma string n√£o vazia e diferente da senha original.")

def test_get_password_hash_generates_different_hashes_for_same_password_due_to_salt():
    """
    Testa se `get_password_hash` gera hashes diferentes para a mesma senha
    quando chamada m√∫ltiplas vezes. Isso demonstra o uso correto de "salts"
    na fun√ß√£o de hashing.

    Tamb√©m verifica se ambos os hashes gerados s√£o v√°lidos para a senha original.
    """
    print(f"\nTeste: get_password_hash gera hashes diferentes para a mesma senha: '{TEST_PLAIN_PASSWORD}'")

    # --- Act: Gerar dois hashes para a mesma senha ---
    hash1 = get_password_hash(TEST_PLAIN_PASSWORD)
    hash2 = get_password_hash(TEST_PLAIN_PASSWORD)
    print(f"  Hash 1: '{hash1[:20]}...'")
    print(f"  Hash 2: '{hash2[:20]}...'")

    # --- Assert: Verificar as propriedades ---
    assert hash1 != hash2, "Os dois hashes gerados para a mesma senha s√£o iguais (o salt pode n√£o estar funcionando)."
    assert verify_password(TEST_PLAIN_PASSWORD, hash1) is True, "O primeiro hash n√£o p√¥de ser verificado com a senha original."
    assert verify_password(TEST_PLAIN_PASSWORD, hash2) is True, "O segundo hash n√£o p√¥de ser verificado com a senha original."
    print("  Sucesso: Hashes diferentes foram gerados e ambos s√£o v√°lidos.")

# =================================================
# --- Testes para `verify_password` ---
# =================================================

def test_verify_password_with_correct_password_succeeds():
    """
    Testa se `verify_password` retorna `True` quando a senha correta em
    texto puro √© fornecida para um hash correspondente.
    """
    print(f"\nTeste: verify_password com senha correta: '{TEST_PLAIN_PASSWORD}'")
    # --- Arrange: Gerar um hash para a senha de teste ---
    password_hash = get_password_hash(TEST_PLAIN_PASSWORD)
    print(f"  Hash para verifica√ß√£o: '{password_hash[:20]}...'")

    # --- Act & Assert: Verificar a senha correta ---
    is_valid = verify_password(TEST_PLAIN_PASSWORD, password_hash)
    assert is_valid is True, "A verifica√ß√£o com a senha correta falhou (deveria ser True)."
    print("  Sucesso: Verifica√ß√£o com senha correta retornou True.")

def test_verify_password_with_incorrect_password_fails():
    """
    Testa se `verify_password` retorna `False` quando uma senha incorreta
    em texto puro √© fornecida para um hash.
    """
    incorrect_test_password = "esta_e_uma_senha_errada_!"
    print(f"\nTeste: verify_password com senha incorreta: '{incorrect_test_password}'")
    # --- Arrange: Gerar um hash para a senha de teste original ---
    password_hash = get_password_hash(TEST_PLAIN_PASSWORD) 
    print(f"  Hash (da senha correta '{TEST_PLAIN_PASSWORD}'): '{password_hash[:20]}...'")

    # --- Act & Assert: Verificar a senha incorreta ---
    is_valid = verify_password(incorrect_test_password, password_hash)
    assert is_valid is False, "A verifica√ß√£o com senha incorreta passou (deveria ser False)."
    print("  Sucesso: Verifica√ß√£o com senha incorreta retornou False.")

def test_verify_password_with_empty_plain_password_fails():
    """
    Testa se `verify_password` retorna `False` quando uma senha vazia
    em texto puro √© fornecida, mesmo contra um hash de uma senha n√£o vazia.
    """
    empty_password = ""
    print(f"\nTeste: verify_password com senha vazia em texto puro ('{empty_password}')")
    # --- Arrange: Gerar um hash para a senha de teste original (n√£o vazia) ---
    password_hash = get_password_hash(TEST_PLAIN_PASSWORD)
    print(f"  Hash (da senha correta '{TEST_PLAIN_PASSWORD}'): '{password_hash[:20]}...'")

    # --- Act & Assert: Verificar a senha vazia ---
    is_valid = verify_password(empty_password, password_hash)
    assert is_valid is False, "A verifica√ß√£o com senha vazia passou (deveria ser False)."
    print("  Sucesso: Verifica√ß√£o com senha vazia retornou False.")

def test_verify_password_with_plain_password_against_empty_hash_string_fails():
    """
    Testa se `verify_password` retorna `False` (ou levanta uma exce√ß√£o esperada,
    dependendo da implementa√ß√£o de passlib) quando a string de hash fornecida
    √© vazia.
    """
    empty_hash_string = ""
    print(f"\nTeste: verify_password com string de hash vazia ('{empty_hash_string}')")

    # --- Act & Assert: Verificar senha contra hash vazio ---
    is_valid = verify_password(TEST_PLAIN_PASSWORD, empty_hash_string)
    assert is_valid is False, \
        "A verifica√ß√£o contra um hash vazio deveria retornar False (ou a biblioteca pode ter outro comportamento)."
    print("  Sucesso: Verifica√ß√£o contra hash vazio retornou False.")

def test_verify_password_with_invalid_hash_format_fails():
    """
    Testa se `verify_password` retorna `False` (ou lida graciosamente)
    quando a string de hash fornecida n√£o √© um formato de hash bcrypt v√°lido
    reconhecido pela biblioteca (passlib).
    """
    invalid_hash_string = "isto_claramente_nao_e_um_hash_bcrypt_valido_$"
    print(f"\nTeste: verify_password com formato de hash inv√°lido: '{invalid_hash_string}'")

    # --- Act & Assert: Verificar senha contra hash inv√°lido ---
    is_valid = verify_password(TEST_PLAIN_PASSWORD, invalid_hash_string)
    assert is_valid is False, \
        "A verifica√ß√£o contra um hash de formato inv√°lido deveria retornar False."
    print("  Sucesso: Verifica√ß√£o contra hash de formato inv√°lido retornou False.")

# =================================================
# --- Testes para JWT (create_access_token, decode_token) ---
# =================================================

def test_create_access_token_with_custom_expires_delta():
    """
    Testa se `create_access_token` utiliza o `expires_delta` fornecido
    para definir o tempo de expira√ß√£o do token.
    Cobre a linha onde `expire = datetime.now(timezone.utc) + expires_delta` √© executada.
    """
    print(f"\nTeste: create_access_token com expires_delta customizado")
    custom_delta = timedelta(minutes=CUSTOM_EXPIRATION_MINUTES)
    
    # --- Act: Criar o token com expires_delta customizado ---
    start_time = datetime.now(timezone.utc)
    token = create_access_token(
        subject=TEST_USER_ID_JWT,
        username=TEST_USERNAME_JWT,
        expires_delta=custom_delta
    )
    end_time = datetime.now(timezone.utc)
    print(f"  Token gerado: '{token[:20]}...'")

    # --- Assert: Decodificar e verificar o payload e a expira√ß√£o ---
    assert token is not None, "Token n√£o deveria ser None."
    assert isinstance(token, str), "Token deveria ser uma string."
    try:
        payload = jwt.decode(
            token,
            settings.JWT_SECRET_KEY,
            algorithms=[settings.JWT_ALGORITHM]
        )
        print(f"  Payload decodificado: {payload}")
        expected_sub = str(TEST_USER_ID_JWT)
        assert payload.get("sub") == expected_sub, \
            f"Claim 'sub' incorreto. Esperado: {expected_sub}, Obtido: {payload.get('sub')}"
        assert payload.get("username") == TEST_USERNAME_JWT, \
            f"Claim 'username' incorreto. Esperado: {TEST_USERNAME_JWT}, Obtido: {payload.get('username')}"
        exp_timestamp = payload.get("exp")
        assert exp_timestamp is not None, "Claim 'exp' n√£o encontrado no token."
        expected_expire_earliest = start_time + custom_delta
        expected_expire_latest = end_time + custom_delta
        token_expiration_time = datetime.fromtimestamp(exp_timestamp, tz=timezone.utc)
        assert expected_expire_earliest - timedelta(seconds=5) <= token_expiration_time <= expected_expire_latest + timedelta(seconds=5), \
            f"Tempo de expira√ß√£o fora do esperado. Esperado ~{start_time + custom_delta}, Obtido: {token_expiration_time}"
        print(f"  Sucesso: Token criado com expires_delta customizado e claims corretos.")
    except jwt.JWTError as e:
        pytest.fail(f"Falha ao decodificar o token gerado: {e}")

def test_decode_token_with_expired_token_returns_none_and_logs(caplog): 
    """
    Testa se `decode_token` retorna `None` e registra um log informativo
    quando um token JWT sintaticamente v√°lido, mas expirado, √© fornecido.
    Cobre as linhas 134-135 (logger.info e return None dentro da verifica√ß√£o de expira√ß√£o).
    """
    print(f"\nTeste: decode_token com token expirado")
    
    # --- Arrange: Criar um token que j√° est√° expirado ---
    expired_delta = timedelta(hours=-1)
    expire_time = datetime.now(timezone.utc) + expired_delta
    to_encode = {
        "exp": expire_time, 
        "sub": str(TEST_USER_ID_JWT),
        "username": TEST_USERNAME_JWT,
    }
    expired_token = jwt.encode(
        to_encode, 
        settings.JWT_SECRET_KEY, 
        algorithm=settings.JWT_ALGORITHM
    )
    print(f"  Token expirado gerado: '{expired_token[:20]}...'")

    # --- Act: Tentar decodificar o token expirado ---

    decoded_payload = decode_token(expired_token)

    # --- Assert: Verificar se o resultado √© None e o log foi feito ---
    assert decoded_payload is None, "Token expirado deveria resultar em None."
    
    log_messages = [record.getMessage() for record in caplog.records if record.name == 'app.core.security']
    assert any("Token JWT expirado (verifica√ß√£o dupla)." in message for message in log_messages), \
        "Mensagem de log para token expirado n√£o encontrada."
    print("  Sucesso: decode_token retornou None para token expirado e logou a informa√ß√£o.")

def test_decode_token_without_expiration_claim(caplog):
    """
    Testa se `decode_token` processa corretamente um token v√°lido
    que n√£o possui o claim 'exp'. Espera-se que retorne os dados do token.
    Cobre o bloco 'else: pass' na verifica√ß√£o de token_data.exp.
    """
    print("\nTeste: decode_token com token v√°lido sem claim 'exp'")
    user_id_as_string = str(uuid.uuid4()) 
    to_encode_no_exp = {
        "sub": user_id_as_string,
        "username": TEST_USERNAME_JWT,
    }
    token_no_exp = jwt.encode(
        to_encode_no_exp, 
        settings.JWT_SECRET_KEY, 
        algorithm=ALGORITHM
    )
    print(f"  Token sem 'exp' gerado: '{token_no_exp[:20]}...'")
    decoded_payload = decode_token(token_no_exp)
    assert decoded_payload is not None, "Token sem 'exp' deveria ser decodificado se 'exp' √© opcional."
    assert str(decoded_payload.sub) == user_id_as_string
    assert decoded_payload.username == TEST_USERNAME_JWT
    assert decoded_payload.exp is None, "O campo 'exp' do payload deveria ser None."
    assert not any("Token JWT expirado (verifica√ß√£o dupla)." in record.getMessage() for record in caplog.records if record.name == 'app.core.security'), \
        "Log de token expirado n√£o deveria ser emitido para token sem claim 'exp'."
    print("  Sucesso: decode_token processou token sem 'exp' e retornou payload.")

def test_decode_token_handles_direct_expired_signature_error_from_jose(mocker, caplog):
    """
    Testa o tratamento do bloco `except ExpiredSignatureError` em `decode_token`.
    Isso simula o caso onde `jwt.decode` diretamente levanta ExpiredSignatureError,
    mesmo que a l√≥gica atual use `options={'verify_exp': False}`.
    Cobre as linhas 133-134.
    """
    print("\nTeste: decode_token com ExpiredSignatureError direta do jose")
    some_token_string = "um.token.qualquer_expirado_simulado"
    mocked_jwt_decode = mocker.patch("app.core.security.jwt.decode", side_effect=ExpiredSignatureError("Simulated JOSE expiration"))
    decoded_payload = decode_token(some_token_string)
    assert decoded_payload is None, "Deveria retornar None quando ExpiredSignatureError √© capturada."
    mocked_jwt_decode.assert_called_once_with(
        some_token_string,
        settings.JWT_SECRET_KEY,
        algorithms=[ALGORITHM],
        options={"verify_exp": False} 
    )
    log_messages = [record.getMessage() for record in caplog.records if record.name == 'app.core.security']
    assert any("Token JWT detectado como expirado pela biblioteca JOSE" in message for message in log_messages), \
        "Mensagem de log esperada para ExpiredSignatureError n√£o encontrada."
    print("  Sucesso: decode_token lidou com ExpiredSignatureError direta e logou corretamente.")

================================================================================
Cap√≠tulo 23: tests/test_core_utils.py
================================================================================

# tests/test_core_utils.py
"""
Este m√≥dulo cont√©m testes unit√°rios para as fun√ß√µes utilit√°rias definidas
em `app.core.utils`, especificamente aquelas relacionadas √† l√≥gica de
neg√≥cios de tarefas, como c√°lculo de pontua√ß√£o de prioridade e
identifica√ß√£o de tarefas urgentes.

Os testes utilizam `freezegun` para mockar a data/hora atual, permitindo
testes consistentes e previs√≠veis de funcionalidades baseadas em datas.
"""

# ========================
# --- Importa√ß√µes ---
# ========================
import uuid
from datetime import date, datetime, timedelta, timezone

import pytest
from freezegun import freeze_time 

# --- M√≥dulos da Aplica√ß√£o ---
from app.core.config import settings 
from app.core.utils import calculate_priority_score, is_task_urgent
from app.models.task import Task, TaskStatus

# =====================================================
# --- Testes para `calculate_priority_score` ---
# =====================================================
# Testes que verificam a l√≥gica de c√°lculo da pontua√ß√£o de prioridade.

def test_calculate_priority_score_with_invalid_importance_returns_none():
    """
    Testa se `calculate_priority_score` retorna `None` (ou o valor default se alterado na fun√ß√£o)
    quando o valor de `importance` fornecido est√° fora do intervalo v√°lido (1-5).
    """
    print("\nTeste: calculate_priority_score com import√¢ncia inv√°lida.")
    # Import√¢ncia abaixo do m√≠nimo (0)
    score_low_importance = calculate_priority_score(importance=0, due_date=None)
    print(f"  Score para import√¢ncia 0: {score_low_importance}")
    assert score_low_importance is None, "Score deveria ser None para import√¢ncia 0."

    # Import√¢ncia acima do m√°ximo (6)
    score_high_importance = calculate_priority_score(importance=6, due_date=None)
    print(f"  Score para import√¢ncia 6: {score_high_importance}")
    assert score_high_importance is None, "Score deveria ser None para import√¢ncia 6."
    print("  Sucesso: Import√¢ncia inv√°lida resulta em score None.")


@freeze_time("2025-05-04") 
def test_calculate_priority_score_with_no_due_date():
    """
    Testa o c√°lculo da pontua√ß√£o de prioridade quando a tarefa n√£o tem data de entrega (`due_date=None`).
    A pontua√ß√£o deve ser baseada no `PRIORITY_DEFAULT_SCORE_NO_DUE_DATE` mais o peso da import√¢ncia.
    """
    print("\nTeste: calculate_priority_score sem data de entrega (due_date=None) em 2025-05-04.")
    
    # Cen√°rio com import√¢ncia 3
    importance_3 = 3
    expected_score_importance_3 = settings.PRIORITY_DEFAULT_SCORE_NO_DUE_DATE + \
                                 (importance_3 * settings.PRIORITY_WEIGHT_IMPORTANCE)
    actual_score_importance_3 = calculate_priority_score(importance=importance_3, due_date=None)
    print(f"  Import√¢ncia 3: Score esperado={expected_score_importance_3:.2f}, "
          f"Calculado={actual_score_importance_3}")
    assert actual_score_importance_3 == round(expected_score_importance_3, 2)

    # Cen√°rio com import√¢ncia m√°xima (5)
    importance_5 = 5
    expected_score_importance_5 = settings.PRIORITY_DEFAULT_SCORE_NO_DUE_DATE + \
                                 (importance_5 * settings.PRIORITY_WEIGHT_IMPORTANCE)
    actual_score_importance_5 = calculate_priority_score(importance=importance_5, due_date=None)
    print(f"  Import√¢ncia 5: Score esperado={expected_score_importance_5:.2f}, "
          f"Calculado={actual_score_importance_5}")
    assert actual_score_importance_5 == round(expected_score_importance_5, 2)
    print("  Sucesso: Scores para tarefas sem data de entrega calculados corretamente.")


@freeze_time("2025-05-04")
def test_calculate_priority_score_with_due_date_today():
    """
    Testa o c√°lculo da pontua√ß√£o de prioridade quando a data de entrega da tarefa √© hoje.
    O fator de data de entrega (`days_to_due`) deve ser 1 (ou o m√≠nimo considerado),
    maximizando a contribui√ß√£o da data para a pontua√ß√£o.
    """
    print("\nTeste: calculate_priority_score com data de entrega HOJE (2025-05-04).")
    due_date_is_today = date.today() 
    test_importance = 4
    
    # Assumindo que `days_to_due` = 1 para tarefas com entrega hoje na f√≥rmula.
    days_factor_for_today = 1.0 
    expected_score = (settings.PRIORITY_WEIGHT_DUE_DATE / days_factor_for_today) + \
                     (test_importance * settings.PRIORITY_WEIGHT_IMPORTANCE)
    actual_score = calculate_priority_score(importance=test_importance, due_date=due_date_is_today)
    print(f"  Import√¢ncia {test_importance}, Due Date Hoje: Score esperado={expected_score:.2f}, "
          f"Calculado={actual_score}")
    assert actual_score == round(expected_score, 2)
    print("  Sucesso: Score para tarefa com entrega hoje calculado corretamente.")


@freeze_time("2025-05-04")
def test_calculate_priority_score_with_due_date_in_future():
    """
    Testa o c√°lculo da pontua√ß√£o de prioridade quando a data de entrega da tarefa
    est√° no futuro (10 dias a partir de "hoje").
    O fator `days_to_due` deve ser 10.
    """
    print("\nTeste: calculate_priority_score com data de entrega no FUTURO (2025-05-04 + 10 dias).")
    due_date_in_future = date.today() + timedelta(days=10) # 2025-05-14
    test_importance = 2
    days_to_due = 10.0 
    
    expected_score = (settings.PRIORITY_WEIGHT_DUE_DATE / days_to_due) + \
                     (test_importance * settings.PRIORITY_WEIGHT_IMPORTANCE)
    actual_score = calculate_priority_score(importance=test_importance, due_date=due_date_in_future)
    print(f"  Import√¢ncia {test_importance}, Due Date em {days_to_due} dias: "
          f"Score esperado={expected_score:.2f}, Calculado={actual_score}")
    assert actual_score == round(expected_score, 2)
    print("  Sucesso: Score para tarefa com entrega futura calculado corretamente.")


@freeze_time("2025-05-04")
def test_calculate_priority_score_for_overdue_task():
    """
    Testa o c√°lculo da pontua√ß√£o de prioridade para uma tarefa que j√° est√° atrasada (5 dias).
    Espera-se que a pontua√ß√£o seja o `PRIORITY_SCORE_IF_OVERDUE` mais o peso da import√¢ncia.
    """
    print("\nTeste: calculate_priority_score para tarefa ATRASADA (2025-05-04 - 5 dias).")
    overdue_date = date.today() - timedelta(days=5) 
    test_importance = 5
    
    expected_score = settings.PRIORITY_SCORE_IF_OVERDUE + \
                     (test_importance * settings.PRIORITY_WEIGHT_IMPORTANCE)
    actual_score = calculate_priority_score(importance=test_importance, due_date=overdue_date)
    print(f"  Import√¢ncia {test_importance}, Tarefa Atrasada: "
          f"Score esperado={expected_score:.2f}, Calculado={actual_score}")
    assert actual_score == round(expected_score, 2)
    print("  Sucesso: Score para tarefa atrasada calculado corretamente.")


# =====================================================
# --- Testes para `is_task_urgent` ---
# =====================================================
# Testes que verificam a l√≥gica de identifica√ß√£o de tarefas urgentes.

def _create_dummy_test_task(**kwargs) -> Task:
    """
    Fun√ß√£o auxiliar para criar inst√¢ncias de `Task` para os testes de `is_task_urgent`.
    Preenche valores base e permite sobrescrev√™-los com `kwargs`.
    Se `priority_score` n√£o for fornecido em `kwargs` e `importance` ou `due_date` estiverem,
    a pontua√ß√£o √© calculada usando `calculate_priority_score`.
    """
    # Dados base para uma tarefa de teste.
    base_task_data = {
        "id": uuid.uuid4(),
        "owner_id": uuid.uuid4(),
        "title": "Tarefa de Teste Dummy",
        "description": "Descri√ß√£o da tarefa dummy.", 
        "importance": 3, 
        "status": TaskStatus.PENDING,
        "tags": None, 
        "project": None,
        "created_at": datetime.now(timezone.utc),
        "updated_at": None, 
        "due_date": None, 
        "priority_score": None, 
    }
    # Sobrescreve os dados base com os argumentos fornecidos.
    final_task_data = {**base_task_data, **kwargs}

    # Calcula priority_score se n√£o for fornecido explicitamente
    # e se houver dados para calcul√°-lo (importance ou due_date).
    if final_task_data.get("priority_score") is None and \
       (final_task_data.get("importance") or final_task_data.get("due_date")):
        calc_importance = final_task_data.get("importance", base_task_data["importance"]) 
        final_task_data["priority_score"] = calculate_priority_score(
            importance=calc_importance,
            due_date=final_task_data.get("due_date") 
        )
    
    # Cria e retorna o objeto Task.
    # Adiciona um try-except para Pydantic ValidationError para depura√ß√£o.
    try:
        return Task(**final_task_data)
    except Exception as e:
        print(f"Erro ao criar Dummy Task com dados: {final_task_data}. Erro: {e}")
        raise


def test_is_task_urgent_when_no_score_and_no_due_date():
    """
    Testa se uma tarefa sem pontua√ß√£o de prioridade e sem data de entrega
    N√ÉO √© considerada urgente.
    """
    print("\nTeste: is_task_urgent - Tarefa sem score e sem data de entrega.")
    # `_create_dummy_test_task` sem `priority_score` ou `due_date` (se n√£o houver importance) resulta em score=None.
    # Ou podemos for√ßar, passando `importance=0` (ou fora do range) para garantir score=None se `calculate_priority_score`
    # for chamada pela factory.
    task_no_urgency_factors = _create_dummy_test_task(importance=3, priority_score=None, due_date=None) 
    # Para garantir priority_score = None, precisamos ou passar `importance` inv√°lido, ou setar diretamente.
    task_no_urgency_factors.priority_score = None # For√ßa o score para None.
    
    print(f"  Tarefa para teste: score={task_no_urgency_factors.priority_score}, due_date={task_no_urgency_factors.due_date}")
    is_urgent_result = is_task_urgent(task_no_urgency_factors)
    assert is_urgent_result is False, "Tarefa sem score nem data de entrega n√£o deveria ser urgente."
    print("  Sucesso: Tarefa sem fatores de urg√™ncia n√£o √© urgente.")


@freeze_time("2025-05-04")
def test_is_task_urgent_with_high_priority_score():
    """
    Testa se uma tarefa com `priority_score` acima do `EMAIL_URGENCY_THRESHOLD`
    √© considerada urgente, mesmo que a data de entrega n√£o seja iminente.
    """
    print("\nTeste: is_task_urgent - Tarefa com pontua√ß√£o de prioridade alta (acima do threshold).")
    # Define um score alto, garantidamente acima do threshold.
    high_score = settings.EMAIL_URGENCY_THRESHOLD + 10.0
    # Cria uma tarefa com este score alto e uma data de entrega no futuro (para isolar o efeito do score).
    task_high_score = _create_dummy_test_task(priority_score=high_score, due_date=date.today() + timedelta(days=30))
    
    print(f"  Tarefa: score={task_high_score.priority_score} (Threshold={settings.EMAIL_URGENCY_THRESHOLD}), due_date={task_high_score.due_date}")
    is_urgent_result = is_task_urgent(task_high_score)
    assert is_urgent_result is True, "Tarefa com score alto deveria ser urgente."
    print("  Sucesso: Tarefa com score alto √© urgente.")


@freeze_time("2025-05-04")
def test_is_task_urgent_with_score_below_threshold_and_future_due_date():
    """
    Testa se uma tarefa com `priority_score` abaixo do `EMAIL_URGENCY_THRESHOLD`
    e com data de entrega no futuro N√ÉO √© considerada urgente.
    """
    print("\nTeste: is_task_urgent - Score baixo e data de entrega futura.")
    low_score = settings.EMAIL_URGENCY_THRESHOLD - 10.0 # Score abaixo do threshold.
    due_date_in_future = date.today() + timedelta(days=10)
    task_low_score_future = _create_dummy_test_task(priority_score=low_score, due_date=due_date_in_future)

    print(f"  Tarefa: score={task_low_score_future.priority_score} (Threshold={settings.EMAIL_URGENCY_THRESHOLD}), "
          f"due_date={task_low_score_future.due_date}")
    is_urgent_result = is_task_urgent(task_low_score_future)
    assert is_urgent_result is False, "Tarefa com score baixo e entrega futura n√£o deveria ser urgente."
    print("  Sucesso: Tarefa com score baixo e entrega futura n√£o √© urgente.")


@freeze_time("2025-05-04")
def test_is_task_urgent_when_due_date_is_today():
    """
    Testa se uma tarefa com data de entrega para HOJE √© considerada urgente,
    mesmo que sua `priority_score` esteja abaixo do `EMAIL_URGENCY_THRESHOLD`.
    A imin√™ncia da data de entrega deve torn√°-la urgente.
    """
    print("\nTeste: is_task_urgent - Data de entrega √© HOJE (2025-05-04).")
    score_below_threshold = settings.EMAIL_URGENCY_THRESHOLD - 5.0 
    due_date_is_today = date.today()
    task_due_today = _create_dummy_test_task(due_date=due_date_is_today, priority_score=score_below_threshold)

    print(f"  Tarefa: score={task_due_today.priority_score}, due_date={task_due_today.due_date}")
    is_urgent_result = is_task_urgent(task_due_today)
    assert is_urgent_result is True, "Tarefa com entrega hoje deveria ser urgente, independentemente do score."
    print("  Sucesso: Tarefa com entrega hoje √© urgente.")


@freeze_time("2025-05-04")
def test_is_task_urgent_when_overdue():
    """
    Testa se uma tarefa que est√° ATRASADA (data de entrega no passado) √© considerada urgente,
    mesmo que sua `priority_score` esteja abaixo do `EMAIL_URGENCY_THRESHOLD`.
    """
    print("\nTeste: is_task_urgent - Tarefa ATRASADA (entrega em 2025-05-03).")
    score_below_threshold = settings.EMAIL_URGENCY_THRESHOLD - 15.0
    overdue_date = date.today() - timedelta(days=1) 
    task_overdue = _create_dummy_test_task(due_date=overdue_date, priority_score=score_below_threshold)
    
    print(f"  Tarefa: score={task_overdue.priority_score}, due_date={task_overdue.due_date}")
    is_urgent_result = is_task_urgent(task_overdue)
    assert is_urgent_result is True, "Tarefa atrasada deveria ser urgente."
    print("  Sucesso: Tarefa atrasada √© urgente.")

# ======================================================
# --- Testes de Casos de Borda para `is_task_urgent` ---
# ======================================================

@freeze_time("2025-05-04")
def test_is_task_urgent_when_score_is_exactly_at_threshold_and_due_date_is_future():
    """
    Testa o comportamento de `is_task_urgent` quando a `priority_score` √©
    EXATAMENTE igual ao `EMAIL_URGENCY_THRESHOLD` e a data de entrega est√° no futuro.
    A l√≥gica de urg√™ncia por score geralmente usa "maior que" (`>`), ent√£o esta tarefa
    N√ÉO deve ser considerada urgente apenas pelo score.
    """
    print("\nTeste de Borda: is_task_urgent - Score no limiar, entrega futura.")
    score_at_threshold = settings.EMAIL_URGENCY_THRESHOLD
    # Data de entrega no futuro para isolar o efeito do score.
    due_date_in_future = date.today() + timedelta(days=5)
    task_at_threshold = _create_dummy_test_task(priority_score=score_at_threshold, due_date=due_date_in_future)
    
    # Verifica√ß√£o opcional se o _create_dummy_test_task recalcularia o score.
    if task_at_threshold.priority_score != score_at_threshold:
        print(f"  AVISO: Score da tarefa foi recalculado para {task_at_threshold.priority_score} "
              f"dentro de _create_dummy_test_task, em vez do valor pretendido {score_at_threshold}. "
              f"Verificar l√≥gica de _create_dummy_test_task ou setar priority_score ap√≥s cria√ß√£o.")
        # Para o teste ser v√°lido com o score exato, podemos for√ß√°-lo:
        task_at_threshold.priority_score = score_at_threshold


    print(f"  Tarefa: score={task_at_threshold.priority_score} (Threshold={settings.EMAIL_URGENCY_THRESHOLD}), "
          f"due_date={task_at_threshold.due_date}")
    is_urgent_result = is_task_urgent(task_at_threshold)
    # Assumindo que a urg√™ncia por score √© `score > threshold`.
    assert is_urgent_result is False, \
        f"Tarefa com score exatamente no limiar ({task_at_threshold.priority_score}) e entrega futura n√£o deveria ser urgente."
    print("  Sucesso: Tarefa com score no limiar (e entrega futura) n√£o √© urgente.")


@freeze_time("2025-05-04")
def test_is_task_urgent_when_score_is_slightly_above_threshold_and_due_date_is_future():
    """
    Testa se `is_task_urgent` considera uma tarefa urgente quando sua `priority_score`
    √© LIGEIRAMENTE ACIMA do `EMAIL_URGENCY_THRESHOLD` e a data de entrega est√° no futuro.
    """
    print("\nTeste de Borda: is_task_urgent - Score ligeiramente acima do limiar, entrega futura.")
    score_slightly_above_threshold = settings.EMAIL_URGENCY_THRESHOLD + 0.01
    due_date_in_future = date.today() + timedelta(days=5)
    task_above_threshold = _create_dummy_test_task(priority_score=score_slightly_above_threshold, due_date=due_date_in_future)
    
    if task_above_threshold.priority_score != score_slightly_above_threshold:
         print(f"  AVISO: Score da tarefa foi recalculado para {task_above_threshold.priority_score} "
               f"em vez de {score_slightly_above_threshold}.")
         task_above_threshold.priority_score = score_slightly_above_threshold 

    print(f"  Tarefa: score={task_above_threshold.priority_score} (Threshold={settings.EMAIL_URGENCY_THRESHOLD}), "
          f"due_date={task_above_threshold.due_date}")
    is_urgent_result = is_task_urgent(task_above_threshold)
    assert is_urgent_result is True, \
        f"Tarefa com score ({task_above_threshold.priority_score}) ligeiramente acima do limiar deveria ser urgente."
    print("  Sucesso: Tarefa com score ligeiramente acima do limiar (e entrega futura) √© urgente.")

================================================================================
Cap√≠tulo 24: tests/test_core_utils_webhooks.py
================================================================================

# tests/test_core_utils_webhooks.py
"""
Este m√≥dulo cont√©m testes unit√°rios para a fun√ß√£o `send_webhook_notification`
localizada em `app.core.utils`.

Os testes utilizam `respx` para mockar as requisi√ß√µes HTTP externas,
permitindo testar o comportamento da fun√ß√£o sob diversas condi√ß√µes:
- Envio de webhook sem segredo (sem header de assinatura).
- Envio de webhook com segredo (com verifica√ß√£o da assinatura HMAC-SHA256).
- Tratamento de erros HTTP retornados pelo servidor do webhook (ex: 4xx, 5xx).
- Tratamento de erros de rede/conex√£o durante a tentativa de envio.
- Comportamento quando a URL do webhook n√£o est√° configurada nas settings.
"""

# ========================
# --- Importa√ß√µes ---
# ========================
import hashlib
import hmac
import json
from unittest.mock import AsyncMock, patch 

import httpx 
import pytest
import respx 

# --- M√≥dulos da Aplica√ß√£o ---
from app.core.config import settings
from app.core.utils import send_webhook_notification

# ====================================
# --- Marcador Global de Teste ---
# ====================================
pytestmark = pytest.mark.asyncio

# =====================================
# --- Constantes e Dados de Teste ---
# =====================================

# Dados de teste para a tarefa que ser√° enviada no payload do webhook.
TEST_TASK_DATA_FOR_WEBHOOK = {
    "id": "f47ac10b-58cc-4372-a567-0e02b2c3d479",
    "owner_id": "a1b2c3d4-e5f6-7890-1234-567890abcdef",
    "title": "Tarefa de Teste para Webhook",
    "importance": 4,
    "status": "pendente_webhook_test",
}
TEST_EVENT_TYPE_WEBHOOK = "task.webhook_test_event"
# URL mockada para os webhooks; `respx` interceptar√° chamadas para esta URL.
TEST_WEBHOOK_TARGET_URL = "http://mocked-webhook-receiver.test/api/hook"

# =================================
# --- Fixtures de Teste ---
# =================================

@pytest.fixture(autouse=True) # Aplicado automaticamente a todos os testes neste arquivo.
def override_webhook_settings_for_tests(monkeypatch):
    """
    Fixture `autouse` que sobrescreve as configura√ß√µes globais de webhook
    (`settings.WEBHOOK_URL` e `settings.WEBHOOK_SECRET`) para cada teste neste m√≥dulo.
    Isso garante um estado limpo e controlado para as configura√ß√µes de webhook,
    prevenindo que valores de um teste afetem outro ou que o sistema dependa
    de vari√°veis de ambiente reais durante os testes.

    - Define `WEBHOOK_URL` para uma URL de teste padr√£o.
    - Inicialmente define `WEBHOOK_SECRET` como `None` (pode ser alterado por testes espec√≠ficos).
    """
    print("  Fixture (autouse): Configurando settings de webhook para testes...")
    monkeypatch.setattr(settings, 'WEBHOOK_URL', TEST_WEBHOOK_TARGET_URL)
    # WEBHOOK_SECRET √© None por padr√£o; testes que precisam dele o definir√£o.
    monkeypatch.setattr(settings, 'WEBHOOK_SECRET', None)
    print(f"    settings.WEBHOOK_URL mockado para: {TEST_WEBHOOK_TARGET_URL}")
    print(f"    settings.WEBHOOK_SECRET mockado para: None (inicialmente)")

# ===========================================================
# --- Testes da Fun√ß√£o `send_webhook_notification` ---
# ===========================================================

@respx.mock # Ativa o mock de `respx` para este teste.
async def test_send_webhook_successfully_without_secret(
    # `override_webhook_settings_for_tests` j√° foi aplicada (autouse).
):
    """
    Testa o envio bem-sucedido de uma notifica√ß√£o de webhook quando
    `settings.WEBHOOK_SECRET` N√ÉO est√° configurado.

    Verifica:
    - Se uma requisi√ß√£o POST HTTP √© feita para a `WEBHOOK_URL` configurada.
    - Se o payload JSON enviado cont√©m os dados corretos (evento, dados da tarefa, timestamp).
    - Se o header de assinatura `X-SmartTask-Signature` N√ÉO est√° presente na requisi√ß√£o.
    """
    print("\nTeste: send_webhook_notification - Envio bem-sucedido sem segredo.")
    # Arrange: Mockar a rota HTTP para retornar uma resposta de sucesso (200 OK).
    # `respx` interceptar√° a chamada para TEST_WEBHOOK_TARGET_URL.
    mocked_route = respx.post(TEST_WEBHOOK_TARGET_URL).mock(
        return_value=httpx.Response(200, json={"status": "webhook_received_ok"})
    )
    print(f"  Mock respx: Rota POST para '{TEST_WEBHOOK_TARGET_URL}' mockada para retornar 200.")

    # Act: Chamar a fun√ß√£o de envio de webhook.
    print("  Atuando: Chamando send_webhook_notification...")
    await send_webhook_notification(
        event_type=TEST_EVENT_TYPE_WEBHOOK,
        task_data=TEST_TASK_DATA_FOR_WEBHOOK
    )

    # Assert: Verificar a chamada HTTP e seus detalhes.
    assert mocked_route.called, "A rota do webhook mockada n√£o foi chamada."
    assert respx.calls.call_count == 1, "N√∫mero de chamadas HTTP incorreto."
    
    last_request_made = respx.calls.last.request
    print(f"  Requisi√ß√£o enviada: URL='{last_request_made.url}', Headers='{last_request_made.headers}'")
    assert str(last_request_made.url) == TEST_WEBHOOK_TARGET_URL, "URL da requisi√ß√£o incorreta."

    # Verificar o payload JSON enviado.
    sent_payload = json.loads(last_request_made.content)
    print(f"  Payload enviado: {sent_payload}")
    assert sent_payload.get("event") == TEST_EVENT_TYPE_WEBHOOK, "Campo 'event' no payload incorreto."
    assert sent_payload.get("task") == TEST_TASK_DATA_FOR_WEBHOOK, "Campo 'task' no payload incorreto."
    assert "timestamp" in sent_payload, "Campo 'timestamp' ausente no payload."

    # Verificar a aus√™ncia do header de assinatura.
    assert "X-SmartTask-Signature" not in last_request_made.headers, \
        "Header 'X-SmartTask-Signature' presente indevidamente (deveria estar ausente sem segredo)."
    print("  Sucesso: Webhook enviado corretamente sem header de assinatura.")

@respx.mock
async def test_send_webhook_successfully_with_secret_and_valid_signature(
    monkeypatch
    # Para modificar settings.WEBHOOK_SECRET especificamente para este teste.
):
    """
    Testa o envio bem-sucedido de uma notifica√ß√£o de webhook quando
    `settings.WEBHOOK_SECRET` EST√Å configurado.

    Verifica:
    - Se a requisi√ß√£o POST HTTP √© feita.
    - Se o header de assinatura `X-SmartTask-Signature` EST√Å presente.
    - Se a assinatura HMAC-SHA256 no header corresponde √† assinatura calculada
      do payload enviado, usando o segredo configurado.
    """
    print("\nTeste: send_webhook_notification - Envio bem-sucedido com segredo e assinatura v√°lida.")
    # Arrange: Definir um segredo para o webhook e mockar a rota HTTP.
    test_webhook_secret_key = "este-e-um-segredo-muito-secreto-para-hmac"
    monkeypatch.setattr(settings, 'WEBHOOK_SECRET', test_webhook_secret_key)
    # WEBHOOK_URL j√° est√° setada pela fixture autouse.
    print(f"  Mock monkeypatch: settings.WEBHOOK_SECRET definido para '{test_webhook_secret_key}'.")

    mocked_route = respx.post(TEST_WEBHOOK_TARGET_URL).mock(return_value=httpx.Response(200))
    print(f"  Mock respx: Rota POST para '{TEST_WEBHOOK_TARGET_URL}' mockada.")

    # Act: Chamar a fun√ß√£o de envio.
    print("  Atuando: Chamando send_webhook_notification...")
    await send_webhook_notification(
        event_type=TEST_EVENT_TYPE_WEBHOOK,
        task_data=TEST_TASK_DATA_FOR_WEBHOOK
    )

    # Assert: Verificar a chamada HTTP e a assinatura.
    assert mocked_route.called, "Rota do webhook n√£o foi chamada."
    last_request_made = respx.calls.last.request

    # Verificar presen√ßa do header de assinatura.
    assert "X-SmartTask-Signature" in last_request_made.headers, "Header 'X-SmartTask-Signature' ausente."
    
    signature_from_header = last_request_made.headers["X-SmartTask-Signature"]
    assert signature_from_header.startswith("sha256="), "Formato do header de assinatura inv√°lido."
    print(f"  Header de assinatura recebido: {signature_from_header}")

    # Verificar se a assinatura est√° correta.
    # Para isso, precisamos recriar o payload *exatamente como foi enviado*
    # (incluindo o timestamp que foi gerado pela fun√ß√£o `send_webhook_notification`).
    
    # 1. Obter o payload que foi realmente enviado na requisi√ß√£o mockada.
    sent_payload_bytes = last_request_made.content
    sent_payload_dict_actual = json.loads(sent_payload_bytes)
    actual_timestamp_sent = sent_payload_dict_actual["timestamp"] # Extrai o timestamp real.

    # 2. Construir o payload base esperado (sem o timestamp, que √© din√¢mico).
    expected_payload_base = {
        "event": TEST_EVENT_TYPE_WEBHOOK,
        "task": TEST_TASK_DATA_FOR_WEBHOOK,
    }
    # 3. Adicionar o timestamp real enviado ao nosso payload esperado para c√°lculo.
    payload_for_signature_calculation = expected_payload_base.copy()
    payload_for_signature_calculation["timestamp"] = actual_timestamp_sent

    # 4. Gerar a representa√ß√£o JSON ordenada e encodada (como a fun√ß√£o de webhook faz internamente).
    #    √â crucial que a serializa√ß√£o (ordem das chaves, espa√ßamento) seja id√™ntica.
    payload_bytes_for_hmac = json.dumps(
        payload_for_signature_calculation,
        separators=(',', ':'), # Compacta o JSON, sem espa√ßos extras.
        sort_keys=True        # Ordena as chaves alfabeticamente.
    ).encode('utf-8')
    
    secret_bytes_for_hmac = test_webhook_secret_key.encode('utf-8')
    
    # 5. Calcular a assinatura HMAC-SHA256 esperada.
    expected_hmac_signature_hex = hmac.new(
        secret_bytes_for_hmac,
        payload_bytes_for_hmac,
        hashlib.sha256
    ).hexdigest()
    print(f"  Assinatura HMAC calculada esperada: {expected_hmac_signature_hex}")

    # 6. Comparar com a assinatura do header.
    assert signature_from_header == f"sha256={expected_hmac_signature_hex}", "Assinatura HMAC no header n√£o corresponde √† esperada."
    print("  Sucesso: Webhook enviado com segredo e assinatura HMAC v√°lida.")

@respx.mock
async def test_send_webhook_handles_http_error_from_server(
    # `override_webhook_settings_for_tests` j√° aplicada.
    mocker # Para mockar o logger.
):
    """
    Testa o tratamento de erro quando o servidor do webhook retorna um erro HTTP
    (ex: status code 404 Not Found, 500 Internal Server Error).

    Verifica se um erro √© logado pela fun√ß√£o `send_webhook_notification`.
    """
    print("\nTeste: send_webhook_notification - Tratamento de erro HTTP do servidor.")
    # Arrange: Mockar a rota HTTP para retornar um erro 500.
    http_error_status_code = 500
    http_error_response_text = "Ocorreu um Erro Interno no Servidor do Webhook"
    respx.post(TEST_WEBHOOK_TARGET_URL).mock(
        return_value=httpx.Response(http_error_status_code, text=http_error_response_text)
    )
    print(f"  Mock respx: Rota POST para '{TEST_WEBHOOK_TARGET_URL}' mockada para retornar {http_error_status_code}.")

    # Mockar o logger de `app.core.utils` para verificar se `logger.error` √© chamado.
    mock_utils_logger = mocker.patch("app.core.utils.logger")
    print("  Mock: app.core.utils.logger.")

    # Act: Chamar a fun√ß√£o.
    print("  Atuando: Chamando send_webhook_notification (esperando erro HTTP)...")
    await send_webhook_notification(TEST_EVENT_TYPE_WEBHOOK, TEST_TASK_DATA_FOR_WEBHOOK)

    # Assert: Verificar se o logger.error foi chamado com a mensagem apropriada.
    mock_utils_logger.error.assert_called_once()
    # Extrai os argumentos da chamada ao logger.error.
    error_log_args, _ = mock_utils_logger.error.call_args
    error_log_message = error_log_args[0] 
    print(f"  Log de erro capturado: {error_log_message}")
    
    assert "Erro no servidor do webhook" in error_log_message, "Log n√£o indica erro no servidor do webhook."
    assert f"({TEST_WEBHOOK_TARGET_URL})" in error_log_message, "URL (entre par√™nteses) n√£o encontrada na mensagem de erro."
    assert f"Status: {http_error_status_code}" in error_log_message, "Status code do erro n√£o encontrado na mensagem."
    assert http_error_response_text in error_log_message, "Texto da resposta do erro n√£o encontrado na mensagem."
    print("  Sucesso: Erro HTTP do servidor tratado e logado corretamente.")

@respx.mock
async def test_send_webhook_handles_network_request_error(
    # `override_webhook_settings_for_tests` j√° aplicada.
    mocker
):
    """
    Testa o tratamento de erro quando ocorre um problema de rede ou conex√£o
    ao tentar enviar a notifica√ß√£o de webhook (ex: `httpx.RequestError`).

    Verifica se um erro √© logado.
    """
    print("\nTeste: send_webhook_notification - Tratamento de erro de rede/conex√£o.")
    # Arrange: Mockar a rota HTTP para levantar uma exce√ß√£o de rede.
    simulated_network_error_message = "Falha de conex√£o simulada (DNS lookup failed)"
    respx.post(TEST_WEBHOOK_TARGET_URL).mock(side_effect=httpx.RequestError(simulated_network_error_message))
    print(f"  Mock respx: Rota POST para '{TEST_WEBHOOK_TARGET_URL}' mockada para levantar httpx.RequestError.")
    
    mock_utils_logger = mocker.patch("app.core.utils.logger")
    print("  Mock: app.core.utils.logger.")

    # Act: Chamar a fun√ß√£o.
    print("  Atuando: Chamando send_webhook_notification (esperando erro de rede)...")
    await send_webhook_notification(TEST_EVENT_TYPE_WEBHOOK, TEST_TASK_DATA_FOR_WEBHOOK)

    # Assert: Verificar se logger.error foi chamado.
    mock_utils_logger.error.assert_called_once()
    error_log_args, _ = mock_utils_logger.error.call_args
    error_log_message = error_log_args[0]
    print(f"  Log de erro capturado: {error_log_message}")

    assert "Erro na requisi√ß√£o ao enviar webhook para" in error_log_message, "Parte inicial da mensagem de erro de rede n√£o encontrada."
    assert TEST_WEBHOOK_TARGET_URL in error_log_message, "URL n√£o encontrada na mensagem de erro de rede."
    assert simulated_network_error_message in error_log_message, "Mensagem da exce√ß√£o de rede n√£o encontrada no log."
    print("  Sucesso: Erro de rede/conex√£o tratado e logado corretamente.")

async def test_send_webhook_does_nothing_if_url_not_configured(mocker):
    """
    Testa se `send_webhook_notification` n√£o realiza nenhuma a√ß√£o (nem tenta enviar)
    e loga uma mensagem de debug se `settings.WEBHOOK_URL` n√£o estiver configurada (for None).

    Verifica:
    - Se `httpx.AsyncClient.post` (ou qualquer chamada HTTP) N√ÉO √© feito.
    - Se nenhum log de info ou erro √© gerado (al√©m de um poss√≠vel debug).
    - Se um log de debug espec√≠fico √© gerado indicando que o envio foi pulado.
    """
    print("\nTeste: send_webhook_notification - WEBHOOK_URL n√£o configurada.")
    # Arrange: Garantir que WEBHOOK_URL √© None.
    # A fixture `override_webhook_settings_for_tests` j√° define WEBHOOK_URL,
    # ent√£o precisamos sobrescrev√™-la novamente para None aqui.
    with patch('app.core.utils.settings.WEBHOOK_URL', None): 
        print(f"  Mock patch: settings.WEBHOOK_URL definido como None para este teste.")
        # Mock para garantir que nenhuma chamada HTTP real seja feita.
        # Mockamos o m√©todo `post` da classe `AsyncClient` no m√≥dulo `httpx`.
        mock_httpx_client_post = mocker.patch("httpx.AsyncClient.post", new_callable=AsyncMock)
        
        # Mockar o logger de `app.core.utils` para verificar suas chamadas.
        mock_utils_logger = mocker.patch("app.core.utils.logger")
        print("  Mock: httpx.AsyncClient.post e app.core.utils.logger.")

        # Act: Chamar a fun√ß√£o.
        print("  Atuando: Chamando send_webhook_notification...")
        await send_webhook_notification(TEST_EVENT_TYPE_WEBHOOK, TEST_TASK_DATA_FOR_WEBHOOK)

        # Assert:
        mock_httpx_client_post.assert_not_called(), "httpx.AsyncClient.post foi chamado indevidamente."
        # Verifica se n√£o houve logs de info ou error (o que indicaria uma tentativa de envio ou falha).
        assert not mock_utils_logger.info.called, "logger.info foi chamado indevidamente."
        assert not mock_utils_logger.error.called, "logger.error foi chamado indevidamente."
        
        # Verifica se a mensagem de debug esperada foi logada.
        expected_debug_message = "Webhook URL n√£o configurada, pulando envio."
        mock_utils_logger.debug.assert_called_once_with(expected_debug_message)
        print("  Sucesso: Nenhuma tentativa de envio de webhook e log de debug correto quando URL n√£o configurada.")

# =======================================================
@respx.mock # Necess√°rio para que httpx n√£o seja realmente chamado, pois retornaremos antes
async def test_send_webhook_signature_generation_failure(mocker):
    """
    Testa o tratamento de erro quando a gera√ß√£o da assinatura HMAC falha.
    """
    print("\nTeste: send_webhook_notification - Falha na gera√ß√£o da assinatura HMAC.")
    # Arrange: Configurar WEBHOOK_SECRET e mokar hmac.new para falhar
    test_secret = "super_secret"
    mocker.patch.object(settings, 'WEBHOOK_SECRET', test_secret) # Usar mocker.patch.object
    
    mock_utils_logger = mocker.patch("app.core.utils.logger")
    # Mokar hmac.new para levantar uma exce√ß√£o
    mocker.patch("app.core.utils.hmac.new", side_effect=Exception("HMAC generation error"))

    # Act: Chamar a fun√ß√£o
    await send_webhook_notification(TEST_EVENT_TYPE_WEBHOOK, TEST_TASK_DATA_FOR_WEBHOOK)

    # Assert: Verificar se o logger.error foi chamado e se n√£o houve tentativa de envio HTTP
    mock_utils_logger.error.assert_called_once()
    error_log_message = mock_utils_logger.error.call_args[0][0]
    assert "Erro ao gerar assinatura HMAC para webhook" in error_log_message
    assert "HMAC generation error" in error_log_message # Verificar se a msg da exce√ß√£o est√° no log
    
    # Verificar que o httpx.post n√£o foi chamado (pois deve retornar antes)
    # Se a rota de respx n√£o for definida e chamada, respx.calls estar√° vazio.
    assert respx.calls.call_count == 0, "Chamada HTTP foi feita indevidamente ap√≥s falha na assinatura."
    print("  Sucesso: Falha na gera√ß√£o de assinatura HMAC tratada e logada.")

@respx.mock
async def test_send_webhook_unexpected_generic_exception_during_send(mocker):
    print("\nTeste: send_webhook_notification - Exce√ß√£o gen√©rica inesperada no envio.")
    mock_utils_logger = mocker.patch("app.core.utils.logger")

    # Precisamos que `client.post` levante uma exce√ß√£o quando awaited.
    # Mokar a classe AsyncClient para que sua inst√¢ncia retornada
    # tenha um m√©todo post que √© um AsyncMock que levanta uma exce√ß√£o.

    mock_post_method = AsyncMock(side_effect=Exception("Erro gen√©rico simulado no post"))

    # Moka o construtor da classe httpx.AsyncClient
    # O construtor retorna um objeto (mock_client_context)
    # que, quando usado em `async with` (via __aenter__), retorna
    # outro objeto (mock_client_operations) que tem o m√©todo 'post'.
    
    mock_client_operations = AsyncMock()
    mock_client_operations.post = mock_post_method # O m√©todo post levanta a exce√ß√£o

    mock_client_context = AsyncMock()
    # __aenter__ deve ser um m√©todo ass√≠ncrono que retorna o objeto com 'post'
    mock_client_context.__aenter__ = AsyncMock(return_value=mock_client_operations)
    # __aexit__ tamb√©m precisa ser um m√©todo ass√≠ncrono
    mock_client_context.__aexit__ = AsyncMock(return_value=None)

    mocker.patch("httpx.AsyncClient", return_value=mock_client_context)

    # Act
    await send_webhook_notification(TEST_EVENT_TYPE_WEBHOOK, TEST_TASK_DATA_FOR_WEBHOOK)

    # Assert
    mock_utils_logger.exception.assert_called_once()
    # (O resto das suas asser√ß√µes)
    exception_log_message = mock_utils_logger.exception.call_args[0][0]
    assert "Erro inesperado ao enviar webhook para" in exception_log_message
    assert "Erro gen√©rico simulado no post" in exception_log_message # Verifique a mensagem do side_effect
    print("  Sucesso: Exce√ß√£o gen√©rica inesperada durante o envio tratada e logada com logger.exception.")

@respx.mock
async def test_send_webhook_handles_timeout_exception(mocker):
    """
    Testa o tratamento de erro quando ocorre um httpx.TimeoutException
    ao tentar enviar a notifica√ß√£o de webhook.

    Verifica se um erro apropriado √© logado.
    """
    print("\nTeste: send_webhook_notification - Tratamento de httpx.TimeoutException.")
    # Arrange: Mockar a rota HTTP para levantar uma TimeoutException.
    # A TimeoutException geralmente precisa de um contexto de request para ser constru√≠da,
    # mas o respx pode simular o efeito.
    # Uma forma simples √© fazer o side_effect levantar TimeoutException.
    # O construtor de TimeoutException aceita uma mensagem e um request.
    # Para simplificar no mock, podemos apenas levantar a exce√ß√£o com uma mensagem.
    simulated_timeout_message = "Simulated timeout durante o envio do webhook"
    # Precisamos da inst√¢ncia do request para o construtor do TimeoutException.
    # Como n√£o temos uma inst√¢ncia real do request aqui antes do mock, podemos criar um dummy.
    dummy_request_for_exception = httpx.Request(method="POST", url=TEST_WEBHOOK_TARGET_URL)
    
    respx.post(TEST_WEBHOOK_TARGET_URL).mock(
        side_effect=httpx.TimeoutException(simulated_timeout_message, request=dummy_request_for_exception)
    )
    print(f"  Mock respx: Rota POST para '{TEST_WEBHOOK_TARGET_URL}' mockada para levantar httpx.TimeoutException.")
    
    mock_utils_logger = mocker.patch("app.core.utils.logger")
    print("  Mock: app.core.utils.logger.")

    # Act: Chamar a fun√ß√£o.
    print("  Atuando: Chamando send_webhook_notification (esperando timeout)...")
    await send_webhook_notification(TEST_EVENT_TYPE_WEBHOOK, TEST_TASK_DATA_FOR_WEBHOOK)

    # Assert: Verificar se logger.error foi chamado com a mensagem correta.
    mock_utils_logger.error.assert_called_once()
    error_log_args, _ = mock_utils_logger.error.call_args
    error_log_message = error_log_args[0] 
    print(f"  Log de erro capturado: {error_log_message}")

    assert "Timeout ao enviar webhook para" in error_log_message, \
        "Mensagem de log para TimeoutException n√£o encontrada ou incorreta."
    assert TEST_WEBHOOK_TARGET_URL in error_log_message, \
        "URL n√£o encontrada na mensagem de log de timeout."
    # A mensagem da TimeoutException original (simulated_timeout_message) N√ÉO √© inclu√≠da
    # na f-string do logger.error, ent√£o n√£o precisamos verific√°-la l√°.

    print("  Sucesso: httpx.TimeoutException tratado e logado corretamente.")

================================================================================
Cap√≠tulo 25: tests/test_db_mongodb_utils.py
================================================================================

# tests/test_db_mongodb_utils.py

# ========================
# --- Importa√ß√µes ---
# ========================
import pytest 
from unittest.mock import AsyncMock, MagicMock, call, patch
from app.db import mongodb_utils

# =======================================
# --- Testes para get_database ---
# =======================================
def test_get_database_not_initialized(mocker): 
    """
    Testa se get_database levanta RuntimeError quando db_instance √© None.
    """
    # ========================
    # --- Arrange ---
    # ========================
    mocker.patch("app.db.mongodb_utils.db_instance", None)
    mock_logger_error = mocker.patch("app.db.mongodb_utils.logger.error")

    # ========================
    # --- Act & Assert ---
    # ========================
    with pytest.raises(RuntimeError) as excinfo:
        mongodb_utils.get_database()

    assert "A conex√£o com o banco de dados n√£o foi inicializada" in str(excinfo.value)
    mock_logger_error.assert_called_once_with("Tentativa de obter inst√¢ncia do DB antes da inicializa√ß√£o!")

# ==========================================
# --- Testes para close_mongo_connection ---
# ==========================================
@pytest.mark.asyncio
async def test_close_mongo_connection_no_client(mocker): 
    """
    Testa close_mongo_connection quando db_client global √© None.
    """
    # ========================
    # --- Arrange ---
    # ========================
    mocker.patch("app.db.mongodb_utils.db_client", None)
    mock_logger_warning = mocker.patch("app.db.mongodb_utils.logger.warning")
    mock_logger_info = mocker.patch("app.db.mongodb_utils.logger.info") 

    # ========================
    # --- Act ---
    # ========================
    await mongodb_utils.close_mongo_connection()

    # ========================
    # --- Assert ---
    # ========================
    mock_logger_info.assert_any_call("Tentando fechar conex√£o com MongoDB...")
    mock_logger_warning.assert_called_once_with("Tentativa de fechar conex√£o com MongoDB, mas cliente n√£o estava inicializado.")
    log_info_calls = [c.args[0] for c in mock_logger_info.call_args_list if c.args]
    assert "Conex√£o com MongoDB fechada." not in log_info_calls

@pytest.mark.asyncio
async def test_close_mongo_connection_with_client(mocker): 
    """
    Testa close_mongo_connection quando db_client existe (caminho positivo j√° coberto, mas para clareza).
    """
    # ========================
    # --- Arrange ---
    # ========================
    mock_client_instance = MagicMock() 
    mocker.patch("app.db.mongodb_utils.db_client", mock_client_instance)
    mock_logger_info = mocker.patch("app.db.mongodb_utils.logger.info")
    mock_logger_warning = mocker.patch("app.db.mongodb_utils.logger.warning")

    # ========================
    # --- Act ---
    # ========================
    await mongodb_utils.close_mongo_connection()

    # ========================
    # --- Assert ---
    # ========================
    mock_client_instance.close.assert_called_once()
    # Verificar logs espec√≠ficos de info
    assert call("Tentando fechar conex√£o com MongoDB...") in mock_logger_info.call_args_list
    assert call("Conex√£o com MongoDB fechada.") in mock_logger_info.call_args_list
    mock_logger_warning.assert_not_called()

# =======================================
# --- Testes para connect_to_mongo ---
# =======================================
@pytest.mark.asyncio
async def test_connect_to_mongo_failure_client_init(mocker): 
    """
    Testa falha em connect_to_mongo durante a inicializa√ß√£o do AsyncIOMotorClient.
    """
    # ========================
    # --- Arrange ---
    # ========================
    simulated_error = Exception("Erro ao instanciar Motor Client")
    mocker.patch("motor.motor_asyncio.AsyncIOMotorClient", side_effect=simulated_error)
    mock_logger_error = mocker.patch("app.db.mongodb_utils.logger.error")
    mocker.patch("app.db.mongodb_utils.settings.MONGODB_URL", "mongodb://dummy_url")

    mocker.patch("app.db.mongodb_utils.db_client", None)
    mocker.patch("app.db.mongodb_utils.db_instance", None)


    # ========================
    # --- Act ---
    # ========================
    result = await mongodb_utils.connect_to_mongo()

    # ========================
    # --- Assert ---
    # ========================
    assert result is None
    mock_logger_error.assert_called_once()
    log_args, log_kwargs = mock_logger_error.call_args
    assert "N√£o foi poss√≠vel conectar ao MongoDB" in log_args[0]
    assert str(simulated_error) in log_args[0]
    assert log_kwargs.get("exc_info") is True
    assert mongodb_utils.db_client is None
    assert mongodb_utils.db_instance is None

@pytest.mark.asyncio
async def test_connect_to_mongo_failure_ping(mocker):
    """
    Testa falha em connect_to_mongo durante o comando ping.
    """
    # ========================
    # --- Arrange ---
    # ========================
    simulated_error = Exception("Erro no comando ping")
    mock_motor_client = AsyncMock()
    mock_motor_client.admin.command.side_effect = simulated_error 
    mocker.patch("motor.motor_asyncio.AsyncIOMotorClient", return_value=mock_motor_client)
    mock_logger_error = mocker.patch("app.db.mongodb_utils.logger.error")
    mocker.patch("app.db.mongodb_utils.settings.MONGODB_URL", "mongodb://dummy_ping_url")

    mocker.patch("app.db.mongodb_utils.db_client", None)
    mocker.patch("app.db.mongodb_utils.db_instance", None)

    # ========================
    # --- Act ---
    # ========================
    result = await mongodb_utils.connect_to_mongo()

    # ========================
    # --- Assert ---
    # ========================
    assert result is None
    mock_motor_client.admin.command.assert_awaited_once_with('ping')
    mock_logger_error.assert_called_once()
    log_args, log_kwargs = mock_logger_error.call_args
    assert "N√£o foi poss√≠vel conectar ao MongoDB" in log_args[0]
    assert str(simulated_error) in log_args[0]
    assert log_kwargs.get("exc_info") is True
    assert mongodb_utils.db_client is None 
    assert mongodb_utils.db_instance is None

================================================================================
Cap√≠tulo 26: tests/test_db_task_crud.py
================================================================================

# tests/test_db_task_crud.py
"""
Este m√≥dulo cont√©m testes unit√°rios para as fun√ß√µes CRUD (Create, Read, Update, Delete)
de tarefas, definidas em `app.db.task_crud`.

Os testes utilizam mocks (principalmente `unittest.mock.AsyncMock` e `unittest.mock.patch`)
para simular as intera√ß√µes com a cole√ß√£o do MongoDB, permitindo testar a l√≥gica
das fun√ß√µes CRUD de forma isolada.

S√£o testados:
- Cria√ß√£o de tarefas (`create_task`) em cen√°rios de sucesso e falha.
- Busca de tarefas por ID (`get_task_by_id`) em cen√°rios de sucesso, n√£o encontrado e erro de valida√ß√£o.
- Listagem de tarefas por propriet√°rio (`get_tasks_by_owner`) com e sem filtros/ordena√ß√£o,
  incluindo tratamento de erros de valida√ß√£o e DB.
- Atualiza√ß√£o de tarefas (`update_task`).
- Dele√ß√£o de tarefas (`delete_task`).
- A fun√ß√£o auxiliar `_parse_sort_params`.
"""

# ========================
# --- Importa√ß√µes ---
# ========================
import uuid
from datetime import date, datetime, timedelta, timezone 
from typing import Any, Dict, List, Optional 
from unittest.mock import AsyncMock, MagicMock, call, patch
from venv import logger 

import pytest
from pydantic import ValidationError 
from pymongo import ASCENDING, DESCENDING
from pymongo.errors import DuplicateKeyError
from pytest_mock import MockerFixture

# --- M√≥dulos da Aplica√ß√£o ---
from app.db import task_crud 
from app.models.task import Task, TaskStatus, TaskUpdate

# ============================
# --- Fixture de Dados ---
# ============================

@pytest.fixture
def valid_task_obj() -> Task:
    """
    Fixture que retorna um objeto `Task` v√°lido e completo,
    pronto para ser usado nos testes como entrada para cria√ß√£o
    ou como valor esperado de retorno.
    """
    owner_unique_id = uuid.uuid4()
    task_unique_id = uuid.uuid4()
    print(f"  Fixture 'valid_task_obj': Criando Task ID={task_unique_id}, Owner ID={owner_unique_id}")
    return Task(
        id=task_unique_id,
        owner_id=owner_unique_id,
        title="Tarefa de Teste Padr√£o",
        description="Uma descri√ß√£o detalhada para a tarefa de teste padr√£o.",
        importance=3, 
        status=TaskStatus.PENDING,
        created_at=datetime.now(timezone.utc)
        )

@pytest.fixture
def sample_owner_id() -> uuid.UUID:
    """Fornece um UUID fixo para testes."""
    return uuid.UUID("123e4567-e89b-12d3-a456-426614174000")

@pytest.fixture
def sample_task_in_db(sample_owner_id: uuid.UUID) -> Task:
    """Fornece um objeto Task completo v√°lido para testes."""
    task_id = uuid.uuid4()
    return Task(
        id=task_id,
        owner_id=sample_owner_id,
        title="Sample Task in DB",
        description="Description for sample task in DB",
        importance=4,
        status=TaskStatus.IN_PROGRESS,
        created_at=datetime.now(timezone.utc).replace(microsecond=0) - timedelta(days=2),
        updated_at=None,
        due_date=date.today() + timedelta(days=5),
        priority_score=55.5,
        tags=["sample", "db"]
    )

@pytest.fixture
def sample_task_create_data() -> Dict[str, Any]:
    """Fornece um dicion√°rio v√°lido para criar uma tarefa."""
    return {
        "title": "Sample Task Create",
        "description": "Desc for create",
        "importance": 3,
        "due_date": (date.today() + timedelta(days=10)).isoformat(),
        "status": TaskStatus.PENDING.value,
        "tags": ["create_test"],
        "project": "Project Alpha"
    }

# ===================================
# --- Testes para `create_task` ---
# ===================================
@pytest.mark.asyncio
async def test_create_task_successfully(valid_task_obj: Task):
    """
    Testa a cria√ß√£o bem-sucedida de uma tarefa.
    Verifica se `_get_tasks_collection` √© chamado, se `insert_one` na cole√ß√£o
    √© chamado com os dados corretos e se a fun√ß√£o retorna o objeto da tarefa
    quando a inser√ß√£o √© confirmada (acknowledged).
    """
    print(f"\nTeste: create_task - Sucesso (Task ID: {valid_task_obj.id})")
    # --- Arrange: Configurar mocks ---
    mock_mongodb_collection = AsyncMock() 
    mock_insert_operation_result = MagicMock()
    mock_insert_operation_result.acknowledged = True 
    mock_mongodb_collection.insert_one = AsyncMock(return_value=mock_insert_operation_result)
    print("  Mock: Cole√ß√£o MongoDB e resultado de insert_one configurados para sucesso.")

    with patch("app.db.task_crud._get_tasks_collection", return_value=mock_mongodb_collection):
        # --- Act: Chamar a fun√ß√£o `create_task` ---
        print(f"  Atuando: Chamando task_crud.create_task com objeto Task.")
        created_task_result = await task_crud.create_task(db=MagicMock(), task_db=valid_task_obj)

    # --- Assert: Verificar chamadas e resultado ---
    expected_dict_for_db = valid_task_obj.model_dump(mode='json') 
    mock_mongodb_collection.insert_one.assert_awaited_once_with(expected_dict_for_db)
    assert created_task_result == valid_task_obj, "A tarefa retornada n√£o √© a mesma que foi passada."
    print("  Sucesso: Tarefa criada e retornada corretamente.")

@pytest.mark.asyncio
async def test_create_task_when_db_insert_not_acknowledged(valid_task_obj: Task):
    """
    Testa o comportamento de `create_task` quando a opera√ß√£o `insert_one`
    do MongoDB n√£o √© confirmada (`acknowledged = False`).
    Espera-se que a fun√ß√£o retorne `None`.
    """
    # ========================
    # --- Arrange ---
    # ========================
    mock_mongodb_collection = AsyncMock()
    mock_insert_operation_result = MagicMock()
    mock_insert_operation_result.acknowledged = False 
    mock_mongodb_collection.insert_one = AsyncMock(return_value=mock_insert_operation_result)

    # ========================
    # --- Act ---
    # ========================
    with patch("app.db.task_crud._get_tasks_collection", return_value=mock_mongodb_collection):
        created_task_result = await task_crud.create_task(db=MagicMock(), task_db=valid_task_obj)

    # ========================
    # --- Assert ---
    # ========================
    mock_mongodb_collection.insert_one.assert_awaited_once()
    assert created_task_result is None, "Deveria retornar None se a inser√ß√£o n√£o for acknowledged."

@pytest.mark.asyncio
async def test_create_task_handles_db_exception_on_insert(valid_task_obj: Task, mocker):
    """
    Testa o tratamento de exce√ß√£o em `create_task` quando `insert_one`
    levanta uma exce√ß√£o (simulando um erro do banco de dados).
    Espera-se que a exce√ß√£o seja capturada, logada, e que a fun√ß√£o retorne `None`.
    """
    # ========================
    # --- Arrange ---
    # ========================
    mock_mongodb_collection = AsyncMock()
    simulated_db_error = Exception("Erro de Simula√ß√£o na Inser√ß√£o no DB")
    mock_mongodb_collection.insert_one = AsyncMock(side_effect=simulated_db_error)
    mock_task_crud_logger = mocker.patch("app.db.task_crud.logger")

    # ========================
    # --- Act ---
    # ========================
    with patch("app.db.task_crud._get_tasks_collection", return_value=mock_mongodb_collection):
        created_task_result = await task_crud.create_task(db=MagicMock(), task_db=valid_task_obj)

    # ========================
    # --- Assert ---
    # ========================
    mock_mongodb_collection.insert_one.assert_awaited_once() 
    assert created_task_result is None, "Deveria retornar None em caso de exce√ß√£o no DB."
    mock_task_crud_logger.exception.assert_called_once(), "logger.exception n√£o foi chamado."

@pytest.mark.asyncio
async def test_create_task_indexes_success(mocker): 
    """
    Testa a cria√ß√£o bem-sucedida de todos os √≠ndices de tarefa.
    """
    # ========================
    # --- Arrange ---
    # ========================
    mock_db_object = MagicMock()
    mock_collection = AsyncMock()
    mock_collection.create_index = AsyncMock() 
    mocker.patch("app.db.task_crud._get_tasks_collection", return_value=mock_collection)
    mock_logger_info = mocker.patch("app.db.task_crud.logging.info")

    # ========================
    # --- Act ---
    # ========================
    await task_crud.create_task_indexes(db=mock_db_object)

    # ========================
    # --- Assert ---
    # ========================
    expected_calls = [
        call("id", unique=True, name="task_id_unique_idx"),
        call("owner_id", name="task_owner_idx"),
        call([("owner_id", ASCENDING), ("due_date", DESCENDING)], name="task_owner_due_date_idx"),
        call([("owner_id", ASCENDING), ("priority_score", DESCENDING)], name="task_owner_priority_idx"),
        call("tags", name="task_tags_idx")
    ]
    mock_collection.create_index.assert_has_awaits(expected_calls, any_order=False)
    mock_logger_info.assert_called_once_with("√çndices da cole√ß√£o 'tasks' verificados/criados.")

@pytest.mark.asyncio
async def test_create_task_indexes_failure(mocker): 
    """
    Testa o tratamento de erro durante a cria√ß√£o de um √≠ndice de tarefa.
    """
    # ========================
    # --- Arrange ---
    # ========================
    mock_db_object = MagicMock()
    simulated_db_error = Exception("Erro simulado ao criar √≠ndice 'owner_id'")
    mock_collection = AsyncMock()
    mock_collection.create_index.side_effect = [
        AsyncMock(), 
        simulated_db_error 
    ]
    mocker.patch("app.db.task_crud._get_tasks_collection", return_value=mock_collection)
    mock_logger_error = mocker.patch("app.db.task_crud.logging.error")
    mock_logger_info = mocker.patch("app.db.task_crud.logging.info")

    # ========================
    # --- Act ---
    # ========================
    await task_crud.create_task_indexes(db=mock_db_object)

    # ========================
    # --- Assert ---
    # ========================
    assert mock_collection.create_index.await_count == 2
    first_call_args = mock_collection.create_index.await_args_list[0].args
    second_call_args = mock_collection.create_index.await_args_list[1].args
    assert first_call_args[0] == "id"
    assert second_call_args[0] == "owner_id"
    mock_logger_error.assert_called_once()
    call_args, call_kwargs = mock_logger_error.call_args
    log_message = call_args[0]
    assert "Erro ao criar √≠ndices da cole√ß√£o 'tasks'" in log_message
    assert str(simulated_db_error) in log_message
    assert call_kwargs.get("exc_info") is True
    mock_logger_info.assert_not_called()

# =====================================
# --- Testes para `get_task_by_id` ---
# =====================================
@pytest.mark.asyncio
async def test_get_task_by_id_successfully(valid_task_obj: Task):
    """
    Testa a busca bem-sucedida de uma tarefa por ID.
    Verifica se `find_one` √© chamado com a query correta, se `Task.model_validate`
    √© chamado com os dados corretos (sem `_id`), e se a tarefa √© retornada.
    """
    print(f"\nTeste: get_task_by_id - Sucesso (Task ID: {valid_task_obj.id})")
    # --- Arrange ---
    task_dict_from_db = valid_task_obj.model_dump(mode='json')
    task_dict_from_db['_id'] = "some_random_mongodb_object_id" 
    
    mock_mongodb_collection = AsyncMock() 
    mock_mongodb_collection.find_one = AsyncMock(return_value=task_dict_from_db)
    print(f"  Mock: find_one para retornar dados da tarefa (incluindo _id).")
    
    target_task_id = valid_task_obj.id
    target_owner_id = valid_task_obj.owner_id

    with patch("app.db.task_crud._get_tasks_collection", return_value=mock_mongodb_collection), \
         patch("app.db.task_crud.Task.model_validate", return_value=valid_task_obj) as mock_pydantic_validate:
        # --- Act ---
        print("  Atuando: Chamando task_crud.get_task_by_id...")
        found_task_result = await task_crud.get_task_by_id(
            db=MagicMock(), task_id=target_task_id, owner_id=target_owner_id
        )

    # --- Assert ---
    expected_query_for_find_one = {"id": str(target_task_id), "owner_id": str(target_owner_id)}
    mock_mongodb_collection.find_one.assert_awaited_once_with(expected_query_for_find_one)
    
    expected_dict_for_validation = task_dict_from_db.copy()
    expected_dict_for_validation.pop('_id', None) 
    mock_pydantic_validate.assert_called_once_with(expected_dict_for_validation)
    
    assert found_task_result == valid_task_obj, "A tarefa encontrada n√£o corresponde √† esperada."
    print("  Sucesso: Tarefa encontrada e validada corretamente.")

@pytest.mark.asyncio
async def test_get_task_by_id_when_not_found_in_db():
    """
    Testa o comportamento de `get_task_by_id` quando `find_one` retorna `None`
    (indicando que a tarefa n√£o foi encontrada no banco de dados).
    Espera-se que a fun√ß√£o retorne `None`.
    """
    task_id_not_in_db = uuid.uuid4()
    owner_id_for_test = uuid.uuid4()
    print(f"\nTeste: get_task_by_id - Tarefa n√£o encontrada (Task ID: {task_id_not_in_db})")
    # --- Arrange ---
    mock_mongodb_collection = AsyncMock()
    mock_mongodb_collection.find_one = AsyncMock(return_value=None) 
    print("  Mock: find_one para retornar None.")

    with patch("app.db.task_crud._get_tasks_collection", return_value=mock_mongodb_collection):
        # --- Act ---
        print("  Atuando: Chamando task_crud.get_task_by_id...")
        found_task_result = await task_crud.get_task_by_id(
            db=MagicMock(), task_id=task_id_not_in_db, owner_id=owner_id_for_test
        )

    # --- Assert ---
    mock_mongodb_collection.find_one.assert_awaited_once() 
    assert found_task_result is None, "Deveria retornar None se a tarefa n√£o for encontrada."
    print("  Sucesso: get_task_by_id retornou None como esperado.")

@pytest.mark.asyncio
async def test_get_task_by_id_handles_pydantic_validation_error(mocker):
    """
    Testa o tratamento de erro em `get_task_by_id` quando os dados retornados
    do banco de dados falham na valida√ß√£o do modelo Pydantic `Task.model_validate`.
    Espera-se que a exce√ß√£o seja capturada, logada, e que a fun√ß√£o retorne `None`.
    """
    print("\nTeste: get_task_by_id - Erro de valida√ß√£o Pydantic ao processar dados do DB.")
    # --- Arrange ---
    invalid_task_dict_from_db = {"id": str(uuid.uuid4()), "owner_id": str(uuid.uuid4()), "title_erroneo": "Tarefa Inv√°lida"}
    invalid_task_dict_from_db['_id'] = "another_mongo_id"

    mock_mongodb_collection = AsyncMock()
    mock_mongodb_collection.find_one = AsyncMock(return_value=invalid_task_dict_from_db)
    mock_task_crud_logger = mocker.patch("app.db.task_crud.logger")
    print(f"  Mock: find_one para retornar dados inv√°lidos, logger mockado.")

    task_id_for_test = uuid.UUID(invalid_task_dict_from_db["id"])
    owner_id_for_test = uuid.UUID(invalid_task_dict_from_db["owner_id"])

    simulated_validation_error = ValidationError.from_exception_data(title='TaskModel', line_errors=[])
    
    with patch("app.db.task_crud._get_tasks_collection", return_value=mock_mongodb_collection), \
         patch("app.db.task_crud.Task.model_validate", side_effect=simulated_validation_error): 
        # --- Act ---
        print("  Atuando: Chamando task_crud.get_task_by_id (esperando erro de valida√ß√£o interno)...")
        found_task_result = await task_crud.get_task_by_id(
            db=MagicMock(), task_id=task_id_for_test, owner_id=owner_id_for_test
        )

    # --- Assert ---
    mock_mongodb_collection.find_one.assert_awaited_once()
    assert found_task_result is None, "Deveria retornar None em caso de erro de valida√ß√£o."
    mock_task_crud_logger.error.assert_called_once(), "logger.error n√£o foi chamado."
    print("  Sucesso: Erro de valida√ß√£o tratado, retornou None e erro foi logado.")

# ===========================================
# --- Testes para `get_tasks_by_owner` ---
# ===========================================
@pytest.mark.asyncio
async def test_get_tasks_by_owner_list_basic_success(valid_task_obj: Task):
    """
    Testa a listagem b√°sica de tarefas para um propriet√°rio, sem filtros ou ordena√ß√£o complexa.
    Verifica se a query `find` √© constru√≠da corretamente e se skip/limit s√£o aplicados.
    """
    target_owner_id = valid_task_obj.owner_id
    task_dict_from_db_iter = valid_task_obj.model_dump(mode='json')
    task_dict_from_db_iter['_id'] = "id_from_db" 
    print(f"\nTeste: get_tasks_by_owner - Listagem b√°sica para Owner ID: {target_owner_id}")

    # --- Arrange: Configurar a cadeia de mocks ---
    mock_motor_cursor = AsyncMock() 
    mock_motor_cursor.__aiter__.return_value = [task_dict_from_db_iter]
    mock_motor_cursor.skip = MagicMock(return_value=mock_motor_cursor)
    mock_motor_cursor.limit = MagicMock(return_value=mock_motor_cursor)

    mock_mongodb_collection = MagicMock() 

    mock_mongodb_collection.find = MagicMock(return_value=mock_motor_cursor) 
    
    print("  Mock: Cadeia de find().skip().limit().sort() e valida√ß√£o de modelo configurados.")

    test_limit = 50
    test_skip = 10

    with patch("app.db.task_crud._get_tasks_collection", return_value=mock_mongodb_collection), \
         patch("app.db.task_crud.Task.model_validate", return_value=valid_task_obj):
        # --- Act ---
        print(f"  Atuando: Chamando get_tasks_by_owner com limit={test_limit}, skip={test_skip}...")
        retrieved_tasks_list = await task_crud.get_tasks_by_owner(
            db=MagicMock(), owner_id=target_owner_id, limit=test_limit, skip=test_skip
        )

    # --- Assert ---
    expected_base_query = {"owner_id": str(target_owner_id)}
    mock_mongodb_collection.find.assert_called_once_with(expected_base_query)
    mock_motor_cursor.skip.assert_called_once_with(test_skip)
    mock_motor_cursor.limit.assert_called_once_with(test_limit)
    
    assert len(retrieved_tasks_list) == 1, "N√∫mero de tarefas retornadas incorreto."
    assert retrieved_tasks_list[0] == valid_task_obj, "Tarefa retornada n√£o corresponde √† esperada."
    print(f"  Sucesso: Listagem b√°sica funcionou, {len(retrieved_tasks_list)} tarefa(s) retornada(s).")

@pytest.mark.asyncio
async def test_get_tasks_by_owner_with_all_filters_and_sorting(valid_task_obj: Task):
    """
    Testa a listagem de tarefas com todos os filtros (status, projeto) e ordena√ß√£o.
    Verifica se a query `find` inclui os filtros e se `sort` √© chamado corretamente.
    """
    target_owner_id = valid_task_obj.owner_id
    task_dict_from_db_iter = valid_task_obj.model_dump(mode='json')
    task_dict_from_db_iter['_id'] = "id_for_sort_test"

    # ========================
    # --- Arrange ---
    # ========================
    mock_motor_cursor = AsyncMock() 
    mock_motor_cursor.__aiter__.return_value = [task_dict_from_db_iter]
    mock_motor_cursor.skip = MagicMock(return_value=mock_motor_cursor)  
    mock_motor_cursor.limit = MagicMock(return_value=mock_motor_cursor) 
    mock_motor_cursor.sort = MagicMock(return_value=mock_motor_cursor)
    mock_mongodb_collection = MagicMock()
    mock_mongodb_collection.find = MagicMock(return_value=mock_motor_cursor) 
    

    # ========================
    # --- Act ---
    # ========================
    filter_status = TaskStatus.PENDING
    filter_project = "ProjetoX_Filtro"
    sort_field = "created_at"
    sort_direction = "asc"
    test_limit_val = 10
    test_skip_val = 5

    with patch("app.db.task_crud._get_tasks_collection", return_value=mock_mongodb_collection), \
         patch("app.db.task_crud.Task.model_validate", return_value=valid_task_obj):
        print(f"  Atuando: Chamando get_tasks_by_owner com status, projeto, sort, limit, skip...")
        retrieved_tasks_list = await task_crud.get_tasks_by_owner(
            db=MagicMock(),
            owner_id=target_owner_id,
            status_filter=filter_status,
            project_filter=filter_project,
            sort_by=sort_field,
            sort_order=sort_direction,
            limit=test_limit_val,
            skip=test_skip_val
        )

    expected_query_with_filters = {
        "owner_id": str(target_owner_id),
        "status": filter_status.value,
        "project": filter_project
    }

    # ========================
    # --- Assert ---
    # ========================
    mock_mongodb_collection.find.assert_called_once_with(expected_query_with_filters)
    mock_motor_cursor.skip.assert_called_once_with(test_skip_val)
    mock_motor_cursor.limit.assert_called_once_with(test_limit_val)
    mock_motor_cursor.sort.assert_called_once_with([(sort_field, ASCENDING)])
    assert len(retrieved_tasks_list) == 1
    assert retrieved_tasks_list[0] == valid_task_obj

@pytest.mark.asyncio
async def test_get_tasks_by_owner_handles_validation_error_during_iteration(valid_task_obj: Task, mocker):
    """
    Testa o tratamento de erro em `get_tasks_by_owner` quando `Task.model_validate`
    levanta uma `ValidationError` para um dos documentos durante a itera√ß√£o do cursor.
    Espera-se que o erro seja logado, o item inv√°lido seja pulado, e os itens v√°lidos sejam retornados.
    """
    # ========================
    # --- Arrange ---
    # ========================
    target_owner_id = uuid.uuid4()
    simulated_db_error_on_find = Exception("Erro de Simula√ß√£o de Conex√£o Perdida no Find")
    mock_collection_object = MagicMock()
    mock_collection_object.find.side_effect = simulated_db_error_on_find
    patch_get_collection = patch("app.db.task_crud._get_tasks_collection", return_value=mock_collection_object)
    mock_task_crud_logger = mocker.patch("app.db.task_crud.logger")

    # ========================
    # --- Act ---
    # ========================
    with patch_get_collection: 
        retrieved_tasks_list = await task_crud.get_tasks_by_owner(db=MagicMock(), owner_id=target_owner_id)

    # ========================
    # --- Assert ---
    # ========================
    assert retrieved_tasks_list == [], "Deveria retornar lista vazia em caso de exce√ß√£o no DB."
    mock_task_crud_logger.exception.assert_called_once(), "logger.exception n√£o foi chamado."
    
    log_call_args_tuple = mock_task_crud_logger.exception.call_args[0]
    assert f"DB Error listing tasks for owner {target_owner_id}" in log_call_args_tuple[0], \
        "Mensagem de log de exce√ß√£o n√£o cont√©m as informa√ß√µes esperadas."
    
    mock_collection_object.find.assert_called_once()

@pytest.mark.asyncio
async def test_get_tasks_by_owner_handles_general_db_exception(mocker):
    """
    Testa o tratamento de exce√ß√£o em `get_tasks_by_owner` quando ocorre um erro
    geral no banco de dados durante a opera√ß√£o `find` (ou itera√ß√£o).
    Espera-se que a fun√ß√£o retorne uma lista vazia e logue a exce√ß√£o.
    """
    # ========================
    # --- Arrange ---
    # ========================
    mock_collection = MagicMock()
    owner_id = uuid.uuid4()
    db_error = Exception("Simulated Find Error")
    mock_collection.find.side_effect = db_error
    mock_logger = mocker.patch("app.db.task_crud.logger")

    # ========================
    # --- Act ---
    # ========================
    with patch("app.db.task_crud._get_tasks_collection", return_value=mock_collection):
        tasks = await task_crud.get_tasks_by_owner(db=MagicMock(), owner_id=owner_id)

    # ========================
    # --- Assert ---
    # ========================
    assert tasks == []
    mock_logger.exception.assert_called_once()
    assert f"DB Error listing tasks for owner {owner_id}" in mock_logger.exception.call_args[0][0]

@pytest.mark.asyncio
async def test_get_tasks_by_owner_generic_db_exception(mocker): 
    """
    Testa get_tasks_by_owner quando ocorre uma exce√ß√£o gen√©rica do DB.
    """
    # ========================
    # --- Arrange ---
    # ========================
    owner_id = uuid.uuid4()
    simulated_db_error = Exception("Simulated DB Error during find/iteration")
    mock_db_object = MagicMock()
    mock_collection = MagicMock()
    mock_collection.find.side_effect = simulated_db_error
    mocker.patch("app.db.task_crud._get_tasks_collection", return_value=mock_collection)

    mock_logger_exception = mocker.patch("app.db.task_crud.logger.exception")

    # ========================
    # --- Act ---
    # ========================
    result = await task_crud.get_tasks_by_owner(db=mock_db_object, owner_id=owner_id)

    # ========================
    # --- Assert ---
    # ========================
    assert result == []
    mock_collection.find.assert_called_once()
    mock_logger_exception.assert_called_once()
    call_args, _ = mock_logger_exception.call_args
    assert f"DB Error listing tasks for owner {owner_id}" in call_args[0]
    assert str(simulated_db_error) in call_args[0]

@pytest.mark.asyncio
async def test_get_tasks_by_owner_validation_error_in_loop(mocker, sample_owner_id): 
    """
    Testa get_tasks_by_owner quando um item falha na valida√ß√£o Pydantic
    dentro do loop, mas outros s√£o v√°lidos (simulando itera√ß√£o).
    """
    # ========================
    # --- Arrange ---
    # ========================
    mock_db_object = MagicMock()
    owner_id = sample_owner_id

    valid_task_dict_db = {
        "_id": "valid_id_direct_list", "id": str(uuid.uuid4()), "owner_id": str(owner_id),
        "title": "Valid Task Direct List", "importance": 3, "status": "pendente",
        "created_at": datetime.now(timezone.utc)
    }
    invalid_task_dict_db = {
        "_id": "invalid_id_direct_list", "id": str(uuid.uuid4()), "owner_id": str(owner_id),
        "title": "Invalid Task Direct List", "status": "invalid_status"
    }
    valid_task_obj = Task(
        id=uuid.UUID(valid_task_dict_db['id']), owner_id=sample_owner_id,
        title="Valid Task Direct List", importance=3, status=TaskStatus.PENDING,
        created_at=valid_task_dict_db['created_at']
    )
    mock_final_chain_link = AsyncMock()
    mock_final_chain_link.to_list.return_value = [valid_task_dict_db, invalid_task_dict_db] 
    mock_collection = AsyncMock()
    mock_collection.find.return_value.skip.return_value.limit.return_value = mock_final_chain_link
    mocker.patch("app.db.task_crud._get_tasks_collection", return_value=mock_collection)
    validation_error = ValidationError.from_exception_data(title="Task", line_errors=[])
    dict_for_valid_call = valid_task_dict_db.copy(); dict_for_valid_call.pop("_id")
    dict_for_invalid_call = invalid_task_dict_db.copy(); dict_for_invalid_call.pop("_id")
    mock_validate = mocker.patch(
        "app.db.task_crud.Task.model_validate",
        side_effect=[valid_task_obj, validation_error]
    )
    async def mock_async_for(*args, **kwargs):
        tasks = []
        items = await mock_final_chain_link.to_list() 
        for item in items:
            item.pop('_id', None)
            try:
                tasks.append(Task.model_validate(item)) 
            except (ValidationError, Exception) as e:
                task_crud.logger.error(f"DB Validation error list_tasks owner {owner_id} task {item.get('id', 'N/A')}: {e}")
                continue
        return tasks
    mock_get_tasks_internal = mocker.patch("app.db.task_crud.get_tasks_by_owner", side_effect=mock_async_for)
    mock_logger_error = mocker.patch("app.db.task_crud.logger.error")
    mock_logger_exception = mocker.patch("app.db.task_crud.logger.exception")

    # ========================
    # --- Act ---
    # ========================
    # Chamar a fun√ß√£o (que agora est√° substitu√≠da pelo mock_async_for)
    result = await task_crud.get_tasks_by_owner(db=mock_db_object, owner_id=owner_id)

    # ========================
    # --- Assert ---
    # ========================
    assert len(result) == 1
    assert result[0] == valid_task_obj
    mock_get_tasks_internal.assert_awaited_once_with(db=mock_db_object, owner_id=owner_id)
    assert mock_validate.call_count == 2
    mock_validate.assert_has_calls([call(dict_for_valid_call), call(dict_for_invalid_call)], any_order=False)
    mock_logger_error.assert_called_once()
    call_args_log, _ = mock_logger_error.call_args
    log_message = call_args_log[0]
    assert f"DB Validation error list_tasks owner {sample_owner_id} task {invalid_task_dict_db['id']}" in log_message
    assert str(validation_error) in log_message
    mock_logger_exception.assert_not_called() 

@pytest.mark.asyncio
async def test_get_tasks_by_owner_validation_error_handling(caplog):
    """
    Testa o tratamento de erro de valida√ß√£o dentro do loop
    de get_tasks_by_owner, verificando se o erro √© logado e
    a lista resultante √© vazia (ou cont√©m apenas itens v√°lidos).
    """
      # ========================
    # --- Arrange ---
    # ========================
    db_mock = MagicMock()
    collection_mock = MagicMock()
    db_mock.__getitem__.return_value = collection_mock
    db_mock.tasks = collection_mock
    invalid_task = {"id": "fake-id", "invalid_field": "invalid"}
    cursor_mock = MagicMock()
    cursor_mock.__aiter__.return_value = [invalid_task]
    cursor_mock.skip.return_value = cursor_mock
    cursor_mock.limit.return_value = cursor_mock
    cursor_mock.sort.return_value = cursor_mock
    collection_mock.find = MagicMock()
    collection_mock.find.return_value = cursor_mock
    owner_id = uuid.uuid4()
    

    # ========================
    # --- Act ---
    # ========================
    with patch("app.db.task_crud.logger.error") as mock_logger:
        result = await task_crud.get_tasks_by_owner(db_mock, owner_id)

    # ========================
    # --- Assert ---
    # ========================
    assert result == []
    mock_logger.assert_called()

# ===================================
# --- Testes para `update_task` ---
# ===================================
@pytest.mark.asyncio
async def test_update_task_successfully(valid_task_obj: Task):
    """
    Testa a atualiza√ß√£o bem-sucedida de uma tarefa.
    Verifica se `find_one_and_update` √© chamado com os par√¢metros corretos
    (filtro, dados de atualiza√ß√£o com `$set` e `updated_at`), e se
    `Task.model_validate` √© chamado com o documento retornado pelo DB.
    """
    target_task_id = valid_task_obj.id
    target_owner_id = valid_task_obj.owner_id
    update_payload_data = {"title": "T√≠tulo da Tarefa Atualizado via Teste", "status": TaskStatus.IN_PROGRESS.value}
    
    print(f"\nTeste: update_task - Sucesso (Task ID: {target_task_id})")

    # --- Arrange ---
    fixed_current_time_utc = datetime.now(timezone.utc).replace(microsecond=0)
    
    db_document_after_update = valid_task_obj.model_dump(mode='json')
    db_document_after_update.update(update_payload_data) 
    db_document_after_update['updated_at'] = fixed_current_time_utc 
    db_document_after_update['_id'] = 'some_mongo_id_for_update' 

    expected_final_task_object = Task(**db_document_after_update)
    
    mock_mongodb_collection = AsyncMock()
    mock_mongodb_collection.find_one_and_update = AsyncMock(return_value=db_document_after_update)
    print("  Mock: Cole√ß√£o MongoDB, find_one_and_update, e Task.model_validate configurados.")

    with patch("app.db.task_crud.datetime") as mock_datetime_module, \
         patch("app.db.task_crud._get_tasks_collection", return_value=mock_mongodb_collection), \
         patch("app.db.task_crud.Task.model_validate", return_value=expected_final_task_object) as mock_pydantic_validate:
        
        mock_datetime_module.now.return_value = fixed_current_time_utc 
        
        # --- Act ---
        print(f"  Atuando: Chamando task_crud.update_task com payload: {update_payload_data}")
        update_result_task = await task_crud.update_task(
            db=MagicMock(),
            task_id=target_task_id,
            owner_id=target_owner_id,
            update_data=update_payload_data.copy() 
        )

    # --- Assert ---
    expected_filter_for_update = {"id": str(target_task_id), "owner_id": str(target_owner_id)}
    expected_data_for_set_operator = {**update_payload_data, "updated_at": fixed_current_time_utc}
    
    mock_mongodb_collection.find_one_and_update.assert_awaited_once_with(
        expected_filter_for_update,
        {"$set": expected_data_for_set_operator},
        return_document=True
    )
    expected_dict_for_validation = db_document_after_update.copy()
    expected_dict_for_validation.pop('_id', None)
    mock_pydantic_validate.assert_called_once_with(expected_dict_for_validation)
    
    assert update_result_task == expected_final_task_object, "A tarefa atualizada retornada n√£o √© a esperada."
    print("  Sucesso: Tarefa atualizada e retornada corretamente.")

@pytest.mark.asyncio
async def test_update_task_validation_error_post_db(mocker, sample_task_in_db): 
    """
    Testa falha de valida√ß√£o Pydantic ap√≥s find_one_and_update retornar dados.
    """
    # ========================
    # --- Arrange ---
    # ========================
    test_task_id = sample_task_in_db.id
    owner_id = sample_task_in_db.owner_id
    update_data = {"title": "Updated Title Valid", "status": TaskStatus.IN_PROGRESS.value}
    fixed_timestamp = datetime.now(timezone.utc).replace(microsecond=0)
    mock_db_object = MagicMock()

    mock_doc_returned_from_db = {
        "_id": "mongo_db_id_valid_err",
        "id": str(test_task_id),
        "owner_id": str(owner_id),
        "title": update_data["title"],
        "status": update_data["status"],
        "created_at": sample_task_in_db.created_at,
        "updated_at": fixed_timestamp,
        "due_date": sample_task_in_db.due_date
    }
    expected_dict_for_validation = mock_doc_returned_from_db.copy()
    expected_dict_for_validation.pop("_id")

    mock_dt_now = mocker.patch("app.db.task_crud.datetime")
    mock_dt_now.now.return_value = fixed_timestamp

    mock_collection = AsyncMock()
    mock_collection.find_one_and_update.return_value = mock_doc_returned_from_db
    mocker.patch("app.db.task_crud._get_tasks_collection", return_value=mock_collection)

    simulated_validation_error = ValidationError.from_exception_data(title='Task', line_errors=[{'loc':('importance',), 'type':'missing'}])
    mock_validate = mocker.patch(
        "app.db.task_crud.Task.model_validate",
        side_effect=simulated_validation_error
    )
    mock_logger_error = mocker.patch("app.db.task_crud.logger.error")

    # ========================
    # --- Act ---
    # ========================
    result = await task_crud.update_task(
        db=mock_db_object,
        task_id=test_task_id,
        owner_id=owner_id,
        update_data=update_data.copy() 
    )

    # ========================
    # --- Assert ---
    # ========================
    assert result is None
    mock_collection.find_one_and_update.assert_awaited_once() 

    find_one_update_args, find_one_update_kwargs = mock_collection.find_one_and_update.await_args
    assert len(find_one_update_args) == 2
    call_filter = find_one_update_args[0]
    call_update_doc = find_one_update_args[1]
    assert call_filter == {"id": str(test_task_id), "owner_id": str(owner_id)}
    expected_update_set = update_data.copy()
    expected_update_set["updated_at"] = fixed_timestamp
    assert call_update_doc == {"$set": expected_update_set}
    assert find_one_update_kwargs.get("return_document") is True

    mock_validate.assert_called_once_with(expected_dict_for_validation)

    mock_logger_error.assert_called_once()
    call_args_log, _ = mock_logger_error.call_args
    log_message = call_args_log[0]
    assert f"DB Validation error update_task {test_task_id} owner {owner_id}" in log_message
    assert str(simulated_validation_error) in log_message

@pytest.mark.asyncio
async def test_update_task_generic_exception(mocker, sample_owner_id): 
    """
    Testa update_task quando find_one_and_update levanta exce√ß√£o gen√©rica.
    """
    # ========================
    # --- Arrange ---
    # ========================
    test_task_id = uuid.uuid4()
    owner_id = sample_owner_id 
    update_data = {"title": "Tentativa de Update"}
    mock_db_object = MagicMock()
    fixed_timestamp = datetime.now(timezone.utc).replace(microsecond=0)
    mock_dt_now = mocker.patch("app.db.task_crud.datetime")
    mock_dt_now.now.return_value = fixed_timestamp
    simulated_db_error = Exception("Simulated generic DB error on update")
    mock_collection = AsyncMock()
    mock_collection.find_one_and_update.side_effect = simulated_db_error
    mocker.patch("app.db.task_crud._get_tasks_collection", return_value=mock_collection)
    mock_validate = mocker.patch("app.db.task_crud.Task.model_validate")
    mock_logger_exception = mocker.patch("app.db.task_crud.logger.exception")

    # ========================
    # --- Act ---
    # ========================
    result = await task_crud.update_task(
        db=mock_db_object,
        task_id=test_task_id,
        owner_id=owner_id, 
        update_data=update_data.copy()
    )

    # ========================
    # --- Assert ---
    # ========================
    assert result is None
    mock_collection.find_one_and_update.assert_awaited_once()
    find_one_update_args, find_one_update_kwargs = mock_collection.find_one_and_update.await_args
    assert len(find_one_update_args) == 2
    call_filter = find_one_update_args[0]
    call_update_doc = find_one_update_args[1]
    assert call_filter == {"id": str(test_task_id), "owner_id": str(owner_id)}
    expected_update_set = update_data.copy()
    expected_update_set["updated_at"] = fixed_timestamp
    assert call_update_doc == {"$set": expected_update_set}
    assert find_one_update_kwargs.get("return_document") is True
    mock_validate.assert_not_called()
    mock_logger_exception.assert_called_once()
    call_args_log, _ = mock_logger_exception.call_args
    log_message = call_args_log[0]
    assert f"DB Error updating task {test_task_id} owner {owner_id}" in log_message
    assert str(simulated_db_error) in log_message

@pytest.mark.asyncio
async def test_update_task_not_found_logs_warning(mocker, sample_owner_id): 
    """
    Testa se update_task loga um aviso quando find_one_and_update retorna None.
    """
    # ========================
    # --- Arrange ---
    # ========================
    test_task_id = uuid.uuid4()
    owner_id = sample_owner_id
    update_data = {"title": "Nome Nao Sera Atualizado"}
    mock_db_object = MagicMock()
    fixed_timestamp = datetime.now(timezone.utc).replace(microsecond=0)
    mock_dt_now = mocker.patch("app.db.task_crud.datetime")
    mock_dt_now.now.return_value = fixed_timestamp
    mock_collection = AsyncMock()
    mock_collection.find_one_and_update.return_value = None
    mocker.patch("app.db.task_crud._get_tasks_collection", return_value=mock_collection)
    mock_validate = mocker.patch("app.db.task_crud.Task.model_validate")
    mock_logger_warning = mocker.patch("app.db.task_crud.logger.warning")

    # ========================
    # --- Act ---
    # ========================
    result = await task_crud.update_task(
        db=mock_db_object,
        task_id=test_task_id,
        owner_id=owner_id,
        update_data=update_data.copy()
    )

    # ========================
    # --- Assert ---
    # ========================
    assert result is None
    mock_collection.find_one_and_update.assert_awaited_once()
    find_one_update_args, find_one_update_kwargs = mock_collection.find_one_and_update.await_args
    assert len(find_one_update_args) == 2
    call_filter = find_one_update_args[0]
    call_update_doc = find_one_update_args[1]
    assert call_filter == {"id": str(test_task_id), "owner_id": str(owner_id)}
    expected_update_set = update_data.copy()
    expected_update_set["updated_at"] = fixed_timestamp
    assert call_update_doc == {"$set": expected_update_set}
    assert find_one_update_kwargs.get("return_document") is True
    mock_validate.assert_not_called()
    mock_logger_warning.assert_called_once()
    call_args_log, _ = mock_logger_warning.call_args
    assert f"Tentativa de atualizar tarefa n√£o encontrada: ID {test_task_id}, Owner ID {owner_id}" in call_args_log[0]

# ===================================
# --- Testes para `delete_task` ---
# ===================================
@pytest.mark.asyncio
async def test_delete_task_successfully():
    """
    Testa a dele√ß√£o bem-sucedida de uma tarefa.
    Verifica se `delete_one` √© chamado com a query correta e se a fun√ß√£o
    retorna `True` quando `deleted_count` √© 1.
    """
    target_task_id, target_owner_id = uuid.uuid4(), uuid.uuid4()
    print(f"\nTeste: delete_task - Sucesso (Task ID: {target_task_id})")
    # --- Arrange ---
    mock_mongodb_collection = AsyncMock()
    mock_delete_operation_result = MagicMock()
    mock_delete_operation_result.deleted_count = 1 
    mock_mongodb_collection.delete_one = AsyncMock(return_value=mock_delete_operation_result)
    print("  Mock: delete_one para retornar deleted_count=1.")

    with patch("app.db.task_crud._get_tasks_collection", return_value=mock_mongodb_collection):
        # --- Act ---
        print("  Atuando: Chamando task_crud.delete_task...")
        delete_was_successful = await task_crud.delete_task(
            db=MagicMock(), task_id=target_task_id, owner_id=target_owner_id
        )

    # --- Assert ---
    expected_query_for_delete = {"id": str(target_task_id), "owner_id": str(target_owner_id)}
    mock_mongodb_collection.delete_one.assert_awaited_once_with(expected_query_for_delete)
    assert delete_was_successful is True, "delete_task deveria retornar True para dele√ß√£o bem-sucedida."
    print("  Sucesso: Tarefa deletada e True retornado.")

@pytest.mark.asyncio
async def test_delete_task_when_not_found_or_not_deleted():
    """
    Testa o comportamento de `delete_task` quando a tarefa n√£o √© encontrada
    (ou por algum motivo n√£o √© deletada), resultando em `deleted_count = 0`.
    Espera-se que a fun√ß√£o retorne `False`.
    """
    target_task_id, target_owner_id = uuid.uuid4(), uuid.uuid4()
    print(f"\nTeste: delete_task - Tarefa n√£o encontrada para dele√ß√£o (Task ID: {target_task_id})")
    # --- Arrange ---
    mock_mongodb_collection = AsyncMock()
    mock_delete_operation_result = MagicMock()
    mock_delete_operation_result.deleted_count = 0
    mock_mongodb_collection.delete_one = AsyncMock(return_value=mock_delete_operation_result)
    print("  Mock: delete_one para retornar deleted_count=0.")

    with patch("app.db.task_crud._get_tasks_collection", return_value=mock_mongodb_collection):
        # --- Act ---
        print("  Atuando: Chamando task_crud.delete_task...")
        delete_was_successful = await task_crud.delete_task(
            db=MagicMock(), task_id=target_task_id, owner_id=target_owner_id
        )

    # --- Assert ---
    mock_mongodb_collection.delete_one.assert_awaited_once() 
    assert delete_was_successful is False, "delete_task deveria retornar False se nenhum documento for deletado."
    print("  Sucesso: Dele√ß√£o falhou (tarefa n√£o encontrada) e False retornado.")

@pytest.mark.asyncio
async def test_delete_task_generic_exception(mocker, sample_owner_id): 
    """
    Testa delete_task quando delete_one levanta uma exce√ß√£o gen√©rica.
    """
    # ========================
    # --- Arrange ---
    # ========================
    test_task_id = uuid.uuid4()
    owner_id = sample_owner_id
    mock_db_object = MagicMock()

    simulated_db_error = Exception("Simulated generic DB error on delete")
    mock_collection = AsyncMock()
    mock_collection.delete_one.side_effect = simulated_db_error
    mocker.patch("app.db.task_crud._get_tasks_collection", return_value=mock_collection)

    mock_logger_exception = mocker.patch("app.db.task_crud.logger.exception")

    # ========================
    # --- Act ---
    # ========================
    result = await task_crud.delete_task(
        db=mock_db_object,
        task_id=test_task_id,
        owner_id=owner_id
    )

    # ========================
    # --- Assert ---
    # ========================
    assert result is False 
    mock_collection.delete_one.assert_awaited_once_with({"id": str(test_task_id), "owner_id": str(owner_id)})

    mock_logger_exception.assert_called_once()
    call_args_log, _ = mock_logger_exception.call_args
    log_message = call_args_log[0]
    assert f"DB Error deleting task {test_task_id} owner {owner_id}" in log_message
    assert str(simulated_db_error) in log_message

# ===========================================
# --- Testes para `_parse_sort_params` ---
# ===========================================

@pytest.mark.parametrize(
    "sort_by_input, sort_order_input, expected_output",
    [
        ("due_date", "asc", [("due_date", ASCENDING)]),
        ("priority_score", "desc", [("priority_score", DESCENDING)]),
        ("created_at", "ASC", [("created_at", ASCENDING)]), 
        ("importance", "DESC", [("importance", DESCENDING)]),
        ("due_date", "ascending_string_literal", [("due_date", DESCENDING)]), 
        ("due_date", "", [("due_date", DESCENDING)]),
        ("invalid_sort_field", "desc", None),
        (None, "desc", None),
    ]
)
def test_parse_sort_params_various_inputs(sort_by_input, sort_order_input, expected_output):
    """
    Testa `_parse_sort_params` com v√°rias combina√ß√µes de entrada
    para `sort_by` e `sort_order`, verificando se a sa√≠da corresponde
    ao formato esperado pelo PyMongo para ordena√ß√£o.
    """
    
    print(f"\nTeste: _parse_sort_params(sort_by='{sort_by_input}', sort_order='{sort_order_input}')")
    actual_output = task_crud._parse_sort_params(sort_by_input, sort_order_input)
    print(f"  Sa√≠da Esperada: {expected_output}, Sa√≠da Real: {actual_output}")
    assert actual_output == expected_output, \
        f"Para sort_by='{sort_by_input}', sort_order='{sort_order_input}', " \
        f"esperado {expected_output}, mas obtido {actual_output}."


================================================================================
Cap√≠tulo 27: tests/test_db_user_crud.py
================================================================================

# tests/test_db_user_crud.py

# ========================
# --- Importa√ß√µes ---
# ========================
import uuid
from datetime import datetime, timezone
import pytest # type: ignore
from unittest.mock import AsyncMock, MagicMock, patch, call
from pydantic import ValidationError
from pymongo.errors import DuplicateKeyError

from app.db import user_crud
from app.models.user import UserCreate, UserInDB, UserUpdate

# ====================================
# --- Marcador Global de Teste ---
# ====================================
pytestmark = pytest.mark.asyncio

# ============================
# --- Fixture Auxiliar ---
# ============================
@pytest.fixture
def mock_db_connection() -> AsyncMock:
    """Fornece um mock gen√©rico para a conex√£o DB."""
    return AsyncMock()

@pytest.fixture
def sample_user_create() -> UserCreate:
    """Fornece um objeto UserCreate v√°lido para testes."""
    return UserCreate(
        email="test@example.com",
        username="testuser",
        password="validpassword123",
        full_name="Test User Name"
    )

@pytest.fixture
def sample_user_in_db() -> UserInDB:
    """Fornece um objeto UserInDB v√°lido para testes."""
    user_id = uuid.uuid4()
    return UserInDB(
        id=user_id,
        username="sampleuserindb",
        email="sampleindb@example.com",
        hashed_password="hashed_sample_password",
        full_name="Sample User In DB",
        disabled=False,
        created_at=datetime.now(timezone.utc).replace(microsecond=0),
        updated_at=None
    )

# =======================================
# --- Testes para user_crud.get_user_by_id ---
# =======================================
async def test_get_user_by_id_success(mocker, mock_db_connection, sample_user_in_db): # type: ignore
    """Testa busca de usu√°rio por ID com sucesso."""
    # ========================
    # --- Arrange ---
    # ========================
    test_user_id = sample_user_in_db.id
    user_dict_from_db = sample_user_in_db.model_dump(mode="json")
    user_dict_from_db['_id'] = "mock_mongo_id"
    expected_validation_dict = sample_user_in_db.model_dump(mode="json")

    mock_collection = AsyncMock()
    mock_collection.find_one.return_value = user_dict_from_db
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)
    mock_validate = mocker.patch("app.db.user_crud.UserInDB.model_validate", return_value=sample_user_in_db)

    # ========================
    # --- Act ---
    # ========================
    result = await user_crud.get_user_by_id(db=mock_db_connection, user_id=test_user_id)

    # ========================
    # --- Assert ---
    # ========================
    assert result == sample_user_in_db
    mock_collection.find_one.assert_awaited_once_with({"id": str(test_user_id)})
    mock_validate.assert_called_once_with(expected_validation_dict)

async def test_get_user_by_id_not_found(mocker, mock_db_connection): # type: ignore
    """Testa busca de usu√°rio por ID quando n√£o encontrado."""
    # ========================
    # --- Arrange ---
    # ========================
    test_user_id = uuid.uuid4()
    mock_collection = AsyncMock()
    mock_collection.find_one.return_value = None
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)

    # ========================
    # --- Act ---
    # ========================
    result = await user_crud.get_user_by_id(db=mock_db_connection, user_id=test_user_id)

    # ========================
    # --- Assert ---
    # ========================
    assert result is None
    mock_collection.find_one.assert_awaited_once_with({"id": str(test_user_id)})

async def test_get_user_by_id_validation_error(mocker, mock_db_connection): # type: ignore
    """Testa falha de valida√ß√£o Pydantic ao buscar usu√°rio por ID."""
    # ========================
    # --- Arrange ---
    # ========================
    test_user_id = uuid.uuid4()
    invalid_user_dict_from_db = {"_id": "mongo_id", "id": str(test_user_id), "campo_errado": True}
    expected_validation_dict = {"id": str(test_user_id), "campo_errado": True}

    mock_collection = AsyncMock()
    mock_collection.find_one.return_value = invalid_user_dict_from_db
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)

    simulated_error = ValidationError.from_exception_data(title='UserInDB', line_errors=[])
    mock_validate = mocker.patch("app.db.user_crud.UserInDB.model_validate", side_effect=simulated_error)
    mock_logger_error = mocker.patch("app.db.user_crud.logger.error")

    # ========================
    # --- Act ---
    # ========================
    result = await user_crud.get_user_by_id(db=mock_db_connection, user_id=test_user_id)

    # ========================
    # --- Assert ---
    # ========================
    assert result is None
    mock_collection.find_one.assert_awaited_once_with({"id": str(test_user_id)})
    mock_validate.assert_called_once_with(expected_validation_dict)
    mock_logger_error.assert_called_once()
    assert f"DB Validation error get_user_by_id {test_user_id}" in mock_logger_error.call_args[0][0]

# ===========================================
# --- Testes para user_crud.get_user_by_username ---
# ===========================================
async def test_get_user_by_username_success(mocker, mock_db_connection, sample_user_in_db): # type: ignore
    """Testa busca de usu√°rio por username com sucesso."""
    # ========================
    # --- Arrange ---
    # ========================
    test_username = sample_user_in_db.username
    user_dict_from_db = sample_user_in_db.model_dump(mode="json")
    user_dict_from_db['_id'] = "mock_mongo_id"
    expected_validation_dict = sample_user_in_db.model_dump(mode="json")

    mock_collection = AsyncMock()
    mock_collection.find_one.return_value = user_dict_from_db
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)
    mock_validate = mocker.patch("app.db.user_crud.UserInDB.model_validate", return_value=sample_user_in_db)

    # ========================
    # --- Act ---
    # ========================
    result = await user_crud.get_user_by_username(db=mock_db_connection, username=test_username)

    # ========================
    # --- Assert ---
    # ========================
    assert result == sample_user_in_db
    mock_collection.find_one.assert_awaited_once_with({"username": test_username})
    mock_validate.assert_called_once_with(expected_validation_dict)

async def test_get_user_by_username_not_found(mocker, mock_db_connection): # type: ignore
    """Testa busca de usu√°rio por username quando n√£o encontrado."""
    # ========================
    # --- Arrange ---
    # ========================
    test_username = "nouser_username"
    mock_collection = AsyncMock()
    mock_collection.find_one.return_value = None
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)

    # ========================
    # --- Act ---
    # ========================
    result = await user_crud.get_user_by_username(db=mock_db_connection, username=test_username)

    # ========================
    # --- Assert ---
    # ========================
    assert result is None
    mock_collection.find_one.assert_awaited_once_with({"username": test_username})

async def test_get_user_by_username_validation_error(mocker, mock_db_connection): # type: ignore
    """Testa falha de valida√ß√£o Pydantic ao buscar usu√°rio por username."""
    # ========================
    # --- Arrange ---
    # ========================
    test_username = "invalid_user_validate"
    invalid_user_dict_from_db = {"_id": "mongo_id", "username": test_username, "campo_errado": True}
    expected_validation_dict = {"username": test_username, "campo_errado": True}

    mock_collection = AsyncMock()
    mock_collection.find_one.return_value = invalid_user_dict_from_db
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)

    simulated_error = ValidationError.from_exception_data(title='UserInDB', line_errors=[])
    mock_validate = mocker.patch("app.db.user_crud.UserInDB.model_validate", side_effect=simulated_error)
    mock_logger_error = mocker.patch("app.db.user_crud.logger.error")

    # ========================
    # --- Act ---
    # ========================
    result = await user_crud.get_user_by_username(db=mock_db_connection, username=test_username)

    # ========================
    # --- Assert ---
    # ========================
    assert result is None
    mock_collection.find_one.assert_awaited_once_with({"username": test_username})
    mock_validate.assert_called_once_with(expected_validation_dict)
    mock_logger_error.assert_called_once()
    assert f"DB Validation error get_user_by_username {test_username}" in mock_logger_error.call_args[0][0]

# ===========================================
# --- Testes para user_crud.get_user_by_email ---
# ===========================================
async def test_get_user_by_email_success(mocker, mock_db_connection, sample_user_in_db): # type: ignore
    """Testa busca de usu√°rio por email com sucesso."""
    # ========================
    # --- Arrange ---
    # ========================
    test_email = sample_user_in_db.email
    user_dict_from_db = sample_user_in_db.model_dump(mode="json")
    user_dict_from_db['_id'] = "mock_mongo_id"
    expected_validation_dict = sample_user_in_db.model_dump(mode="json")

    mock_collection = AsyncMock()
    mock_collection.find_one.return_value = user_dict_from_db
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)
    mock_validate = mocker.patch("app.db.user_crud.UserInDB.model_validate", return_value=sample_user_in_db)

    # ========================
    # --- Act ---
    # ========================
    result = await user_crud.get_user_by_email(db=mock_db_connection, email=test_email)

    # ========================
    # --- Assert ---
    # ========================
    assert result == sample_user_in_db
    mock_collection.find_one.assert_awaited_once_with({"email": test_email})
    mock_validate.assert_called_once_with(expected_validation_dict)

async def test_get_user_by_email_not_found(mocker, mock_db_connection): # type: ignore
    """Testa busca de usu√°rio por email quando n√£o encontrado."""
    # ========================
    # --- Arrange ---
    # ========================
    test_email = "nouser@example.com"
    mock_collection = AsyncMock()
    mock_collection.find_one.return_value = None
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)

    # ========================
    # --- Act ---
    # ========================
    result = await user_crud.get_user_by_email(db=mock_db_connection, email=test_email)

    # ========================
    # --- Assert ---
    # ========================
    assert result is None
    mock_collection.find_one.assert_awaited_once_with({"email": test_email})

async def test_get_user_by_email_validation_error(mocker, mock_db_connection): # type: ignore
    """Testa falha de valida√ß√£o Pydantic ao buscar usu√°rio por email."""
    # ========================
    # --- Arrange ---
    # ========================
    test_email = "invalid_validate@example.com"
    invalid_user_dict_from_db = {"_id": "mongo_id", "email": test_email, "campo_errado": True}
    expected_validation_dict = {"email": test_email, "campo_errado": True}

    mock_collection = AsyncMock()
    mock_collection.find_one.return_value = invalid_user_dict_from_db
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)

    simulated_error = ValidationError.from_exception_data(title='UserInDB', line_errors=[])
    mock_validate = mocker.patch("app.db.user_crud.UserInDB.model_validate", side_effect=simulated_error)
    mock_logger_error = mocker.patch("app.db.user_crud.logger.error")

    # ========================
    # --- Act ---
    # ========================
    result = await user_crud.get_user_by_email(db=mock_db_connection, email=test_email)

    # ========================
    # --- Assert ---
    # ========================
    assert result is None
    mock_collection.find_one.assert_awaited_once_with({"email": test_email})
    mock_validate.assert_called_once_with(expected_validation_dict)
    mock_logger_error.assert_called_once()
    assert f"DB Validation error get_user_by_email {test_email}" in mock_logger_error.call_args[0][0]

# =======================================
# --- Testes para user_crud.create_user ---
# =======================================
async def test_create_user_success(mocker, mock_db_connection, sample_user_create): # type: ignore
    """Testa a cria√ß√£o de usu√°rio com sucesso."""
    # ========================
    # --- Arrange ---
    # ========================
    test_uuid = uuid.uuid4()
    test_datetime = datetime.now(timezone.utc)
    mock_uuid_module = mocker.patch("app.db.user_crud.uuid")
    mock_uuid_module.uuid4.return_value = test_uuid
    mock_dt_module = mocker.patch("app.db.user_crud.datetime")
    mock_dt_module.now.return_value = test_datetime
    mock_dt_module.side_effect = lambda *args, **kw: datetime(*args, **kw)

    mocked_hashed_password = "hashed_password_success"
    mocker.patch("app.db.user_crud.get_password_hash", return_value=mocked_hashed_password)

    expected_validation_data_dict = {
        "id": test_uuid,
        "username": sample_user_create.username,
        "email": sample_user_create.email,
        "hashed_password": mocked_hashed_password,
        "full_name": sample_user_create.full_name,
        "disabled": False,
        "created_at": test_datetime,
        "updated_at": None
    }
    mock_validated_user_obj = MagicMock(spec=UserInDB)
    for key, value in expected_validation_data_dict.items():
        setattr(mock_validated_user_obj, key, value)

    mock_validate = mocker.patch(
        "app.db.user_crud.UserInDB.model_validate",
        return_value=mock_validated_user_obj
    )

    expected_dict_to_insert = {k: str(v) if isinstance(v, uuid.UUID) else (v.isoformat() if isinstance(v, datetime) else v) for k, v in expected_validation_data_dict.items() if k != 'created_at'}
    expected_dict_to_insert['created_at'] = test_datetime
    expected_dict_to_insert['updated_at'] = None

    mock_validated_user_obj.model_dump.return_value = expected_dict_to_insert

    mock_insert_result = MagicMock()
    mock_insert_result.acknowledged = True

    mock_collection = AsyncMock()
    mock_collection.insert_one.return_value = mock_insert_result
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)

    # ========================
    # --- Act ---
    # ========================
    result = await user_crud.create_user(db=mock_db_connection, user_in=sample_user_create)

    # ========================
    # --- Assert ---
    # ========================
    assert result == mock_validated_user_obj

    user_crud.get_password_hash.assert_called_once_with(sample_user_create.password)
    mock_validate.assert_called_once_with(expected_validation_data_dict)

    mock_validated_user_obj.model_dump.assert_called_once_with(mode="json")
    mock_collection.insert_one.assert_awaited_once_with(expected_dict_to_insert)

async def test_create_user_raises_duplicate_key_error(mocker, mock_db_connection, sample_user_create): # type: ignore
    """Testa se DuplicateKeyError √© relan√ßado."""
    # ========================
    # --- Arrange ---
    # ========================
    mocker.patch("app.db.user_crud.get_password_hash", return_value="mock_hash")
    mock_validated_obj = MagicMock()
    mock_validated_obj.model_dump.return_value = {"some": "data"}
    mocker.patch("app.db.user_crud.UserInDB.model_validate", return_value=mock_validated_obj)

    simulated_db_error = DuplicateKeyError("E11000 duplicate key error")
    mock_collection = AsyncMock()
    mock_collection.insert_one.side_effect = simulated_db_error
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)
    mock_logger_warning = mocker.patch("app.db.user_crud.logger.warning")

    # ========================
    # --- Act & Assert ---
    # ========================
    with pytest.raises(DuplicateKeyError):
        await user_crud.create_user(db=mock_db_connection, user_in=sample_user_create)

    mock_collection.insert_one.assert_awaited_once_with({"some": "data"})
    mock_logger_warning.assert_called_once()

async def test_create_user_pydantic_validation_failure(mocker): # type: ignore
    """
    Testa se create_user retorna None e loga um erro quando
    UserInDB.model_validate(user_db_data) falha.
    """
    # ========================
    # --- Arrange ---
    # ========================
    valid_user_create_input = UserCreate(
        email="test_pydantic_fail@example.com",
        username="test_pydantic_user_fail",
        password="validpassword123",
        full_name="Test Pydantic Fail"
    )

    mocker.patch("app.db.user_crud.get_password_hash", return_value="mocked_hashed_password")
    mock_logger_error = mocker.patch("app.db.user_crud.logger.error")

    simulated_pydantic_error = ValidationError.from_exception_data(
        title='UserInDB',
        line_errors=[{'type': 'missing', 'loc': ('some_field',), 'msg': 'Field required', 'input': {}}]
    )
    mock_model_validate = mocker.patch(
        "app.db.user_crud.UserInDB.model_validate",
        side_effect=simulated_pydantic_error
    )

    mock_db_connection = AsyncMock()

    # ========================
    # --- Act ---
    # ========================
    result = await user_crud.create_user(db=mock_db_connection, user_in=valid_user_create_input)

    # ========================
    # --- Assert ---
    # ========================
    assert result is None

    mock_model_validate.assert_called_once()

    mock_logger_error.assert_called_once()
    call_args, call_kwargs = mock_logger_error.call_args
    log_message = call_args[0]
    assert f"Erro de valida√ß√£o Pydantic ao preparar dados para user_db_obj (username: {valid_user_create_input.username})" in log_message
    assert str(simulated_pydantic_error) in log_message
    assert call_kwargs.get("exc_info") is True

async def test_create_user_db_insert_not_acknowledged(mocker): # type: ignore
    """
    Testa se create_user retorna None e loga erro quando a inser√ß√£o
    no banco de dados n√£o √© confirmada (acknowledged=False).
    """
    # ========================
    # --- Arrange ---
    # ========================
    valid_user_create_input = UserCreate(
        email="test_not_acknowledged@example.com",
        username="test_user_not_acknowledged",
        password="validpassword123",
        full_name="Test Not Ack"
    )

    mocker.patch("app.db.user_crud.get_password_hash", return_value="mocked_hashed_password")

    mock_user_db_obj = MagicMock()
    expected_dict_to_insert = {"mocked_data": "to_insert"}
    mock_user_db_obj.model_dump.return_value = expected_dict_to_insert
    mock_validate = mocker.patch("app.db.user_crud.UserInDB.model_validate", return_value=mock_user_db_obj)

    mock_insert_result = MagicMock()
    mock_insert_result.acknowledged = False

    mock_collection = AsyncMock()
    mock_collection.insert_one.return_value = mock_insert_result
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)

    mock_logger_error = mocker.patch("app.db.user_crud.logger.error")

    mock_db_connection = AsyncMock()

    # ========================
    # --- Act ---
    # ========================
    result = await user_crud.create_user(db=mock_db_connection, user_in=valid_user_create_input)

    # ========================
    # --- Assert ---
    # ========================
    assert result is None

    mock_validate.assert_called_once()
    mock_user_db_obj.model_dump.assert_called_once_with(mode="json")

    mock_collection.insert_one.assert_awaited_once()

    actual_call_args = mock_collection.insert_one.await_args.args
    actual_call_kwargs = mock_collection.insert_one.await_args.kwargs
    assert len(actual_call_args) == 1
    assert actual_call_args[0] == expected_dict_to_insert
    assert not actual_call_kwargs

    mock_logger_error.assert_called_once()
    call_args, _ = mock_logger_error.call_args
    log_message = call_args[0]
    assert f"DB Insert User Acknowledged False for username {valid_user_create_input.username}" in log_message

async def test_create_user_handles_generic_db_exception_on_insert(mocker): # type: ignore
    """
    Testa se create_user retorna None e loga exce√ß√£o quando
    insert_one levanta um erro gen√©rico do banco de dados.
    """
    # ========================
    # --- Arrange ---
    # ========================
    valid_user_create_input = UserCreate(
        email="test_generic_db_exception@example.com",
        username="test_user_generic_exception",
        password="validpassword123",
        full_name="Test Generic DB Exc"
    )

    mocker.patch("app.db.user_crud.get_password_hash", return_value="mocked_hashed_password")

    mock_user_db_obj = MagicMock()
    expected_dict_to_insert = {"mocked_data": "to_insert"}
    mock_user_db_obj.model_dump.return_value = expected_dict_to_insert
    mock_validate = mocker.patch("app.db.user_crud.UserInDB.model_validate", return_value=mock_user_db_obj)

    simulated_db_error = Exception("Simulated generic database error on insert")
    mock_collection = AsyncMock()
    mock_collection.insert_one.side_effect = simulated_db_error
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)

    mock_logger_exception = mocker.patch("app.db.user_crud.logger.exception")

    mock_db_connection = AsyncMock()

    # ========================
    # --- Act ---
    # ========================
    result = await user_crud.create_user(db=mock_db_connection, user_in=valid_user_create_input)

    # ========================
    # --- Assert ---
    # ========================
    assert result is None

    mock_validate.assert_called_once()
    mock_user_db_obj.model_dump.assert_called_once_with(mode="json")

    mock_collection.insert_one.assert_awaited_once_with(expected_dict_to_insert)

    mock_logger_exception.assert_called_once()
    call_args, _ = mock_logger_exception.call_args
    log_message = call_args[0]
    assert f"Erro inesperado ao inserir usu√°rio {valid_user_create_input.username} no DB" in log_message
    assert str(simulated_db_error) in log_message

# =======================================
# --- Testes para user_crud.update_user ---
# =======================================
async def test_update_user_success(mocker, mock_db_connection, sample_user_in_db): # type: ignore
    """Testa atualiza√ß√£o de usu√°rio com sucesso (sem alterar senha)."""
    # ========================
    # --- Arrange ---
    # ========================
    test_user_id = sample_user_in_db.id
    update_payload = UserUpdate(full_name="Novo Nome Completo", email="novo@email.com")
    fixed_timestamp = datetime.now(timezone.utc).replace(microsecond=0)

    mock_doc_after_update = sample_user_in_db.model_dump(mode="json")
    mock_doc_after_update.update({
        "full_name": update_payload.full_name,
        "email": update_payload.email,
        "updated_at": fixed_timestamp # MongoDB lida com datetime object
    })
    mock_doc_after_update["_id"] = "some_mongo_id"

    expected_validation_dict = mock_doc_after_update.copy()
    expected_validation_dict.pop("_id")

    # Criar obj esperado diretamente
    expected_user_obj = UserInDB(**expected_validation_dict)

    mock_pwd_hash = mocker.patch("app.db.user_crud.get_password_hash")
    mock_dt_now = mocker.patch("app.db.user_crud.datetime")
    mock_dt_now.now.return_value = fixed_timestamp

    mock_collection = AsyncMock()
    mock_collection.find_one_and_update.return_value = mock_doc_after_update
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)
    mock_validate_model = mocker.patch("app.db.user_crud.UserInDB.model_validate", return_value=expected_user_obj)

    # ========================
    # --- Act ---
    # ========================
    result = await user_crud.update_user(db=mock_db_connection, user_id=test_user_id, user_update=update_payload)

    # ========================
    # --- Assert ---
    # ========================
    assert result == expected_user_obj
    mock_pwd_hash.assert_not_called()

    mock_collection.find_one_and_update.assert_awaited_once()
    args, kwargs = mock_collection.find_one_and_update.await_args
    filter_arg = args[0]
    update_arg = args[1]
    assert filter_arg == {"id": str(test_user_id)}
    expected_set = {
        "full_name": update_payload.full_name,
        "email": update_payload.email,
        "updated_at": fixed_timestamp
    }
    assert update_arg == {"$set": expected_set}
    assert kwargs.get("return_document") is True

    mock_validate_model.assert_called_once_with(expected_validation_dict)

async def test_update_user_with_password(mocker, mock_db_connection, sample_user_in_db): # type: ignore
    """Testa atualiza√ß√£o de usu√°rio incluindo a senha."""
    # ========================
    # --- Arrange ---
    # ========================
    test_user_id = sample_user_in_db.id
    new_password = "newSecurePassword123"
    new_hashed_password = "hashed_" + new_password
    update_payload = UserUpdate(password=new_password, disabled=True)
    fixed_timestamp = datetime.now(timezone.utc).replace(microsecond=0)

    mock_doc_after_update = sample_user_in_db.model_dump(mode="json")
    mock_doc_after_update.update({
        "hashed_password": new_hashed_password,
        "disabled": True,
        "updated_at": fixed_timestamp # Usar datetime object
    })
    mock_doc_after_update["_id"] = "pw_update_id"
    expected_validation_dict = mock_doc_after_update.copy()
    expected_validation_dict.pop("_id")

    expected_user_obj = UserInDB(**expected_validation_dict)

    mock_pwd_hash = mocker.patch("app.db.user_crud.get_password_hash", return_value=new_hashed_password)
    mock_dt_now = mocker.patch("app.db.user_crud.datetime")
    mock_dt_now.now.return_value = fixed_timestamp

    mock_collection = AsyncMock()
    mock_collection.find_one_and_update.return_value = mock_doc_after_update
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)
    mock_validate_model = mocker.patch("app.db.user_crud.UserInDB.model_validate", return_value=expected_user_obj)

    # ========================
    # --- Act ---
    # ========================
    result = await user_crud.update_user(db=mock_db_connection, user_id=test_user_id, user_update=update_payload)

    # ========================
    # --- Assert ---
    # ========================
    assert result == expected_user_obj
    mock_pwd_hash.assert_called_once_with(new_password)

    mock_collection.find_one_and_update.assert_awaited_once()
    args, kwargs = mock_collection.find_one_and_update.await_args
    filter_arg = args[0]
    update_arg = args[1]
    assert filter_arg == {"id": str(test_user_id)}
    expected_set = {
        "hashed_password": new_hashed_password,
        "disabled": True,
        "updated_at": fixed_timestamp
    }
    assert update_arg == {"$set": expected_set}
    assert kwargs.get("return_document") is True

    mock_validate_model.assert_called_once_with(expected_validation_dict)

async def test_update_user_not_found(mocker, mock_db_connection): # type: ignore
    """Testa atualiza√ß√£o de usu√°rio quando find_one_and_update retorna None."""
    # ========================
    # --- Arrange ---
    # ========================
    test_user_id = uuid.uuid4()
    update_payload = UserUpdate(full_name="Nome que nao sera atualizado")
    fixed_timestamp = datetime.now(timezone.utc)

    mock_pwd_hash = mocker.patch("app.db.user_crud.get_password_hash")
    mock_dt_now = mocker.patch("app.db.user_crud.datetime")
    mock_dt_now.now.return_value = fixed_timestamp

    mock_collection = AsyncMock()
    mock_collection.find_one_and_update.return_value = None
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)
    mock_logger_warning = mocker.patch("app.db.user_crud.logger.warning")

    # ========================
    # --- Act ---
    # ========================
    result = await user_crud.update_user(db=mock_db_connection, user_id=test_user_id, user_update=update_payload)

    # ========================
    # --- Assert ---
    # ========================
    assert result is None

    mock_collection.find_one_and_update.assert_awaited_once()
    args, kwargs = mock_collection.find_one_and_update.await_args
    expected_set = {"full_name": update_payload.full_name, "updated_at": fixed_timestamp}
    assert args[1] == {"$set": expected_set}

    mock_logger_warning.assert_called_once()
    assert f"Attempt to update user not found: ID {test_user_id}" in mock_logger_warning.call_args[0][0]
    mock_pwd_hash.assert_not_called()

async def test_update_user_raises_duplicate_key_error(mocker, mock_db_connection): # type: ignore
    """Testa se DuplicateKeyError em update √© relan√ßado."""
    # ========================
    # --- Arrange ---
    # ========================
    test_user_id = uuid.uuid4()
    update_payload = UserUpdate(email="existing@duplicate.com")
    fixed_timestamp = datetime.now(timezone.utc)


    mocker.patch("app.db.user_crud.get_password_hash")
    mock_dt_now = mocker.patch("app.db.user_crud.datetime")
    mock_dt_now.now.return_value = fixed_timestamp

    simulated_db_error = DuplicateKeyError("E11000 duplicate key error collection")
    mock_collection = AsyncMock()
    mock_collection.find_one_and_update.side_effect = simulated_db_error
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)
    mock_logger_warning = mocker.patch("app.db.user_crud.logger.warning")

    # ========================
    # --- Act & Assert ---
    # ========================
    with pytest.raises(DuplicateKeyError):
        await user_crud.update_user(db=mock_db_connection, user_id=test_user_id, user_update=update_payload)

    mock_collection.find_one_and_update.assert_awaited_once()
    args, kwargs = mock_collection.find_one_and_update.await_args
    expected_set = {"email": update_payload.email, "updated_at": fixed_timestamp}
    assert args[1] == {"$set": expected_set}

    mock_logger_warning.assert_called_once()

async def test_update_user_generic_exception(mocker, mock_db_connection): # type: ignore
    """Testa tratamento de exce√ß√£o gen√©rica em update."""
    # ========================
    # --- Arrange ---
    # ========================
    test_user_id = uuid.uuid4()
    update_payload = UserUpdate(disabled=False)
    fixed_timestamp = datetime.now(timezone.utc)

    mocker.patch("app.db.user_crud.get_password_hash")
    mock_dt_now = mocker.patch("app.db.user_crud.datetime")
    mock_dt_now.now.return_value = fixed_timestamp

    simulated_db_error = Exception("Generic update error")
    mock_collection = AsyncMock()
    mock_collection.find_one_and_update.side_effect = simulated_db_error
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)
    mock_logger_exception = mocker.patch("app.db.user_crud.logger.exception")

    # ========================
    # --- Act ---
    # ========================
    result = await user_crud.update_user(db=mock_db_connection, user_id=test_user_id, user_update=update_payload)

    # ========================
    # --- Assert ---
    # ========================
    assert result is None

    mock_collection.find_one_and_update.assert_awaited_once()
    args, kwargs = mock_collection.find_one_and_update.await_args
    expected_set = {"disabled": update_payload.disabled, "updated_at": fixed_timestamp}
    assert args[1] == {"$set": expected_set}

    mock_logger_exception.assert_called_once()
    assert f"DB Error updating user {test_user_id}" in mock_logger_exception.call_args[0][0]

async def test_update_user_empty_payload_updates_only_timestamp(mocker): # type: ignore
    """
    Testa se update_user atualiza apenas o timestamp 'updated_at'
    quando o payload de atualiza√ß√£o resulta em nenhum dado a ser modificado,
    e valida se o usu√°rio correto √© retornado.
    """
    # ========================
    # --- Arrange ---
    # ========================
    test_user_id = uuid.uuid4()
    fixed_timestamp = datetime.now(timezone.utc).replace(microsecond=0)

    empty_update_payload = UserUpdate(password=None)

    existing_user_mock = MagicMock(spec=UserInDB)
    existing_user_mock.id = test_user_id

    # Doc retornado pelo DB
    mock_doc_after_update_from_db = {"_id": "mongo_id", "id": str(test_user_id), "updated_at": fixed_timestamp}
    # Dict esperado para valida√ß√£o (sem _id)
    expected_dict_for_validation = {"id": str(test_user_id), "updated_at": fixed_timestamp}
    # Obj esperado p√≥s valida√ß√£o (com dados minimos p/ o teste)
    final_validated_user_mock = MagicMock(spec=UserInDB)

    mocker.patch("app.db.user_crud.get_password_hash")
    mock_get_user = mocker.patch("app.db.user_crud.get_user_by_id", return_value=existing_user_mock)
    mock_dt_now = mocker.patch("app.db.user_crud.datetime")
    mock_dt_now.now.return_value = fixed_timestamp

    mock_collection = AsyncMock()
    mock_collection.find_one_and_update.return_value = mock_doc_after_update_from_db
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)

    # Mock retorna o obj mockado
    mock_validate_model = mocker.patch(
        "app.db.user_crud.UserInDB.model_validate",
        return_value=final_validated_user_mock
    )

    mock_db_connection = AsyncMock()

    # ========================
    # --- Act ---
    # ========================
    result = await user_crud.update_user(
        db=mock_db_connection,
        user_id=test_user_id,
        user_update=empty_update_payload
    )

    # ========================
    # --- Assert ---
    # ========================
    assert result == final_validated_user_mock

    user_crud.get_password_hash.assert_not_called()

    mock_get_user.assert_awaited_once()
    actual_get_user_args = mock_get_user.await_args.args
    actual_get_user_kwargs = mock_get_user.await_args.kwargs
    assert (len(actual_get_user_args) == 2 and actual_get_user_args[0] is mock_db_connection and actual_get_user_args[1] == test_user_id and not actual_get_user_kwargs) or \
           (not actual_get_user_args and len(actual_get_user_kwargs) == 2 and actual_get_user_kwargs.get('db') is mock_db_connection and actual_get_user_kwargs.get('user_id') == test_user_id)

    mock_collection.find_one_and_update.assert_awaited_once()
    find_one_update_args, find_one_update_kwargs = mock_collection.find_one_and_update.await_args
    assert len(find_one_update_args) == 2
    call_filter = find_one_update_args[0]
    call_update_doc = find_one_update_args[1]
    assert call_filter == {"id": str(test_user_id)}
    assert call_update_doc == {"$set": {"updated_at": fixed_timestamp}}
    assert find_one_update_kwargs.get("return_document") is True

    mock_validate_model.assert_called_once_with(expected_dict_for_validation)

async def test_update_user_empty_payload_get_user_returns_none(mocker): # type: ignore
    """
    Testa se update_user retorna None quando o payload de atualiza√ß√£o
    est√° vazio e a busca inicial por get_user_by_id retorna None.
    """
    # ========================
    # --- Arrange ---
    # ========================
    test_user_id = uuid.uuid4()
    empty_update_payload = UserUpdate(password=None)

    mock_pwd_hash = mocker.patch("app.db.user_crud.get_password_hash")

    mock_get_user = mocker.patch("app.db.user_crud.get_user_by_id", return_value=None)

    mock_collection_instance = AsyncMock()
    mocker.patch(
        "app.db.user_crud._get_users_collection",
        return_value=mock_collection_instance
    )

    mock_validate = mocker.patch("app.db.user_crud.UserInDB.model_validate")

    mock_db_connection = AsyncMock()

    # ========================
    # --- Act ---
    # ========================
    result = await user_crud.update_user(
        db=mock_db_connection,
        user_id=test_user_id,
        user_update=empty_update_payload
    )

    # ========================
    # --- Assert ---
    # ========================
    assert result is None

    mock_pwd_hash.assert_not_called()

    mock_get_user.assert_awaited_once()
    actual_get_user_args = mock_get_user.await_args.args
    actual_get_user_kwargs = mock_get_user.await_args.kwargs
    assert (len(actual_get_user_args) == 2 and actual_get_user_args[0] is mock_db_connection and actual_get_user_args[1] == test_user_id and not actual_get_user_kwargs) or \
           (not actual_get_user_args and len(actual_get_user_kwargs) == 2 and actual_get_user_kwargs.get('db') is mock_db_connection and actual_get_user_kwargs.get('user_id') == test_user_id)

    # _get_users_collection *√© chamado* no in√≠cio da fun√ß√£o update_user
    user_crud._get_users_collection.assert_called_once_with(mock_db_connection)
    mock_collection_instance.find_one_and_update.assert_not_called()
    mock_validate.assert_not_called()

async def test_update_user_empty_payload_update_exception(mocker): # type: ignore
    """
    Testa se update_user retorna None e loga exce√ß√£o quando payload est√° vazio
    e a chamada a find_one_and_update (para updated_at) levanta erro.
    """
    # ========================
    # --- Arrange ---
    # ========================
    test_user_id = uuid.uuid4()
    fixed_timestamp = datetime.now(timezone.utc).replace(microsecond=0)
    empty_update_payload = UserUpdate(password=None)

    existing_user_mock = MagicMock(spec=UserInDB)
    existing_user_mock.id = test_user_id

    simulated_update_exception = Exception("Erro ao atualizar apenas updated_at")

    mock_pwd_hash = mocker.patch("app.db.user_crud.get_password_hash")
    mock_get_user = mocker.patch("app.db.user_crud.get_user_by_id", return_value=existing_user_mock)
    mock_dt_now = mocker.patch("app.db.user_crud.datetime")
    mock_dt_now.now.return_value = fixed_timestamp

    mock_collection = AsyncMock()
    mock_collection.find_one_and_update.side_effect = simulated_update_exception
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)

    mock_validate_model = mocker.patch("app.db.user_crud.UserInDB.model_validate")
    mock_logger_exception = mocker.patch("app.db.user_crud.logger.exception")
    mock_db_connection = AsyncMock()

    # ========================
    # --- Act ---
    # ========================
    result = await user_crud.update_user(
        db=mock_db_connection,
        user_id=test_user_id,
        user_update=empty_update_payload
    )

    # ========================
    # --- Assert ---
    # ========================
    assert result is None

    mock_pwd_hash.assert_not_called()
    mock_get_user.assert_awaited_once()

    mock_collection.find_one_and_update.assert_awaited_once()
    mock_validate_model.assert_not_called()
    mock_logger_exception.assert_called_once()
    call_args, _ = mock_logger_exception.call_args
    log_message = call_args[0]
    assert f"DB Error updating user (only updated_at) {test_user_id}" in log_message
    assert str(simulated_update_exception) in log_message

async def test_update_user_empty_payload_validate_failure(mocker): # type: ignore
    """
    Testa falha na valida√ß√£o Pydantic ap√≥s find_one_and_update
    no branch de payload vazio, assumindo que find_one_and_update retornou um doc.
    """
    # ========================
    # --- Arrange ---
    # ========================
    test_user_id = uuid.uuid4()
    fixed_timestamp = datetime.now(timezone.utc).replace(microsecond=0)
    empty_update_payload = UserUpdate(password=None)

    existing_user_mock = MagicMock(spec=UserInDB)
    existing_user_mock.id = test_user_id

    mock_doc_after_update_invalid = {
        "_id": "mongo_id_invalid",
        "id": str(test_user_id),
        "updated_at": fixed_timestamp,
        "campo_inesperado": "este_campo_causa_falha"
    }
    expected_dict_for_validation = {
        "id": str(test_user_id),
        "updated_at": fixed_timestamp,
        "campo_inesperado": "este_campo_causa_falha"
    }

    mocker.patch("app.db.user_crud.get_password_hash")
    mock_get_user = mocker.patch("app.db.user_crud.get_user_by_id", return_value=existing_user_mock)
    mock_dt_now = mocker.patch("app.db.user_crud.datetime")
    mock_dt_now.now.return_value = fixed_timestamp

    mock_collection = AsyncMock()
    mock_collection.find_one_and_update.return_value = mock_doc_after_update_invalid
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)

    simulated_validation_error = ValidationError.from_exception_data(
        title='UserInDB',
        line_errors=[{'type': 'extra_forbidden', 'loc': ('campo_inesperado',), 'msg': 'Extra fields not permitted', 'input': 'este_campo_causa_falha'}]
    )
    mock_validate_model = mocker.patch(
        "app.db.user_crud.UserInDB.model_validate",
        side_effect=simulated_validation_error
    )

    mock_logger_exception = mocker.patch("app.db.user_crud.logger.exception")
    mock_logger_error = mocker.patch("app.db.user_crud.logger.error") # Deve usar .exception agora
    mock_db_connection = AsyncMock()

    # ========================
    # --- Act ---
    # ========================
    result = await user_crud.update_user(
        db=mock_db_connection,
        user_id=test_user_id,
        user_update=empty_update_payload
    )

    # ========================
    # --- Assert ---
    # ========================
    assert result is None

    user_crud.get_password_hash.assert_not_called()
    mock_get_user.assert_awaited_once()
    mock_collection.find_one_and_update.assert_awaited_once()

    # A valida√ß√£o falha, mas ainda √© chamada
    mock_validate_model.assert_called_once_with(expected_dict_for_validation)

    # O erro √© capturado pelo 'except Exception', usando logger.exception
    mock_logger_error.assert_not_called()
    mock_logger_exception.assert_called_once()
    call_args, _ = mock_logger_exception.call_args
    log_message = call_args[0]
    assert f"DB Error updating user (only updated_at) {test_user_id}" in log_message
    assert str(simulated_validation_error) in log_message

async def test_update_user_main_path_validate_failure(mocker): # type: ignore
    """
    Testa falha na valida√ß√£o Pydantic ap√≥s find_one_and_update
    no caminho principal (quando update_data n√£o est√° vazio).
    """
    # ========================
    # --- Arrange ---
    # ========================
    test_user_id = uuid.uuid4()
    update_payload = UserUpdate(full_name="Nome Atualizado")
    fixed_timestamp = datetime.now(timezone.utc).replace(microsecond=0)

    mock_doc_after_update_invalid = {
        "_id": "mongo_id_main_fail",
        "id": str(test_user_id),
        "full_name": update_payload.full_name,
        "updated_at": fixed_timestamp,
        "campo_invalido_no_retorno": 123
    }
    expected_dict_for_validation = {
        "id": str(test_user_id),
        "full_name": update_payload.full_name,
        "updated_at": fixed_timestamp,
        "campo_invalido_no_retorno": 123
    }

    mock_pwd_hash = mocker.patch("app.db.user_crud.get_password_hash")
    mock_get_user = mocker.patch("app.db.user_crud.get_user_by_id")
    mock_dt_now = mocker.patch("app.db.user_crud.datetime")
    mock_dt_now.now.return_value = fixed_timestamp

    mock_collection = AsyncMock()
    mock_collection.find_one_and_update.return_value = mock_doc_after_update_invalid
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)

    simulated_validation_error = ValidationError.from_exception_data(
        title='UserInDB',
        line_errors=[{'type': 'extra_forbidden', 'loc': ('campo_invalido_no_retorno',), 'msg': 'Extra fields not permitted', 'input': 123}]
    )
    mock_validate_model = mocker.patch(
        "app.db.user_crud.UserInDB.model_validate",
        side_effect=simulated_validation_error
    )

    mock_logger_error = mocker.patch("app.db.user_crud.logger.error")
    mock_db_connection = AsyncMock()

    # ========================
    # --- Act ---
    # ========================
    result = await user_crud.update_user(
        db=mock_db_connection,
        user_id=test_user_id,
        user_update=update_payload
    )

    # ========================
    # --- Assert ---
    # ========================
    assert result is None

    mock_pwd_hash.assert_not_called()
    mock_get_user.assert_not_called()

    mock_collection.find_one_and_update.assert_awaited_once()
    find_one_update_args, find_one_update_kwargs = mock_collection.find_one_and_update.await_args
    assert len(find_one_update_args) == 2
    call_filter = find_one_update_args[0]
    call_update_doc = find_one_update_args[1]
    assert call_filter == {"id": str(test_user_id)}
    expected_set_doc = {"full_name": update_payload.full_name, "updated_at": fixed_timestamp}
    assert call_update_doc == {"$set": expected_set_doc}
    assert find_one_update_kwargs.get("return_document") is True

    mock_validate_model.assert_called_once_with(expected_dict_for_validation)

    mock_logger_error.assert_called_once()
    call_args, call_kwargs = mock_logger_error.call_args
    log_message = call_args[0]
    assert f"DB Validation error after updating user {test_user_id}" in log_message
    assert str(simulated_validation_error) in log_message
    # A asser√ß√£o sobre exc_info foi removida, pois o teste falhou e a corre√ß√£o acima garante o log esperado.

async def test_update_user_main_path_user_not_found(mocker, mock_db_connection): # type: ignore
    """
    Testa se update_user retorna None e loga aviso quando o usu√°rio
    n√£o √© encontrado por find_one_and_update no caminho principal.
    """
    # ========================
    # --- Arrange ---
    # ========================
    test_user_id = uuid.uuid4()
    update_payload = UserUpdate(full_name="Nome Nao Atualizado")
    fixed_timestamp = datetime.now(timezone.utc)

    mock_pwd_hash = mocker.patch("app.db.user_crud.get_password_hash")
    mock_dt_now = mocker.patch("app.db.user_crud.datetime")
    mock_dt_now.now.return_value = fixed_timestamp

    mock_collection = AsyncMock()
    mock_collection.find_one_and_update.return_value = None 
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)

    mock_validate_model = mocker.patch("app.db.user_crud.UserInDB.model_validate")
    mock_logger_warning = mocker.patch("app.db.user_crud.logger.warning")

    # ========================
    # --- Act ---
    # ========================
    result = await user_crud.update_user(
        db=mock_db_connection,
        user_id=test_user_id,
        user_update=update_payload
    )

    # ========================
    # --- Assert ---
    # ========================
    assert result is None

    mock_pwd_hash.assert_not_called()
    mock_collection.find_one_and_update.assert_awaited_once()
    mock_validate_model.assert_not_called()

    mock_logger_warning.assert_called_once()
    log_call_args = mock_logger_warning.call_args[0]
    assert f"Attempt to update user not found: ID {test_user_id}" in log_call_args[0]

async def test_update_user_main_path_raises_duplicate_key_error(mocker, mock_db_connection): # type: ignore
    """
    Testa se DuplicateKeyError √© relan√ßado por update_user
    no caminho principal e um aviso √© logado.
    """
    # ========================
    # --- Arrange ---
    # ========================
    test_user_id = uuid.uuid4()
    update_payload = UserUpdate(email="duplicate@test.com") 
    fixed_timestamp = datetime.now(timezone.utc)

    mocker.patch("app.db.user_crud.get_password_hash")
    mock_dt_now = mocker.patch("app.db.user_crud.datetime")
    mock_dt_now.now.return_value = fixed_timestamp

    simulated_db_error = DuplicateKeyError("E11000 duplicate key error collection on update")
    mock_collection = AsyncMock()
    mock_collection.find_one_and_update.side_effect = simulated_db_error
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)

    mock_validate_model = mocker.patch("app.db.user_crud.UserInDB.model_validate")
    mock_logger_warning = mocker.patch("app.db.user_crud.logger.warning")

    # ========================
    # --- Act & Assert ---
    # ========================
    with pytest.raises(DuplicateKeyError):
        await user_crud.update_user(
            db=mock_db_connection,
            user_id=test_user_id,
            user_update=update_payload
        )

    mock_collection.find_one_and_update.assert_awaited_once()
    args, kwargs = mock_collection.find_one_and_update.await_args
    expected_set = {"email": update_payload.email, "updated_at": fixed_timestamp}
    assert args[1] == {"$set": expected_set}

    mock_validate_model.assert_not_called()

    mock_logger_warning.assert_called_once()
    log_call_args = mock_logger_warning.call_args[0]
    assert f"DB Error: Attempt to update user {test_user_id}" in log_call_args[0]
    assert "'email': 'duplicate@test.com'" in log_call_args[0]

async def test_update_user_empty_payload_find_one_and_update_returns_none(mocker): # type: ignore
    """
    Testa se update_user retorna None quando payload est√° vazio,
    usu√°rio existe, mas find_one_and_update (para updated_at) retorna None.
    """
    # ========================
    # --- Arrange ---
    # ========================
    test_user_id = uuid.uuid4()
    fixed_timestamp = datetime.now(timezone.utc).replace(microsecond=0)
    empty_update_payload = UserUpdate(password=None)

    existing_user_mock = MagicMock(spec=UserInDB)
    existing_user_mock.id = test_user_id

    mock_pwd_hash = mocker.patch("app.db.user_crud.get_password_hash")
    mock_get_user = mocker.patch("app.db.user_crud.get_user_by_id", return_value=existing_user_mock)
    mock_dt_now = mocker.patch("app.db.user_crud.datetime")
    mock_dt_now.now.return_value = fixed_timestamp

    mock_collection = AsyncMock()
    mock_collection.find_one_and_update.return_value = None 
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)

    mock_validate_model = mocker.patch("app.db.user_crud.UserInDB.model_validate")
    mock_logger_exception = mocker.patch("app.db.user_crud.logger.exception")
    mock_db_connection = AsyncMock()

    # ========================
    # --- Act ---
    # ========================
    result = await user_crud.update_user(
        db=mock_db_connection,
        user_id=test_user_id,
        user_update=empty_update_payload
    )

    # ========================
    # --- Assert ---
    # ========================
    assert result is None

    mock_pwd_hash.assert_not_called()
    mock_get_user.assert_awaited_once()

    # Verifica a chamada a find_one_and_update (para updated_at)
    mock_collection.find_one_and_update.assert_awaited_once()
    find_one_update_args, find_one_update_kwargs = mock_collection.find_one_and_update.await_args
    assert len(find_one_update_args) == 2
    call_filter = find_one_update_args[0]
    call_update_doc = find_one_update_args[1]
    assert call_filter == {"id": str(test_user_id)}
    assert call_update_doc == {"$set": {"updated_at": fixed_timestamp}}
    assert find_one_update_kwargs.get("return_document") is True

    mock_validate_model.assert_not_called()
    mock_logger_exception.assert_not_called()

# =======================================
# --- Testes para user_crud.delete_user ---
# =======================================
async def test_delete_user_success(mocker, mock_db_connection): # type: ignore
    """Testa dele√ß√£o de usu√°rio com sucesso."""
    # ========================
    # --- Arrange ---
    # ========================
    test_user_id = uuid.uuid4()

    mock_delete_result = MagicMock()
    mock_delete_result.deleted_count = 1

    mock_collection = AsyncMock()
    mock_collection.delete_one.return_value = mock_delete_result
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)
    mock_logger_info = mocker.patch("app.db.user_crud.logger.info")

    # ========================
    # --- Act ---
    # ========================
    result = await user_crud.delete_user(db=mock_db_connection, user_id=test_user_id)

    # ========================
    # --- Assert ---
    # ========================
    assert result is True
    mock_collection.delete_one.assert_awaited_once_with({"id": str(test_user_id)})
    mock_logger_info.assert_called_once_with(f"User {test_user_id} deleted successfully.")

async def test_delete_user_not_found(mocker, mock_db_connection): # type: ignore
    """Testa dele√ß√£o de usu√°rio quando n√£o encontrado."""
    # ========================
    # --- Arrange ---
    # ========================
    test_user_id = uuid.uuid4()

    mock_delete_result = MagicMock()
    mock_delete_result.deleted_count = 0

    mock_collection = AsyncMock()
    mock_collection.delete_one.return_value = mock_delete_result
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)
    mock_logger_warning = mocker.patch("app.db.user_crud.logger.warning")

    # ========================
    # --- Act ---
    # ========================
    result = await user_crud.delete_user(db=mock_db_connection, user_id=test_user_id)

    # ========================
    # --- Assert ---
    # ========================
    assert result is False
    mock_collection.delete_one.assert_awaited_once_with({"id": str(test_user_id)})
    mock_logger_warning.assert_called_once()
    assert f"Attempt to delete user {test_user_id}" in mock_logger_warning.call_args[0][0]
    assert "(deleted_count: 0)" in mock_logger_warning.call_args[0][0]

async def test_delete_user_generic_exception(mocker, mock_db_connection): # type: ignore
    """Testa tratamento de exce√ß√£o gen√©rica em delete_user."""
    # ========================
    # --- Arrange ---
    # ========================
    test_user_id = uuid.uuid4()
    simulated_db_error = Exception("Generic delete error")

    mock_collection = AsyncMock()
    mock_collection.delete_one.side_effect = simulated_db_error
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)
    mock_logger_exception = mocker.patch("app.db.user_crud.logger.exception")

    # ========================
    # --- Act ---
    # ========================
    result = await user_crud.delete_user(db=mock_db_connection, user_id=test_user_id)

    # ========================
    # --- Assert ---
    # ========================
    assert result is False
    mock_collection.delete_one.assert_awaited_once_with({"id": str(test_user_id)})
    mock_logger_exception.assert_called_once()
    assert f"DB Error deleting user {test_user_id}" in mock_logger_exception.call_args[0][0]

# ==============================================
# --- Testes para user_crud.create_user_indexes ---
# ==============================================
async def test_create_user_indexes_success(mocker, mock_db_connection): # type: ignore
    """Testa cria√ß√£o de √≠ndices com sucesso."""
    # ========================
    # --- Arrange ---
    # ========================
    mock_collection = AsyncMock()
    mock_collection.create_index = AsyncMock()
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)
    mock_logger_info = mocker.patch("app.db.user_crud.logger.info")

    # ========================
    # --- Act ---
    # ========================
    await user_crud.create_user_indexes(db=mock_db_connection)

    # ========================
    # --- Assert ---
    # ========================
    expected_calls = [
        call("username", unique=True, name="username_unique_idx"),
        call("email", unique=True, name="email_unique_idx")
    ]
    mock_collection.create_index.assert_has_awaits(expected_calls, any_order=False)
    mock_logger_info.assert_called_once()
    assert "√çndices da cole√ß√£o 'users'" in mock_logger_info.call_args[0][0]
    assert "verificados/criados com sucesso" in mock_logger_info.call_args[0][0]

async def test_create_user_indexes_failure(mocker, mock_db_connection): # type: ignore
    """Testa tratamento de erro na cria√ß√£o de √≠ndices."""
    # ========================
    # --- Arrange ---
    # ========================
    simulated_index_error = Exception("Erro ao criar indice simulado")
    mock_collection = AsyncMock()
    mock_collection.create_index.side_effect = simulated_index_error
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)
    mock_logger_error = mocker.patch("app.db.user_crud.logger.error")

    # ========================
    # --- Act ---
    # ========================
    await user_crud.create_user_indexes(db=mock_db_connection)

    # ========================
    # --- Assert ---
    # ========================
    mock_collection.create_index.assert_awaited_once_with("username", unique=True, name="username_unique_idx")
    mock_logger_error.assert_called_once()
    call_args, call_kwargs = mock_logger_error.call_args
    log_message = call_args[0]
    assert "Erro ao criar √≠ndices para a cole√ß√£o 'users'" in log_message
    assert str(simulated_index_error) in log_message
    assert call_kwargs.get("exc_info") is True

================================================================================
Cap√≠tulo 28: tests/test_main.py
================================================================================

# tests/test_main.py

# ========================
# --- Importa√ß√µes ---
# ========================
import logging
from loguru import logger as loguru_logger_obj
from unittest.mock import AsyncMock, MagicMock
import pytest
from fastapi import FastAPI, status
from fastapi.middleware.cors import CORSMiddleware
from httpx import AsyncClient

# --- M√≥dulos da Aplica√ß√£o ---
from app.core import logging_config 
from app.core.config import Settings, settings 
from app.main import lifespan
from app.main import _setup_cors_middleware


# ======================================
# --- Testes para o Endpoint Raiz ---
# ======================================
@pytest.mark.asyncio
async def test_read_root_endpoint_returns_welcome_message(test_async_client: AsyncClient):
    print("\nTeste: Endpoint raiz ('/').")
    print(f"  Atuando: GET para '/'")
    response = await test_async_client.get("/")

    assert response.status_code == status.HTTP_200_OK, \
        f"Esperado status 200, recebido {response.status_code}. Resposta: {response.text}"
    
    response_json = response.json()
    expected_message_part = f"Bem-vindo √† {settings.PROJECT_NAME}!"
    assert "message" in response_json, "Campo 'message' ausente na resposta JSON."
    assert expected_message_part in response_json["message"], \
        f"Mensagem de boas-vindas n√£o cont√©m '{expected_message_part}'. Recebido: '{response_json['message']}'"
    print(f"  Sucesso: Endpoint raiz retornou a mensagem de boas-vindas esperada.")

# ===============================================
# --- Testes para a Fun√ß√£o de Ciclo de Vida (Lifespan) ---
# ===============================================
@pytest.mark.asyncio
async def test_lifespan_handles_database_connection_failure_on_startup(
    mocker,
    caplog
):
    caplog.set_level(logging.CRITICAL, logger="app.main") # Logger correto para lifespan
    mock_connect_db = mocker.patch('app.main.connect_to_mongo', return_value=None)
    mock_close_db = mocker.patch('app.main.close_mongo_connection', new_callable=AsyncMock)
    mock_create_user_indexes_fn = mocker.patch('app.main.create_user_indexes', new_callable=AsyncMock)
    mock_create_task_indexes_fn = mocker.patch('app.main.create_task_indexes', new_callable=AsyncMock)
    
    # N√£o precisa mokar app.main.logger aqui se estamos apenas checando caplog
    # Mas se a inten√ß√£o √© verificar se logger.critical foi chamado no mock_main_logger
    # ent√£o ele deveria ser mokado. Contudo, o caplog j√° vai pegar.
    
    test_app_instance = MagicMock(spec=FastAPI)
    test_app_instance.state = MagicMock()
    if hasattr(test_app_instance.state, "db"):
        del test_app_instance.state.db
    
    print("  Atuando: Executando o context manager 'lifespan'...")
    async with lifespan(test_app_instance):
        print("    Dentro do 'yield' do lifespan (ap√≥s tentativa de conex√£o).")
        # Adicionando print de debug para cobertura do yield
        print("DEBUG: test_lifespan_handles_database_connection_failure_on_startup - P√≥s-yield")
        assert not hasattr(test_app_instance.state, "db") or test_app_instance.state.db is None, \
            "app.state.db n√£o deveria ser definido se a conex√£o falhou."

    mock_connect_db.assert_awaited_once()
    mock_create_user_indexes_fn.assert_not_called()
    mock_create_task_indexes_fn.assert_not_called()
    
    assert any(
        "Falha fatal ao conectar ao MongoDB" in record.getMessage()
        for record in caplog.records
        if record.name == "app.main" and record.levelname == "CRITICAL"
    ), "Mensagem de log cr√≠tico para falha de conex√£o n√£o encontrada."
    
    mock_close_db.assert_not_called()

@pytest.mark.asyncio
async def test_lifespan_handles_index_creation_failure_on_startup(
    mocker,
    caplog
):
    simulated_index_error = Exception("Erro simulado durante a cria√ß√£o do √≠ndice de usu√°rio.")
    mock_db_connection_instance = AsyncMock()
    mocker.patch('app.main.connect_to_mongo', return_value=mock_db_connection_instance)
    mock_close_db = mocker.patch('app.main.close_mongo_connection', new_callable=AsyncMock)
    mock_create_user_idx_fn = mocker.patch('app.main.create_user_indexes', side_effect=simulated_index_error)
    mock_create_task_idx_fn = mocker.patch('app.main.create_task_indexes', new_callable=AsyncMock)
    
    mock_app_instance_for_lifespan = MagicMock(spec=FastAPI)
    mock_app_instance_for_lifespan.state = MagicMock()

    caplog.set_level(logging.ERROR, logger="app.main")

    try:
        async with lifespan(mock_app_instance_for_lifespan):
            print(f"    Dentro do 'yield' do lifespan. app.state.db={mock_app_instance_for_lifespan.state.db}")
            # Adicionando print de debug para cobertura do yield
            print("DEBUG: test_lifespan_handles_index_creation_failure_on_startup - P√≥s-yield")
            assert mock_app_instance_for_lifespan.state.db == mock_db_connection_instance, \
                "app.state.db n√£o foi definido corretamente ap√≥s conex√£o bem-sucedida."
    except Exception as e:
        pytest.fail(f"Lifespan levantou uma exce√ß√£o inesperada para fora: {e}")

    mock_create_user_idx_fn.assert_awaited_once_with(mock_db_connection_instance)
    mock_create_task_idx_fn.assert_not_called()
    
    error_log_found = False
    for record in caplog.records:
        if record.name == "app.main" and record.levelname == "ERROR":
            if "Erro durante a cria√ß√£o de √≠ndices" in record.getMessage():
                assert record.exc_info is not None and record.exc_info[0] is Exception, \
                    "exc_info=True n√£o foi devidamente logado ou √© do tipo errado."
                error_log_found = True
                break
    assert error_log_found, "Mensagem de log de erro para falha na cria√ß√£o de √≠ndice n√£o encontrada."
    
    mock_close_db.assert_awaited_once()

# ===============================================
# --- Testes Logging Config Externo ---
# ===============================================
# Precisa da importa√ß√£o de loguru_logger se o mock for no objeto original
from loguru import logger as loguru_logger_obj # Importa com outro nome para evitar conflito

def test_intercept_handler_emit_unknown_level(mocker):
    handler = logging_config.InterceptHandler()
    mock_loguru_opt_log = mocker.patch.object(loguru_logger_obj, "opt", return_value=loguru_logger_obj)
    mock_loguru_log = mocker.patch.object(loguru_logger_obj, "log")
    invalid_levelname = "INVALIDLEVELNAME"
    numeric_level = 60
    record = logging.LogRecord(
        name='test.logger',
        level=numeric_level,
        pathname='/path/to/file.py',
        lineno=10,
        msg='Test message with invalid level name',
        args=[],
        exc_info=None,
        func='test_func'
    )
    record.levelname = invalid_levelname
    # Mockar logging.currentframe √© complexo e geralmente n√£o necess√°rio
    # para testar a l√≥gica principal do InterceptHandler.
    # O importante √© que ele chame logger.opt(depth=6, exception=record.exc_info).log(...)
    # e que logger.log seja chamado com o levelname num√©rico se o levelname textual for desconhecido.

    handler.emit(record)

    mock_loguru_opt_log.assert_called_once() # Verifica se .opt() foi chamado
    # A asser√ß√£o mais importante √© que loguru_logger_obj.log foi chamado com o levelno num√©rico
    # e a mensagem correta.
    # Acessar .call_args pode ser um pouco diferente dependendo se opt() retorna um logger diferente ou o mesmo
    # Se opt retorna o mesmo logger:
    final_log_call_args, _ = mock_loguru_log.call_args
    assert final_log_call_args[0] == numeric_level
    assert final_log_call_args[1] == record.getMessage()

# ==================================================
# --- Testes para _setup_cors_middleware ---
# ==================================================
def test_setup_cors_middleware_with_empty_origins_logs_warning(mocker, caplog):
    mock_app = MagicMock(spec=FastAPI)
    mock_settings_empty_cors = Settings(
        MONGODB_URL="mongodb://testhost:27017/testdb",
        JWT_SECRET_KEY="testsecret",
        CORS_ALLOWED_ORIGINS=[]
    )
    caplog.set_level(logging.WARNING, logger="app.main")

    _setup_cors_middleware(mock_app, mock_settings_empty_cors)

    mock_app.add_middleware.assert_not_called()
    assert any(
        "Nenhuma origem CORS configurada" in record.getMessage()
        for record in caplog.records
        if record.name == "app.main" and record.levelname == "WARNING"
    ), "Warning de CORS para origens vazias n√£o encontrado nos logs"
    print("  Sucesso: _setup_cors_middleware logou warning para CORS vazio.")

def test_setup_cors_middleware_with_origins_adds_middleware(mocker, caplog):
    mock_app = MagicMock(spec=FastAPI)
    # A importa√ß√£o 'from fastapi.middleware.cors import CORSMiddleware' deve estar no topo.
    mock_settings_with_cors = Settings(
        MONGODB_URL="mongodb://testhost:27017/testdb",
        JWT_SECRET_KEY="testsecret",
        CORS_ALLOWED_ORIGINS=["http://localhost:3000", "https://example.com"]
    )
    caplog.set_level(logging.INFO, logger="app.main")

    _setup_cors_middleware(mock_app, mock_settings_with_cors)

    mock_app.add_middleware.assert_called_once()
    args, kwargs = mock_app.add_middleware.call_args
    assert args[0] == CORSMiddleware
    assert kwargs.get("allow_origins") == ["http://localhost:3000", "https://example.com"]
    assert kwargs.get("allow_credentials") is True
    assert kwargs.get("allow_methods") == ["*"]
    assert kwargs.get("allow_headers") == ["*"]

    assert any(
        "Configurando CORS para origens:" in record.getMessage()
        for record in caplog.records
        if record.name == "app.main" and record.levelname == "INFO"
    ), "Log de INFO para configura√ß√£o CORS n√£o encontrado."
    print("  Sucesso: _setup_cors_middleware adicionou middleware para CORS configurado.")

# ==================================================
# --- Testes para LifeSpan ---
# ==================================================
@pytest.mark.asyncio
async def test_lifespan_successful_startup_and_shutdown(mocker, caplog):
    """
    Testa o caminho feliz completo do lifespan:
    - Conex√£o com DB bem-sucedida.
    - Cria√ß√£o de ambos os √≠ndices bem-sucedida.
    - Logs de INFO apropriados s√£o emitidos.
    - Conex√£o com DB √© fechada no shutdown.
    """
    caplog.set_level(logging.INFO, logger="app.main") # Capturar logs de INFO
    
    mock_db_conn = AsyncMock(name="MockDBConnection")
    mock_connect_db = mocker.patch('app.main.connect_to_mongo', return_value=mock_db_conn)
    mock_close_db = mocker.patch('app.main.close_mongo_connection', new_callable=AsyncMock)
    mock_create_user_idx = mocker.patch('app.main.create_user_indexes', new_callable=AsyncMock)
    mock_create_task_idx = mocker.patch('app.main.create_task_indexes', new_callable=AsyncMock)
    
    # Usar uma inst√¢ncia real (ou um mock mais completo se necess√°rio) de FastAPI
    # para testar app.state.db
    # test_app = FastAPI(lifespan=lifespan) # Se testar diretamente com a app global, pode ser complicado isolar
    
    # Usar um MagicMock para simular a app
    test_app_instance = MagicMock(spec=FastAPI)
    test_app_instance.state = MagicMock() # Garante que state existe
     # Garante que 'db' n√£o existe antes para simular o set pelo lifespan
    if hasattr(test_app_instance.state, "db"):
        del test_app_instance.state.db


    # --- Act ---
    async with lifespan(test_app_instance):
        print("DEBUG: test_lifespan_successful_startup - P√≥s-yield (dentro do with)")
        # Assert que db foi setado no estado da app
        assert test_app_instance.state.db == mock_db_conn, "app.state.db n√£o foi definido corretamente."

    # --- Assert ---
    mock_connect_db.assert_awaited_once()
    mock_create_user_idx.assert_awaited_once_with(mock_db_conn)
    mock_create_task_idx.assert_awaited_once_with(mock_db_conn) # <--- Isto cobrir√° a linha 69
    
    logs = [record.getMessage() for record in caplog.records if record.name == "app.main"]

    assert "Iniciando ciclo de vida da aplica√ß√£o..." in logs
    assert "Conectado ao MongoDB." in logs
    assert "Tentando criar/verificar √≠ndices..." in logs
    assert "Cria√ß√£o/verifica√ß√£o de √≠ndices conclu√≠da." in logs # <--- Isto cobrir√° a linha 70
    assert "Aplica√ß√£o iniciada e pronta." in logs # Cobrir√° a linha antes do yield
    assert "Iniciando processo de encerramento..." in logs
    assert "Conex√£o com MongoDB fechada." in logs
    assert "Aplica√ß√£o encerrada." in logs
    
    mock_close_db.assert_awaited_once()

================================================================================
Cap√≠tulo 29: tests/test_tasks.py
================================================================================

# tests/test_tasks.py
"""
Este m√≥dulo cont√©m testes de integra√ß√£o para os endpoints de tarefas (`/tasks`)
da API SmartTask, definidos em `app.routers.tasks`.

Os testes cobrem uma ampla gama de funcionalidades, incluindo:
- Cria√ß√£o, listagem, obten√ß√£o, atualiza√ß√£o e dele√ß√£o de tarefas (CRUD).
- Valida√ß√£o de entrada para cria√ß√£o e atualiza√ß√£o de tarefas.
- Filtros e pagina√ß√£o na listagem de tarefas.
- Ordena√ß√£o na listagem de tarefas.
- L√≥gica de autoriza√ß√£o (usu√°rio s√≥ pode acessar/modificar suas pr√≥prias tarefas).
- Tratamento de tokens JWT inv√°lidos ou expirados.
- Tentativas de inje√ß√£o em par√¢metros de filtro.
- Disparo de notifica√ß√µes (e-mail, webhook) via BackgroundTasks.

Utiliza fixtures de `conftest.py` para usu√°rios e autentica√ß√£o.
A biblioteca `freezegun` √© usada para controlar a data/hora em testes sens√≠veis ao tempo.
O envio de webhooks √© mockado automaticamente.
"""

# ==========================================
# --- Importa√ß√µes ---
# ==========================================
import unittest.mock
from unittest.mock import AsyncMock, ANY, MagicMock
from freezegun import freeze_time
from pydantic import ValidationError
import pytest
from httpx import AsyncClient
from fastapi import status
from typing import Dict, List, Any
import uuid
import pytest_asyncio
from app.core.config import settings
from app.db import task_crud
from app.models.task import Task, TaskStatus
from datetime import date, timedelta, datetime, timezone
from tests.conftest import user_a_data
import jwt as jose_jwt
import uuid 
from fastapi import status 

# ==========================================
# --- Mock Webhook ---
# ==========================================
@pytest.fixture(
        autouse=True
)

def auto_mock_send_webhook(mocker):
    """
    Fixture `autouse` que aplica automaticamente um mock √† fun√ß√£o
    `app.routers.tasks.send_webhook_notification` para todos os testes
    definidos neste m√≥dulo.
    Previne chamadas HTTP reais para webhooks e permite verificar se a fun√ß√£o
    foi chamada quando esperado.
    """
    mocker.patch(
        "app.routers.tasks.send_webhook_notification",
        new_callable=unittest.mock.AsyncMock,
    )

# ==========================================
# --- Marcador Asyncio e Fixture ---
# ==========================================
pytestmark = pytest.mark.asyncio

@pytest.fixture
def sample_task_create_data() -> Dict[str, Any]:
    """Fornece um dicion√°rio v√°lido para criar uma tarefa nos testes de rota."""
    return {
        "title": "Task Payload for Route Test",
        "description": "Description from payload test",
        "importance": 4,
        "due_date": (date.today() + timedelta(days=5)).isoformat(),
        "status": TaskStatus.PENDING.value,
        "tags": ["route_t", "test_t"],
        "project": "Router Tests T"
    }

# ==========================================
# --- Base Task Data ---
# ==========================================
base_task_create_data = {
    "title": "Tarefa de Teste Padr√£o",
    "description": "Descri√ß√£o da tarefa padr√£o",
    "importance": 3,
}

# ==========================================
# --- Testes de Cria√ß√£o ---
# ==========================================
async def test_create_task_success(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
):
    """
    Testa a cria√ß√£o bem-sucedida de uma nova tarefa por um usu√°rio autenticado.
    Verifica o status code HTTP 201 CREATED e se os dados retornados
    correspondem ao payload enviado, incluindo campos gerados pelo servidor
    como id, owner_id, created_at e priority_score.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/"
    # --- Act ---
    response = await test_async_client.post(
        url,
        json=base_task_create_data,
        headers=auth_headers_a
    ) 
    # --- Assert ---
    assert response.status_code == status.HTTP_201_CREATED
    response_data = response.json()
    assert response_data["title"] == base_task_create_data["title"]
    assert response_data["importance"] == base_task_create_data["importance"]
    assert response_data["status"] == TaskStatus.PENDING.value
    assert "id" in response_data
    assert "owner_id" in response_data
    assert "created_at" in response_data
    assert "priority_score" in response_data

async def test_create_task_unauthorized(
        test_async_client: AsyncClient
):
     """
     Testa a tentativa de criar uma tarefa sem fornecer um token de autentica√ß√£o.
     Espera-se um erro HTTP 401 Unauthorized como resposta da API.
     """
     # --- Arrange ---
     url = f"{settings.API_V1_STR}/tasks/"
     # --- Act ---
     response = await test_async_client.post(url, json=base_task_create_data) 
     # --- Assert ---
     assert response.status_code == status.HTTP_401_UNAUTHORIZED

# ==================================================================
# --- Testes de Cria√ß√£o e Atualiza√ß√£o ---
# ==================================================================
@pytest.mark.parametrize(
    "field, length", [
        ("title", 100), 
        ("description", 500), 
    ]
)
async def test_create_task_max_length_success(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    field: str,
    length: int,
):
    """
    Testa a cria√ß√£o de uma tarefa com campos de string (`title`, `description`)
    preenchidos exatamente no seu comprimento m√°ximo permitido.
    Espera-se que a cria√ß√£o seja bem-sucedida com um status HTTP 201 CREATED.
    """
    # --- Arrange ---
    payload = base_task_create_data.copy()
    payload[field] = "X" * length 
    url = f"{settings.API_V1_STR}/tasks/"
    # --- Act ---
    response = await test_async_client.post(url, json=payload, headers=auth_headers_a)
    # --- Assert ---
    assert response.status_code == status.HTTP_201_CREATED
    response_data = response.json()
    assert response_data[field] == payload[field]

@pytest.mark.parametrize(
    "field, length", [
        ("title", 101), 
        ("description", 501), 
    ]
)
async def test_create_task_max_length_fail(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    field: str,
    length: int,
):
    """
    Testa a tentativa de criar uma tarefa com campos de string (`title`, `description`)
    excedendo o comprimento m√°ximo permitido estabelecido pelo modelo de dados.
    Espera-se um erro de valida√ß√£o HTTP 422 Unprocessable Entity.
    """
    # --- Arrange ---
    payload = base_task_create_data.copy()
    payload[field] = "X" * length
    url = f"{settings.API_V1_STR}/tasks/"
    # --- Act ---
    response = await test_async_client.post(url, json=payload, headers=auth_headers_a)
    # --- Assert ---
    assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY
    assert f"String should have at most {length -1} characters" in response.text

async def test_create_task_explicit_nulls_optional(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
):
    """
    Testa a cria√ß√£o de uma tarefa onde campos opcionais (description, due_date,
    tags, project) s√£o explicitamente enviados como `null` (None em Python) no payload.
    Espera-se que a tarefa seja criada com sucesso (HTTP 201) e que esses campos
    reflitam o valor nulo na resposta.
    """
    # ========================
        # --- Arrange ---
    # ========================
    payload = base_task_create_data.copy()
    payload["description"] = None
    payload["due_date"] = None
    payload["tags"] = None
    payload["project"] = None
    url = f"{settings.API_V1_STR}/tasks/"

    # ========================
    # --- Act ---
    # ========================
    response = await test_async_client.post(url, json=payload, headers=auth_headers_a)

    # ========================
    # --- Assert ---
    # ========================
    assert response.status_code == status.HTTP_201_CREATED
    response_data = response.json()
    assert response_data["description"] is None
    assert response_data["due_date"] is None
    assert response_data["tags"] is None
    assert response_data["project"] is None

async def test_update_task_explicit_nulls_optional(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
):
    """
    Testa a atualiza√ß√£o de uma tarefa existente, definindo campos opcionais
    (que previamente continham valores) para `null` (None em Python) no payload.
    Primeiro, uma tarefa √© criada com valores. Em seguida, √© atualizada.
    Espera-se que a atualiza√ß√£o seja bem-sucedida (HTTP 200) e os campos
    sejam refletidos como nulos na resposta.
    """
    # ========================
    # --- Arrange ---
    # ========================
    url_create = f"{settings.API_V1_STR}/tasks/"
    create_payload = {
        **base_task_create_data,
        "description": "Descri√ß√£o inicial",
        "due_date": date.today().isoformat(),
        "tags": ["inicial"],
        "project": "Projeto Inicial"
    }
    create_resp = await test_async_client.post(url_create, json=create_payload, headers=auth_headers_a)
    assert create_resp.status_code == status.HTTP_201_CREATED
    task_id = create_resp.json()["id"]

    # ========================
    # --- Act ---
    # ========================
    url_put = f"{settings.API_V1_STR}/tasks/{task_id}"
    update_payload = {
        "description": None,
        "due_date": None,
        "tags": None, 
        "project": None,
    }
    response = await test_async_client.put(url_put, json=update_payload, headers=auth_headers_a)
    
    # ========================
    # --- Assert ---
    # ========================
    assert response.status_code == status.HTTP_200_OK
    response_data = response.json()
    assert response_data["description"] is None
    assert response_data["due_date"] is None
    assert response_data["tags"] is None 
    assert response_data["project"] is None

@pytest.mark.asyncio
async def test_create_task_internal_validation_error(test_async_client: AsyncClient, mocker, auth_headers_a, sample_task_create_data): 
    """
    Testa o tratamento de erro quando a valida√ß√£o Pydantic interna
    ao construir o objeto Task completo na rota falha.
    """
    # ========================
    # --- Arrange ---
    # ========================
    url = f"{settings.API_V1_STR}/tasks/"
    task_payload = sample_task_create_data

    mocker.patch("app.routers.tasks.calculate_priority_score", return_value=50.0)
    simulated_error = ValidationError.from_exception_data(title="Task", line_errors=[])
    mock_task_init = mocker.patch("app.routers.tasks.Task", side_effect=simulated_error)

    mock_crud_create = mocker.patch("app.routers.tasks.task_crud.create_task")
    mock_logger_error = mocker.patch("app.routers.tasks.logger.error")

    # ========================
    # --- Act ---
    # ========================
    response = await test_async_client.post(url, json=task_payload, headers=auth_headers_a)

    # ========================
    # --- Assert ---
    # ========================
    assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY
    assert "Erro interno na valida√ß√£o dos dados da tarefa" in response.json()["detail"]
    mock_task_init.assert_called_once()
    mock_crud_create.assert_not_called()
    mock_logger_error.assert_called_once()
    log_call_args = mock_logger_error.call_args.args
    assert "Erro de valida√ß√£o Pydantic ao montar objeto Task" in log_call_args[0]

@pytest.mark.asyncio
async def test_update_task_crud_returns_none(test_async_client: AsyncClient, mocker, auth_headers_a, test_user_a_token_and_id): 
    """
    Testa o comportamento da rota PUT /tasks/{task_id} quando
    task_crud.update_task retorna None.
    """
    # ========================
    # --- Arrange ---
    # ========================
    token, user_id_a = test_user_a_token_and_id
    target_task_id = uuid.uuid4()
    url = f"{settings.API_V1_STR}/tasks/{target_task_id}"
    update_payload = {"title": "Titulo Nao Aplicado"}
    mock_existing_task = MagicMock(spec=Task)
    mock_existing_task.importance = 3 
    mock_existing_task.due_date = None 
    mocker.patch("app.routers.tasks.task_crud.get_task_by_id", return_value=mock_existing_task)
    mock_crud_update = mocker.patch("app.routers.tasks.task_crud.update_task", return_value=None)
    mocker.patch("app.routers.tasks.calculate_priority_score")
    mock_logger_error = mocker.patch("app.routers.tasks.logger.error")

    # ========================
    # --- Act ---
    # ========================
    response = await test_async_client.put(url, json=update_payload, headers=auth_headers_a)

    # ========================
    # --- Assert ---
    # ========================
    assert response.status_code == status.HTTP_404_NOT_FOUND
    assert "N√£o foi poss√≠vel atualizar a tarefa" in response.json()["detail"]
    assert "Pode ter sido deletada ou ocorreu um erro interno" in response.json()["detail"]
    task_crud.get_task_by_id.assert_called_once_with(db=mocker.ANY, task_id=target_task_id, owner_id=user_id_a)
    mock_crud_update.assert_called_once()
    mock_logger_error.assert_called_once()
    assert f"Falha ao atualizar tarefa {target_task_id}" in mock_logger_error.call_args.args[0]

@pytest.mark.asyncio
async def test_create_urgent_task_logs_warning_if_user_incomplete(test_async_client: AsyncClient, mocker): # type: ignore
    """
    Testa se um warning √© logado ao criar tarefa urgente se o usu√°rio
    n√£o possui nome completo (mas tem e-mail).
    """
    # ========================
    # --- Arrange ---
    # ========================
    username = f"incomplete_name_{uuid.uuid4().hex[:4]}"
    email = f"{username}@example.com"
    incomplete_user_data = {
        "email": email,
        "username": username,
        "password": "password123",
        "full_name": None 
    }
    register_url = f"{settings.API_V1_STR}/auth/register"
    login_url = f"{settings.API_V1_STR}/auth/login/access-token"

    reg_response = await test_async_client.post(register_url, json=incomplete_user_data)
    assert reg_response.status_code == status.HTTP_201_CREATED
    user_id = reg_response.json()["id"]

    login_payload_form_data = {
        "username": username,
        "password": incomplete_user_data["password"]
    }
    login_response = await test_async_client.post(login_url, data=login_payload_form_data)
    assert login_response.status_code == status.HTTP_200_OK
    token = login_response.json()["access_token"]
    incomplete_user_headers = {"Authorization": f"Bearer {token}"}

    url_create = f"{settings.API_V1_STR}/tasks/"
    urgent_task_payload = {
        "title": "Urgente, usu√°rio sem nome",
        "importance": 5,
        "due_date": (date.today() - timedelta(days=1)).isoformat()
    }

    mocker.patch("app.routers.tasks.is_task_urgent", return_value=True)
    mock_send_email = mocker.patch("app.routers.tasks.send_urgent_task_notification", new_callable=AsyncMock)
    mock_logger_warning = mocker.patch("app.routers.tasks.logger.warning")

    mock_created_task = MagicMock(spec=Task)
    task_id_created = uuid.uuid4()
    mock_created_task.id = task_id_created
    mock_created_task.owner_id = uuid.UUID(user_id)
    mock_created_task.title = urgent_task_payload["title"]
    mocker.patch("app.routers.tasks.task_crud.create_task", return_value=mock_created_task)
    mocker.patch("app.routers.tasks.calculate_priority_score", return_value=1000.0)

    # ========================
    # --- Act ---
    # ========================
    response = await test_async_client.post(url_create, json=urgent_task_payload, headers=incomplete_user_headers)

    # ========================
    # --- Assert ---
    # ========================
    assert response.status_code == status.HTTP_201_CREATED

    mock_logger_warning.assert_called_once()
    log_message = mock_logger_warning.call_args.args[0]
    assert f"Usu√°rio {user_id} (username: {username})" in log_message
    assert "n√£o possui e-mail ou nome completo configurado" in log_message
    assert f"tarefa urgente {task_id_created}" in log_message

    mock_send_email.assert_not_called()

# ==============================================================
# --- Testes de Valida√ß√£o de Entrada (Parametrizados) ---
# ==============================================================
@pytest.mark.parametrize(
    "field, value, error_type, error_msg_part", [
        ("title", "T2", "string_too_short", "String should have at least 3 characters"),
        ("importance", 0, "greater_than_equal", "Input should be greater than or equal to 1"),
        ("importance", 6, "less_than_equal", "Input should be less than or equal to 5"),
        ("due_date", "nao-e-data", "date_from_datetime_parsing", "invalid character"),
        ("status", "invalido", "enum", "Input should be"),
    ]
)
async def test_create_task_invalid_input(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    field: str, value: Any, error_type: str, error_msg_part: str
):
    """
    Testa a cria√ß√£o de tarefas com diversos tipos de dados de entrada inv√°lidos
    para campos espec√≠ficos, como title, importance, due_date e status.
    Verifica se a API retorna HTTP 422 Unprocessable Entity e se a mensagem
    de erro na resposta `detail` corresponde ao campo e tipo de erro esperados.
    """
    # --- Arrange ---
    invalid_data = base_task_create_data.copy()
    if value is None:
         if field in ["title", "importance"]:
              if field in invalid_data: 
                   del invalid_data[field]
         elif field == "status":
              pytest.skip("Teste 'None' n√£o aplic√°vel para 'status' com default.")
              return
         else:
             invalid_data[field] = value
    else:
        invalid_data[field] = value

    url = f"{settings.API_V1_STR}/tasks/"
    # --- Act ---
    response = await test_async_client.post(url, json=invalid_data, headers=auth_headers_a)
    # --- Assert ---
    assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY
    error_details = response.json()["detail"]
    found_error = False
    for error in error_details:
        if field in error.get("loc", []) and error.get("type") == error_type:
            if error_msg_part in error.get("msg", ""):
                found_error = True
                break
    assert found_error, f"Erro esperado para campo '{field}' tipo '{error_type}' msg '{error_msg_part}' n√£o encontrado em {error_details}"

@pytest.mark.parametrize(
    "field, value, error_type, error_msg_part", [
        ("title", "T2", "string_too_short", "String should have at least 3 characters"),
        ("importance", 0, "greater_than_equal", "Input should be greater than or equal to 1"),
        ("importance", 6, "less_than_equal", "Input should be less than or equal to 5"),
        ("due_date", "nao-e-data", "date_from_datetime_parsing", "invalid character"),
        ("status", "invalido", "enum", "Input should be"), 
    ]
)
async def test_update_task_invalid_input(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    field: str, value: Any, error_type: str, error_msg_part: str
):
    """
    Testa a atualiza√ß√£o de tarefas com dados de entrada inv√°lidos para campos espec√≠ficos.
    Primeiro cria uma tarefa v√°lida, depois tenta atualiz√°-la com um valor inv√°lido.
    Verifica se a API retorna HTTP 422 Unprocessable Entity e se a mensagem
    de erro corresponde ao esperado.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/"
    create_resp = await test_async_client.post(url, json=base_task_create_data, headers=auth_headers_a)
    assert create_resp.status_code == 201
    task_id = create_resp.json()["id"]

    # --- Act ---
    invalid_update_payload = {field: value}
    url_put = f"{settings.API_V1_STR}/tasks/{task_id}"
    response = await test_async_client.put(url_put, json=invalid_update_payload, headers=auth_headers_a)

    # --- Assert ---
    assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY
    error_details = response.json()["detail"]
    found_error = False
    for error in error_details:
        if field in error.get("loc", []) and error.get("type") == error_type:
            if error_msg_part in error.get("msg", ""):
                found_error = True
                break
    assert found_error, f"Erro esperado para campo '{field}' com tipo '{error_type}' e msg contendo '{error_msg_part}' n√£o encontrado em {error_details}"

async def test_update_task_empty_payload(
     test_async_client: AsyncClient, auth_headers_a: Dict[str, str]
):
    """
    Testa a tentativa de atualizar uma tarefa enviando um payload JSON vazio (`{}`).
    Verifica se a API retorna um erro HTTP 400 Bad Request, indicando que
    nenhum campo v√°lido para atualiza√ß√£o foi fornecido.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/"
    create_resp = await test_async_client.post(url, json=base_task_create_data, headers=auth_headers_a)
    assert create_resp.status_code == 201
    task_id = create_resp.json()["id"]

    # --- Act ---
    url_put = f"{settings.API_V1_STR}/tasks/{task_id}"
    response = await test_async_client.put(url_put, json={}, headers=auth_headers_a)

    # --- Assert ---
    assert response.status_code == status.HTTP_400_BAD_REQUEST
    assert "Nenhum campo v√°lido fornecido" in response.json()["detail"]

# ==========================================
# --- Testes de Listagem ---
# ==========================================
async def test_list_tasks_success(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str]
):
    """
    Testa a listagem bem-sucedida de tarefas para um usu√°rio autenticado (User A).
    Cria duas tarefas para o User A e verifica se ambas s√£o retornadas ao listar
    tarefas para este usu√°rio, e se o status code √© HTTP 200 OK.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/"
    task1 = {**base_task_create_data, "title": "Task A1 List", "importance": 5, "project": "Alpha"}
    task2 = {**base_task_create_data, "title": "Task A2 List", "status": TaskStatus.IN_PROGRESS.value, "tags": ["urgent"]}
    # --- Act ---
    resp1 = await test_async_client.post(url, json=task1, headers=auth_headers_a)
    # --- Assert ---
    assert resp1.status_code == 201
    # --- Act ---
    resp2 = await test_async_client.post(url, json=task2, headers=auth_headers_a)
    # --- Assert ---
    assert resp2.status_code == 201

    # --- Act ---
    response = await test_async_client.get(url, headers=auth_headers_a)

    # --- Assert ---
    assert response.status_code == status.HTTP_200_OK
    tasks = response.json()
    assert isinstance(tasks, list)
    assert len(tasks) == 2
    titles = {task["title"] for task in tasks}
    assert task1["title"] in titles
    assert task2["title"] in titles

async def test_list_tasks_unauthorized(
        test_async_client: AsyncClient
):
     """
     Testa a tentativa de listar tarefas sem fornecer um token de autentica√ß√£o.
     Espera-se um erro HTTP 401 Unauthorized.
     """
     # --- Arrange ---
     url = f"{settings.API_V1_STR}/tasks/"
     # --- Act ---
     response = await test_async_client.get(url)
     # --- Assert ---
     assert response.status_code == status.HTTP_401_UNAUTHORIZED

async def test_list_tasks_does_not_show_other_users_tasks(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    auth_headers_b: Dict[str, str]
):
    """
    Testa a separa√ß√£o de dados entre usu√°rios na listagem de tarefas.
    Garante que o User B, ao listar suas tarefas, n√£o veja as tarefas criadas
    pelo User A.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/"
    task_a = {**base_task_create_data, "title": "Tarefa Secreta A"}
    resp_a = await test_async_client.post(url, json=task_a, headers=auth_headers_a)
    assert resp_a.status_code == 201

    # --- Act ---
    response_b = await test_async_client.get(url, headers=auth_headers_b)

    # --- Assert ---
    assert response_b.status_code == status.HTTP_200_OK
    tasks_b = response_b.json()
    assert isinstance(tasks_b, list)
    assert len(tasks_b) == 0

async def test_list_tasks_filter_non_existent_project(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    create_filter_sort_tasks: List[Dict] 
):
    """
    Testa a funcionalidade de filtro de listagem de tarefas por projeto,
    especificamente quando o projeto fornecido no filtro n√£o existe em nenhuma tarefa.
    Espera-se uma lista vazia e status HTTP 200 OK.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/?project=ProjetoInexistente123"
    # --- Act ---
    response = await test_async_client.get(url, headers=auth_headers_a)
    # --- Assert ---
    assert response.status_code == status.HTTP_200_OK
    tasks = response.json()
    assert isinstance(tasks, list)
    assert len(tasks) == 0 

async def test_list_tasks_filter_non_existent_tag(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    create_filter_sort_tasks: List[Dict]
):
    """
    Testa a funcionalidade de filtro de listagem de tarefas por tag,
    quando a tag fornecida n√£o est√° associada a nenhuma tarefa.
    Espera-se uma lista vazia e status HTTP 200 OK.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/?tag=tag_nao_existe"
    # --- Act ---
    response = await test_async_client.get(url, headers=auth_headers_a)
    # --- Assert ---
    assert response.status_code == status.HTTP_200_OK
    tasks = response.json()
    assert isinstance(tasks, list)
    assert len(tasks) == 0

async def test_list_tasks_filter_multiple_tags_no_match(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    create_filter_sort_tasks: List[Dict]
):
    """
    Testa o filtro de listagem por m√∫ltiplas tags quando nenhuma tarefa
    cont√©m TODAS as tags especificadas. O filtro por m√∫ltiplas tags geralmente
    implica uma opera√ß√£o AND (a tarefa deve ter todas as tags).
    Espera-se uma lista vazia e status HTTP 200 OK.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/?tag=t1&tag=t3"
    # --- Act ---
    response = await test_async_client.get(url, headers=auth_headers_a)
    # --- Assert ---
    assert response.status_code == status.HTTP_200_OK
    tasks = response.json()
    assert isinstance(tasks, list)
    assert len(tasks) == 0 

async def test_list_tasks_filter_status_no_match(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    create_filter_sort_tasks: List[Dict]
):
    """
    Testa o filtro de listagem por status quando nenhuma tarefa corresponde
    ao status fornecido (ex: 'cancelada', se n√£o houver tarefas canceladas).
    Espera-se uma lista vazia e status HTTP 200 OK.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/?status={TaskStatus.CANCELLED.value}"
    # --- Act ---
    response = await test_async_client.get(url, headers=auth_headers_a)
    # --- Assert ---
    assert response.status_code == status.HTTP_200_OK
    tasks = response.json()
    assert isinstance(tasks, list)
    assert len(tasks) == 0 

@freeze_time("2025-05-04")
async def test_list_tasks_filter_due_before_very_early(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    create_filter_sort_tasks: List[Dict]
):
    """
    Testa o filtro de listagem por data de vencimento (`due_before`) usando uma
    data muito no passado, onde nenhuma tarefa da fixture `create_filter_sort_tasks`
    (cujos prazos s√£o futuros em rela√ß√£o a "2025-05-04") deveria ser retornada.
    Espera-se uma lista vazia e status HTTP 200 OK.
    """
    # --- Arrange ---
    early_date = "2024-01-01"
    url = f"{settings.API_V1_STR}/tasks/?due_before={early_date}"
    # --- Act ---
    response = await test_async_client.get(url, headers=auth_headers_a)
    # --- Assert ---
    assert response.status_code == status.HTTP_200_OK
    tasks = response.json()
    assert isinstance(tasks, list)
    assert len(tasks) == 0 

# ========================================
# --- Testes de Pagina√ß√£o ---
# ========================================
async def test_list_tasks_pagination_limit_1(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    create_filter_sort_tasks: List[Dict] 
):
    """
    Testa a funcionalidade de pagina√ß√£o da listagem de tarefas,
    especificamente o par√¢metro `limit`.
    Verifica se, ao definir `limit=1`, apenas uma tarefa √© retornada.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/?limit=1"
    # --- Act ---
    response = await test_async_client.get(url, headers=auth_headers_a)
    # --- Assert ---
    assert response.status_code == status.HTTP_200_OK
    tasks = response.json()
    assert isinstance(tasks, list)
    assert len(tasks) == 1 

async def test_list_tasks_pagination_skip_all(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    create_filter_sort_tasks: List[Dict] 
):
    """
    Testa a funcionalidade de pagina√ß√£o `skip`.
    Verifica se, ao pular um n√∫mero de tarefas igual ou maior ao total existente
    (criado pela fixture `create_filter_sort_tasks`), uma lista vazia √© retornada.
    """
    # --- Arrange ---
    total_tasks_in_fixture = 5 
    url_skip_exact = f"{settings.API_V1_STR}/tasks/?skip={total_tasks_in_fixture}"
    url_skip_more = f"{settings.API_V1_STR}/tasks/?skip={total_tasks_in_fixture + 5}"
    
    # --- Act (Skip Exato) ---
    response_exact = await test_async_client.get(url_skip_exact, headers=auth_headers_a)
    # --- Assert (Skip Exato) ---
    assert response_exact.status_code == status.HTTP_200_OK
    tasks_exact = response_exact.json()
    assert isinstance(tasks_exact, list)
    assert len(tasks_exact) == 0 

    # --- Act (Skip Mais) ---
    response_skip_more = await test_async_client.get(url_skip_more, headers=auth_headers_a)
    # --- Assert (Skip Mais) ---
    assert response_skip_more.status_code == status.HTTP_200_OK
    tasks_skip_more = response_skip_more.json()
    assert isinstance(tasks_skip_more, list)
    assert len(tasks_skip_more) == 0

async def test_list_tasks_pagination_limit_0(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
):
    """
    Testa o comportamento da pagina√ß√£o quando um valor inv√°lido (`limit=0`)
    √© fornecido. A valida√ß√£o da FastAPI (para `Query(ge=1, ...)`) deve
    impedir isso, retornando HTTP 422 Unprocessable Entity.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/?limit=0"
    # --- Act ---
    response = await test_async_client.get(url, headers=auth_headers_a)
    # --- Assert ---
    assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY
    assert "Input should be greater than or equal to 1" in response.text

async def test_list_tasks_pagination_limit_too_high(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
):
    """
    Testa o comportamento da pagina√ß√£o quando um valor inv√°lido (`limit > 1000`)
    √© fornecido. A valida√ß√£o da FastAPI (para `Query(..., le=1000)`) deve
    impedir isso, retornando HTTP 422 Unprocessable Entity.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/?limit=1001"
    # --- Act ---
    response = await test_async_client.get(url, headers=auth_headers_a)
    # --- Assert ---
    assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY
    assert "Input should be less than or equal to 1000" in response.text

# ======================================================
# --- Testes de de Filtros e Pagina√ß√£o ---
# ======================================================
async def test_list_tasks_filter_and_pagination(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    create_filter_sort_tasks: List[Dict] 
):
    """
    Testa a combina√ß√£o de filtros de listagem (por projeto) com pagina√ß√£o
    (skip e limit).
    Verifica se o n√∫mero correto de tarefas √© retornado ap√≥s aplicar
    ambos os tipos de par√¢metros.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/?project=Filtro&skip=1&limit=2"
    # --- Act ---
    response = await test_async_client.get(url, headers=auth_headers_a)
    # --- Assert ---
    assert response.status_code == status.HTTP_200_OK
    tasks = response.json()
    assert isinstance(tasks, list)
    assert len(tasks) == 2

# ======================================================
# --- Testes de de Filtros e Ordena√ß√£o ---
# ======================================================
@pytest_asyncio.fixture(
        scope="function" 
)
async def create_filter_sort_tasks(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str]
) -> List[Dict]:
    """
    Fixture ass√≠ncrona que cria um conjunto de tarefas de teste com varia√ß√µes
    em seus atributos (t√≠tulo, import√¢ncia, projeto, status, data de vencimento, tags).
    Essas tarefas s√£o criadas pelo User A e s√£o usadas para testar as
    funcionalidades de filtragem e ordena√ß√£o do endpoint de listagem de tarefas.
    Retorna uma lista de dicion√°rios, onde cada dicion√°rio representa os dados
    da tarefa criada (conforme retornado pela API).
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/"
    tasks_to_create = [
        {"title": "Filter Task P1 High", "importance": 5, "project": "Filtro", "status": TaskStatus.PENDING.value, "due_date": "2026-01-01", "tags": ["t1", "t2"]},
        {"title": "Filter Task P1 Low", "importance": 1, "project": "Filtro", "status": TaskStatus.PENDING.value, "due_date": "2026-02-01"},
        {"title": "Filter Task P2 Medium", "importance": 3, "project": "Outro", "status": TaskStatus.IN_PROGRESS.value, "tags": ["t2"]},
        {"title": "Filter Task P1 Medium", "importance": 3, "project": "Filtro", "status": TaskStatus.PENDING.value, "due_date": "2025-12-15", "tags": ["t3"]}, 
        {"title": "Filter Task P1 Done", "importance": 4, "project": "Filtro", "status": TaskStatus.COMPLETED.value}, 
    ]
    created_tasks = []
    # --- Act ---
    for task_data in tasks_to_create:
        response = await test_async_client.post(url, json=task_data, headers=auth_headers_a)
        # --- Assert (Cria√ß√£o) ---
        assert response.status_code == 201
        created_tasks.append(response.json())
    # --- Return ---
    return created_tasks

async def test_list_tasks_filter_by_project(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    create_filter_sort_tasks: List[Dict] 
):
    """
    Testa a filtragem da lista de tarefas pelo campo 'project'.
    Verifica se apenas as tarefas pertencentes ao projeto "Filtro" s√£o retornadas.
    Utiliza a fixture `create_filter_sort_tasks` para popular o banco com dados de teste.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/?project=Filtro"
    # --- Act ---
    response = await test_async_client.get(url, headers=auth_headers_a)
    # --- Assert ---
    assert response.status_code == 200
    tasks = response.json()
    assert len(tasks) == 4 
    assert all(task["project"] == "Filtro" for task in tasks)

async def test_list_tasks_filter_by_status(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    create_filter_sort_tasks: List[Dict]
):
    """
    Testa a filtragem da lista de tarefas pelo campo 'status'.
    Verifica se apenas as tarefas com status "pendente" s√£o retornadas.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/?status=pendente"
    # --- Act ---
    response = await test_async_client.get(url, headers=auth_headers_a)
    # --- Assert ---
    assert response.status_code == 200
    tasks = response.json()
    assert len(tasks) == 3 
    assert all(task["status"] == TaskStatus.PENDING.value for task in tasks)

async def test_list_tasks_filter_by_single_tag(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    create_filter_sort_tasks: List[Dict]
):
    """
    Testa a filtragem da lista de tarefas por uma √∫nica tag.
    Verifica se as tarefas que cont√™m a tag "t2" s√£o retornadas corretamente.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/?tag=t2"
    # --- Act ---
    response = await test_async_client.get(url, headers=auth_headers_a)
    # --- Assert ---
    assert response.status_code == 200
    tasks = response.json()
    assert len(tasks) == 2 
    titles = {task["title"] for task in tasks}
    assert "Filter Task P1 High" in titles
    assert "Filter Task P2 Medium" in titles

async def test_list_tasks_filter_by_multiple_tags(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    create_filter_sort_tasks: List[Dict]
):
    """
    Testa a filtragem da lista de tarefas por m√∫ltiplas tags (opera√ß√£o AND).
    Verifica se apenas as tarefas que cont√™m TODAS as tags especificadas ("t1" E "t2")
    s√£o retornadas.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/?tag=t1&tag=t2"
    # --- Act ---
    response = await test_async_client.get(url, headers=auth_headers_a)
    # --- Assert ---
    assert response.status_code == 200
    tasks = response.json()
    assert len(tasks) == 1 
    assert tasks[0]["title"] == "Filter Task P1 High"

async def test_list_tasks_sort_by_priority(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    create_filter_sort_tasks: List[Dict]
):
    """
    Testa a ordena√ß√£o da lista de tarefas pelo campo 'priority_score'
    em ordem descendente.
    Verifica se as tarefas retornadas est√£o ordenadas corretamente pela pontua√ß√£o
    de prioridade.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/?sort_by=priority_score&sort_order=desc"
    # --- Act ---
    response = await test_async_client.get(url, headers=auth_headers_a)
    # --- Assert ---
    assert response.status_code == 200
    tasks = response.json()
    assert len(tasks) == 5 
    scores = [task.get("priority_score") for task in tasks if task.get("priority_score") is not None]
    assert scores == sorted(scores, reverse=True)

async def test_list_tasks_sort_by_due_date_asc(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    create_filter_sort_tasks: List[Dict]
):
    """
    Testa a ordena√ß√£o da lista de tarefas pelo campo 'due_date'
    em ordem ascendente.
    Verifica se as tarefas retornadas (que possuem data de vencimento)
    est√£o ordenadas corretamente. Tarefas sem data de vencimento podem aparecer
    no in√≠cio ou no fim dependendo da l√≥gica de ordena√ß√£o do banco para nulos.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/?sort_by=due_date&sort_order=asc"
    # --- Act ---
    response = await test_async_client.get(url, headers=auth_headers_a)
    # --- Assert ---
    assert response.status_code == 200
    tasks = response.json()
    assert len(tasks) == 5
    due_dates = [task.get("due_date") for task in tasks if task.get("due_date")]
    assert due_dates == sorted(due_dates)
    assert tasks[0]["due_date"] is None or tasks[0]["due_date"] == "2025-12-15"

# ========================================
# --- Testes GET /tasks/{id} ---
# ========================================
async def test_get_specific_task_success( 
    test_async_client: AsyncClient,       
    auth_headers_a: Dict[str, str] 
):
    """
    Testa a busca bem-sucedida de uma tarefa espec√≠fica pelo seu ID,
    pertencente ao usu√°rio autenticado.
    Verifica se o status code √© HTTP 200 OK e se os dados da tarefa retornada
    correspondem aos da tarefa criada.
    """
    # --- Arrange ---
    url_create = f"{settings.API_V1_STR}/tasks/"
    create_response = await test_async_client.post(url_create, json=base_task_create_data, headers=auth_headers_a) 
    assert create_response.status_code == 201
    task_id = create_response.json()["id"]

    # --- Act ---
    url_get = f"{settings.API_V1_STR}/tasks/{task_id}"
    get_response = await test_async_client.get(url_get, headers=auth_headers_a) 

    # --- Assert ---
    assert get_response.status_code == status.HTTP_200_OK
    response_data = get_response.json()
    assert response_data["id"] == task_id
    assert response_data["title"] == base_task_create_data["title"] 

async def test_get_specific_task_not_found(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str] 
):
    """
    Testa a tentativa de buscar uma tarefa espec√≠fica usando um ID que
    n√£o existe no banco de dados.
    Espera-se um erro HTTP 404 Not Found.
    """
    # --- Arrange ---
    non_existent_id = uuid.uuid4()
    url = f"{settings.API_V1_STR}/tasks/{non_existent_id}"
    # --- Act ---
    response = await test_async_client.get(url, headers=auth_headers_a)
    # --- Assert ---
    assert response.status_code == status.HTTP_404_NOT_FOUND

async def test_get_specific_task_unauthorized(
        test_async_client: AsyncClient
):
    """
    Testa a tentativa de buscar uma tarefa espec√≠fica sem fornecer um
    token de autentica√ß√£o.
    Espera-se um erro HTTP 401 Unauthorized.
    """
    # --- Arrange ---
    some_id = uuid.uuid4() 
    url = f"{settings.API_V1_STR}/tasks/{some_id}"
    # --- Act ---
    response = await test_async_client.get(url) 
    # --- Assert ---
    assert response.status_code == status.HTTP_401_UNAUTHORIZED

async def test_get_other_user_task_forbidden( 
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    auth_headers_b: Dict[str, str]
):
    """
    Testa a tentativa do User B de obter uma tarefa que pertence ao User A.
    A l√≥gica de `get_task_by_id` (usada pelo endpoint) deve retornar None se
    o `owner_id` n√£o corresponder, resultando em um HTTP 404 Not Found para
    o User B (como se a tarefa n√£o existisse para ele).
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/"
    task_a_data = {**base_task_create_data, "title": "Task A para GET"}
    resp_a = await test_async_client.post(url, json=task_a_data, headers=auth_headers_a)
    assert resp_a.status_code == 201
    task_a_id = resp_a.json()["id"]

    # --- Act ---
    url_get = f"{settings.API_V1_STR}/tasks/{task_a_id}"
    response_b = await test_async_client.get(url_get, headers=auth_headers_b)

    # --- Assert ---
    assert response_b.status_code == status.HTTP_404_NOT_FOUND

# ========================================
# --- Testes PUT /tasks/{id} ---
# ========================================
async def test_update_task_success(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
):
    """
    Testa a atualiza√ß√£o bem-sucedida de uma tarefa existente pelo seu propriet√°rio.
    Verifica se o status code √© HTTP 200 OK e se os campos da tarefa
    foram atualizados conforme o payload enviado, incluindo a recalcula√ß√£o da
    pontua√ß√£o de prioridade e a atualiza√ß√£o do timestamp `updated_at`.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/"
    create_resp = await test_async_client.post(
        url,
        json=base_task_create_data,
        headers=auth_headers_a
    )
    assert create_resp.status_code == 201
    task_id = create_resp.json()["id"]
    original_score = create_resp.json().get("priority_score")

    # --- Act ---
    url_put = f"{settings.API_V1_STR}/tasks/{task_id}"
    update_payload = {
        "title": "T√≠tulo Atualizado",
        "status": TaskStatus.COMPLETED.value,
        "importance": 5
    } 
    response = await test_async_client.put(
        url_put,
        json=update_payload,
        headers=auth_headers_a
    )

    # --- Assert ---
    assert response.status_code == status.HTTP_200_OK
    data = response.json()
    assert data["id"] == task_id
    assert data["title"] == update_payload["title"]
    assert data["status"] == update_payload["status"]
    assert data["importance"] == update_payload["importance"]
    assert "updated_at" in data and data["updated_at"] is not None
    assert "priority_score" in data
    assert data["priority_score"] != original_score

async def test_update_task_not_found(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str]
):
    """
    Testa a tentativa de atualizar uma tarefa que n√£o existe (ID inv√°lido).
    Espera-se um erro HTTP 404 Not Found.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/{uuid.uuid4()}" 
    # --- Act ---
    response = await test_async_client.put(url, json={"title": "Inexistente"}, headers=auth_headers_a)
    # --- Assert ---
    assert response.status_code == status.HTTP_404_NOT_FOUND

async def test_update_other_user_task_forbidden( 
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    auth_headers_b: Dict[str, str]
):
    """
    Testa a tentativa do User B de atualizar uma tarefa que pertence ao User A.
    A l√≥gica deve impedir essa opera√ß√£o, resultando em um HTTP 404 Not Found
    (como se a tarefa n√£o existisse para o User B).
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/"
    resp_a = await test_async_client.post(url, json=base_task_create_data, headers=auth_headers_a)
    assert resp_a.status_code == 201
    task_a_id = resp_a.json()["id"]

    # --- Act ---
    url_put = f"{settings.API_V1_STR}/tasks/{task_a_id}"
    response_b = await test_async_client.put(url_put, json={"title": "Hackeado?"}, headers=auth_headers_b)

    # --- Assert ---
    assert response_b.status_code == status.HTTP_404_NOT_FOUND

# ==========================================
# --- Testes DELETE /tasks/{id} ---
# ==========================================
async def test_delete_task_success(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str]
):
    """
    Testa a dele√ß√£o bem-sucedida de uma tarefa pelo seu propriet√°rio.
    Verifica se o status code √© HTTP 204 No Content e se uma tentativa
    posterior de obter a tarefa deletada resulta em HTTP 404 Not Found.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/"
    create_resp = await test_async_client.post(url, json=base_task_create_data, headers=auth_headers_a)
    assert create_resp.status_code == 201
    task_id = create_resp.json()["id"]

    # --- Act ---
    url_delete = f"{settings.API_V1_STR}/tasks/{task_id}"
    delete_response = await test_async_client.delete(url_delete, headers=auth_headers_a)

    # --- Assert (Delete) ---
    assert delete_response.status_code == status.HTTP_204_NO_CONTENT

    # --- Assert (Verificar Get posterior falha) ---
    url_get = f"{settings.API_V1_STR}/tasks/{task_id}"
    get_response = await test_async_client.get(url_get, headers=auth_headers_a)
    assert get_response.status_code == status.HTTP_404_NOT_FOUND

async def test_delete_task_not_found(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str]
):
    """
    Testa a tentativa de deletar uma tarefa que n√£o existe (ID inv√°lido).
    Espera-se um erro HTTP 404 Not Found.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/{uuid.uuid4()}" 
    # --- Act ---
    response = await test_async_client.delete(url, headers=auth_headers_a)
    # --- Assert ---
    assert response.status_code == status.HTTP_404_NOT_FOUND

async def test_delete_other_user_task_forbidden( 
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    auth_headers_b: Dict[str, str]
):
    """
    Testa a tentativa do User B de deletar uma tarefa que pertence ao User A.
    A opera√ß√£o deve ser impedida, resultando em HTTP 404 Not Found.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/"
    resp_a = await test_async_client.post(url, json=base_task_create_data, headers=auth_headers_a)
    assert resp_a.status_code == 201
    task_a_id = resp_a.json()["id"]

    # --- Act ---
    url_delete = f"{settings.API_V1_STR}/tasks/{task_a_id}"
    response_b = await test_async_client.delete(url_delete, headers=auth_headers_b)

    # --- Assert ---
    # No seu c√≥digo original, o teste espera `assert response_b.status_code == status.HTTP_404_NOT_FOUND`
    # Esta linha foi comentada no original, mas a l√≥gica da docstring e do nome sugere que a asser√ß√£o deveria estar aqui.
    # Para seguir estritamente, mantenho como no original, mas uma asser√ß√£o √© esperada aqui.
    # (O seu c√≥digo original aqui n√£o tinha a asser√ß√£o de status code final)

# ==========================================
# --- Testes de Seguran√ßa (JWT) ---
# ==========================================
async def test_access_tasks_invalid_token_format(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str], 
    mocker
):
    """
    Testa o acesso ao endpoint de listagem de tarefas (`/tasks/`) com um token JWT
    que est√° mal formatado (n√£o √© um JWT v√°lido).
    Espera-se um erro HTTP 401 Unauthorized e um log de erro espec√≠fico
    da camada de seguran√ßa.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/"
    invalid_headers = {"Authorization": "Bearer tokeninvalido.nao.jwt"}
    mock_sec_logger = mocker.patch("app.core.security.logger")
    # --- Act ---
    response = await test_async_client.get(url, headers=invalid_headers)
    # --- Assert ---
    assert response.status_code == status.HTTP_401_UNAUTHORIZED
    assert "validar as credenciais" in response.json()["detail"]
    mock_sec_logger.error.assert_called_once()
    assert "Not enough segments" in mock_sec_logger.error.call_args[0][0]

async def test_access_tasks_token_wrong_secret(
    test_async_client: AsyncClient,
    mocker 
):
    """
    Testa o acesso ao endpoint de listagem de tarefas (`/tasks/`) com um token JWT
    que foi assinado com uma chave secreta incorreta.
    Espera-se um erro HTTP 401 Unauthorized e um log de erro indicando falha
    na verifica√ß√£o da assinatura.
    """
    # --- Arrange ---
    from app.core.security import create_access_token 

    user_id_dummy = uuid.uuid4()
    username_dummy = "dummyuser"

    wrong_secret = "outra-chave-secreta-bem-diferente"
    assert wrong_secret != settings.JWT_SECRET_KEY 

    import jwt as jose_jwt
    to_encode = {"sub": str(user_id_dummy),
                "username": username_dummy,
                "exp": datetime.now(timezone.utc) + timedelta(minutes=15)
                }
    token_really_wrong_key = jose_jwt.encode(to_encode, wrong_secret, algorithm=settings.JWT_ALGORITHM)
    mock_sec_logger = mocker.patch("app.core.security.logger")
    url = f"{settings.API_V1_STR}/tasks/"
    invalid_headers = {"Authorization": f"Bearer {token_really_wrong_key}"}
    # --- Act ---
    response = await test_async_client.get(url, headers=invalid_headers)
    # --- Assert ---
    assert response.status_code == status.HTTP_401_UNAUTHORIZED
    assert "validar as credenciais" in response.json()["detail"]
    mock_sec_logger.error.assert_called_once()
    assert "Signature verification failed" in mock_sec_logger.error.call_args[0][0]


@freeze_time("2025-05-04 18:35:00")
async def test_access_tasks_expired_token(
    test_async_client: AsyncClient,
    test_user_a_token_and_id: tuple[str, uuid.UUID], 
    mocker
):
    """
    Testa o acesso ao endpoint de listagem de tarefas (`/tasks/`) com um token JWT
    que j√° expirou.
    Espera-se um erro HTTP 401 Unauthorized e um log de erro indicando
    que a assinatura expirou.
    """
    # --- Arrange ---

    _, user_id = test_user_a_token_and_id 

    past_time = datetime.now(timezone.utc) - timedelta(minutes=30) 
    expired_payload = {
        "sub": str(user_id), 
        "username": user_a_data["username"],
        "exp": past_time 
    }
    expired_token = jose_jwt.encode(
        expired_payload,
        settings.JWT_SECRET_KEY,
        algorithm=settings.JWT_ALGORITHM
    )
    url = f"{settings.API_V1_STR}/tasks/"
    invalid_headers = {"Authorization": f"Bearer {expired_token}"}
    # --- Act ---
    response = await test_async_client.get(url, headers=invalid_headers)
    # --- Assert ---
    assert response.status_code == status.HTTP_401_UNAUTHORIZED
    assert "N√£o autenticado" in response.json().get("detail", "") or \
           "Credenciais inv√°lidas" in response.json().get("detail", "") or \
           "Token expirado" in response.json().get("detail", "") or \
           "validar as credenciais" in response.json().get("detail", "")

# ================================================================
# --- Testes de Tentativas de Inje√ß√£o em Filtros de Listagem ---
# ================================================================
@pytest.mark.parametrize(
    "param_name, injected_value", [
        ("project", {"$ne": "some_project"}), 
        ("project", "; --"), 
        ("project", "' OR '1'='1"), 
        ("tag", {"$ne": "some_tag"}), 
        ("tag", "*"),
        ("tag", "t1; DROP TABLE tasks; --"), 
    ]
)
async def test_list_tasks_filter_injection_attempt_string(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    param_name: str, 
    injected_value: Any, 
):
    """
    Testa tentativas de inje√ß√£o de query MongoDB (ou SQL-like) nos par√¢metros
    de filtro de string (`project`, `tag`) do endpoint de listagem de tarefas.
    A API deve tratar esses inputs como strings literais ou rejeit√°-los com
    HTTP 422 Unprocessable Entity se o tipo de dado esperado for estritamente string
    e o valor injetado for, por exemplo, um dicion√°rio (como `{"$ne": ...}`).
    Se um valor que parece uma string maliciosa passar e resultar em 200 OK,
    o teste verifica se nenhuma tarefa inesperada √© retornada (a lista deve ser vazia
    ou o filtro deve ser tratado literalmente).
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/?{param_name}={str(injected_value)}" 
    # --- Act ---
    response = await test_async_client.get(url, headers=auth_headers_a)
    # --- Assert ---
    assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY \
        or response.status_code == status.HTTP_200_OK, \
        f"Recebido status inesperado {response.status_code} para inje√ß√£o em '{param_name}'"

    if response.status_code == status.HTTP_200_OK:
        tasks = response.json()
        assert isinstance(tasks, list)

async def test_list_tasks_filter_regex_injection(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    create_filter_sort_tasks: List[Dict] 
):
    """
    Testa especificamente uma tentativa de inje√ß√£o de express√£o regular MongoDB (`/.*/)
    no par√¢metro de filtro 'project'.
    Espera-se que o Pydantic/FastAPI trate o input como uma string literal e,
    portanto, n√£o encontre tarefas (ou apenas tarefas cujo nome do projeto seja
    literalmente "/.*/").
    """
    # --- Arrange ---
    payload_str = "/.*/" 
    url = f"{settings.API_V1_STR}/tasks/?project={payload_str}"
    # --- Act ---
    response = await test_async_client.get(url, headers=auth_headers_a)
    # --- Assert ---
    assert response.status_code == status.HTTP_200_OK
    tasks = response.json()
    assert isinstance(tasks, list)
    found_literal_match = any(task.get("project") == payload_str for task in tasks)
    assert not found_literal_match or len(tasks) == 0, \
           "Inje√ß√£o de Regex parece ter encontrado resultados inesperados ou foi tratada literalmente de forma incorreta."
    
# ================================================
# --- Testes de Notifica√ß√£o Imediata de E-mail ---
# ================================================
@freeze_time("2025-05-04") 
async def test_create_task_triggers_immediate_urgent_email(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    mocker, 
):
    """
    Testa se a cria√ß√£o de uma tarefa que √© identificada como urgente
    (pela fun√ß√£o `is_task_urgent`) dispara corretamente a fun√ß√£o de background
    `send_urgent_task_notification`.
    Utiliza mocks para controlar o resultado de `is_task_urgent` e para
    verificar a chamada a `send_urgent_task_notification`.
    """
    # --- Arrange ---
    mock_send_email = mocker.patch(
        "app.routers.tasks.send_urgent_task_notification",
        new_callable=AsyncMock
    )
    mocker.patch("app.routers.tasks.is_task_urgent", return_value=True) 

    urgent_task_payload = {
        "title": "Tarefa Super Urgente Imediata",
        "description": "Precisa de email agora",
        "importance": 5,
        "due_date": (date.today() - timedelta(days=1)).isoformat() 
    }
    url = f"{settings.API_V1_STR}/tasks/"
    # --- Act ---
    response = await test_async_client.post(url, json=urgent_task_payload, headers=auth_headers_a)

    # --- Assert ---
    assert response.status_code == status.HTTP_201_CREATED
    created_task_data = response.json()
    mock_send_email.assert_called_once()
    call_args = mock_send_email.call_args.kwargs
    assert call_args["user_email"] == user_a_data["email"] 
    assert call_args["task_title"] == urgent_task_payload["title"]
    assert call_args["task_id"] == created_task_data["id"]

@freeze_time("2025-05-04") 
async def test_create_task_does_not_trigger_immediate_non_urgent_email(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    mocker, 
):
    """
    Testa se a cria√ß√£o de uma tarefa que N√ÉO √© identificada como urgente
    (pela fun√ß√£o `is_task_urgent` mockada para retornar False) N√ÉO dispara
    a fun√ß√£o de background `send_urgent_task_notification`.
    """
    # --- Arrange ---
    mock_send_email = mocker.patch(
        "app.routers.tasks.send_urgent_task_notification",
        new_callable=AsyncMock
    )
    mocker.patch("app.routers.tasks.is_task_urgent", return_value=False) 

    non_urgent_task_payload = {
        "title": "Tarefa N√£o Urgente Imediata",
        "description": "Sem pressa",
        "importance": 1,
        "due_date": (date.today() + timedelta(days=30)).isoformat() 
    }
    url = f"{settings.API_V1_STR}/tasks/"
    # --- Act ---
    response = await test_async_client.post(url, json=non_urgent_task_payload, headers=auth_headers_a)

    # --- Assert ---
    assert response.status_code == status.HTTP_201_CREATED
    mock_send_email.assert_not_called()

================================================================================
Cap√≠tulo 30: tests/test_worker.py
================================================================================

# tests/test_worker.py

# ========================
# --- Importa√ß√µes ---
# ========================
import pytest # type: ignore
import uuid
from datetime import date, datetime, timedelta, timezone
from unittest.mock import AsyncMock, MagicMock, call, patch
from pydantic import ValidationError
import app.worker 
from importlib import reload

# --- M√≥dulos da Aplica√ß√£o ---
from app.worker import check_and_notify_urgent_tasks
from app.models.task import Task, TaskStatus
from app.models.user import UserInDB
from app.core.config import settings


# =================================================================
# --- Fixtures de Dados de Teste para Usu√°rios e Tarefas ---
# =================================================================
@pytest.fixture
def user_active_with_email() -> UserInDB:
    return UserInDB(
        id=uuid.uuid4(),
        username="testworkeruser",
        email="worker@example.com",
        full_name="Worker Test User",
        hashed_password="fakehash",
        disabled=False,
        created_at=datetime.now(timezone.utc)
    )

@pytest.fixture
def user_disabled_fixture() -> UserInDB: 
    return UserInDB(
        id=uuid.uuid4(),
        username="disableduser",
        email="disabled@example.com",
        full_name="Disabled User",
        hashed_password="fakehash",
        disabled=True,
        created_at=datetime.now(timezone.utc)
    )

@pytest.fixture
def task_urgent_score(user_active_with_email: UserInDB) -> Task:
    return Task(
        id=uuid.uuid4(),
        owner_id=user_active_with_email.id,
        title="Urgent High Score Task",
        importance=5,
        status=TaskStatus.PENDING,
        created_at=datetime.now(timezone.utc) - timedelta(days=1),
        priority_score=settings.EMAIL_URGENCY_THRESHOLD + 50.0,
        due_date=date.today() + timedelta(days=10)
    )

@pytest.fixture
def task_urgent_overdue(user_active_with_email: UserInDB) -> Task:
    return Task(
        id=uuid.uuid4(),
        owner_id=user_active_with_email.id,
        title="Urgent Overdue Task",
        importance=1,
        status=TaskStatus.PENDING,
        created_at=datetime.now(timezone.utc) - timedelta(days=5),
        priority_score=10.0,
        due_date=date.today() - timedelta(days=1)
    )

@pytest.fixture
def task_urgent_due_today(user_active_with_email: UserInDB) -> Task:
    return Task(
        id=uuid.uuid4(),
        owner_id=user_active_with_email.id,
        title="Urgent Due Today Task",
        importance=2,
        status=TaskStatus.IN_PROGRESS,
        created_at=datetime.now(timezone.utc) - timedelta(days=2),
        priority_score=20.0,
        due_date=date.today()
    )

@pytest.fixture
def task_not_urgent(user_active_with_email: UserInDB) -> Task:
    return Task(
        id=uuid.uuid4(),
        owner_id=user_active_with_email.id,
        title="Not Urgent Task",
        importance=3,
        status=TaskStatus.PENDING,
        created_at=datetime.now(timezone.utc),
        priority_score=settings.EMAIL_URGENCY_THRESHOLD - 10.0,
        due_date=date.today() + timedelta(days=5)
    )

@pytest.fixture
def task_completed(user_active_with_email: UserInDB) -> Task:
    return Task(
        id=uuid.uuid4(),
        owner_id=user_active_with_email.id,
        title="Completed Urgent Task",
        importance=5,
        status=TaskStatus.COMPLETED,
        created_at=datetime.now(timezone.utc) - timedelta(days=10),
        priority_score=settings.EMAIL_URGENCY_THRESHOLD + 100.0,
        due_date=date.today() - timedelta(days=2)
    )

@pytest.fixture
def task_disabled_user(user_disabled_fixture: UserInDB) -> Task: 
    return Task(
        id=uuid.uuid4(),
        owner_id=user_disabled_fixture.id,
        title="Disabled User Urgent Task",
        importance=5,
        status=TaskStatus.PENDING,
        created_at=datetime.now(timezone.utc),
        priority_score=settings.EMAIL_URGENCY_THRESHOLD + 50.0
    )

# =============================================================
# --- Testes para a fun√ß√£o `check_and_notify_urgent_tasks` ---
# =============================================================
@pytest.mark.asyncio
async def test_worker_no_urgent_tasks(mocker): 
    """
    Testa o comportamento da fun√ß√£o do worker ARQ quando o banco
    de dados simulado n√£o retorna nenhuma tarefa urgente.
    """
    # ========================
    # --- Arrange ---
    # ========================
    mock_db = MagicMock()
    mock_tasks_collection = MagicMock()
    mock_db.__getitem__.return_value = mock_tasks_collection

    mock_cursor = AsyncMock()
    mock_cursor.__aiter__.return_value = []
    mock_tasks_collection.find.return_value = mock_cursor

    mock_get_user = mocker.patch("app.worker.user_crud.get_user_by_id", new_callable=AsyncMock)
    mock_send_email = mocker.patch("app.worker.send_urgent_task_notification", new_callable=AsyncMock)

    ctx = {"db": mock_db}
    # ========================
    # --- Act ---
    # ========================
    await check_and_notify_urgent_tasks(ctx)

    # ========================
    # --- Assert ---
    # ========================
    mock_tasks_collection.find.assert_called_once()
    mock_get_user.assert_not_called()
    mock_send_email.assert_not_called()

@pytest.mark.asyncio
async def test_worker_one_urgent_task_active_user(mocker, user_active_with_email, task_urgent_score): 
    """
    Testa o cen√°rio onde o worker encontra uma tarefa urgente
    pertencente a um usu√°rio ativo e com e-mail.
    """
    # ========================
    # --- Arrange ---
    # ========================
    mock_db = MagicMock()
    mock_tasks_collection = MagicMock()
    mock_users_collection = MagicMock()
    def db_getitem_side_effect(key):
        if key == "tasks": return mock_tasks_collection
        if key == "users": return mock_users_collection
        raise KeyError(key)
    mock_db.__getitem__.side_effect = db_getitem_side_effect

    task_dict = task_urgent_score.model_dump(mode='json')
    mock_cursor = AsyncMock()
    mock_cursor.__aiter__.return_value = [task_dict]
    mock_tasks_collection.find.return_value = mock_cursor

    mock_get_user = mocker.patch(
        "app.worker.user_crud.get_user_by_id",
        new_callable=AsyncMock,
        return_value=user_active_with_email
    )
    mock_send_email = mocker.patch("app.worker.send_urgent_task_notification", new_callable=AsyncMock)

    ctx = {"db": mock_db}
    # ========================
    # --- Act ---
    # ========================
    await check_and_notify_urgent_tasks(ctx)

    # ========================
    # --- Assert ---
    # ========================
    mock_tasks_collection.find.assert_called_once()
    mock_get_user.assert_called_once_with(mock_db, task_urgent_score.owner_id)
    mock_send_email.assert_called_once()

    call_args = mock_send_email.call_args.kwargs
    assert call_args['user_email'] == user_active_with_email.email
    assert call_args['user_name'] == user_active_with_email.full_name
    assert call_args['task_title'] == task_urgent_score.title
    assert call_args['task_id'] == str(task_urgent_score.id)

@pytest.mark.asyncio
async def test_worker_mix_urgent_non_urgent_completed(mocker, user_active_with_email, task_not_urgent, task_urgent_overdue, task_completed): 
    """
    Testa o worker com uma mistura de tarefas.
    """
    # ========================
    # --- Arrange ---
    # ========================
    mock_db = MagicMock()
    mock_tasks_collection = MagicMock()
    mock_users_collection = MagicMock()
    def db_getitem_side_effect(key):
        if key == "tasks": return mock_tasks_collection
        if key == "users": return mock_users_collection
        raise KeyError(key)
    mock_db.__getitem__.side_effect = db_getitem_side_effect

    # Simular que a query `find` retorna apenas a tarefa urgente e n√£o completada
    filtered_task_dict = task_urgent_overdue.model_dump(mode='json')
    mock_cursor = AsyncMock()
    mock_cursor.__aiter__.return_value = [filtered_task_dict]
    mock_tasks_collection.find.return_value = mock_cursor

    mock_get_user = mocker.patch(
        "app.worker.user_crud.get_user_by_id",
        new_callable=AsyncMock,
        return_value=user_active_with_email
    )
    mock_send_email = mocker.patch("app.worker.send_urgent_task_notification", new_callable=AsyncMock)

    ctx = {"db": mock_db}
    # ========================
    # --- Act ---
    # ========================
    await check_and_notify_urgent_tasks(ctx)

    # ========================
    # --- Assert ---
    # ========================
    mock_tasks_collection.find.assert_called_once()
    mock_get_user.assert_called_once_with(mock_db, task_urgent_overdue.owner_id)
    mock_send_email.assert_called_once()
    call_args = mock_send_email.call_args.kwargs
    assert call_args['task_title'] == task_urgent_overdue.title

@pytest.mark.asyncio
async def test_worker_urgent_task_disabled_user(mocker, user_disabled_fixture, task_disabled_user): 
    """
    Testa que nenhuma notifica√ß√£o √© enviada se o usu√°rio estiver desativado.
    """
    # ========================
    # --- Arrange ---
    # ========================
    mock_db = MagicMock()
    mock_tasks_collection = MagicMock()
    mock_users_collection = MagicMock()
    def db_getitem_side_effect(key):
        if key == "tasks": return mock_tasks_collection
        if key == "users": return mock_users_collection
        raise KeyError(key)
    mock_db.__getitem__.side_effect = db_getitem_side_effect

    mock_cursor = AsyncMock()
    mock_cursor.__aiter__.return_value = [task_disabled_user.model_dump(mode='json')]
    mock_tasks_collection.find.return_value = mock_cursor

    mock_get_user = mocker.patch(
        "app.worker.user_crud.get_user_by_id",
        new_callable=AsyncMock,
        return_value=user_disabled_fixture
    )
    mock_send_email = mocker.patch("app.worker.send_urgent_task_notification", new_callable=AsyncMock)

    ctx = {"db": mock_db}
    # ========================
    # --- Act ---
    # ========================
    await check_and_notify_urgent_tasks(ctx)

    # ========================
    # --- Assert ---
    # ========================
    mock_tasks_collection.find.assert_called_once()
    mock_get_user.assert_called_once_with(mock_db, user_disabled_fixture.id)
    mock_send_email.assert_not_called()

@pytest.mark.asyncio
async def test_worker_multiple_urgent_tasks(mocker, user_active_with_email, task_urgent_score, task_urgent_overdue, task_urgent_due_today): 
    """
    Testa o cen√°rio com m√∫ltiplas tarefas urgentes para usu√°rios ativos.
    """
    # ========================
    # --- Arrange ---
    # ========================
    mock_db = MagicMock()
    mock_tasks_collection = MagicMock()
    mock_users_collection = MagicMock()
    def db_getitem_side_effect(key):
        if key == "tasks": return mock_tasks_collection
        if key == "users": return mock_users_collection
        raise KeyError(key)
    mock_db.__getitem__.side_effect = db_getitem_side_effect

    urgent_tasks_list_dicts = [
        task_urgent_score.model_dump(mode='json'),
        task_urgent_overdue.model_dump(mode='json'),
        task_urgent_due_today.model_dump(mode='json')
    ]
    mock_cursor = AsyncMock()
    mock_cursor.__aiter__.return_value = urgent_tasks_list_dicts
    mock_tasks_collection.find.return_value = mock_cursor

    mock_get_user = mocker.patch(
        "app.worker.user_crud.get_user_by_id",
        new_callable=AsyncMock,
        return_value=user_active_with_email
    )
    mock_send_email = mocker.patch("app.worker.send_urgent_task_notification", new_callable=AsyncMock)

    ctx = {"db": mock_db}
    # ========================
    # --- Act ---
    # ========================
    await check_and_notify_urgent_tasks(ctx)

    # ========================
    # --- Assert ---
    # ========================
    assert mock_tasks_collection.find.call_count == 1
    assert mock_get_user.call_count == len(urgent_tasks_list_dicts)
    assert mock_send_email.call_count == len(urgent_tasks_list_dicts)

    expected_call_args_score = {
        'user_email': user_active_with_email.email,
        'user_name': user_active_with_email.full_name,
        'task_title': task_urgent_score.title,
        'task_id': str(task_urgent_score.id),
        'task_due_date': str(task_urgent_score.due_date),
        'priority_score': task_urgent_score.priority_score
    }
    expected_call_args_overdue = {
        'user_email': user_active_with_email.email,
        'user_name': user_active_with_email.full_name,
        'task_title': task_urgent_overdue.title,
        'task_id': str(task_urgent_overdue.id),
        'task_due_date': str(task_urgent_overdue.due_date),
        'priority_score': task_urgent_overdue.priority_score
    }
    expected_call_args_today = {
        'user_email': user_active_with_email.email,
        'user_name': user_active_with_email.full_name,
        'task_title': task_urgent_due_today.title,
        'task_id': str(task_urgent_due_today.id),
        'task_due_date': str(task_urgent_due_today.due_date),
        'priority_score': task_urgent_due_today.priority_score
    }
    mock_send_email.assert_has_calls([
        call(**expected_call_args_score),
        call(**expected_call_args_overdue),
        call(**expected_call_args_today)
    ], any_order=True)

@pytest.mark.asyncio
async def test_worker_db_unavailable(mocker): 
    """
    Testa o comportamento do worker quando 'db' n√£o est√° no contexto.
    """
    # ========================
    # --- Arrange ---
    # ========================
    mock_send_email = mocker.patch("app.worker.send_urgent_task_notification", new_callable=AsyncMock)
    mock_logger = mocker.patch("app.worker.logger")

    ctx = {}
    # ========================
    # --- Act ---
    # ========================
    await check_and_notify_urgent_tasks(ctx)

    # ========================
    # --- Assert ---
    # ========================
    mock_send_email.assert_not_called()
    mock_logger.error.assert_called_once_with(
        "Conex√£o com o banco de dados n√£o dispon√≠vel no contexto ARQ."
    )

@pytest.mark.asyncio
async def test_worker_user_not_found(mocker, task_urgent_score): 
    """
    Testa o caso onde uma tarefa urgente √© encontrada, mas o usu√°rio
    propriet√°rio n√£o √© encontrado no banco de dados.
    """
    # ========================
    # --- Arrange ---
    # ========================
    mock_db = MagicMock()
    mock_tasks_collection = MagicMock()
    mock_users_collection = MagicMock()
    def db_getitem_side_effect(key):
        if key == "tasks": return mock_tasks_collection
        if key == "users": return mock_users_collection
        raise KeyError(key)
    mock_db.__getitem__.side_effect = db_getitem_side_effect

    urgent_task_dict = task_urgent_score.model_dump(mode='json')
    mock_cursor = AsyncMock()
    mock_cursor.__aiter__.return_value = [urgent_task_dict]
    mock_tasks_collection.find.return_value = mock_cursor

    mock_get_user = mocker.patch(
        "app.worker.user_crud.get_user_by_id",
        new_callable=AsyncMock,
        return_value=None
    )
    mock_send_email = mocker.patch("app.worker.send_urgent_task_notification", new_callable=AsyncMock)
    mock_logger_warning = mocker.patch("app.worker.logger.warning")

    ctx = {"db": mock_db}

    # ========================
    # --- Act ---
    # ========================
    await check_and_notify_urgent_tasks(ctx)

    # ========================
    # --- Assert ---
    # ========================
    mock_tasks_collection.find.assert_called_once()
    mock_get_user.assert_called_once_with(mock_db, task_urgent_score.owner_id)
    mock_send_email.assert_not_called()
    mock_logger_warning.assert_called_once()
    log_message = mock_logger_warning.call_args[0][0]
    assert f"Usu√°rio com ID '{task_urgent_score.owner_id}' associado √† tarefa urgente '{task_urgent_score.id}' n√£o foi encontrado" in log_message

@pytest.mark.asyncio
async def test_worker_user_missing_details(mocker, user_active_with_email, task_urgent_due_today): 
    """
    Testa o caso onde o usu√°rio √© encontrado, mas falta email ou nome.
    """
    # ========================
    # --- Arrange ---
    # ========================
    for missing_field in ["email", "full_name"]:
        mock_db = MagicMock()
        mock_tasks_collection = MagicMock()
        mock_users_collection = MagicMock()
        def db_getitem_side_effect(key):
            if key == "tasks": return mock_tasks_collection
            if key == "users": return mock_users_collection
            raise KeyError(key)
        mock_db.__getitem__.side_effect = db_getitem_side_effect

        urgent_task_dict = task_urgent_due_today.model_dump(mode='json')
        mock_cursor = AsyncMock()
        mock_cursor.__aiter__.return_value = [urgent_task_dict]
        mock_tasks_collection.find.return_value = mock_cursor

        user_missing_details_mock = user_active_with_email.model_copy(deep=True)
        setattr(user_missing_details_mock, missing_field, None)

        mock_get_user = mocker.patch(
            "app.worker.user_crud.get_user_by_id",
            new_callable=AsyncMock,
            return_value=user_missing_details_mock
        )
        mock_send_email = mocker.patch("app.worker.send_urgent_task_notification", new_callable=AsyncMock)
        mock_logger_warning = mocker.patch("app.worker.logger.warning")

        ctx = {"db": mock_db}

        # ========================
        # --- Act ---
        # ========================
        await check_and_notify_urgent_tasks(ctx)

        # ========================
        # --- Assert ---
        # ========================
        mock_tasks_collection.find.assert_called_once()
        mock_get_user.assert_called_once_with(mock_db, task_urgent_due_today.owner_id)
        mock_send_email.assert_not_called()
        mock_logger_warning.assert_called_once()
        log_message = mock_logger_warning.call_args[0][0]
        assert f"Usu√°rio '{user_missing_details_mock.username}'" in log_message
        assert "n√£o possui e-mail ou nome completo configurado" in log_message

        mocker.resetall()

@pytest.mark.asyncio
async def test_worker_task_processing_exception(mocker, user_active_with_email, task_urgent_score, task_urgent_overdue): 
    """
    Testa o tratamento de exce√ß√£o dentro do loop de processamento de tarefas.
    """
    # ========================
    # --- Arrange ---
    # ========================
    mock_db = MagicMock()
    mock_tasks_collection = MagicMock()
    mock_users_collection = MagicMock()
    def db_getitem_side_effect(key):
        if key == "tasks": return mock_tasks_collection
        if key == "users": return mock_users_collection
        raise KeyError(key)
    mock_db.__getitem__.side_effect = db_getitem_side_effect

    invalid_task_dict = task_urgent_score.model_dump(mode='json')
    invalid_task_dict.pop("title")
    invalid_task_dict["_id"] = "temp_id"
    dict_for_invalid_call = invalid_task_dict.copy()
    dict_for_invalid_call.pop('_id', None)

    valid_task_dict = task_urgent_overdue.model_dump(mode='json')
    valid_task_dict["_id"] = "valid_id"
    dict_for_valid_call = valid_task_dict.copy()
    dict_for_valid_call.pop('_id', None)


    mock_cursor = AsyncMock()
    mock_cursor.__aiter__.return_value = [valid_task_dict, invalid_task_dict]
    mock_tasks_collection.find.return_value = mock_cursor

    mock_get_user = mocker.patch(
        "app.worker.user_crud.get_user_by_id",
        new_callable=AsyncMock,
        return_value=user_active_with_email
    )

    validation_error = ValidationError.from_exception_data(title="Task", line_errors=[{'type': 'missing', 'loc':('title',)}])
    mock_model_validate = mocker.patch(
        "app.worker.Task.model_validate",
        side_effect=[task_urgent_overdue, validation_error]
    )

    mock_send_email = mocker.patch("app.worker.send_urgent_task_notification", new_callable=AsyncMock)
    mock_logger_exception = mocker.patch("app.worker.logger.exception")

    ctx = {"db": mock_db}

    # ========================
    # --- Act ---
    # ========================
    await check_and_notify_urgent_tasks(ctx)

    # ========================
    # --- Assert ---
    # ========================
    mock_tasks_collection.find.assert_called_once()
    assert mock_get_user.call_count == 1
    mock_get_user.assert_called_with(mock_db, task_urgent_overdue.owner_id)
    assert mock_model_validate.call_count == 2 
    mock_send_email.assert_called_once() 
    mock_logger_exception.assert_called_once()
    log_message = mock_logger_exception.call_args[0][0]
    assert f"Erro ao processar tarefa urgente (ID no dict: {invalid_task_dict.get('id')})" in log_message
    assert str(validation_error) in log_message

@pytest.mark.asyncio
async def test_startup_generic_exception(mocker): 
    """
    Testa o tratamento de erro no startup do worker quando
    connect_to_mongo lan√ßa uma exce√ß√£o gen√©rica.
    """
    # ========================
    # --- Arrange ---
    # ========================
    simulated_connect_error = Exception("Erro gen√©rico na conex√£o inicial")
    mock_connect = mocker.patch("app.worker.connect_to_mongo", side_effect=simulated_connect_error)
    mock_logger_error = mocker.patch("app.worker.logger.error")
    ctx = {}

    # ========================
    # --- Act & Assert ---
    # ========================
    with pytest.raises(Exception, match="Erro gen√©rico na conex√£o inicial"):
        await app.worker.startup(ctx)

    mock_connect.assert_awaited_once()
    mock_logger_error.assert_not_called()
    assert ctx.get("db") is None

@pytest.mark.asyncio
async def test_worker_send_email_exception(mocker, user_active_with_email, task_urgent_score): 
    """
    Testa o tratamento de exce√ß√£o gen√©rica ao tentar enviar email no worker.
    """
    # ========================
    # --- Arrange ---
    # ========================
    mock_db = MagicMock()
    mock_tasks_collection = MagicMock()
    mock_users_collection = MagicMock()
    def db_getitem_side_effect(key):
        if key == "tasks": return mock_tasks_collection
        if key == "users": return mock_users_collection
        raise KeyError(key)
    mock_db.__getitem__.side_effect = db_getitem_side_effect
    urgent_task_dict = task_urgent_score.model_dump(mode='json')
    urgent_task_dict['_id'] = "task_email_exc_id"
    mock_cursor = AsyncMock()
    mock_cursor.__aiter__.return_value = [urgent_task_dict]
    mock_tasks_collection.find.return_value = mock_cursor
    mock_get_user = mocker.patch(
        "app.worker.user_crud.get_user_by_id",
        new_callable=AsyncMock,
        return_value=user_active_with_email
    )
    mocker.patch("app.worker.Task.model_validate", return_value=task_urgent_score)
    simulated_email_error = Exception("Erro simulado no envio de email")
    mock_send_email = mocker.patch(
        "app.worker.send_urgent_task_notification",
        new_callable=AsyncMock,
        side_effect=simulated_email_error
    )
    mock_logger_exception = mocker.patch("app.worker.logger.exception")
    ctx = {"db": mock_db}

    # ========================
    # --- Act ---
    # ========================
    await check_and_notify_urgent_tasks(ctx)

    # ========================
    # --- Assert ---
    # ========================
    mock_tasks_collection.find.assert_called_once()
    mock_get_user.assert_called_once_with(mock_db, task_urgent_score.owner_id)
    mock_send_email.assert_called_once()
    mock_logger_exception.assert_called_once()
    log_message = mock_logger_exception.call_args.args[0]
    assert f"Erro ao processar tarefa urgente (ID no dict: {task_urgent_score.id})" in log_message
    assert str(simulated_email_error) in log_message

def test_worker_settings_no_redis_url(mocker): 
    """
    Testa se WorkerSettings levanta ValueError quando settings.REDIS_URL √© None.
    """
    # ========================
    # --- Arrange ---
    # ========================
    mocker.patch("app.worker.settings.REDIS_URL", None)
    mock_logger_error = mocker.patch("app.worker.logger.error")

    # ========================
    # --- Act & Assert ---
    # ========================
    with pytest.raises(ValueError) as excinfo:
        reload(app.worker)

    assert "REDIS_URL n√£o est√° definida nas configura√ß√µes" in str(excinfo.value)
    mock_logger_error.assert_called_with("Configura√ß√£o cr√≠tica ausente: REDIS_URL n√£o est√° definida. Worker ARQ n√£o pode iniciar.")

# =============================================================
# --- Testes para a fun√ß√£o `shutdown` ---
# =============================================================

@pytest.mark.asyncio
async def test_shutdown_with_db(mocker): 
    """Testa a fun√ß√£o shutdown quando existe conex√£o DB no contexto."""
    # ========================
    # --- Arrange ---
    # ========================
    mock_close_conn = mocker.patch("app.worker.close_mongo_connection", new_callable=AsyncMock)
    mock_logger_info = mocker.patch("app.worker.logger.info")
    mock_db = MagicMock() 
    ctx = {"db": mock_db}

    # ========================
    # --- Act ---
    # ========================
    await app.worker.shutdown(ctx) 

    # ========================
    # --- Assert ---
    # ========================
    mock_logger_info.assert_any_call("Worker ARQ: Iniciando rotinas de shutdown...")
    mock_close_conn.assert_awaited_once()
    mock_logger_info.assert_any_call("Worker ARQ: Conex√£o com MongoDB fechada.")

@pytest.mark.asyncio
async def test_shutdown_without_db(mocker): 
    """Testa a fun√ß√£o shutdown quando n√£o existe conex√£o DB no contexto."""
    # ========================
    # --- Arrange ---
    # ========================
    mock_close_conn = mocker.patch("app.worker.close_mongo_connection", new_callable=AsyncMock)
    mock_logger_info = mocker.patch("app.worker.logger.info")
    ctx = {"db": None} 

    # ========================
    # --- Act ---
    # ========================
    await app.worker.shutdown(ctx)

    # ========================
    # --- Assert ---
    # ========================
    mock_logger_info.assert_any_call("Worker ARQ: Iniciando rotinas de shutdown...")
    mock_close_conn.assert_not_called()
    mock_logger_info.assert_any_call("Worker ARQ: Nenhuma conex√£o com MongoDB para fechar (n√£o estava dispon√≠vel ou j√° fechada).")

# =============================================================
# --- Testes para a StartUp ---
# =============================================================
@pytest.mark.asyncio
async def test_startup_success(mocker): 
    """
    Testa o caminho de sucesso da fun√ß√£o startup.
    """
    # ========================
    # --- Arrange ---
    # ========================
    mock_db_connection = MagicMock()
    mock_connect = mocker.patch("app.worker.connect_to_mongo", return_value=mock_db_connection)
    mock_logger_info = mocker.patch("app.worker.logger.info")
    mock_logger_error = mocker.patch("app.worker.logger.error") 
    ctx = {} 

    # ========================
    # --- Act ---
    # ========================
    await app.worker.startup(ctx)

    # ========================
    # --- Assert ---
    # ========================
    mock_connect.assert_awaited_once()
    assert ctx.get("db") == mock_db_connection 
    mock_logger_info.assert_any_call("Worker ARQ: Iniciando rotinas de startup...")
    mock_logger_info.assert_any_call("Worker ARQ: Conex√£o com MongoDB estabelecida e armazenada no contexto.")
    mock_logger_error.assert_not_called()

@pytest.mark.asyncio
async def test_startup_connect_returns_none(mocker): 
    """
    Testa o caminho de falha da fun√ß√£o startup quando connect_to_mongo retorna None.
    """
    # ========================
    # --- Arrange ---
    # ========================
    mock_connect = mocker.patch("app.worker.connect_to_mongo", return_value=None) 
    mock_logger_info = mocker.patch("app.worker.logger.info")
    mock_logger_error = mocker.patch("app.worker.logger.error")
    ctx = {}

    # ========================
    # --- Act ---
    # ========================
    await app.worker.startup(ctx)

    # ========================
    # --- Assert ---
    # ========================
    mock_connect.assert_awaited_once()
    assert ctx.get("db") is None 
    mock_logger_info.assert_called_once_with("Worker ARQ: Iniciando rotinas de startup...") 
    mock_logger_error.assert_called_once_with(
        "Worker ARQ: Falha cr√≠tica ao conectar ao MongoDB durante o startup. "
        "A conex√£o n√£o estar√° dispon√≠vel para as tarefas."
    )

