================================================================================
C√ìDIGO-FONTE DO PROJETO
================================================================================

SUM√ÅRIO
--------------------------------------------------------------------------------
Cap√≠tulo 1: app/core/config.py
Cap√≠tulo 2: app/core/dependencies.py
Cap√≠tulo 3: app/core/email.py
Cap√≠tulo 4: app/core/logging_config.py
Cap√≠tulo 5: app/core/security.py
Cap√≠tulo 6: app/core/utils.py
Cap√≠tulo 7: app/db/mongodb_utils.py
Cap√≠tulo 8: app/db/task_crud.py
Cap√≠tulo 9: app/db/user_crud.py
Cap√≠tulo 10: app/main.py
Cap√≠tulo 11: app/models/task.py
Cap√≠tulo 12: app/models/token.py
Cap√≠tulo 13: app/models/user.py
Cap√≠tulo 14: app/routers/auth.py
Cap√≠tulo 15: app/routers/tasks.py
Cap√≠tulo 16: app/worker.py
Cap√≠tulo 17: tests/conftest.py
Cap√≠tulo 18: tests/test_auth.py
Cap√≠tulo 19: tests/test_core_config.py
Cap√≠tulo 20: tests/test_core_dependencies.py
Cap√≠tulo 21: tests/test_core_email.py
Cap√≠tulo 22: tests/test_core_security.py
Cap√≠tulo 23: tests/test_core_utils.py
Cap√≠tulo 24: tests/test_core_utils_webhooks.py
Cap√≠tulo 25: tests/test_db_mongodb_utils.py
Cap√≠tulo 26: tests/test_db_task_crud.py
Cap√≠tulo 27: tests/test_db_user_crud.py
Cap√≠tulo 28: tests/test_main.py
Cap√≠tulo 29: tests/test_tasks.py
Cap√≠tulo 30: tests/test_worker.py


================================================================================
Cap√≠tulo 1: app/core/config.py
================================================================================

# app/core/config.py
"""
Configura√ß√µes da aplica√ß√£o lidas do ambiente usando Pydantic BaseSettings.
Procura vari√°veis de ambiente ou vari√°veis em um arquivo .env.
"""

# ========================
# --- Importa√ß√µes ---
# ========================
import os
import logging
from typing import Optional, List
from pydantic_settings import BaseSettings
from pydantic import EmailStr, Field, RedisDsn, ValidationError, model_validator, HttpUrl
from dotenv import load_dotenv

# ========================
# --- Configura√ß√£o do Logger ---
# ========================
logger = logging.getLogger(__name__)

# ========================
# --- Carregamento do .env.test ---
# ========================
base_dir = os.path.dirname(os.path.dirname(os.path.dirname(__file__)))
env_file = ".env.test" if os.getenv("ENVIRONMENT") == "test" else ".env"
dotenv_path = os.path.join(base_dir, env_file)
load_dotenv(dotenv_path=dotenv_path)


# ========================
# --- Defini√ß√£o das Configura√ß√µes ---
# ========================
class Settings(BaseSettings):
    """
    Configura√ß√µes da aplica√ß√£o lidas do ambiente usando Pydantic BaseSettings.
    """
    # --- Config Gerais ---
    PROJECT_NAME: str = Field("SmartTask API", description="Nome do Projeto")
    API_V1_STR: str = Field("/api/v1", description="Prefixo para a vers√£o 1 da API")

    # --- Configura√ß√µes MongoDB ---
    MONGODB_URL: str = Field(..., description="URL de conex√£o completa do MongoDB (obrigat√≥ria)")
    DATABASE_NAME: str = Field("smarttask_db", description="Nome do banco de dados MongoDB")

    # --- Configura√ß√µes JWT ---
    JWT_SECRET_KEY: str = Field(..., description="Chave secreta forte para assinar tokens JWT (obrigat√≥ria)")
    JWT_ALGORITHM: str = Field("HS256", description="Algoritmo de assinatura JWT")
    ACCESS_TOKEN_EXPIRE_MINUTES: int = Field(60 * 24 * 7, description="Validade do token de acesso em minutos (padr√£o: 7 dias)")

    # --- Configura√ß√µes de Prioridade ---
    PRIORITY_WEIGHT_DUE_DATE: float = Field(
        100.0,
        description="Peso para o componente de prazo no c√°lculo de prioridade."
    )
    PRIORITY_WEIGHT_IMPORTANCE: float = Field(
        10.0,
        description="Peso (multiplicador) para o componente de import√¢ncia no c√°lculo de prioridade."
    )
    PRIORITY_DEFAULT_SCORE_NO_DUE_DATE: Optional[float] = Field(
        0.0,
        description="Pontua√ß√£o base de prazo para tarefas sem data de vencimento (pode ser None ou 0.0)."
    )
    PRIORITY_SCORE_IF_OVERDUE: float = Field(
        1000.0,
        description="Pontua√ß√£o (ou fator aditivo/multiplicativo) especial para tarefas atrasadas."
    )

    # --- Configura√ß√£o Webhook ---
    WEBHOOK_URL: Optional[HttpUrl] = Field(
        default=None,
        description="URL opcional para enviar notifica√ß√µes de eventos de tarefas (webhooks)."
    )
    WEBHOOK_SECRET: Optional[str] = Field(
        default=None,
        description="Segredo opcional usado para assinar payloads de webhook para verifica√ß√£o (HMAC-SHA256)."
    )

    # --- Configura√ß√µes de E-mail ---
    MAIL_ENABLED: bool = Field(
            default=False,
            description="Flag para habilitar/desabilitar envio de e-mails globalmente."
    )
    MAIL_USERNAME: Optional[str] = Field(default=None, description="Usu√°rio do servidor SMTP.")
    MAIL_PASSWORD: Optional[str] = Field(default=None, description="Senha do servidor SMTP.")
    MAIL_FROM: Optional[EmailStr] = Field(
        default=None,
        description="Endere√ßo de e-mail remetente."
    )
    MAIL_FROM_NAME: Optional[str] = Field(
        default="SmartTask Notifica√ß√µes",
        description="Nome do remetente exibido no e-mail."
    )
    MAIL_PORT: int = Field(
        default=587,
        description="Porta do servidor SMTP."
    )
    MAIL_SERVER: Optional[str] = Field(
        default=None,
        description="Endere√ßo do servidor SMTP."
    )
    MAIL_STARTTLS: bool = Field(default=True, description="Usar STARTTLS para conex√£o SMTP.")
    MAIL_SSL_TLS: bool = Field(default=False, description="Usar SSL/TLS direto para conex√£o SMTP.")
    USE_CREDENTIALS: bool = Field(default=True, description="Usar credenciais (username/password) para SMTP.")
    VALIDATE_CERTS: bool = Field(default=True, description="Validar certificados SSL/TLS do servidor SMTP.")

    # --- Configura√ß√µes Adicionais Espec√≠ficas ---
    EMAIL_TEMPLATES_DIR: str = Field(default="app/email-templates/build", description="Diret√≥rio de templates de e-mail compilados.")
    EMAIL_URGENCY_THRESHOLD: float = Field(
        default=100.0,
        description="Limiar de priority_score para considerar uma tarefa urgente para notifica√ß√£o por e-mail."
    )
    FRONTEND_URL: Optional[str] = Field(default=None, description="URL base do frontend para links no e-mail (se houver).")

    # --- Configura√ß√£o Redis ---
    REDIS_URL: Optional[RedisDsn] = Field(
        default=None,
        description="URL de conex√£o do Redis para filas de tarefas (ARQ)."
    )

    # --- Configura√ß√£o de Logging ---
    LOG_LEVEL: str = Field(default="INFO", description="N√≠vel de log (DEBUG, INFO, WARNING, ERROR, CRITICAL)")

    # --- Configura√ß√µes CORS ---
    # A convers√£o de string separada por v√≠rgula para List[str] √© feita automaticamente pelo Pydantic v2
    CORS_ALLOWED_ORIGINS: List[str] = Field(default=[], description="Lista de origens CORS permitidas (separadas por v√≠rgula no .env)")

    # --- Configura√ß√£o do Modelo Pydantic BaseSettings ---
    model_config = {
        "case_sensitive": False,
    }

    # --- Validadores ---
    @model_validator(mode='after')
    def check_mail_config(self) -> 'Settings':
        """Valida se as credenciais de e-mail est√£o presentes quando habilitado."""
        if self.MAIL_ENABLED and not all([self.MAIL_USERNAME, self.MAIL_PASSWORD, self.MAIL_FROM, self.MAIL_SERVER]):
            raise ValueError(
                "Se MAIL_ENABLED for True, MAIL_USERNAME, MAIL_PASSWORD, MAIL_FROM e MAIL_SERVER devem ser definidos."
            )
        return self

    @model_validator(mode='after')
    def check_webhook_config(self) -> 'Settings':
        """Valida√ß√µes adicionais para configura√ß√£o do webhook, se necess√°rio."""
        if self.WEBHOOK_URL and not self.WEBHOOK_SECRET:
            raise ValueError("WEBHOOK_SECRET deve ser definido quando WEBHOOK_URL estiver ativa.")
        return self

# ========================
# --- Cria√ß√£o da Inst√¢ncia ---
# ========================
try:
    # Pydantic BaseSettings l√™ do ambiente ou .env na instancia√ß√£o
    settings = Settings()
except ValidationError as e:# pragma: no cover
    logger.critical(f"Erro fatal de valida√ß√£o ao carregar configura√ß√µes: {e}") # pragma: no cover
    raise e # pragma: no cover
except ValueError as e:# pragma: no cover
    logger.critical(f"Erro fatal de valida√ß√£o na configura√ß√£o (check_mail_config?): {e}") # pragma: no cover
    raise e # pragma: no cover
except Exception as e:# pragma: no cover
    logger.critical(f"Erro inesperado ao carregar configura√ß√µes: {e}", exc_info=True) # pragma: no cover
    raise e # pragma: no cover

================================================================================
Cap√≠tulo 2: app/core/dependencies.py
================================================================================

# app/core/dependencies.py
"""
Define as depend√™ncias reutiliz√°veis para a aplica√ß√£o FastAPI,
especialmente aquelas relacionadas √† autentica√ß√£o e acesso ao banco de dados.
"""

# ========================
# --- Importa√ß√µes ---
# ========================
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from motor.motor_asyncio import AsyncIOMotorDatabase
from typing import Annotated
import uuid

# --- M√≥dulos da Aplica√ß√£o ---
from app.db.mongodb_utils import get_database
from app.core.security import decode_token
from app.db import user_crud
from app.models.user import UserInDB

# ========================
# --- Esquema OAuth2 ---
# ========================
# Define o esquema OAuth2 para obter o token do header 'Authorization: Bearer <token>'.
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/v1/auth/login/access-token")

# ========================
# --- Tipos de Depend√™ncia ---
# ========================
DbDep = Annotated[AsyncIOMotorDatabase, Depends(get_database)]
TokenDep = Annotated[str, Depends(oauth2_scheme)]

# ========================
# --- Depend√™ncia: Usu√°rio Atual ---
# ========================
async def get_current_user(
    db: DbDep,
    token: TokenDep
) -> UserInDB:
    """
    Depend√™ncia para obter o usu√°rio atual com base no token JWT fornecido.

    Processo:
    1. Extrai e valida o token do header.
    2. Decodifica o token e obt√©m o payload ('sub' como ID do usu√°rio).
    3. Converte 'sub' para UUID e busca o usu√°rio no banco de dados.
    4. Levanta HTTPException 401 se a valida√ß√£o falhar.

    Args:
        db: Inst√¢ncia do banco de dados.
        token: Token JWT do header.

    Returns:
        O objeto UserInDB correspondente ao token.

    Raises:
        HTTPException: Status 401 se as credenciais n√£o puderem ser validadas.
    """
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="N√£o foi poss√≠vel validar as credenciais",
        headers={"WWW-Authenticate": "Bearer"},
    )

    token_payload = decode_token(token)

    if token_payload is None or token_payload.sub is None:
        raise credentials_exception

    try:
        user_id = uuid.UUID(str(token_payload.sub))
    except ValueError:
        raise credentials_exception

    user = await user_crud.get_user_by_id(db=db, user_id=user_id)
    if user is None:
        raise credentials_exception

    return user

# ========================
# --- Depend√™ncia: Usu√°rio Ativo Atual ---
# ========================
async def get_current_active_user(
    current_user: Annotated[UserInDB, Depends(get_current_user)]
) -> UserInDB:
    """
    Depend√™ncia que reutiliza `get_current_user` e garante que o usu√°rio n√£o est√° desativado.

    Args:
        current_user: Usu√°rio retornado por `get_current_user`.

    Returns:
        O objeto UserInDB se o usu√°rio estiver ativo.

    Raises:
        HTTPException: Status 400 se o usu√°rio estiver desativado.
    """
    if current_user.disabled:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Usu√°rio inativo")
    return current_user

# ========================
# --- Tipos Anotados para Rotas ---
# ========================
# Injeta um usu√°rio ativo validado (UserInDB) nos endpoints.
CurrentUser = Annotated[UserInDB, Depends(get_current_active_user)]

================================================================================
Cap√≠tulo 3: app/core/email.py
================================================================================

# app/core/email.py
"""
Este m√≥dulo lida com o envio de e-mails, utilizando a biblioteca FastAPI-Mail.
Inclui a configura√ß√£o da conex√£o SMTP e fun√ß√µes para enviar e-mails
de forma ass√≠ncrona, tanto com templates HTML quanto com texto puro.
"""

# ========================
# --- Importa√ß√µes ---
# ========================
import logging
from pathlib import Path
from typing import List, Optional, Dict, Any
from fastapi_mail import FastMail, MessageSchema, ConnectionConfig, MessageType
from pydantic import EmailStr

# --- M√≥dulos da Aplica√ß√£o ---
from app.core.config import settings

# ========================
# --- Configura√ß√£o do Logger ---
# ========================
logger = logging.getLogger(__name__)

# ========================
# --- Configura√ß√£o FastMail ---
# ========================
# Cria a configura√ß√£o de conex√£o para o FastMail com base nas settings.
conf = ConnectionConfig(
    MAIL_USERNAME=settings.MAIL_USERNAME or "",
    MAIL_PASSWORD=settings.MAIL_PASSWORD or "",
    MAIL_FROM=settings.MAIL_FROM or "default@example.com",
    MAIL_PORT=settings.MAIL_PORT,
    MAIL_SERVER=settings.MAIL_SERVER or "",
    MAIL_FROM_NAME=settings.MAIL_FROM_NAME or "Default Sender",
    MAIL_STARTTLS=settings.MAIL_STARTTLS,
    MAIL_SSL_TLS=settings.MAIL_SSL_TLS,
    USE_CREDENTIALS=settings.USE_CREDENTIALS,
    VALIDATE_CERTS=settings.VALIDATE_CERTS,
    TEMPLATE_FOLDER=Path(settings.EMAIL_TEMPLATES_DIR) if settings.EMAIL_TEMPLATES_DIR else None,
)

# ========================
# --- Inst√¢ncia do FastMail ---
# ========================
fm = FastMail(conf)

# ========================
# --- Fun√ß√£o Principal de Envio ---
# ========================
async def send_email_async(
    subject: str,
    recipient_to: List[EmailStr],
    body: Dict[str, Any],
    template_name: Optional[str] = None,
    plain_text_body: Optional[str] = None
):
    """
    Envia um e-mail de forma ass√≠ncrona.

    Verifica se o envio de e-mail est√° habilitado e se as credenciais
    necess√°rias est√£o configuradas antes de tentar o envio.

    Args:
        subject: Assunto do e-mail.
        recipient_to: Lista de e-mails dos destinat√°rios.
        body: Dicion√°rio com vari√°veis para o template HTML (se usado).
        template_name: Nome do arquivo do template HTML.
        plain_text_body: Conte√∫do em texto puro (usado se template_name n√£o for fornecido).
    """
    if not settings.MAIL_ENABLED:
        logger.warning("Envio de e-mail desabilitado nas configura√ß√µes (MAIL_ENABLED=false).")
        return

    if not all([settings.MAIL_USERNAME, settings.MAIL_PASSWORD, settings.MAIL_FROM, settings.MAIL_SERVER]):
        logger.error("Configura√ß√µes essenciais de e-mail ausentes. N√£o foi poss√≠vel enviar.")
        return

    message = MessageSchema(
        subject=subject,
        recipients=recipient_to,
        template_body=body if template_name else None,
        body=plain_text_body if not template_name else None,
        subtype=MessageType.html if template_name else MessageType.plain,
    )

    try:
        logger.info(f"Tentando enviar e-mail para {recipient_to} com assunto '{subject}'...")
        await fm.send_message(message, template_name=template_name)
        logger.info(f"E-mail enviado com sucesso para {recipient_to}.")
    except Exception as e:
        logger.exception(f"Erro ao enviar e-mail para {recipient_to}: {e}")

# ========================
# --- Fun√ß√µes Utilit√°rias Espec√≠ficas ---
# ========================
async def send_urgent_task_notification(
    user_email: EmailStr,
    user_name: str,
    task_title: str,
    task_id: str,
    task_due_date: Optional[str],
    priority_score: float
):
    """
    Prepara e envia uma notifica√ß√£o espec√≠fica para tarefas urgentes.

    Args:
        user_email: Email do destinat√°rio.
        user_name: Nome do destinat√°rio.
        task_title: T√≠tulo da tarefa urgente.
        task_id: ID da tarefa (para link).
        task_due_date: Data de vencimento formatada (ou None).
        priority_score: Pontua√ß√£o de prioridade da tarefa.
    """
    subject = f"üö® Tarefa Urgente no SmartTask: {task_title}"
    task_link = f"{settings.FRONTEND_URL}/tasks/{task_id}" if settings.FRONTEND_URL else None

    email_body_data = {
        "task_title": task_title,
        "user_name": user_name,
        "due_date": task_due_date or "N/A",
        "priority_score": f"{priority_score:.2f}",
        "task_link": task_link,
        "project_name": settings.PROJECT_NAME
    }
    template_name = "urgent_task.html"
    plain_text_body = (
        f"Ol√° {user_name},\n"
        f"A tarefa '{task_title}' no {settings.PROJECT_NAME} √© considerada urgente.\n"
        f"Prioridade: {priority_score:.2f}, Vencimento: {task_due_date or 'N/A'}.\n"
    )
    if task_link:
        plain_text_body += f"Acesse a tarefa aqui: {task_link}"

    await send_email_async(
        subject=subject,
        recipient_to=[user_email],
        body=email_body_data,
        template_name=template_name,
        plain_text_body=plain_text_body
    )

================================================================================
Cap√≠tulo 4: app/core/logging_config.py
================================================================================

# app/core/logging_config.py
"""
Este m√≥dulo configura o sistema de logging da aplica√ß√£o utilizando Loguru.
Inclui um InterceptHandler para redirecionar logs do sistema de logging
padr√£o do Python para o Loguru, garantindo um formato de log consistente.
"""

# ========================
# --- Importa√ß√µes ---
# ========================
import logging
import sys
from loguru import logger as loguru_logger

# ========================
# --- Handler de Intercep√ß√£o ---
# ========================
class InterceptHandler(logging.Handler):
    """
    Handler do `logging` que redireciona mensagens para o Loguru.
    Permite que logs emitidos por bibliotecas que usam o `logging` padr√£o
    sejam formatados e gerenciados pelo Loguru.
    """
    def emit(self, record: logging.LogRecord) -> None:
        """
        Recebe um registro de log padr√£o e o envia para o Loguru,
        tentando manter o n√≠vel de log e informa√ß√µes de rastreamento.
        """
        try:
            level = loguru_logger.level(record.levelname).name
        except ValueError:
            level = record.levelno

        frame, depth = logging.currentframe(), 2
        while hasattr(frame, "f_code") and frame.f_code.co_filename == logging.__file__:
            frame = frame.f_back # pragma: no cover
            if frame is None: # pragma: no cover
                break # pragma: no cover
            depth += 1 # pragma: no cover

        loguru_logger.opt(depth=depth, exception=record.exc_info).log(level, record.getMessage())

# ========================
# --- Fun√ß√£o de Setup ---
# ========================
def setup_logging(log_level: str = "INFO"):
    """
    Configura o sistema de logging global da aplica√ß√£o.

    - Remove handlers padr√£o do Loguru para evitar duplica√ß√£o.
    - Adiciona um novo handler Loguru para `sys.stderr` com formato e n√≠vel configur√°veis.
    - Configura o `logging` padr√£o do Python para usar o `InterceptHandler`,
      canalizando todos os logs para o Loguru.
    - Desabilita ou ajusta propaga√ß√£o para loggers espec√≠ficos (Uvicorn, httpx)
      para evitar logs excessivos ou duplicados.

    Args:
        log_level: N√≠vel m√≠nimo de log a ser exibido (ex: "INFO", "DEBUG").
    """
    log_level = log_level.upper()

    loguru_logger.remove() # Limpa handlers pr√©-existentes do Loguru

    # Adiciona o handler principal para stderr
    loguru_logger.add(
        sys.stderr,
        level=log_level,
        format="<green>{time:YYYY-MM-DD HH:mm:ss}</green> | <level>{level: <8}</level> | <cyan>{name}</cyan>:<cyan>{function}</cyan>:<cyan>{line}</cyan> - <level>{message}</level>",
        enqueue=True,    # Torna o logging ass√≠ncrono e seguro para threads/processos
        diagnose=False   # Desabilita diagn√≥sticos detalhados de exce√ß√µes por padr√£o
    )

    # Configura o logging padr√£o do Python para usar o InterceptHandler
    logging.basicConfig(handlers=[InterceptHandler()], level=0, force=True)

    # Ajustes espec√≠ficos para loggers de bibliotecas comuns
    logging.getLogger("uvicorn.access").disabled = True # Desabilita logs de acesso do Uvicorn
    logging.getLogger("uvicorn.error").propagate = False # Evita duplica√ß√£o de erros do Uvicorn

    # Desabilita logs de httpx, pois podem ser muito verbosos.
    # Se precisar depurar httpx, comente ou ajuste esta linha.
    loguru_logger.disable("httpx")

================================================================================
Cap√≠tulo 5: app/core/security.py
================================================================================

# app/core/security.py
"""
M√≥dulo respons√°vel pelas funcionalidades de seguran√ßa da aplica√ß√£o,
incluindo hashing de senhas e gerenciamento de tokens JWT (JSON Web Token)
para autentica√ß√£o e autoriza√ß√£o.
"""

# ========================
# --- Importa√ß√µes ---
# ========================
import logging
from datetime import datetime, timedelta, timezone
from typing import Any, Union, Optional
from passlib.context import CryptContext
from jose import ExpiredSignatureError, jwt, JWTError
from pydantic import ValidationError

# --- M√≥dulos da Aplica√ß√£o ---
from app.core.config import settings
from app.models.token import TokenPayload

# ========================
# --- Configura√ß√£o do Logger ---
# ========================
logger = logging.getLogger(__name__)

# ========================
# --- Configura√ß√£o Hashing de Senha ---
# ========================
# Contexto Passlib para hashing e verifica√ß√£o de senhas usando bcrypt.
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

# ========================
# --- Constantes JWT ---
# ========================
ALGORITHM = settings.JWT_ALGORITHM
ACCESS_TOKEN_EXPIRE_MINUTES = settings.ACCESS_TOKEN_EXPIRE_MINUTES

# ========================
# --- Fun√ß√µes de Senha ---
# ========================
def verify_password(plain_password: str, hashed_password: str) -> bool:
    """
    Verifica se uma senha em texto plano corresponde a um hash armazenado.

    Args:
        plain_password: A senha fornecida pelo usu√°rio (texto plano).
        hashed_password: O hash da senha armazenado.

    Returns:
        True se a senha corresponder ao hash, False caso contr√°rio.
    """
    try:
        return pwd_context.verify(plain_password, hashed_password)
    except ValueError:
        # Ocorre se o formato do hash for inv√°lido para o passlib
        logger.warning("Tentativa de verificar senha com hash em formato inv√°lido.")
        return False

def get_password_hash(password: str) -> str:
    """
    Gera um hash seguro (bcrypt) para uma senha fornecida.

    Args:
        password: A senha em texto plano a ser hasheada.

    Returns:
        A string do hash bcrypt gerado.
    """
    return pwd_context.hash(password)

# ========================
# --- Fun√ß√µes JWT ---
# ========================
def create_access_token(
    subject: Union[str, Any],
    username: str,
    expires_delta: Optional[timedelta] = None
) -> str:
    """
    Cria um novo token de acesso JWT.

    Args:
        subject: Identificador √∫nico do usu√°rio (normalmente ID).
        username: Nome de usu√°rio.
        expires_delta: Dura√ß√£o opcional para a validade do token.
                       Se None, usa o padr√£o `ACCESS_TOKEN_EXPIRE_MINUTES`.

    Returns:
        O token JWT codificado como uma string.
    """
    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)

    subject_str = str(subject) # Garante que 'sub' seja string no payload

    to_encode = {
        "exp": expire,
        "sub": subject_str,
        "username": username
    }
    encoded_jwt = jwt.encode(to_encode, settings.JWT_SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

def decode_token(token: str) -> Optional[TokenPayload]:
    """
    Decodifica e valida um token JWT.

    Verifica assinatura, expira√ß√£o e estrutura do payload (via Pydantic).
    A verifica√ß√£o de expira√ß√£o padr√£o do `jwt.decode` √© desabilitada
    para que a l√≥gica de verifica√ß√£o dupla de expira√ß√£o seja executada.

    Args:
        token: A string do token JWT.

    Returns:
        Objeto TokenPayload se o token for v√°lido e n√£o expirado, None caso contr√°rio.
    """
    try:
        payload = jwt.decode(
            token,
            settings.JWT_SECRET_KEY,
            algorithms=[ALGORITHM],
            options={"verify_exp": False} # Desabilita verif. de expira√ß√£o da lib JWT
        )
        # Valida o payload contra o modelo Pydantic TokenPayload
        token_data = TokenPayload.model_validate(payload)

        # Verifica√ß√£o dupla da expira√ß√£o
        if token_data.exp is not None:
            token_expiration_time = datetime.fromtimestamp(token_data.exp, tz=timezone.utc)
            if datetime.now(timezone.utc) > token_expiration_time:
                logger.info("Token JWT expirado (verifica√ß√£o dupla).")
                return None
        else:
            # Se 'exp' √© opcional no TokenPayload e est√° ausente
            pass # Tratar como v√°lido neste ponto, se permitido pelo modelo.
                 # Se 'exp' for obrigat√≥rio no TokenPayload, model_validate j√° falharia.
        return token_data
    except ExpiredSignatureError:
        # Este bloco seria alcan√ßado se options={"verify_exp": True} fosse usado
        # e a pr√≥pria lib jose pegasse a expira√ß√£o, ou outro erro inesperado da lib.
        logger.warning("Token JWT detectado como expirado pela biblioteca JOSE antes da verifica√ß√£o dupla.")
        return None
    except (JWTError, ValidationError, KeyError) as e:
        # Captura erros de assinatura/formato JWT, erros de valida√ß√£o Pydantic do payload,
        # ou aus√™ncia de chaves esperadas se a valida√ß√£o Pydantic n√£o for suficiente.
        logger.error(f"Erro ao decodificar/validar token: {e}", exc_info=True)
        return None

================================================================================
Cap√≠tulo 6: app/core/utils.py
================================================================================

# app/core/utils.py
"""
M√≥dulo contendo fun√ß√µes utilit√°rias diversas para a aplica√ß√£o SmartTask.
Inclui c√°lculos de prioridade para tarefas, verifica√ß√£o de urg√™ncia de tarefas,
e envio de notifica√ß√µes via webhook.
"""

# ========================
# --- Importa√ß√µes ---
# ========================
import json
import hmac
import hashlib
import math # Embora math n√£o seja usado explicitamente, √© uma importa√ß√£o comum em utils.
import logging
from datetime import date, datetime, timezone
from typing import Any, Dict, Optional
# TYPE_CHECKING removido se n√£o usado para imports condicionais de tipo.
import httpx

# --- M√≥dulos da Aplica√ß√£o ---
from app.models.task import Task # Importa√ß√£o direta do modelo Task
from app.core.config import settings

# ========================
# --- Configura√ß√£o do Logger ---
# ========================
logger = logging.getLogger(__name__)

# ========================
# --- Fun√ß√£o de C√°lculo de Prioridade ---
# ========================
def calculate_priority_score(
    importance: int,
    due_date: Optional[date]
) -> Optional[float]:
    """
    Calcula a pontua√ß√£o de prioridade de uma tarefa.

    A pontua√ß√£o √© baseada na import√¢ncia fornecida e na data de vencimento,
    utilizando pesos configur√°veis atrav√©s das settings da aplica√ß√£o.

    Args:
        importance: N√≠vel de import√¢ncia da tarefa (inteiro, 1-5).
        due_date: Data de vencimento da tarefa (objeto date ou None).

    Returns:
        A pontua√ß√£o de prioridade calculada (float), ou None se a import√¢ncia for inv√°lida.
    """
    if not 1 <= importance <= 5:
        logger.warning(f"C√°lculo de prioridade recebido com import√¢ncia inv√°lida: {importance}")
        return None

    # --- Score de Import√¢ncia ---
    importance_score = importance * settings.PRIORITY_WEIGHT_IMPORTANCE

    # --- Score de Prazo ---
    due_date_score = 0.0
    if due_date:
        today = date.today()
        days_remaining = (due_date - today).days

        if days_remaining < 0:
            due_date_score = settings.PRIORITY_SCORE_IF_OVERDUE
            logger.debug(f"Tarefa atrasada ({days_remaining} dias), score de overdue: {due_date_score}")
        elif days_remaining == 0:
            due_date_score = settings.PRIORITY_WEIGHT_DUE_DATE / 1.0
            logger.debug(f"Tarefa vence hoje, score de prazo: {due_date_score}")
        elif days_remaining > 0:
            effective_days = max(1, days_remaining) # Evita divis√£o por zero ou por dias < 1
            due_date_score = settings.PRIORITY_WEIGHT_DUE_DATE / effective_days
            logger.debug(f"Tarefa vence em {days_remaining} dias, score de prazo: {due_date_score}")

    elif settings.PRIORITY_DEFAULT_SCORE_NO_DUE_DATE is not None:
        due_date_score = settings.PRIORITY_DEFAULT_SCORE_NO_DUE_DATE
        logger.debug(f"Tarefa sem prazo, score default de prazo: {due_date_score}")

    # --- Combinar Scores ---
    total_score = round(due_date_score + importance_score, 2)
    logger.debug(f"Score final calculado: {total_score} (prazo={due_date_score}, importancia={importance_score})")
    return total_score

# ========================
# --- Fun√ß√£o de Tarefa Urgente ---
# ========================
def is_task_urgent(task: Task) -> bool:
    """
    Verifica se uma tarefa √© considerada urgente para fins de notifica√ß√£o.

    Args:
        task: O objeto Task a ser verificado.

    Returns:
        True se a tarefa for considerada urgente, False caso contr√°rio.
    """
    if task.priority_score is None and task.due_date is None:
        return False # Tarefa sem score nem prazo n√£o pode ser urgente pelos crit√©rios atuais

    if task.priority_score is not None and task.priority_score > settings.EMAIL_URGENCY_THRESHOLD:
        return True

    if task.due_date:
        today = date.today()
        if (task.due_date - today).days <= 0: # Vence hoje ou est√° atrasada
            return True
    return False

# ========================
# --- Fun√ß√£o de Envio de Webhook ---
# ========================
async def send_webhook_notification(
    event_type: str,
    task_data: Dict[str, Any]
):
    """
    Envia uma notifica√ß√£o via webhook para a URL configurada.

    Inclui assinatura HMAC-SHA256 se WEBHOOK_SECRET estiver definido.

    Args:
        event_type: String identificando o tipo do evento (ex: 'task.created').
        task_data: Dicion√°rio com os dados da tarefa.
    """
    if not settings.WEBHOOK_URL:
        logger.debug("Webhook URL n√£o configurada, pulando envio.")
        return

    webhook_url_str = str(settings.WEBHOOK_URL)
    payload = {
        "event": event_type,
        "task": task_data,
        "timestamp": datetime.now(timezone.utc).isoformat()
    }
    headers = {
        "Content-Type": "application/json",
        "User-Agent": "SmartTask-Webhook-Client/1.0"
    }

    # --- Seguran√ßa: Assinatura ---
    if settings.WEBHOOK_SECRET:
        try:
            payload_bytes = json.dumps(payload, separators=(',', ':'), sort_keys=True).encode('utf-8')
            secret_bytes = settings.WEBHOOK_SECRET.encode('utf-8')
            signature = hmac.new(secret_bytes, payload_bytes, hashlib.sha256).hexdigest()
            headers["X-SmartTask-Signature"] = f"sha256={signature}"
        except Exception as e:
            logger.error(f"Erro ao gerar assinatura HMAC para webhook: {e}", exc_info=True)
            return # N√£o envia se a assinatura falhar

    # --- Envio da Requisi√ß√£o HTTP ---
    try:
        async with httpx.AsyncClient() as client:
            logger.info(f"Enviando webhook evento '{event_type}' para {webhook_url_str}")
            response = await client.post(
                webhook_url_str,
                json=payload,
                headers=headers,
                timeout=10.0
            )
            response.raise_for_status() # Levanta exce√ß√£o para status de erro HTTP (4xx, 5xx)
            logger.info(f"Webhook enviado com sucesso para {webhook_url_str}. Status: {response.status_code}")

    except httpx.TimeoutException:
        logger.error(f"Timeout ao enviar webhook para {webhook_url_str}") # pragma: no cover
    except httpx.RequestError as exc:
        logger.error(f"Erro na requisi√ß√£o ao enviar webhook para {webhook_url_str}: {exc}")
    except httpx.HTTPStatusError as exc:
        logger.error(
            f"Erro no servidor do webhook ({webhook_url_str}). "
            f"Status: {exc.response.status_code}. Resposta: {exc.response.text[:200]}..."
        )
    except Exception as e:
        logger.exception(f"Erro inesperado ao enviar webhook para {webhook_url_str}: {e}")

================================================================================
Cap√≠tulo 7: app/db/mongodb_utils.py
================================================================================

# app/db/mongodb_utils.py
"""
Este m√≥dulo gerencia a conex√£o com o banco de dados MongoDB.
Inclui fun√ß√µes para conectar, fechar a conex√£o e obter a inst√¢ncia do banco de dados.
Utiliza a biblioteca Motor para intera√ß√µes ass√≠ncronas com o MongoDB.
"""

# ========================
# --- Importa√ß√µes ---
# ========================
import logging
from typing import Optional
import motor.motor_asyncio
from motor.motor_asyncio import AsyncIOMotorClient, AsyncIOMotorDatabase 

# --- M√≥dulos da Aplica√ß√£o ---
from app.core.config import settings

# ========================
# --- Configura√ß√£o do Logger ---
# ========================
logger = logging.getLogger(__name__)

# ========================
# --- Vari√°veis Globais de Conex√£o ---
# ========================
# Estas vari√°veis mant√™m o estado da conex√£o MongoDB para a aplica√ß√£o.
db_client: Optional[AsyncIOMotorClient] = None
db_instance: Optional[AsyncIOMotorDatabase] = None

# ========================
# --- Fun√ß√£o de Conex√£o ---
# ========================
async def connect_to_mongo() -> Optional[AsyncIOMotorDatabase]:
    """
    Estabelece a conex√£o com o MongoDB.

    Cria um cliente AsyncIOMotorClient, verifica a conex√£o com um comando 'ping',
    e define as vari√°veis globais `db_client` e `db_instance`.

    Returns:
        A inst√¢ncia AsyncIOMotorDatabase se a conex√£o for bem-sucedida, None caso contr√°rio.
    """
    global db_client, db_instance
    logger.info("Tentando conectar ao MongoDB...")
    try:
        db_client = motor.motor_asyncio.AsyncIOMotorClient(
            settings.MONGODB_URL,
            serverSelectionTimeoutMS=5000 # Timeout para sele√ß√£o do servidor
        )
        # Verifica a conex√£o
        await db_client.admin.command('ping')
        logger.info("Comando ping para MongoDB bem-sucedido.")

        db_instance = db_client[settings.DATABASE_NAME]
        logger.info(f"Conectado com sucesso ao banco de dados: {settings.DATABASE_NAME}")
        return db_instance

    except Exception as e:
        logger.error(f"N√£o foi poss√≠vel conectar ao MongoDB: {e}", exc_info=True)
        db_client = None
        db_instance = None
        return None

# ========================
# --- Fun√ß√£o de Fechamento de Conex√£o ---
# ========================
async def close_mongo_connection():
    """
    Fecha a conex√£o com o MongoDB.
    Verifica se o cliente `db_client` foi inicializado antes de tentar fechar.
    """
    global db_client # Indica que estamos referenciando a vari√°vel global
    logger.info("Tentando fechar conex√£o com MongoDB...")
    if db_client:
        db_client.close()
        logger.info("Conex√£o com MongoDB fechada.")
        # Opcionalmente, resetar db_client e db_instance para None ap√≥s fechar:
        # db_client = None
        # db_instance = None
    else:
        logger.warning("Tentativa de fechar conex√£o com MongoDB, mas cliente n√£o estava inicializado.")

# ========================
# --- Fun√ß√£o de Acesso ao DB ---
# ========================
def get_database() -> AsyncIOMotorDatabase:
    """
    Retorna a inst√¢ncia global do banco de dados MongoDB.

    Usada como depend√™ncia FastAPI ou chamada por outras partes da aplica√ß√£o.

    Raises:
        RuntimeError: Se chamada antes de `connect_to_mongo` inicializar `db_instance`.

    Returns:
        A inst√¢ncia AsyncIOMotorDatabase.
    """
    if db_instance is None:
        # Este log de erro √© importante para diagn√≥stico
        logger.error("Tentativa de obter inst√¢ncia do DB antes da inicializa√ß√£o!")
        raise RuntimeError("A conex√£o com o banco de dados n√£o foi inicializada.")
    return db_instance

================================================================================
Cap√≠tulo 8: app/db/task_crud.py
================================================================================

# app/db/task_crud.py
"""
M√≥dulo contendo as fun√ß√µes CRUD (Create, Read, Update, Delete)
para interagir com a cole√ß√£o de tarefas no MongoDB.
Inclui tamb√©m fun√ß√µes auxiliares e para cria√ß√£o de √≠ndices.
"""

# ========================
# --- Importa√ß√µes ---
# ========================
import logging
import uuid
from datetime import date, datetime, timezone
from typing import List, Optional, Dict, Any, Tuple
from motor.motor_asyncio import AsyncIOMotorDatabase, AsyncIOMotorCollection
from pymongo import ASCENDING, DESCENDING
from pydantic import ValidationError

# --- M√≥dulos da Aplica√ß√£o ---
from app.models.task import Task, TaskCreate, TaskUpdate, TaskStatus

# =====================================
# --- Configura√ß√µes e Constantes ---
# =====================================

logger = logging.getLogger(__name__)

TASKS_COLLECTION = "tasks"

# =========================================
# --- Fun√ß√µes Auxiliares (Internas) ---
# =========================================

def _get_tasks_collection(db: AsyncIOMotorDatabase) -> AsyncIOMotorCollection:
    """Retorna a cole√ß√£o de tarefas do banco de dados."""
    return db[TASKS_COLLECTION]

def _parse_sort_params(sort_by: Optional[str], sort_order: str) -> Optional[List[Tuple[str, int]]]:
    """
    Converte os par√¢metros de ordena√ß√£o de string para o formato do PyMongo.

    Args:
        sort_by: Campo pelo qual ordenar.
        sort_order: Ordem da ordena√ß√£o ("asc" ou "desc").

    Returns:
        Lista de tuplas para ordena√ß√£o do PyMongo ou None se o campo n√£o for v√°lido.
    """
    if sort_order.lower() == "asc":
        mongo_order = ASCENDING
    else:
        mongo_order = DESCENDING

    if sort_by in ["priority_score", "due_date", "created_at", "importance"]:
        return [(sort_by, mongo_order)]
    return None

# =======================================
# --- Opera√ß√µes CRUD para Tarefas ---
# =======================================

async def create_task(db: AsyncIOMotorDatabase, task_db: Task) -> Optional[Task]:
    """
    Cria uma nova tarefa no banco de dados.

    A tarefa j√° deve chegar validada e com campos como ID e owner_id preenchidos.

    Args:
        db: Inst√¢ncia da conex√£o com o banco de dados.
        task_db: Objeto Task contendo os dados da tarefa a ser criada.

    Returns:
        O objeto Task criado se sucesso, None caso contr√°rio.
    """
    collection = _get_tasks_collection(db)
    task_db_dict = task_db.model_dump(mode="json")
    try:
        insert_result = await collection.insert_one(task_db_dict)
        if insert_result.acknowledged:
            return task_db
        else:
            logger.warning(f"Cria√ß√£o da tarefa para owner {task_db.owner_id} n√£o foi reconhecida pelo DB (acknowledged=False).")
            return None
    except Exception as e:
        logger.exception(f"DB Error creating task for owner {task_db.owner_id}: {e}")
        return None

async def get_task_by_id(db: AsyncIOMotorDatabase, task_id: uuid.UUID, owner_id: uuid.UUID) -> Optional[Task]:
    """
    Busca uma tarefa espec√≠fica pelo seu ID e pelo ID do propriet√°rio.

    Args:
        db: Inst√¢ncia da conex√£o com o banco de dados.
        task_id: ID da tarefa a ser buscada.
        owner_id: ID do propriet√°rio da tarefa.

    Returns:
        O objeto Task encontrado ou None se a tarefa n√£o existir ou erro de valida√ß√£o.
    """
    collection = _get_tasks_collection(db)
    task_dict = await collection.find_one({"id": str(task_id), "owner_id": str(owner_id)})
    if task_dict:
        task_dict.pop('_id', None)
        try:
            return Task.model_validate(task_dict)
        except (ValidationError, Exception) as e:
            logger.error(f"DB Validation error get_task_by_id {task_id} for owner {owner_id}: {e}")
            return None
    return None

async def get_tasks_by_owner(
    db: AsyncIOMotorDatabase,
    owner_id: uuid.UUID,
    *,
    status_filter: Optional[TaskStatus] = None,
    due_before: Optional[date] = None,
    project_filter: Optional[str] = None,
    tags_filter: Optional[List[str]] = None,
    sort_by: Optional[str] = None,
    sort_order: str = "desc",
    limit: int = 100,
    skip: int = 0
) -> List[Task]:
    """
    Busca tarefas de um propriet√°rio com filtros, ordena√ß√£o e pagina√ß√£o.

    Args:
        db: Inst√¢ncia da conex√£o com o banco de dados.
        owner_id: ID do propriet√°rio das tarefas.
        status_filter: Filtra tarefas pelo status.
        due_before: Filtra tarefas com data de entrega anterior ou igual √† data fornecida.
        project_filter: Filtra tarefas por nome do projeto.
        tags_filter: Filtra tarefas que contenham todas as tags listadas.
        sort_by: Campo para ordena√ß√£o.
        sort_order: Ordem da ordena√ß√£o ("asc" ou "desc").
        limit: N√∫mero m√°ximo de tarefas a retornar.
        skip: N√∫mero de tarefas a pular (para pagina√ß√£o).

    Returns:
        Uma lista de objetos Task. Retorna lista vazia em caso de erro ou nenhuma tarefa encontrada.
    """
    collection = _get_tasks_collection(db)
    query: Dict[str, Any] = {"owner_id": str(owner_id)}

    if status_filter:
        query["status"] = status_filter.value
    if due_before:
        due_before_dt = datetime.combine(due_before, datetime.min.time(), tzinfo=timezone.utc)
        query["due_date"] = {"$lte": due_before_dt}
    if project_filter:
        query["project"] = project_filter
    if tags_filter:
        query["tags"] = {"$all": tags_filter}

    sort_list = _parse_sort_params(sort_by, sort_order)

    validated_tasks = []
    try:
        tasks_cursor = collection.find(query).skip(skip).limit(limit)
        if sort_list:
            tasks_cursor = tasks_cursor.sort(sort_list)

        async for task_dict in tasks_cursor:
            task_dict.pop('_id', None)
            try:
                validated_tasks.append(Task.model_validate(task_dict))
            except (ValidationError, Exception) as e:
                logger.error(f"DB Validation error list_tasks owner {owner_id} task {task_dict.get('id', 'N/A')}: {e}")
                continue
        return validated_tasks
    except Exception as e:
        logger.exception(f"DB Error listing tasks for owner {owner_id}: {e}")
        return []


async def update_task(
    db: AsyncIOMotorDatabase,
    task_id: uuid.UUID,
    owner_id: uuid.UUID,
    update_data: Dict[str, Any]
) -> Optional[Task]:
    """
    Atualiza uma tarefa existente de um propriet√°rio espec√≠fico.

    Os dados de atualiza√ß√£o devem ser fornecidos em um dicion√°rio pronto para o
    operador '$set' do MongoDB. O campo 'updated_at' √© automaticamente atualizado.

    Args:
        db: Inst√¢ncia da conex√£o com o banco de dados.
        task_id: ID da tarefa a ser atualizada.
        owner_id: ID do propriet√°rio da tarefa.
        update_data: Dicion√°rio com os campos a serem atualizados.

    Returns:
        O objeto Task atualizado ou None se a tarefa n√£o for encontrada ou ocorrer um erro.
    """
    collection = _get_tasks_collection(db)
    update_data["updated_at"] = datetime.now(timezone.utc)

    try:
        updated_task_dict_raw = await collection.find_one_and_update(
            {"id": str(task_id), "owner_id": str(owner_id)},
            {"$set": update_data},
            return_document=True
        )

        if updated_task_dict_raw:
            updated_task_dict_raw.pop('_id', None)
            try:
                return Task.model_validate(updated_task_dict_raw)
            except (ValidationError, Exception) as e:
                logger.error(f"DB Validation error update_task {task_id} owner {owner_id}: {e}")
                return None
        else:
            logger.warning(f"Tentativa de atualizar tarefa n√£o encontrada: ID {task_id}, Owner ID {owner_id}")
            return None
    except Exception as e:
        logger.exception(f"DB Error updating task {task_id} owner {owner_id}: {e}")
        return None


async def delete_task(db: AsyncIOMotorDatabase, task_id: uuid.UUID, owner_id: uuid.UUID) -> bool:
    """
    Deleta uma tarefa espec√≠fica pelo seu ID e pelo ID do propriet√°rio.

    Args:
        db: Inst√¢ncia da conex√£o com o banco de dados.
        task_id: ID da tarefa a ser deletada.
        owner_id: ID do propriet√°rio da tarefa.

    Returns:
        True se a tarefa foi deletada com sucesso (1 documento afetado), False caso contr√°rio.
    """
    collection = _get_tasks_collection(db)
    try:
        delete_result = await collection.delete_one({"id": str(task_id), "owner_id": str(owner_id)})
        return delete_result.deleted_count == 1
    except Exception as e:
        logger.exception(f"DB Error deleting task {task_id} owner {owner_id}: {e}")
        return False

# ===================================================
# --- Cria√ß√£o de √çndices do Banco de Dados ---
# ===================================================

async def create_task_indexes(db: AsyncIOMotorDatabase):
    """
    Cria os √≠ndices necess√°rios na cole√ß√£o de tarefas para otimizar consultas.

    Os √≠ndices s√£o criados apenas se ainda n√£o existirem.
    Esta fun√ß√£o √© tipicamente chamada durante a inicializa√ß√£o da aplica√ß√£o.

    Args:
        db: Inst√¢ncia da conex√£o com o banco de dados.
    """
    collection = _get_tasks_collection(db)
    try:
        await collection.create_index("id", unique=True, name="task_id_unique_idx")
        await collection.create_index("owner_id", name="task_owner_idx")
        await collection.create_index(
            [("owner_id", ASCENDING), ("due_date", DESCENDING)],
            name="task_owner_due_date_idx"
        )
        await collection.create_index(
            [("owner_id", ASCENDING), ("priority_score", DESCENDING)],
            name="task_owner_priority_idx"
        )
        await collection.create_index("tags", name="task_tags_idx")
        logging.info("√çndices da cole√ß√£o 'tasks' verificados/criados.")
    except Exception as e:
        logging.error(f"Erro ao criar √≠ndices da cole√ß√£o 'tasks': {e}", exc_info=True)

================================================================================
Cap√≠tulo 9: app/db/user_crud.py
================================================================================

# app/db/user_crud.py
"""
M√≥dulo contendo as fun√ß√µes CRUD (Create, Read, Update, Delete)
para interagir com a cole√ß√£o de usu√°rios no MongoDB.
Inclui tamb√©m fun√ß√µes para cria√ß√£o de √≠ndices.
"""

# ========================
# --- Importa√ß√µes ---
# ========================
import logging
import uuid
from datetime import datetime, timezone
from typing import Optional
from motor.motor_asyncio import AsyncIOMotorDatabase, AsyncIOMotorCollection
from pydantic import ValidationError
from pymongo.errors import DuplicateKeyError

# --- M√≥dulos da Aplica√ß√£o ---
from app.models.user import UserCreate, UserInDB, UserUpdate
from app.core.security import get_password_hash

# ========================
# --- Configura√ß√µes e Constantes ---
# ========================
logger = logging.getLogger(__name__)
USERS_COLLECTION = "users"

# ========================
# --- Fun√ß√µes Auxiliares (Internas) ---
# ========================
def _get_users_collection(db: AsyncIOMotorDatabase) -> AsyncIOMotorCollection:
    """Retorna a cole√ß√£o de usu√°rios do banco de dados."""
    return db[USERS_COLLECTION]

# ========================
# --- Opera√ß√µes CRUD para Usu√°rios ---
# ========================
async def get_user_by_id(db: AsyncIOMotorDatabase, user_id: uuid.UUID) -> Optional[UserInDB]:
    """
    Busca um usu√°rio pelo seu ID (UUID).

    Args:
        db: Inst√¢ncia da conex√£o com o banco de dados.
        user_id: O ID do usu√°rio a ser buscado.

    Returns:
        Um objeto UserInDB se o usu√°rio for encontrado e v√°lido, None caso contr√°rio.
    """
    collection = _get_users_collection(db)
    user_dict = await collection.find_one({"id": str(user_id)})
    if user_dict:
        user_dict.pop('_id', None)
        try:
            return UserInDB.model_validate(user_dict)
        except Exception as e:
            logger.error(f"DB Validation error get_user_by_id {user_id}: {e}")
            return None
    return None

async def get_user_by_username(db: AsyncIOMotorDatabase, username: str) -> Optional[UserInDB]:
    """
    Busca um usu√°rio pelo seu nome de usu√°rio.

    Args:
        db: Inst√¢ncia da conex√£o com o banco de dados.
        username: O nome de usu√°rio a ser buscado.

    Returns:
        Um objeto UserInDB se o usu√°rio for encontrado e v√°lido, None caso contr√°rio.
    """
    collection = _get_users_collection(db)
    user_dict = await collection.find_one({"username": username})
    if user_dict:
        user_dict.pop('_id', None)
        try:
            return UserInDB.model_validate(user_dict)
        except Exception as e:
            logger.error(f"DB Validation error get_user_by_username {username}: {e}")
            return None
    return None

async def get_user_by_email(db: AsyncIOMotorDatabase, email: str) -> Optional[UserInDB]:
    """
    Busca um usu√°rio pelo seu endere√ßo de e-mail.

    Args:
        db: Inst√¢ncia da conex√£o com o banco de dados.
        email: O endere√ßo de e-mail a ser buscado.

    Returns:
        Um objeto UserInDB se o usu√°rio for encontrado e v√°lido, None caso contr√°rio.
    """
    collection = _get_users_collection(db)
    user_dict = await collection.find_one({"email": email})
    if user_dict:
        user_dict.pop('_id', None)
        try:
            return UserInDB.model_validate(user_dict)
        except Exception as e:
            logger.error(f"DB Validation error get_user_by_email {email}: {e}")
            return None
    return None

async def create_user(db: AsyncIOMotorDatabase, user_in: UserCreate) -> Optional[UserInDB]:
    """
    Cria um novo usu√°rio no banco de dados.

    Gera um UUID para o usu√°rio, hasheia a senha e define campos padr√£o
    como 'disabled', 'created_at' e 'updated_at'.

    Args:
        db: Inst√¢ncia da conex√£o com o banco de dados.
        user_in: Objeto UserCreate com os dados do usu√°rio a ser criado.

    Returns:
        Um objeto UserInDB representando o usu√°rio criado se sucesso, None em caso de erro.
        Pode levantar DuplicateKeyError se username ou email j√° existirem e houver
        √≠ndices de unicidade configurados.
    """
    hashed_password = get_password_hash(user_in.password)
    user_db_data = {
        "id": uuid.uuid4(),
        "username": user_in.username,
        "email": user_in.email,
        "hashed_password": hashed_password,
        "full_name": user_in.full_name,
        "disabled": False,
        "created_at": datetime.now(timezone.utc),
        "updated_at": None
    }

    try:
        user_db_obj = UserInDB.model_validate(user_db_data)
    except Exception as validation_error:
        logger.error(f"Erro de valida√ß√£o Pydantic ao preparar dados para user_db_obj (username: {user_in.username}): {validation_error}", exc_info=True)
        return None

    user_db_dict = user_db_obj.model_dump(mode="json")
    collection = _get_users_collection(db)

    try:
        insert_result = await collection.insert_one(user_db_dict)
        if not insert_result.acknowledged: # pragma: no cover
            logger.error(f"DB Insert User Acknowledged False for username {user_in.username}")
            return None
        return user_db_obj
    except DuplicateKeyError:
        logger.warning(f"Tentativa de criar usu√°rio com username ou email duplicado: {user_in.username} / {user_in.email}")
        raise
    except Exception as e:
        logger.exception(f"Erro inesperado ao inserir usu√°rio {user_in.username} no DB: {e}")
        return None

async def update_user(db: AsyncIOMotorDatabase, user_id: uuid.UUID, user_update: UserUpdate) -> Optional[UserInDB]:
    """
    Atualiza os dados de um usu√°rio existente.

    Apenas os campos fornecidos no objeto `user_update` ser√£o alterados.
    O campo `updated_at` √© automaticamente atualizado. Se a senha for
    alterada, ela ser√° hasheada.

    Args:
        db: Inst√¢ncia da conex√£o com o banco de dados.
        user_id: O ID do usu√°rio a ser atualizado.
        user_update: Objeto UserUpdate contendo os dados a serem atualizados.

    Returns:
        O objeto UserInDB atualizado se sucesso, None se o usu√°rio n√£o for encontrado ou erro.
        Pode levantar DuplicateKeyError se a atualiza√ß√£o tentar definir um username/email
        que j√° exista e perten√ßa a outro usu√°rio.
    """
    collection = _get_users_collection(db)
    update_data = user_update.model_dump(exclude_unset=True)

    if "password" in update_data:
        if update_data["password"] is not None:
            update_data["hashed_password"] = get_password_hash(update_data.pop("password"))
        elif "password" in update_data and update_data["password"] is None: # Este elif √© redundante com a condi√ß√£o externa.
            update_data.pop("password") # Evita 'password: null' se for passado explicitamente como None

    if not update_data and "hashed_password" not in update_data :
        existing_user = await get_user_by_id(db, user_id)
        if existing_user:
            try:
                updated_doc = await collection.find_one_and_update(
                    {"id": str(user_id)},
                    {"$set": {"updated_at": datetime.now(timezone.utc)}},
                    return_document=True
                )
                if updated_doc:
                    updated_doc.pop('_id', None)
                    return UserInDB.model_validate(updated_doc)
                return None
            except Exception as e:
                logger.exception(f"DB Error updating user (only updated_at) {user_id}: {e}")
                return None
        return existing_user # Retorna o usu√°rio existente se nada mais for atualizado

    update_data["updated_at"] = datetime.now(timezone.utc)

    try:
        updated_user_doc = await collection.find_one_and_update(
            {"id": str(user_id)},
            {"$set": update_data},
            return_document=True
        )

        if updated_user_doc:
            updated_user_doc.pop('_id', None)
            try:
                return UserInDB.model_validate(updated_user_doc)
            except ValidationError as e:
                logger.error(f"DB Validation error after updating user {user_id}: {e}")
                return None
        else:
            logger.warning(f"Attempt to update user not found: ID {user_id}")
            return None
    except DuplicateKeyError:
        logger.warning(f"DB Error: Attempt to update user {user_id} resulted in duplicate key for data: { {k: v for k, v in update_data.items() if k not in ['hashed_password', 'updated_at']} }")
        raise
    except Exception as e:
        logger.exception(f"DB Error updating user {user_id}: {e}")
        return None

async def delete_user(db: AsyncIOMotorDatabase, user_id: uuid.UUID) -> bool:
    """
    Deleta um usu√°rio do banco de dados pelo seu ID.

    Args:
        db: Inst√¢ncia da conex√£o com o banco de dados.
        user_id: O ID do usu√°rio a ser deletado.

    Returns:
        True se o usu√°rio foi deletado com sucesso (1 documento afetado), False caso contr√°rio.
    """
    collection = _get_users_collection(db)
    try:
        delete_result = await collection.delete_one({"id": str(user_id)})
        if delete_result.deleted_count == 1:
            logger.info(f"User {user_id} deleted successfully.")
            return True
        else:
            logger.warning(f"Attempt to delete user {user_id}, but user was not found or not deleted (deleted_count: {delete_result.deleted_count}).")
            return False
    except Exception as e:
        logger.exception(f"DB Error deleting user {user_id}: {e}")
        return False

# ========================
# --- Configura√ß√£o de √çndices do Banco de Dados ---
# ========================
async def create_user_indexes(db: AsyncIOMotorDatabase):
    """
    Cria os √≠ndices necess√°rios na cole√ß√£o de usu√°rios para otimizar consultas
    e garantir unicidade de campos como username e email.

    Os √≠ndices s√£o criados apenas se ainda n√£o existirem.
    Esta fun√ß√£o √© tipicamente chamada durante a inicializa√ß√£o da aplica√ß√£o.

    Args:
        db: Inst√¢ncia da conex√£o com o banco de dados.
    """
    collection = _get_users_collection(db)
    try:
        await collection.create_index("username", unique=True, name="username_unique_idx")
        await collection.create_index("email", unique=True, name="email_unique_idx")
        logger.info("√çndices da cole√ß√£o 'users' ('username', 'email') verificados/criados com sucesso.")
    except Exception as e:
        logger.error(f"Erro ao criar √≠ndices para a cole√ß√£o 'users': {e}", exc_info=True)

================================================================================
Cap√≠tulo 10: app/main.py
================================================================================

# app/main.py
"""
Ponto de entrada principal e configura√ß√£o da aplica√ß√£o FastAPI SmartTask.
Define a inst√¢ncia da aplica√ß√£o, middlewares, rotas, ciclo de vida (lifespan)
e o endpoint raiz. Tamb√©m inclui o setup de logging inicial.
"""

# ========================
# --- Importa√ß√µes ---
# ========================
import logging
import sys
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from contextlib import asynccontextmanager

# --- M√≥dulos da Aplica√ß√£o ---
from app.routers import tasks
from app.routers import auth
from app.db.mongodb_utils import connect_to_mongo, close_mongo_connection
from app.db.user_crud import create_user_indexes
from app.db.task_crud import create_task_indexes
from app.core.config import Settings, settings # settings importado, Settings para type hint
from app.core.logging_config import setup_logging # InterceptHandler n√£o precisa ser importado aqui

# ========================
# --- Configura√ß√£o de Logging ---
# ========================
setup_logging(log_level=settings.LOG_LEVEL)
logger = logging.getLogger(__name__)

# ========================
# --- Fun√ß√£o de Setup do Middleware CORS ---
# ========================
def _setup_cors_middleware(app_instance: FastAPI, current_settings: Settings):
    """Configura o middleware CORS para a aplica√ß√£o."""
    if current_settings.CORS_ALLOWED_ORIGINS:
        logger.info(f"Configurando CORS para origens: {current_settings.CORS_ALLOWED_ORIGINS}")
        app_instance.add_middleware(
            CORSMiddleware,
            allow_origins=current_settings.CORS_ALLOWED_ORIGINS,
            allow_credentials=True,
            allow_methods=["*"],
            allow_headers=["*"],
        )
    else:
        logger.warning(
            "Nenhuma origem CORS configurada (settings.CORS_ALLOWED_ORIGINS est√° vazia). "
            "API pode n√£o ser acess√≠vel de frontends em outros dom√≠nios."
        )

# ========================
# --- Ciclo de Vida (Lifespan) ---
# ========================
@asynccontextmanager
async def lifespan(app: FastAPI):
    """
    Gerencia o ciclo de vida da aplica√ß√£o.

    Conecta ao MongoDB e cria √≠ndices no startup.
    Fecha a conex√£o com o MongoDB no shutdown.
    """
    logger.info("Iniciando ciclo de vida da aplica√ß√£o...")
    db_connection = await connect_to_mongo()

    if db_connection is None:
        logger.critical("Falha fatal ao conectar ao MongoDB na inicializa√ß√£o. App pode n√£o funcionar corretamente.")
        yield
        logger.info("Encerrando ciclo de vida (conex√£o DB falhou no in√≠cio).")
        return

    app.state.db = db_connection # Armazena a conex√£o no estado da app
    logger.info("Conectado ao MongoDB.")

    try:
        db_instance = app.state.db
        logger.info("Tentando criar/verificar √≠ndices...")
        await create_user_indexes(db_instance)
        await create_task_indexes(db_instance)
        logger.info("Cria√ß√£o/verifica√ß√£o de √≠ndices conclu√≠da.")
    except Exception as e:
        logger.error(f"Erro durante a cria√ß√£o de √≠ndices: {e}", exc_info=True)

    logger.info("Aplica√ß√£o iniciada e pronta.") # pragma: no cover
    yield # pragma: no cover

    # C√≥digo abaixo √© executado no shutdown da aplica√ß√£o
    logger.info("Iniciando processo de encerramento...")
    await close_mongo_connection()
    logger.info("Conex√£o com MongoDB fechada.")
    logger.info("Aplica√ß√£o encerrada.")

# ========================
# --- Inst√¢ncia FastAPI ---
# ========================
app = FastAPI(
    title=settings.PROJECT_NAME,
    description="API RESTful para gerenciamento de tarefas com prioridade inteligente.",
    version="0.1.0",
    contact={
        "name": "Eng. Soft. Cl√°udio",
        "url": "https://www.linkedin.com/in/claudiodelimatosta/",
        "email": "claudiodelimatosta@gmail.com",
    },
    license_info={
        "name": "MIT License",
        "url": "https://opensource.org/licenses/MIT",
    },
    lifespan=lifespan
)

# ========================
# --- Configura√ß√£o de Middlewares ---
# ========================
_setup_cors_middleware(app, settings)

# ========================
# --- Rotas (Routers) ---
# ========================
app.include_router(auth.router, prefix=settings.API_V1_STR + "/auth", tags=["Authentication"])
app.include_router(tasks.router, prefix=settings.API_V1_STR, tags=["Tasks"])

# ========================
# --- Endpoint Raiz ---
# ========================
@app.get("/", tags=["Root"])
async def read_root():
    """Endpoint raiz para verificar se a API est√° online."""
    return {"message": f"Bem-vindo √† {settings.PROJECT_NAME}!"}

# ========================
# --- Execu√ß√£o (Uvicorn) ---
# ========================
if __name__ == "__main__": # pragma: no cover
    import uvicorn # pragma: no cover
    logger.info("Iniciando servidor Uvicorn para desenvolvimento...") # pragma: no cover
    uvicorn.run( # pragma: no cover
        "main:app", # pragma: no cover
        host="0.0.0.0", # pragma: no cover
        port=8000, # pragma: no cover
        reload=True, # pragma: no cover
        log_level=settings.LOG_LEVEL.lower() # pragma: no cover
    )

================================================================================
Cap√≠tulo 11: app/models/task.py
================================================================================

# app/models/task.py
"""
Este m√≥dulo define os modelos Pydantic utilizados para representar Tarefas (Tasks)
na aplica√ß√£o. Inclui modelos para a cria√ß√£o, atualiza√ß√£o, e representa√ß√£o
de tarefas como armazenadas e retornadas pelo banco de dados, al√©m de
defini√ß√µes auxiliares como o status da tarefa.
"""

# ========================
# --- Importa√ß√µes ---
# ========================
import uuid
from datetime import date, datetime, timezone
from enum import Enum
from typing import List, Optional

from pydantic import BaseModel, Field, ConfigDict

# ========================
# --- Enumera√ß√µes de Status ---
# ========================
class TaskStatus(str, Enum):
    """Define os poss√≠veis status de uma tarefa."""
    PENDING = "pendente"        # Tarefa aguardando para ser iniciada.
    IN_PROGRESS = "em_progresso" # Tarefa atualmente em execu√ß√£o.
    COMPLETED = "conclu√≠da"     # Tarefa finalizada com sucesso.
    CANCELLED = "cancelada"     # Tarefa cancelada.

# ========================
# --- Modelos Pydantic de Tarefa ---
# ========================

# --- Modelo Base ---
class TaskBase(BaseModel):
    """
    Modelo base contendo os campos comuns e essenciais de uma tarefa.
    Serve como funda√ß√£o para outros modelos de tarefa mais espec√≠ficos.
    """
    title: str = Field(..., title="T√≠tulo da Tarefa", min_length=3, max_length=100)
    description: Optional[str] = Field(None, title="Descri√ß√£o Detalhada", max_length=500)
    importance: int = Field(..., ge=1, le=5, title="Import√¢ncia (1-5)")
    due_date: Optional[date] = Field(None, title="Data de Vencimento")
    status: TaskStatus = Field(default=TaskStatus.PENDING, title="Status da Tarefa")
    tags: Optional[List[str]] = Field(None, title="Etiquetas/Tags")
    project: Optional[str] = Field(None, title="Projeto Associado")

    model_config = {
        "json_schema_extra": {
            "examples": [
                {
                    "title": "Finalizar relat√≥rio mensal",
                    "description": "Compilar dados e escrever o relat√≥rio final.",
                    "importance": 4,
                    "due_date": "2024-08-15",
                    "status": "pendente",
                    "tags": ["relatorios", "financeiro"],
                    "project": "Relat√≥rios Q3"
                }
            ]
        }
    }

# --- Modelos para Opera√ß√µes ---
class TaskCreate(TaskBase):
    """
    Modelo utilizado para a cria√ß√£o de uma nova tarefa.
    Herda todos os campos de `TaskBase`.
    """
    pass

class TaskUpdate(BaseModel):
    """
    Modelo utilizado para atualizar uma tarefa existente.
    Todos os campos s√£o opcionais, permitindo atualiza√ß√µes parciais.
    """
    title: Optional[str] = Field(None, title="T√≠tulo da Tarefa", min_length=3, max_length=100)
    description: Optional[str] = Field(None, title="Descri√ß√£o Detalhada", max_length=500)
    importance: Optional[int] = Field(None, ge=1, le=5, title="Import√¢ncia (1-5)")
    due_date: Optional[date] = Field(None, title="Data de Vencimento")
    status: Optional[TaskStatus] = Field(None, title="Status da Tarefa")
    tags: Optional[List[str]] = Field(None, title="Etiquetas/Tags")
    project: Optional[str] = Field(None, title="Projeto Associado")
    priority_score: Optional[float] = Field(None, title="Pontua√ß√£o de Prioridade (Ajust√°vel)")

    model_config = {
         "json_schema_extra": {
            "examples": [
                {
                    "title": "Revisar relat√≥rio mensal v2",
                    "status": TaskStatus.IN_PROGRESS.value, # Usar .value para enum em exemplo
                    "importance": 5
                }
            ]
        }
    }

# --- Modelos para Representa√ß√£o no Banco de Dados e Respostas ---
class TaskInDBBase(TaskBase):
    """
    Modelo base para tarefas como s√£o armazenadas e recuperadas do banco de dados.
    Estende `TaskBase` adicionando campos gerenciados pelo sistema.
    """
    id: uuid.UUID = Field(..., title="ID √önico da Tarefa")
    owner_id: uuid.UUID = Field(..., title="ID do Propriet√°rio da Tarefa")
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc), title="Data de Cria√ß√£o")
    updated_at: Optional[datetime] = Field(None, title="Data da √öltima Atualiza√ß√£o")
    priority_score: Optional[float] = Field(None, title="Pontua√ß√£o de Prioridade Calculada")

    model_config = ConfigDict(from_attributes=True)

class Task(TaskInDBBase):
    """
    Modelo completo representando uma tarefa, incluindo todos os campos.
    Tipicamente usado para retornar dados de tarefas da API.
    """
    model_config = ConfigDict(
         from_attributes=True,
         json_schema_extra={
             "examples": [
                {
                    "id": "f47ac10b-58cc-4372-a567-0e02b2c3d479",
                    "owner_id": "a1b2c3d4-e5f6-7890-1234-567890abcdef",
                    "title": "Finalizar relat√≥rio mensal",
                    "description": "Compilar dados e escrever o relat√≥rio final.",
                    "importance": 4,
                    "due_date": "2024-08-15",
                    "status": "pendente", # TaskStatus.PENDING.value se fosse enviar para API como string
                    "tags": ["relatorios", "financeiro"],
                    "project": "Relat√≥rios Q3",
                    "created_at": "2024-07-28T10:00:00Z",
                    "updated_at": None,
                    "priority_score": 75.5 # Exemplo de score
                }
            ]
         }
     )

================================================================================
Cap√≠tulo 12: app/models/token.py
================================================================================

# app/models/token.py
"""
Este m√≥dulo define os modelos Pydantic relacionados √† autentica√ß√£o por token,
especificamente para a estrutura do token JWT retornado ao cliente e
para o payload contido dentro do token JWT.
"""

# ========================
# --- Importa√ß√µes ---
# ========================
import uuid
from typing import Optional

from pydantic import BaseModel, Field

# ========================
# --- Modelos Pydantic Token ---
# ========================
class Token(BaseModel):
    """
    Modelo de resposta para um token de acesso JWT.
    Este √© o formato retornado ao cliente ap√≥s uma autentica√ß√£o bem-sucedida.
    """
    access_token: str = Field(..., title="Token de Acesso JWT")
    token_type: str = Field(default="bearer", title="Tipo do Token")

class TokenPayload(BaseModel):
    """
    Modelo para os dados (payload/claims) contidos dentro de um token JWT.
    Representa as informa√ß√µes decodificadas do token.
    """
    sub: uuid.UUID = Field(..., title="ID do Usu√°rio (Subject)")
    username: str = Field(..., title="Nome de Usu√°rio")
    exp: Optional[int] = Field(None, title="Timestamp de Expira√ß√£o")

================================================================================
Cap√≠tulo 13: app/models/user.py
================================================================================

# app/models/user.py
"""
Este m√≥dulo define os modelos Pydantic para a entidade Usu√°rio (User).
Inclui modelos para cria√ß√£o, atualiza√ß√£o, e diferentes representa√ß√µes
de dados do usu√°rio, como a forma como s√£o armazenados no banco de dados
e como s√£o retornados nas respostas da API.
"""

# ========================
# --- Importa√ß√µes ---
# ========================
import uuid
from datetime import datetime, timezone
from typing import Optional

from pydantic import BaseModel, EmailStr, Field, ConfigDict

# ========================
# --- Modelos Pydantic de User ---
# ========================

# --- Modelo Base ---
class UserBase(BaseModel):
    """
    Modelo base contendo os atributos comuns a todas as varia√ß√µes de usu√°rio.
    Define os campos que podem ser esperados na maioria das representa√ß√µes de um usu√°rio.
    """
    email: EmailStr = Field(..., title="Endere√ßo de E-mail", description="Deve ser um e-mail v√°lido e √∫nico.")
    username: str = Field(
        ...,
        title="Nome de Usu√°rio",
        min_length=3,
        max_length=50,
        pattern="^[a-zA-Z0-9_]+$",
        description="Nome de usu√°rio √∫nico (letras, n√∫meros, underscore)."
    )
    full_name: Optional[str] = Field(None, title="Nome Completo", max_length=100)
    disabled: bool = Field(default=False, title="Status Desativado", description="Indica se o usu√°rio est√° desativado.")

# --- Modelo para Cria√ß√£o de Usu√°rio ---
class UserCreate(BaseModel):
    """
    Modelo para os dados necess√°rios ao criar um novo usu√°rio.
    Este √© o formato esperado no payload da API para registro de usu√°rios.
    """
    email: EmailStr = Field(..., title="Endere√ßo de E-mail")
    username: str = Field(..., title="Nome de Usu√°rio", min_length=3, max_length=50, pattern="^[a-zA-Z0-9_]+$")
    password: str = Field(..., title="Senha", min_length=8, description="Senha (ser√° hasheada antes de salvar).")
    full_name: Optional[str] = Field(None, title="Nome Completo", max_length=100)

    model_config = {
        "json_schema_extra": {
            "examples": [
                {
                    "email": "userTest@example.com",
                    "username": "userTest",
                    "password": "averysecurepassword",
                    "full_name": "User Test"
                }
            ]
        }
    }

# --- Modelo para Atualiza√ß√£o de Usu√°rio ---
class UserUpdate(BaseModel):
    """
    Modelo para os dados que podem ser atualizados em um usu√°rio existente.
    Todos os campos s√£o opcionais, permitindo atualiza√ß√µes parciais.
    """
    email: Optional[EmailStr] = Field(None, title="Endere√ßo de E-mail")
    password: Optional[str] = Field(None, title="Nova Senha", min_length=8, description="Nova senha (se fornecida).")
    full_name: Optional[str] = Field(None, title="Nome Completo", max_length=100)
    disabled: Optional[bool] = Field(None, title="Status Desativado")

    model_config = {
        "json_schema_extra": {
            "examples": [
                {
                    "full_name": "User Test Updated Name",
                    "email": "usertest.updated@example.com",
                    "disabled": False
                },
                {
                    "password": "mynewverysecurepassword123"
                }
            ]
        }
    }

# --- Modelos para Representa√ß√£o no Banco de Dados e Respostas da API ---
class UserInDBBase(UserBase):
    """
    Modelo base para usu√°rios como s√£o armazenados e recuperados do banco de dados.
    Inclui campos gerenciados pelo sistema como ID, senha hasheada e timestamps.
    """
    id: uuid.UUID = Field(..., title="ID √önico do Usu√°rio")
    hashed_password: str = Field(..., title="Senha Hasheada")
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc), title="Data de Cria√ß√£o")
    updated_at: Optional[datetime] = Field(None, title="Data da √öltima Atualiza√ß√£o")

    model_config = ConfigDict(from_attributes=True)

class User(UserBase):
    """
    Modelo de usu√°rio utilizado nas respostas da API.
    Projetado para expor dados seguros do usu√°rio, omitindo a senha hasheada.
    """
    id: uuid.UUID = Field(..., title="ID √önico do Usu√°rio")
    created_at: datetime
    updated_at: Optional[datetime] = None

    model_config = ConfigDict(from_attributes=True)

class UserInDB(UserInDBBase):
    """
    Representa√ß√£o completa de um usu√°rio como armazenado no banco de dados.
    Inclui todos os campos (inclusive senha hasheada) e √© usado internamente.
    """
    # Atualmente n√£o adiciona campos al√©m de UserInDBBase, mas serve para clareza.
    pass

================================================================================
Cap√≠tulo 14: app/routers/auth.py
================================================================================

# app/routers/auth.py
"""
Este m√≥dulo define as rotas da API relacionadas √† autentica√ß√£o de usu√°rios,
incluindo registro, login (obten√ß√£o de token JWT) e gerenciamento
de informa√ß√µes do usu√°rio autenticado (visualizar, atualizar, deletar).
"""

# ========================
# --- Importa√ß√µes ---
# ========================
from typing import Annotated

from fastapi import APIRouter, Body, Depends, HTTPException, Response, status
from fastapi.security import OAuth2PasswordRequestForm
from motor.motor_asyncio import AsyncIOMotorDatabase
from pymongo.errors import DuplicateKeyError

# --- M√≥dulos da Aplica√ß√£o ---
from app.core.dependencies import CurrentUser, DbDep 
from app.core.security import create_access_token, verify_password
from app.db import user_crud
from app.models.token import Token
from app.models.user import User, UserCreate, UserUpdate

# ========================
# --- Configura√ß√£o do Router ---
# ========================
router = APIRouter(
    tags=["Authentication"],
)

# ========================
# --- Rotas da API ---
# ========================

# --- Endpoint de Registro ---
@router.post(
    "/register",
    response_model=User,
    status_code=status.HTTP_201_CREATED,
    summary="Registra um novo usu√°rio no sistema",
    response_description="Dados do usu√°rio rec√©m-registrado (sem senha).",
)
async def register_user(
    db: DbDep,
    user_in: Annotated[UserCreate, Body(description="Dados do novo usu√°rio para registro.")]
):
    """
    Endpoint para registrar um novo usu√°rio.

    Verifica duplicidade de username e email.
    Cria o usu√°rio no banco, hasheando a senha.
    Retorna o usu√°rio criado (sem a senha).
    """
    existing_user_by_username = await user_crud.get_user_by_username(db, user_in.username)
    if existing_user_by_username:
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=f"O nome de usu√°rio '{user_in.username}' j√° existe.",
        )

    existing_user_by_email = await user_crud.get_user_by_email(db, user_in.email)
    if existing_user_by_email:
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=f"O endere√ßo de e-mail '{user_in.email}' j√° registrado.",
        )

    try:
        created_user_db_obj = await user_crud.create_user(db=db, user_in=user_in)
        if created_user_db_obj is None:
            # Este cen√°rio √© menos prov√°vel se as valida√ß√µes anteriores e create_user funcionam
            # como esperado, a menos que create_user retorne None por um motivo n√£o coberto
            # por DuplicateKeyError ou outra Exception espec√≠fica.
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="N√£o foi poss√≠vel criar o usu√°rio devido a um erro interno no servidor."
            )
        return User.model_validate(created_user_db_obj)
    except DuplicateKeyError: # pragma: no cover (Testado no CRUD, dif√≠cil simular aqui se as checagens pr√©vias funcionam)
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail="Conflito: nome de usu√°rio ou e-mail j√° existe (detectado pelo banco de dados).",
        )
    except Exception: # Para outros erros inesperados durante o user_crud.create_user
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Ocorreu um erro inesperado durante o processo de registro.",
        )

# --- Endpoint de Login ---
@router.post(
    "/login/access-token",
    response_model=Token,
    summary="Autentica o usu√°rio e obt√©m um token de acesso JWT",
    description="Endpoint de login padr√£o OAuth2PasswordRequestForm. Envie 'username' e 'password' como form data.",
    response_description="Token de acesso JWT e tipo do token ('bearer')."
)
async def login_for_access_token(
    db: DbDep,
    form_data: Annotated[OAuth2PasswordRequestForm, Depends()]
):
    """
    Autentica um usu√°rio e retorna um token de acesso.

    Verifica usu√°rio, senha e se a conta est√° ativa.
    Gera e retorna um token JWT em caso de sucesso.
    """
    user = await user_crud.get_user_by_username(db, form_data.username)

    if not user or not verify_password(form_data.password, user.hashed_password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Nome de usu√°rio ou senha incorretos.",
            headers={"WWW-Authenticate": "Bearer"},
        )

    if user.disabled:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="A conta do usu√°rio est√° inativa."
        )

    access_token = create_access_token(
        subject=user.id,
        username=user.username
    )
    return Token(access_token=access_token, token_type="bearer")

# --- Endpoint de Dados do Usu√°rio Autenticado ---
@router.get(
    "/users/me",
    response_model=User,
    summary="Obt√©m dados do usu√°rio atualmente autenticado",
    description="Retorna os dados do usu√°rio autenticado via token JWT.",
    response_description="Dados do usu√°rio autenticado (sem a senha)."
)
async def read_users_me(
    current_user: CurrentUser # CurrentUser j√° √© o UserInDB ativo
) -> User:
    """
    Retorna as informa√ß√µes do usu√°rio autenticado.
    A depend√™ncia `CurrentUser` lida com a valida√ß√£o e busca do usu√°rio.
    """
    # current_user j√° √© o objeto UserInDB validado e ativo.
    # O Pydantic cuidar√° da convers√£o para o response_model User.
    return current_user

# --- Endpoint de Atualiza√ß√£o do Usu√°rio Autenticado ---
@router.put(
    "/users/me",
    response_model=User,
    summary="Atualiza os dados do usu√°rio atualmente autenticado",
    description="Permite ao usu√°rio autenticado atualizar e-mail, nome completo ou senha.",
    response_description="Dados do usu√°rio atualizados (sem a senha)."
)
async def update_current_user(
    db: DbDep,
    user_update_payload: Annotated[UserUpdate, Body(description="Campos do usu√°rio a serem atualizados.")],
    current_user: CurrentUser
):
    """
    Permite ao usu√°rio autenticado atualizar suas pr√≥prias informa√ß√µes.
    """
    try:
        updated_user_db_obj = await user_crud.update_user(
            db=db,
            user_id=current_user.id,
            user_update=user_update_payload
        )

        if updated_user_db_obj is None:
            # O user_crud.update_user retorna None se n√£o encontra ou h√° erro de valida√ß√£o Pydantic ap√≥s update
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND, # Ou 500 se a causa for erro de valida√ß√£o
                detail="N√£o foi poss√≠vel atualizar o usu√°rio. Usu√°rio n√£o encontrado ou erro interno."
            )
        return User.model_validate(updated_user_db_obj)
    except DuplicateKeyError:
        email_em_uso = user_update_payload.email if user_update_payload.email else "N/A"
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=f"N√£o foi poss√≠vel atualizar: o e-mail '{email_em_uso}' j√° est√° em uso por outra conta.",
        )
    except Exception: # Para outros erros inesperados vindos do CRUD (que n√£o sejam DuplicateKeyError)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Ocorreu um erro inesperado durante a atualiza√ß√£o do usu√°rio.",
        )

# --- Endpoint de Dele√ß√£o do Usu√°rio Autenticado ---
@router.delete(
    "/users/me",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Deleta a conta do usu√°rio atualmente autenticado",
    description="Permite ao usu√°rio autenticado deletar sua pr√≥pria conta permanentemente.",
    response_description="Nenhum conte√∫do √© retornado em caso de sucesso."
)
async def delete_current_user(
    db: DbDep,
    current_user: CurrentUser
):
    """
    Permite ao usu√°rio autenticado deletar sua pr√≥pria conta.
    """
    try:
        deleted_successfully = await user_crud.delete_user(
            db=db,
            user_id=current_user.id
        )
        if not deleted_successfully:
            # Se delete_user retorna False, significa que n√£o encontrou o usu√°rio para deletar
            # (o que seria estranho aqui, j√° que current_user existe) ou falhou.
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, # HTTP_404_NOT_FOUND pode ser considerado.
                detail="N√£o foi poss√≠vel deletar o usu√°rio. Erro interno ou usu√°rio n√£o encontrado."
            )
        return Response(status_code=status.HTTP_204_NO_CONTENT) # Resposta HTTP 204

    except Exception: # Para outros erros inesperados vindos do CRUD
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Ocorreu um erro inesperado durante a dele√ß√£o do usu√°rio.",
        )

================================================================================
Cap√≠tulo 15: app/routers/tasks.py
================================================================================

# app/routers/tasks.py
"""
Este m√≥dulo define as rotas da API para o gerenciamento de Tarefas (Tasks).
Inclui opera√ß√µes CRUD (Criar, Ler, Atualizar, Deletar) para tarefas,
al√©m de listagem com filtros, ordena√ß√£o e pagina√ß√£o.
As rotas s√£o protegidas e associadas ao usu√°rio autenticado.
Utiliza BackgroundTasks para opera√ß√µes que n√£o precisam bloquear a resposta,
como o envio de webhooks e notifica√ß√µes por e-mail.
"""

# ========================
# --- Importa√ß√µes ---
# ========================
import logging
import uuid
from datetime import date, datetime, timezone
from typing import Annotated, List, Optional

from fastapi import (APIRouter, BackgroundTasks, Body, Depends, HTTPException, Path,
                   Query, Response, status)
from motor.motor_asyncio import AsyncIOMotorDatabase
from pydantic import ValidationError

# --- M√≥dulos da Aplica√ß√£o ---
from app.core.dependencies import CurrentUser, DbDep
from app.core.email import send_urgent_task_notification
from app.core.utils import (calculate_priority_score, is_task_urgent,
                            send_webhook_notification)
from app.db import task_crud
from app.models.task import Task, TaskCreate, TaskStatus, TaskUpdate
from app.core.config import settings

# ========================
# --- Configura√ß√µes e Constantes ---
# ========================
logger = logging.getLogger(__name__)

# ========================
# --- Configura√ß√£o do Router ---
# ========================
router = APIRouter(
    prefix="/tasks",
    tags=["Tasks"],
    responses={
        status.HTTP_404_NOT_FOUND: {"description": "Recurso (tarefa) n√£o encontrado."},
        status.HTTP_401_UNAUTHORIZED: {"description": "N√£o autorizado (Token JWT inv√°lido, ausente ou expirado)."},
        status.HTTP_403_FORBIDDEN: {"description": "Proibido (Usu√°rio autenticado n√£o tem permiss√£o para acessar/modificar este recurso espec√≠fico)."}
    },
)

# ========================
# --- Endpoint: Criar Tarefa ---
# ========================
@router.post(
    "/",
    response_model=Task,
    status_code=status.HTTP_201_CREATED,
    summary="Cria uma nova tarefa para o usu√°rio autenticado",
    description=(
        "Cria uma nova tarefa associada ao usu√°rio atualmente autenticado. "
        "A pontua√ß√£o de prioridade √© calculada automaticamente com base na import√¢ncia e data de entrega. "
        "O ID do propriet√°rio (`owner_id`) e os timestamps (`created_at`) s√£o definidos pelo servidor."
    ),
    response_description="A tarefa rec√©m-criada, incluindo todos os seus detalhes e campos gerados.",
)
async def create_task(
    task_in: Annotated[TaskCreate, Body(description="Dados da nova tarefa a ser criada.")],
    db: DbDep,
    current_user: CurrentUser,
    background_tasks: BackgroundTasks
):
    """
    Endpoint para criar uma nova tarefa.

    Fluxo de execu√ß√£o:
    1. Extrai os dados da tarefa do corpo da requisi√ß√£o (`task_in`).
    2. Calcula a `priority_score` com base na import√¢ncia e data de entrega.
    3. Constr√≥i o objeto completo da tarefa (`Task`), incluindo ID, `owner_id` (do `current_user`),
       `created_at` e a `priority_score` calculada. Valida este objeto com Pydantic.
    4. Persiste a tarefa no banco de dados usando `task_crud.create_task`.
    5. Se a cria√ß√£o for bem-sucedida, agenda tarefas em segundo plano para:
        - Enviar uma notifica√ß√£o de webhook (evento `task.created`).
        - Se a tarefa for urgente, enviar uma notifica√ß√£o por e-mail para o usu√°rio.
    6. Retorna a tarefa criada.

    Levanta `HTTPException` em caso de erro de valida√ß√£o, falha na persist√™ncia ou outros problemas.
    """
    task_data_from_request = task_in.model_dump(exclude_unset=True)

    priority_score_calculated = calculate_priority_score(
        importance=task_in.importance,
        due_date=task_in.due_date
    )
    logger.info(f"Prioridade calculada para nova tarefa (T√≠tulo: '{task_in.title}'): {priority_score_calculated}")

    try:
        task_db_obj_to_create = Task(
            id=uuid.uuid4(),
            owner_id=current_user.id,
            created_at=datetime.now(timezone.utc),
            priority_score=priority_score_calculated,
            **task_data_from_request
        )
    except ValidationError as e:
        logger.error(f"Erro de valida√ß√£o Pydantic ao montar objeto Task para usu√°rio {current_user.id}: {e}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=f"Erro interno na valida√ß√£o dos dados da tarefa: {e.errors()}"
        )

    created_task_from_db = await task_crud.create_task(db=db, task_db=task_db_obj_to_create)
    if created_task_from_db is None: # pragma: no cover
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Falha ao salvar a tarefa no banco de dados."
        )
    logger.info(f"Tarefa {created_task_from_db.id} criada com sucesso para usu√°rio {current_user.id}.")

    task_dict_for_webhook = created_task_from_db.model_dump(mode="json")
    background_tasks.add_task(
         send_webhook_notification,
         event_type="task.created",
         task_data=task_dict_for_webhook
    )
    logger.debug(f"Tarefa de webhook 'task.created' para {created_task_from_db.id} adicionada ao background.")

    if is_task_urgent(created_task_from_db):
        if current_user.email and current_user.full_name:
            logger.info(f"Tarefa {created_task_from_db.id} √© urgente. Agendando e-mail de notifica√ß√£o para {current_user.email}.")
            background_tasks.add_task(
                send_urgent_task_notification,
                user_email=current_user.email,
                user_name=current_user.full_name,
                task_title=created_task_from_db.title,
                task_id=str(created_task_from_db.id),
                task_due_date=str(created_task_from_db.due_date) if created_task_from_db.due_date else None,
                priority_score=created_task_from_db.priority_score or 0.0
            )
        else:
             logger.warning(f"Usu√°rio {current_user.id} (username: {current_user.username}) n√£o possui e-mail ou nome completo configurado. "
                            f"Notifica√ß√£o por e-mail para tarefa urgente {created_task_from_db.id} n√£o ser√° enviada.")

    return created_task_from_db

# ========================
# --- Endpoint: Listar Tarefas ---
# ========================
@router.get(
    "/",
    response_model=List[Task],
    summary="Lista as tarefas do usu√°rio autenticado com filtros e ordena√ß√£o",
    description=(
        "Recupera uma lista de tarefas pertencentes exclusivamente ao usu√°rio autenticado.\n"
        "Suporta m√∫ltiplos filtros combinados (status, data de entrega at√©, projeto, tags).\n"
        "Permite ordena√ß√£o por: `priority_score`, `due_date`, `created_at`, `importance`.\n"
        "A pagina√ß√£o √© controlada por `limit` e `skip`."
    ),
    response_description="Uma lista (potencialmente vazia) das tarefas do usu√°rio, filtradas e ordenadas conforme os par√¢metros.",
)
async def list_tasks(
    db: DbDep,
    current_user: CurrentUser,
    status_filter: Annotated[Optional[TaskStatus], Query(alias="status", description="Filtrar tarefas por status espec√≠fico.")] = None,
    due_before: Annotated[Optional[date], Query(description="Filtrar tarefas com data de entrega at√© (inclusive) esta data.")] = None,
    project_filter: Annotated[Optional[str], Query(alias="project", min_length=1, description="Filtrar tarefas por nome exato do projeto.")] = None,
    tags_filter: Annotated[Optional[List[str]], Query(alias="tag", min_length=1, description="Filtrar tarefas que contenham TODAS as tags fornecidas.")] = None,
    sort_by: Annotated[Optional[str], Query(enum=["priority_score", "due_date", "created_at", "importance"], description="Campo para ordena√ß√£o das tarefas.")] = None,
    sort_order: Annotated[str, Query(enum=["asc", "desc"], description="Ordem da ordena√ß√£o (ascendente ou descendente).")] = "desc",
    limit: Annotated[int, Query(ge=1, le=1000, description="N√∫mero m√°ximo de tarefas a retornar.")] = 100,
    skip: Annotated[int, Query(ge=0, description="N√∫mero de tarefas a pular (para pagina√ß√£o).")] = 0,
):
    """
    Endpoint para listar tarefas do usu√°rio autenticado.

    A busca √© delegada para a fun√ß√£o `task_crud.get_tasks_by_owner`, que lida com a
    constru√ß√£o da query no banco de dados com base nos filtros, ordena√ß√£o e pagina√ß√£o fornecidos.
    Todos os filtros e par√¢metros s√£o opcionais.
    """
    logger.info(f"Listando tarefas para usu√°rio {current_user.id} com filtros: status='{status_filter}', "
                f"due_before='{due_before}', project='{project_filter}', tags='{tags_filter}', "
                f"sort_by='{sort_by}', sort_order='{sort_order}', limit={limit}, skip={skip}")

    tasks = await task_crud.get_tasks_by_owner(
        db=db,
        owner_id=current_user.id,
        status_filter=status_filter,
        due_before=due_before,
        project_filter=project_filter,
        tags_filter=tags_filter,
        sort_by=sort_by,
        sort_order=sort_order,
        limit=limit,
        skip=skip
    )
    logger.debug(f"Encontradas {len(tasks)} tarefas para usu√°rio {current_user.id} com os filtros aplicados.")
    return tasks

# ========================
# --- Endpoint: Obter Tarefa Espec√≠fica ---
# ========================
@router.get(
    "/{task_id}",
    response_model=Task,
    summary="Busca uma tarefa espec√≠fica pelo seu ID",
    description="Recupera os detalhes completos de uma tarefa espec√≠fica, desde que ela perten√ßa ao usu√°rio autenticado.",
    response_description="Os detalhes completos da tarefa encontrada.",
    responses={status.HTTP_403_FORBIDDEN: {"description": "Acesso negado: esta tarefa n√£o pertence a voc√™ ou n√£o existe para voc√™."}}
)
async def get_task(
    task_id: Annotated[uuid.UUID, Path(description="ID da tarefa a ser recuperada.")],
    db: DbDep,
    current_user: CurrentUser
):
    """
    Endpoint para buscar uma √∫nica tarefa pelo seu ID (UUID).

    A fun√ß√£o `task_crud.get_task_by_id` √© respons√°vel por verificar se a tarefa
    com o `task_id` fornecido pertence ao `current_user.id`.
    Se a tarefa n√£o for encontrada ou n√£o pertencer ao usu√°rio, retorna HTTP 404.
    """
    logger.info(f"Buscando tarefa {task_id} para usu√°rio {current_user.id}.")
    task = await task_crud.get_task_by_id(db=db, task_id=task_id, owner_id=current_user.id)

    if task is None:
        logger.warning(f"Tarefa {task_id} n√£o encontrada ou acesso negado para usu√°rio {current_user.id}.")
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Tarefa com ID '{task_id}' n√£o encontrada ou voc√™ n√£o tem permiss√£o para acess√°-la."
        )
    logger.debug(f"Tarefa {task_id} encontrada para usu√°rio {current_user.id}: {task.title}")
    return task

# ========================
# --- Endpoint: Atualizar Tarefa ---
# ========================
@router.put(
    "/{task_id}",
    response_model=Task,
    summary="Atualiza uma tarefa existente do usu√°rio autenticado",
    description=(
        "Atualiza campos de uma tarefa existente, desde que ela perten√ßa ao usu√°rio autenticado.\n"
        "A pontua√ß√£o de prioridade (`priority_score`) √© recalculada automaticamente se `importance` ou `due_date` forem modificados.\n"
        "O campo `updated_at` √© atualizado automaticamente."
    ),
    response_description="Os detalhes completos da tarefa ap√≥s a atualiza√ß√£o.",
    responses={status.HTTP_403_FORBIDDEN: {"description": "Acesso negado: esta tarefa n√£o pertence a voc√™."}}
)
async def update_task(
    task_id: Annotated[uuid.UUID, Path(description="ID da tarefa a ser atualizada.")],
    task_update_payload: Annotated[TaskUpdate, Body(description="Campos da tarefa a serem atualizados.")],
    db: DbDep,
    current_user: CurrentUser,
    background_tasks: BackgroundTasks
):
    """
    Endpoint para atualizar campos espec√≠ficos de uma tarefa existente.

    Fluxo de execu√ß√£o:
    1. Busca a tarefa existente para garantir que ela pertence ao usu√°rio e para obter valores atuais.
    2. Recebe os dados de atualiza√ß√£o validados pelo modelo `TaskUpdate`.
    3. Se nenhum dado for fornecido para atualiza√ß√£o, retorna um erro HTTP 400.
    4. Prepara o dicion√°rio `update_data_for_db` apenas com os campos enviados.
    5. Verifica se `importance` ou `due_date` foram alterados para recalcular `priority_score`.
    6. Chama `task_crud.update_task` para persistir as altera√ß√µes.
    7. Agenda notifica√ß√£o de webhook para `task.updated`.
    8. Retorna a tarefa atualizada.
    """
    logger.info(f"Iniciando atualiza√ß√£o da tarefa {task_id} para usu√°rio {current_user.id} com payload: {task_update_payload.model_dump(exclude_unset=True)}")
    existing_task = await task_crud.get_task_by_id(db=db, task_id=task_id, owner_id=current_user.id)
    if not existing_task:
        logger.warning(f"Tentativa de atualizar tarefa {task_id} que n√£o foi encontrada para usu√°rio {current_user.id}.")
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Tarefa com ID '{task_id}' n√£o encontrada ou voc√™ n√£o tem permiss√£o para modific√°-la."
        )

    update_data_from_request = task_update_payload.model_dump(exclude_unset=True)

    if not update_data_from_request:
        logger.info(f"Nenhum campo fornecido para atualiza√ß√£o da tarefa {task_id}.")
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Nenhum campo v√°lido fornecido para atualiza√ß√£o."
        )

    new_importance = update_data_from_request.get("importance", existing_task.importance)
    if "due_date" in update_data_from_request:
        new_due_date = update_data_from_request.get("due_date")
    else:
        new_due_date = existing_task.due_date

    should_recalculate_priority = False
    if "importance" in update_data_from_request and update_data_from_request["importance"] != existing_task.importance:
        should_recalculate_priority = True
    if "due_date" in update_data_from_request and new_due_date != existing_task.due_date:
        should_recalculate_priority = True
    if "priority_score" in update_data_from_request: # pragma: no cover
        should_recalculate_priority = False

    update_data_for_db = update_data_from_request.copy()

    if should_recalculate_priority:
        new_priority_score = calculate_priority_score(
            importance=new_importance,
            due_date=new_due_date
        )
        update_data_for_db["priority_score"] = new_priority_score
        logger.info(f"Prioridade para tarefa {task_id} recalculada para: {new_priority_score}.")

    updated_task_from_db = await task_crud.update_task(
        db=db,
        task_id=task_id,
        owner_id=current_user.id,
        update_data=update_data_for_db
    )

    if updated_task_from_db is None:
        logger.error(f"Falha ao atualizar tarefa {task_id} no DB para usu√°rio {current_user.id}. CRUD retornou None.")
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"N√£o foi poss√≠vel atualizar a tarefa com ID '{task_id}'. " # String de detalhe original
                   "Pode ter sido deletada ou ocorreu um erro interno." # Mantido para consist√™ncia com teste.
        )
    logger.info(f"Tarefa {updated_task_from_db.id} atualizada com sucesso para usu√°rio {current_user.id}.")

    task_dict_for_webhook = updated_task_from_db.model_dump(mode="json")
    background_tasks.add_task(
        send_webhook_notification,
        event_type="task.updated",
        task_data=task_dict_for_webhook
    )
    logger.debug(f"Tarefa de webhook 'task.updated' para {updated_task_from_db.id} adicionada ao background.")

    return updated_task_from_db

# ========================
# --- Endpoint: Deletar Tarefa ---
# ========================
@router.delete(
    "/{task_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Deleta uma tarefa do usu√°rio autenticado",
    description="Remove permanentemente uma tarefa espec√≠fica do banco de dados, desde que ela perten√ßa ao usu√°rio autenticado.",
    responses={
        status.HTTP_204_NO_CONTENT: {"description": "Tarefa deletada com sucesso (sem corpo de resposta)."}
    }
)
async def delete_task(
    task_id: Annotated[uuid.UUID, Path(description="ID da tarefa a ser deletada.")],
    db: DbDep,
    current_user: CurrentUser
):
    """
    Endpoint para deletar uma tarefa espec√≠fica.

    Verifica se a tarefa pertence ao usu√°rio autenticado e, se sim, a remove
    permanentemente do banco de dados usando `task_crud.delete_task`.
    Retorna HTTP 204 (No Content) em caso de sucesso.

    Levanta `HTTPException` com status 404 se a tarefa n√£o for encontrada ou
    n√£o pertencer ao usu√°rio.
    """
    logger.info(f"Iniciando dele√ß√£o da tarefa {task_id} para usu√°rio {current_user.id}.")
    deleted_successfully = await task_crud.delete_task(
        db=db,
        task_id=task_id,
        owner_id=current_user.id
    )

    if not deleted_successfully:
        logger.warning(f"Falha ao deletar tarefa {task_id}. N√£o encontrada ou n√£o pertence ao usu√°rio {current_user.id}.")
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Tarefa com ID '{task_id}' n√£o encontrada ou voc√™ n√£o tem permiss√£o para delet√°-la."
        )

    logger.info(f"Tarefa {task_id} deletada com sucesso para usu√°rio {current_user.id}.")
    return Response(status_code=status.HTTP_204_NO_CONTENT)

================================================================================
Cap√≠tulo 16: app/worker.py
================================================================================

# app/worker.py
"""
Este m√≥dulo define um worker ARQ (Asynchronous Runtimes for Queueing) para executar
tarefas em segundo plano e agendadas.

Ele inclui:
- Uma tarefa peri√≥dica (`check_and_notify_urgent_tasks`) para verificar tarefas
  que se tornaram urgentes e notificar os usu√°rios correspondentes por e-mail.
- Fun√ß√µes de ciclo de vida (`startup` e `shutdown`) para gerenciar a conex√£o
  com o banco de dados MongoDB para o worker.
- A classe `WorkerSettings` que configura o comportamento do worker ARQ, incluindo
  os `cron_jobs` e as configura√ß√µes de conex√£o com o Redis (usado pelo ARQ como broker).
"""

# ========================
# --- Importa√ß√µes ---
# ========================

# --- Bibliotecas Padr√£o/Terceiros ---
import asyncio
import logging
from datetime import date, datetime, timezone 
from typing import Any, Dict, Optional

import arq.cron
from arq.connections import RedisSettings
from motor.motor_asyncio import AsyncIOMotorDatabase

# --- M√≥dulos da Aplica√ß√£o ---
from app.core.config import settings
from app.core.email import send_urgent_task_notification
from app.db import task_crud, user_crud
from app.db.mongodb_utils import (close_mongo_connection, connect_to_mongo) 
from app.models.task import Task, TaskStatus 

# =====================================
# --- Configura√ß√µes e Constantes ---
# =====================================
logger = logging.getLogger("arq.worker") 

# ==================================
# --- Fun√ß√£o de Tarefa Peri√≥dica ---
# ==================================
async def check_and_notify_urgent_tasks(ctx: Dict[str, Any]):
    """
    Tarefa peri√≥dica ARQ que varre o banco de dados em busca de tarefas
    consideradas urgentes e notifica os respectivos usu√°rios por e-mail.

    Crit√©rios de Urg√™ncia:
    - Tarefas n√£o conclu√≠das ou canceladas.
    - E que atendam a pelo menos um dos seguintes:
        - `priority_score` acima de um limiar definido (`EMAIL_URGENCY_THRESHOLD`).
        - `due_date` √© hoje ou j√° passou.

    Args:
        ctx: Dicion√°rio de contexto fornecido pelo worker ARQ. Espera-se que contenha
             uma inst√¢ncia de conex√£o com o banco de dados (`db`) injetada pela fun√ß√£o `startup`.
    """
    logger.info("Executando job: Verifica√ß√£o e notifica√ß√£o de tarefas urgentes...")
    db: Optional[AsyncIOMotorDatabase] = ctx.get("db")

    if db is None:
        logger.error("Conex√£o com o banco de dados n√£o dispon√≠vel no contexto ARQ.")
        return
    tasks_collection = db[task_crud.TASKS_COLLECTION]
    users_collection = db[user_crud.USERS_COLLECTION] 
    today_start_utc = datetime.combine(date.today(), datetime.min.time(), tzinfo=timezone.utc)
    query_urgent_tasks = {
        "status": {"$nin": [TaskStatus.COMPLETED.value, TaskStatus.CANCELLED.value]},
        "$or": [
            {"priority_score": {"$gt": settings.EMAIL_URGENCY_THRESHOLD}},
            {"due_date": {"$lte": today_start_utc}} 
        ]
    }
    logger.debug(f"Query MongoDB para tarefas urgentes: {query_urgent_tasks}")

    urgent_tasks_cursor = tasks_collection.find(query_urgent_tasks)
    notifications_sent_count = 0
    async for task_dict in urgent_tasks_cursor:
        task_dict.pop('_id', None) 
        try:
            task = Task.model_validate(task_dict)
            logger.debug(f"Processando tarefa urgente ID: {task.id}, T√≠tulo: {task.title}")
            user = await user_crud.get_user_by_id(db, task.owner_id)
            if user and user.email and user.full_name and not user.disabled:
                logger.info(f"Tarefa urgente ID '{task.id}' (T√≠tulo: '{task.title}') encontrada. "
                            f"Notificando usu√°rio: {user.username} (E-mail: {user.email}).")
                await send_urgent_task_notification(
                    user_email=user.email,
                    user_name=user.full_name,
                    task_title=task.title,
                    task_id=str(task.id),
                    task_due_date=str(task.due_date) if task.due_date else None, 
                    priority_score=task.priority_score or 0.0 
                )
                notifications_sent_count += 1
            elif not user:
                logger.warning(f"Usu√°rio com ID '{task.owner_id}' associado √† tarefa urgente '{task.id}' n√£o foi encontrado no banco de dados.")
            elif user and user.disabled:
                logger.info(f"Usu√°rio '{user.username}' (ID: {task.owner_id}) associado √† tarefa urgente '{task.id}' est√° desabilitado. "
                            "Notifica√ß√£o n√£o enviada.")
            else:
                logger.warning(f"Usu√°rio '{user.username}' (ID: {task.owner_id}) associado √† tarefa urgente '{task.id}' "
                               "n√£o possui e-mail ou nome completo configurado. Notifica√ß√£o n√£o enviada.")
        except Exception as e:
            logger.exception(f"Erro ao processar tarefa urgente (ID no dict: {task_dict.get('id', 'N/A')}): {e}")
            continue 
    logger.info(f"Verifica√ß√£o de tarefas urgentes conclu√≠da. Total de {notifications_sent_count} notifica√ß√µes enviadas.")

# ==========================================
# --- Fun√ß√µes de Ciclo de Vida do Worker ---
# ==========================================
async def startup(ctx: Dict[str, Any]):
    """
    Fun√ß√£o executada quando o worker ARQ √© iniciado.
    Respons√°vel por estabelecer conex√µes com recursos externos, como o banco de dados.

    Args:
        ctx: Dicion√°rio de contexto do ARQ, onde podemos armazenar recursos
             (como a conex√£o DB) para serem usados pelas tarefas do worker.
    """
    logger.info("Worker ARQ: Iniciando rotinas de startup...")
    db_connection_instance = await connect_to_mongo()
    if db_connection_instance is not None:
        ctx["db"] = db_connection_instance
        logger.info("Worker ARQ: Conex√£o com MongoDB estabelecida e armazenada no contexto.")
    else:
        logger.error("Worker ARQ: Falha cr√≠tica ao conectar ao MongoDB durante o startup. "
                     "A conex√£o n√£o estar√° dispon√≠vel para as tarefas.")
        ctx["db"] = None

async def shutdown(ctx: Dict[str, Any]):
    """
    Fun√ß√£o executada quando o worker ARQ est√° sendo encerrado.
    Respons√°vel por liberar recursos, como fechar a conex√£o com o banco de dados.

    Args:
        ctx: Dicion√°rio de contexto do ARQ.
    """
    logger.info("Worker ARQ: Iniciando rotinas de shutdown...")
    if ctx.get("db") is not None: 
        await close_mongo_connection()
        logger.info("Worker ARQ: Conex√£o com MongoDB fechada.")
    else:
        logger.info("Worker ARQ: Nenhuma conex√£o com MongoDB para fechar (n√£o estava dispon√≠vel ou j√° fechada).")

# =======================================
# --- Configura√ß√µes do Worker ARQ ---
# =======================================
class WorkerSettings:
    """
    Define as configura√ß√µes para o worker ARQ.
    Isso inclui fun√ß√µes de ciclo de vida (startup/shutdown),
    tarefas agendadas (`cron_jobs`) e configura√ß√µes de conex√£o com o Redis.
    """
    on_startup = startup
    on_shutdown = shutdown
    cron_jobs = [
        arq.cron(check_and_notify_urgent_tasks, minute={*range(0, 60, 15)}, run_at_startup=False), 
        arq.cron(check_and_notify_urgent_tasks, hour=8, minute=0, run_at_startup=False) 
    ]
    logger.info(f"Cron jobs configurados: {len(cron_jobs)} jobs definidos.")
    if settings.REDIS_URL:
        try:
            host = settings.REDIS_URL.host or 'localhost'
            port = int(settings.REDIS_URL.port) if settings.REDIS_URL.port else 6379
            db_num_from_path = int(settings.REDIS_URL.path.strip('/')) if settings.REDIS_URL.path and settings.REDIS_URL.path != '/' else 0
            password = settings.REDIS_URL.password

            redis_settings: RedisSettings = RedisSettings(
                host=host,
                port=port,
                database=db_num_from_path,
                password=password,
            )
            logger.info(f"RedisSettings configuradas para ARQ: host={host}, port={port}, db={db_num_from_path}")
        except Exception as e:# pragma: no cover
            logger.exception(f"Erro cr√≠tico ao configurar RedisSettings a partir da URL: '{settings.REDIS_URL}'. Erro: {e}")
            raise ValueError(f"Erro ao processar REDIS_URL para ARQ: {e}")# pragma: no cover
    else:
        logger.error("Configura√ß√£o cr√≠tica ausente: REDIS_URL n√£o est√° definida. Worker ARQ n√£o pode iniciar.")
        raise ValueError("REDIS_URL n√£o est√° definida nas configura√ß√µes. O worker ARQ requer uma URL do Redis para operar.")

================================================================================
Cap√≠tulo 17: tests/conftest.py
================================================================================

# tests/conftest.py
# Inibir warnings de deprecia√ß√£o de bibliotecas
import warnings
warnings.filterwarnings("ignore", category=DeprecationWarning, module="passlib")

"""
Este m√≥dulo define fixtures do Pytest que s√£o compartilhadas entre diferentes
arquivos de teste na su√≠te de testes da aplica√ß√£o SmartTask.

Fixtures incluem:
- Cliente HTTP ass√≠ncrono (`test_async_client`) para interagir com a API FastAPI.
  Este cliente tamb√©m gerencia a conex√£o com o banco de dados de teste e realiza
  a limpeza das cole√ß√µes antes e depois de cada teste.
- Dados de teste para usu√°rios (User A e User B).
- Fixtures para registrar/logar usu√°rios de teste e obter seus tokens/IDs.
- Fixtures para gerar cabe√ßalhos de autentica√ß√£o.
- Fixtures para criar dados de exemplo (como tarefas) para testes espec√≠ficos
  de listagem, filtragem e ordena√ß√£o.

O objetivo √© prover um ambiente de teste limpo e consistente para cada caso de teste.
"""

# ========================
# --- Importa√ß√µes ---
# ========================
import asyncio
import logging
import uuid
from typing import AsyncGenerator, Dict, List, Any, Optional

import pytest
import pytest_asyncio
from fastapi import status
from httpx import ASGITransport, AsyncClient
from motor.motor_asyncio import AsyncIOMotorDatabase

# --- M√≥dulos da Aplica√ß√£o ---
from app.core.config import settings
from app.db.mongodb_utils import (close_mongo_connection, connect_to_mongo, get_database)
from app.db.task_crud import TASKS_COLLECTION
from app.db.user_crud import USERS_COLLECTION
from app.main import app as fastapi_app
from app.models.task import TaskStatus

# ========================
# --- Configura√ß√µes e Constantes ---
# ========================
logger = logging.getLogger(__name__)

# ========================
# --- Fixture Principal: Cliente de Teste HTTP ---
# ========================
@pytest_asyncio.fixture(scope="function")
async def test_async_client() -> AsyncGenerator[AsyncClient, None]:
    """
    Fixture ass√≠ncrona com escopo de fun√ß√£o para prover um cliente HTTP (`AsyncClient`)
    para interagir com a aplica√ß√£o FastAPI.

    Responsabilidades:
    - Estabelece e fecha a conex√£o com o MongoDB de teste.
    - **Limpa as cole√ß√µes `USERS_COLLECTION` e `TASKS_COLLECTION` antes e depois de cada teste**
      para garantir a isola√ß√£o e idempot√™ncia dos testes.
    - Emite um aviso se o nome do banco de dados n√£o contiver "test", como precau√ß√£o.
    - Fornece o `AsyncClient` configurado com `ASGITransport` para testar a aplica√ß√£o
      diretamente, sem passar por uma camada de rede real.

    Yields:
        AsyncClient: Uma inst√¢ncia do cliente HTTP ass√≠ncrona.

    Raises:
        pytest.fail: Se a conex√£o com o MongoDB falhar durante o setup.
    """
    db_instance: Optional[AsyncIOMotorDatabase] = None
    logger.debug("Fixture 'test_async_client': Iniciando setup...")

    try:
        await connect_to_mongo()
        db_instance = get_database()

        if db_instance is not None:
            if "test" not in settings.DATABASE_NAME.lower(): 
                logger.warning(
                    f"ATEN√á√ÉO: Testes est√£o sendo executados no banco de dados '{settings.DATABASE_NAME}'. "
                    "As cole√ß√µes de usu√°rios e tarefas ser√£o limpas!"
                )

            logger.debug(f"Fixture 'test_async_client': Limpando cole√ß√µes ANTES do teste no DB '{settings.DATABASE_NAME}'...")
            await db_instance[USERS_COLLECTION].delete_many({})
            await db_instance[TASKS_COLLECTION].delete_many({})
            logger.info(f"Fixture 'test_async_client': Cole√ß√µes '{USERS_COLLECTION}' e '{TASKS_COLLECTION}' limpas ANTES do teste.")
        else: 
            logger.error("Fixture 'test_async_client': Falha cr√≠tica ao conectar ao MongoDB durante o setup.")
            pytest.fail("Falha ao obter inst√¢ncia do banco de dados na fixture test_async_client (setup).")

        transport = ASGITransport(app=fastapi_app) 
        async with AsyncClient(transport=transport, base_url="http://testserver") as client:
            logger.debug("Fixture 'test_async_client': Cliente HTTP fornecido ao teste.")
            yield client

    finally:
        logger.debug("Fixture 'test_async_client': Iniciando limpeza P√ìS-teste...")
        if db_instance is not None:
            try:
                logger.debug(f"Fixture 'test_async_client': Limpando cole√ß√µes AP√ìS o teste no DB '{settings.DATABASE_NAME}'...")
                await db_instance[USERS_COLLECTION].delete_many({})
                await db_instance[TASKS_COLLECTION].delete_many({})
                logger.info(f"Fixture 'test_async_client': Cole√ß√µes '{USERS_COLLECTION}' e '{TASKS_COLLECTION}' limpas AP√ìS o teste.")
            except Exception as e_cleanup: 
                logger.error(f"Fixture 'test_async_client': Erro durante a limpeza do DB P√ìS-teste: {e_cleanup}", exc_info=True)
        else: 
            logger.warning("Fixture 'test_async_client': Limpeza P√ìS-teste pulada - conex√£o com DB n√£o estabelecida.")

        logger.debug("Fixture 'test_async_client': Fechando conex√£o MongoDB principal (se houver)...")
        await close_mongo_connection()
        logger.debug("Fixture 'test_async_client': Setup e teardown conclu√≠dos.")

# ========================
# --- Fixtures para Usu√°rio de Teste A ---
# ========================
user_a_data: Dict[str, str] = {
    "email": "testuserA@example.com",
    "username": "testuserA",
    "password": "passwordA",
    "full_name": "Test User A"
}

@pytest_asyncio.fixture(scope="function")
async def test_user_a_token_and_id(test_async_client: AsyncClient) -> tuple[str, uuid.UUID]:
    """
    Fixture para registrar e logar o Usu√°rio A.

    Esta fixture garante que o Usu√°rio A exista no banco de dados de teste.
    Em seguida, realiza o login para obter um token de acesso e o ID do usu√°rio.

    Depende de:
        - `test_async_client`: Para fazer requisi√ß√µes HTTP √† API.

    Returns:
        tuple[str, uuid.UUID]: Uma tupla contendo (access_token, user_id) para o Usu√°rio A.
    """
    logger.debug("Fixture 'test_user_a_token_and_id': Configurando Usu√°rio A...")
    register_url = f"{settings.API_V1_STR}/auth/register"
    login_url = f"{settings.API_V1_STR}/auth/login/access-token"
    users_me_url = f"{settings.API_V1_STR}/auth/users/me"

    reg_response = await test_async_client.post(register_url, json=user_a_data)
    if reg_response.status_code == status.HTTP_201_CREATED:
        logger.info(f"Usu√°rio A ('{user_a_data['username']}') registrado com sucesso para o teste.")
    elif reg_response.status_code == status.HTTP_409_CONFLICT: 
        logger.warning(f"Registro do Usu√°rio A ('{user_a_data['username']}') resultou em conflito (j√° existe). Prosseguindo para login.")
    else: 
        pytest.fail(f"Falha inesperada ao tentar registrar Usu√°rio A: {reg_response.status_code} - {reg_response.text}")

    login_payload = {"username": user_a_data["username"], "password": user_a_data["password"]}
    login_response = await test_async_client.post(login_url, data=login_payload)
    if login_response.status_code != status.HTTP_200_OK: 
        pytest.fail(f"Falha ao fazer login com Usu√°rio A ('{user_a_data['username']}'): {login_response.status_code} - {login_response.text}")
    token: str = login_response.json()["access_token"]
    logger.debug(f"Usu√°rio A ('{user_a_data['username']}') logado com sucesso. Token obtido.")

    user_me_headers = {"Authorization": f"Bearer {token}"}
    user_me_response = await test_async_client.get(users_me_url, headers=user_me_headers)
    if user_me_response.status_code != status.HTTP_200_OK: 
        pytest.fail(f"Falha ao obter dados do Usu√°rio A via /users/me: {user_me_response.status_code} - {user_me_response.text}")
    user_id_str: str = user_me_response.json()["id"]
    user_id: uuid.UUID = uuid.UUID(user_id_str)
    logger.info(f"ID do Usu√°rio A ({user_id}) obtido com sucesso.")
    return token, user_id

@pytest.fixture(scope="function")
def auth_headers_a(test_user_a_token_and_id: tuple[str, uuid.UUID]) -> Dict[str, str]:
    """
    Fixture s√≠ncrona que retorna um dicion√°rio de cabe√ßalhos de autentica√ß√£o
    (Authorization Bearer token) para o Usu√°rio A.
    """
    token, _ = test_user_a_token_and_id
    return {"Authorization": f"Bearer {token}"}

# ========================
# --- Fixtures para Usu√°rio de Teste B ---
# ========================
user_b_data: Dict[str, str] = {
    "email": "testuserB@example.com",
    "username": "testuserB",
    "password": "passwordB",
    "full_name": "Test User B"
}

@pytest_asyncio.fixture(scope="function")
async def test_user_b_token(test_async_client: AsyncClient) -> str:
    """
    Fixture para registrar e logar o Usu√°rio B, retornando apenas seu token de acesso.
    """
    logger.debug("Fixture 'test_user_b_token': Configurando Usu√°rio B...")
    register_url = f"{settings.API_V1_STR}/auth/register"
    login_url = f"{settings.API_V1_STR}/auth/login/access-token"

    reg_response = await test_async_client.post(register_url, json=user_b_data)
    if reg_response.status_code == status.HTTP_201_CREATED:
        logger.info(f"Usu√°rio B ('{user_b_data['username']}') registrado com sucesso para o teste.")
    elif reg_response.status_code == status.HTTP_409_CONFLICT: 
        logger.warning(f"Registro do Usu√°rio B ('{user_b_data['username']}') resultou em conflito (j√° existe). Prosseguindo para login.")
    else: 
        pytest.fail(f"Falha inesperada ao tentar registrar Usu√°rio B: {reg_response.status_code} - {reg_response.text}")

    login_payload = {"username": user_b_data["username"], "password": user_b_data["password"]}
    login_response = await test_async_client.post(login_url, data=login_payload)
    if login_response.status_code != status.HTTP_200_OK: 
        pytest.fail(f"Falha ao fazer login com Usu√°rio B ('{user_b_data['username']}'): {login_response.status_code} - {login_response.text}")
    token: str = login_response.json()["access_token"]
    logger.info(f"Usu√°rio B ('{user_b_data['username']}') logado com sucesso. Token obtido.")
    return token

@pytest.fixture(scope="function")
def auth_headers_b(test_user_b_token: str) -> Dict[str, str]:
    """
    Fixture s√≠ncrona que retorna cabe√ßalhos de autentica√ß√£o para o Usu√°rio B.
    """
    return {"Authorization": f"Bearer {test_user_b_token}"}

# ========================
# --- Fixture para Cria√ß√£o de Tarefas (Filtro/Ordena√ß√£o) ---
# ========================
@pytest_asyncio.fixture(scope="function")
async def create_filter_sort_tasks(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str]
) -> List[Dict[str, Any]]:
    """
    Cria um conjunto de tarefas de teste no banco de dados para o Usu√°rio A.

    Util para testes de listagem, filtragem e ordena√ß√£o.
    """
    logger.info("Fixture 'create_filter_sort_tasks': Criando conjunto de tarefas de teste para Usu√°rio A...")
    tasks_creation_url = f"{settings.API_V1_STR}/tasks/"
    tasks_to_create_data: List[Dict[str, Any]] = [
        {"title": "Task A Filter High Priority", "importance": 5, "project": "Projeto Filtro", "status": TaskStatus.PENDING.value, "due_date": "2026-01-01", "tags": ["importante", "relat√≥rio"]},
        {"title": "Task B Filter Low Priority", "importance": 1, "project": "Projeto Filtro", "status": TaskStatus.PENDING.value, "due_date": "2026-02-01", "tags": ["comum"]},
        {"title": "Task C Another Project InProgress", "importance": 3, "project": "Projeto Secund√°rio", "status": TaskStatus.IN_PROGRESS.value, "tags": ["desenvolvimento"]},
        {"title": "Task D Filter Medium Due Soon", "importance": 3, "project": "Projeto Filtro", "status": TaskStatus.PENDING.value, "due_date": "2025-12-15", "tags": ["urgente", "financeiro"]},
        {"title": "Task E Filter Completed", "importance": 4, "project": "Projeto Filtro", "status": TaskStatus.COMPLETED.value, "tags": ["finalizado"]},
    ]
    created_tasks_list: List[Dict[str, Any]] = []
    for task_payload in tasks_to_create_data:
        response = await test_async_client.post(tasks_creation_url, json=task_payload, headers=auth_headers_a)
        assert response.status_code == status.HTTP_201_CREATED, \
            f"Falha ao criar tarefa de teste (T√≠tulo: '{task_payload['title']}'). Resposta: {response.text}" 
        created_tasks_list.append(response.json())
        logger.debug(f"Tarefa de teste criada: {task_payload['title']} (ID: {response.json()['id']})")

    logger.info(f"Fixture 'create_filter_sort_tasks': {len(created_tasks_list)} tarefas de teste criadas com sucesso.")
    return created_tasks_list

================================================================================
Cap√≠tulo 18: tests/test_auth.py
================================================================================

# tests/test_auth.py
"""
Este m√≥dulo cont√©m testes de integra√ß√£o para os endpoints de autentica√ß√£o
da API SmartTask, definidos em `app.routers.auth`.

Os testes cobrem:
- Registro de novos usu√°rios, incluindo cen√°rios de sucesso e conflito (duplicidade).
- Valida√ß√£o de entrada para o registro de usu√°rios.
- Login de usu√°rios, incluindo sucesso, senha incorreta e usu√°rio n√£o encontrado/desativado.
- Acesso a dados do usu√°rio autenticado (`/users/me`).
- Atualiza√ß√£o de dados do usu√°rio autenticado.
- Dele√ß√£o da conta do usu√°rio autenticado.

As fixtures para cliente HTTP e usu√°rios de teste s√£o definidas em `conftest.py`.
"""

# ========================
# --- Importa√ß√µes ---
# ========================
import uuid
from typing import Any, Dict

import pytest
from fastapi import status
from httpx import AsyncClient
from unittest.mock import MagicMock, patch
from pymongo.errors import DuplicateKeyError

# --- M√≥dulos da Aplica√ß√£o e Configs de Teste ---
from app.core.config import settings
from app.db import user_crud
from app.models.user import User, UserInDB, UserUpdate
from app.routers import auth
from tests.conftest import user_a_data

# ========================
# --- Marcador Global de Teste ---
# ========================
pytestmark = pytest.mark.asyncio

# ========================
# --- Testes de Registro (/auth/register) ---
# ========================
async def test_register_user_success(test_async_client: AsyncClient):
    """
    Testa o registro bem-sucedido de um novo usu√°rio com dados √∫nicos.
    """
    # --- Arrange ---
    new_user_data = {
        "email": "newuniqueuser_auth_test@example.com",
        "username": "newuniqueuser_auth_test",
        "password": "newpassword123",
        "full_name": "New Unique Test User"
    }
    register_url = f"{settings.API_V1_STR}/auth/register"

    # --- Act ---
    response = await test_async_client.post(register_url, json=new_user_data)

    # --- Assert ---
    assert response.status_code == status.HTTP_201_CREATED
    response_data = response.json()
    assert response_data["email"] == new_user_data["email"]
    assert response_data["username"] == new_user_data["username"]
    assert response_data["full_name"] == new_user_data["full_name"]
    assert "id" in response_data
    assert "hashed_password" not in response_data

async def test_register_user_duplicate_username_case_insensitive_is_actually_sensitive(
    test_async_client: AsyncClient,
):
    """
    Testa o registro com um username que difere apenas em mai√∫sculas/min√∫sculas
    de um username existente.
    """
    # --- Arrange ---
    base_url = f"{settings.API_V1_STR}/auth/register"
    unique_email_prefix = uuid.uuid4().hex[:8]

    user_initial_data = {
        "email": f"{unique_email_prefix}_initial@example.com",
        "username": "CamelCaseUser",
        "password": "password123",
    }
    response_initial = await test_async_client.post(base_url, json=user_initial_data)
    assert response_initial.status_code == status.HTTP_201_CREATED

    user_variant_case_data = {
        "email": f"{unique_email_prefix}_variant@example.com",
        "username": "camelcaseuser",
        "password": "password123",
    }

    # --- Act ---
    response_variant = await test_async_client.post(base_url, json=user_variant_case_data)

    # --- Assert ---
    assert response_variant.status_code == status.HTTP_201_CREATED

async def test_register_user_duplicate_username(
    test_async_client: AsyncClient,
    test_user_a_token_and_id: tuple[str, uuid.UUID]
):
    """
    Testa a tentativa de registro de um novo usu√°rio com um username que j√° existe.
    """
    # --- Arrange ---
    attempt_data = {
        "email": "anotherunique_email@example.com",
        "username": user_a_data["username"],
        "password": "anotherpassword",
    }
    register_url = f"{settings.API_V1_STR}/auth/register"

    # --- Act ---
    response = await test_async_client.post(register_url, json=attempt_data)

    # --- Assert ---
    assert response.status_code == status.HTTP_409_CONFLICT
    assert "j√° existe" in response.json()["detail"]

async def test_register_user_duplicate_email(
    test_async_client: AsyncClient,
    test_user_a_token_and_id: tuple[str, uuid.UUID]
):
    """
    Testa a tentativa de registro de um novo usu√°rio com um e-mail que j√° existe.
    """
    # --- Arrange ---
    attempt_data = {
        "email": user_a_data["email"],
        "username": "anotherunique_username_for_email_test",
        "password": "anotherpassword",
    }
    register_url = f"{settings.API_V1_STR}/auth/register"

    # --- Act ---
    response = await test_async_client.post(register_url, json=attempt_data)

    # --- Assert ---
    assert response.status_code == status.HTTP_409_CONFLICT
    assert "j√° registrado" in response.json()["detail"]

async def test_register_user_crud_returns_none(test_async_client: AsyncClient, mocker): # type: ignore
    """
    Testa o registro quando user_crud.create_user retorna None.
    Deve resultar em erro 500 com a mensagem gen√©rica devido √† estrutura do try/except.
    """
    # --- Arrange ---
    user_data = {
        "email": "crudnone@example.com",
        "username": "crudnoneuser",
        "password": "password123"
    }
    register_url = f"{settings.API_V1_STR}/auth/register"

    mocker.patch("app.routers.auth.user_crud.get_user_by_username", return_value=None)
    mocker.patch("app.routers.auth.user_crud.get_user_by_email", return_value=None)
    mocker.patch("app.routers.auth.user_crud.create_user", return_value=None)

    # --- Act ---
    response = await test_async_client.post(register_url, json=user_data)

    # --- Assert ---
    assert response.status_code == status.HTTP_500_INTERNAL_SERVER_ERROR
    # Espera a mensagem do except Exception gen√©rico
    assert "Ocorreu um erro inesperado" in response.json()["detail"]

async def test_register_user_crud_generic_exception(test_async_client: AsyncClient, mocker):
    """
    Testa o registro quando user_crud.create_user levanta Exception gen√©rica.
    """
    # --- Arrange ---
    user_data = {
        "email": "crudexception@example.com",
        "username": "crudexcuser",
        "password": "password123"
    }
    register_url = f"{settings.API_V1_STR}/auth/register"
    simulated_error = Exception("Erro gen√©rico simulado no CRUD")

    mocker.patch("app.routers.auth.user_crud.get_user_by_username", return_value=None)
    mocker.patch("app.routers.auth.user_crud.get_user_by_email", return_value=None)
    mocker.patch("app.routers.auth.user_crud.create_user", side_effect=simulated_error)

    # --- Act ---
    response = await test_async_client.post(register_url, json=user_data)

    # --- Assert ---
    assert response.status_code == status.HTTP_500_INTERNAL_SERVER_ERROR
    assert "Ocorreu um erro inesperado" in response.json()["detail"]

# ========================
# --- Testes de Valida√ß√£o de Entrada (/auth/register) ---
# ========================
@pytest.mark.parametrize(
    "field, value, error_type, error_msg_part",
    [
        ("email", "nao-e-um-email-valido", "value_error", "valid email address"),
        ("username", "us", "string_too_short", "String should have at least 3 characters"),
        ("username", "username com espacos", "string_pattern_mismatch", "match pattern"),
        ("username", "username!Inv√°lido", "string_pattern_mismatch", "match pattern"),
        ("password", "curta", "string_too_short", "String should have at least 8 characters"),
        ("email", None, "missing", "Field required"),
        ("username", None, "missing", "Field required"),
        ("password", None, "missing", "Field required"),
    ]
)
async def test_register_user_invalid_input(
    test_async_client: AsyncClient,
    field: str,
    value: Any,
    error_type: str,
    error_msg_part: str
):
    """
    Testa o registro de usu√°rio com dados de entrada inv√°lidos espec√≠ficos.
    """
    # --- Arrange ---
    valid_base_data = {
        "email": "valid_initial_email@example.com",
        "username": "validinitialuser",
        "password": "validinitialpassword",
        "full_name": "Valid Initial Name"
    }
    test_payload = valid_base_data.copy()
    if value is None:
        if field in test_payload:
            del test_payload[field]
    else:
        test_payload[field] = value

    register_url = f"{settings.API_V1_STR}/auth/register"

    # --- Act ---
    response = await test_async_client.post(register_url, json=test_payload)

    # --- Assert ---
    assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY
    error_details = response.json().get("detail", [])
    assert isinstance(error_details, list)
    found_expected_error = False
    for error_item in error_details:
        field_location_match = isinstance(error_item.get("loc"), list) and field in error_item["loc"]
        type_match = error_item.get("type") == error_type
        msg_match = error_msg_part.lower() in error_item.get("msg", "").lower()

        if field_location_match and type_match and msg_match:
            found_expected_error = True
            break
    assert found_expected_error

# ========================
# --- Testes de Login (/auth/login/access-token) ---
# ========================
async def test_login_success(
    test_async_client: AsyncClient,
    test_user_a_token_and_id: tuple[str, uuid.UUID]
):
    """
    Testa o login bem-sucedido do Usu√°rio A.
    """
    # --- Arrange ---
    login_payload_form_data = {
        "username": user_a_data["username"],
        "password": user_a_data["password"]
    }
    login_url = f"{settings.API_V1_STR}/auth/login/access-token"

    # --- Act ---
    response = await test_async_client.post(login_url, data=login_payload_form_data)

    # --- Assert ---
    assert response.status_code == status.HTTP_200_OK
    token_data = response.json()
    assert "access_token" in token_data
    assert token_data.get("token_type") == "bearer"

async def test_login_wrong_password(
    test_async_client: AsyncClient,
    test_user_a_token_and_id: tuple[str, uuid.UUID]
):
    """
    Testa a tentativa de login do Usu√°rio A com uma senha incorreta.
    """
    # --- Arrange ---
    login_payload_form_data = {
        "username": user_a_data["username"],
        "password": "thisisawrongpassword"
    }
    login_url = f"{settings.API_V1_STR}/auth/login/access-token"

    # --- Act ---
    response = await test_async_client.post(login_url, data=login_payload_form_data)

    # --- Assert ---
    assert response.status_code == status.HTTP_401_UNAUTHORIZED
    assert "incorretos" in response.json()["detail"].lower()

async def test_login_user_not_found(test_async_client: AsyncClient):
    """
    Testa a tentativa de login com um nome de usu√°rio que n√£o existe no sistema.
    """
    # --- Arrange ---
    login_payload_form_data = {
        "username": "nonexistent_test_user",
        "password": "any_password"
    }
    login_url = f"{settings.API_V1_STR}/auth/login/access-token"

    # --- Act ---
    response = await test_async_client.post(login_url, data=login_payload_form_data)

    # --- Assert ---
    assert response.status_code == status.HTTP_401_UNAUTHORIZED

async def test_login_disabled_user(test_async_client: AsyncClient, mocker):
    """
    Testa a tentativa de login com um usu√°rio que est√° desabilitado.
    Espera-se um erro HTTP 400 Bad Request.
    """
    # --- Arrange ---
    disabled_username = "disabled_user_login"
    password = "password_for_disabled"
    login_url = f"{settings.API_V1_STR}/auth/login/access-token"
    login_payload_form_data = {
        "username": disabled_username,
        "password": password
    }

    disabled_user_mock = MagicMock(spec=UserInDB)
    disabled_user_mock.username = disabled_username
    disabled_user_mock.hashed_password = "some_valid_hash"
    disabled_user_mock.disabled = True

    mock_get_user_by_username = mocker.patch("app.routers.auth.user_crud.get_user_by_username", return_value=disabled_user_mock)
    mock_verify_password = mocker.patch("app.routers.auth.verify_password", return_value=True)
    mock_create_token = mocker.patch("app.routers.auth.create_access_token")

    # --- Act ---
    response = await test_async_client.post(login_url, data=login_payload_form_data)

    # --- Assert ---
    assert response.status_code == status.HTTP_400_BAD_REQUEST
    assert "A conta do usu√°rio est√° inativa." == response.json()["detail"]
    mock_create_token.assert_not_called()
    mock_get_user_by_username.assert_called_once_with(mocker.ANY, disabled_username)
    mock_verify_password.assert_called_once_with(password, disabled_user_mock.hashed_password)

# ========================
# --- Testes de /auth/users/me ---
# ========================
async def test_read_users_me_success(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    test_user_a_token_and_id: tuple[str, uuid.UUID]
):
    """
    Testa o acesso bem-sucedido ao endpoint `/users/me` para obter
    os dados do usu√°rio autenticado (User A).
    """
    # --- Arrange ---
    users_me_url = f"{settings.API_V1_STR}/auth/users/me"
    _, expected_user_id = test_user_a_token_and_id

    # --- Act ---
    response = await test_async_client.get(users_me_url, headers=auth_headers_a)

    # --- Assert ---
    assert response.status_code == status.HTTP_200_OK
    user_response_data = response.json()
    assert user_response_data["id"] == str(expected_user_id)
    assert user_response_data["email"] == user_a_data["email"]
    assert user_response_data["username"] == user_a_data["username"]
    assert user_response_data["full_name"] == user_a_data["full_name"]
    assert "disabled" in user_response_data
    assert "hashed_password" not in user_response_data
    assert "created_at" in user_response_data

async def test_read_users_me_unauthorized_no_token(test_async_client: AsyncClient):
    """
    Testa o acesso ao endpoint `/users/me` sem fornecer um token de autentica√ß√£o.
    """
    # --- Arrange ---
    users_me_url = f"{settings.API_V1_STR}/auth/users/me"

    # --- Act ---
    response = await test_async_client.get(users_me_url)

    # --- Assert ---
    assert response.status_code == status.HTTP_401_UNAUTHORIZED
    assert "Not authenticated" in response.json()["detail"]

async def test_read_users_me_invalid_token(test_async_client: AsyncClient, mocker):
    """
    Testa o acesso ao endpoint `/users/me` fornecendo um token JWT inv√°lido/malformado.
    """
    # --- Arrange ---
    users_me_url = f"{settings.API_V1_STR}/auth/users/me"
    invalid_token_headers = {"Authorization": "Bearer an.invalid.jwt.token"}
    mocker.patch("app.core.security.logger")

    # --- Act ---
    response = await test_async_client.get(users_me_url, headers=invalid_token_headers)

    # --- Assert ---
    assert response.status_code == status.HTTP_401_UNAUTHORIZED
    error_detail = response.json()["detail"]
    expected_error_message_part_pt = "n√£o foi poss√≠vel validar as credenciais"
    assert expected_error_message_part_pt.lower() in error_detail.lower()

# ========================
# --- Testes de PUT /users/me ---
# ========================
async def test_update_me_success(test_async_client: AsyncClient, mocker, auth_headers_a, test_user_a_token_and_id):
    """
    Testa a atualiza√ß√£o bem-sucedida dos dados do usu√°rio autenticado.
    """
    # --- Arrange ---
    token, user_id_a = test_user_a_token_and_id
    url = f"{settings.API_V1_STR}/auth/users/me"
    update_payload = {"full_name": "User A Updated Name"}

    mock_updated_user = MagicMock(spec=UserInDB)
    mock_api_user_return = MagicMock(spec=User)
    mock_api_user_return.id = user_id_a
    mock_api_user_return.username = user_a_data["username"]
    mock_api_user_return.email = user_a_data["email"]
    mock_api_user_return.full_name = update_payload["full_name"]
    mock_api_user_return.disabled = False
    mock_crud_update = mocker.patch("app.routers.auth.user_crud.update_user", return_value=mock_updated_user)
    mocker.patch("app.routers.auth.User.model_validate", return_value=mock_api_user_return)

    # --- Act ---
    response = await test_async_client.put(url, json=update_payload, headers=auth_headers_a)

    # --- Assert ---
    assert response.status_code == status.HTTP_200_OK
    response_data = response.json()
    assert response_data["full_name"] == update_payload["full_name"]
    assert response_data["id"] == str(user_id_a)

    mock_crud_update.assert_called_once()
    call_args, call_kwargs = mock_crud_update.call_args
    assert call_kwargs['user_id'] == user_id_a
    crud_update_payload_arg = None
    if 'user_update' in call_kwargs:
        crud_update_payload_arg = call_kwargs['user_update']
    else:
         pytest.fail("Argumento 'user_update' n√£o encontrado na chamada mockada do CRUD.")

    assert isinstance(crud_update_payload_arg, UserUpdate)
    assert crud_update_payload_arg.full_name == update_payload["full_name"]
    assert crud_update_payload_arg.email is None

async def test_update_me_password_success(test_async_client: AsyncClient, mocker, auth_headers_a, test_user_a_token_and_id):
    """
    Testa a atualiza√ß√£o bem-sucedida da senha do usu√°rio autenticado.
    """
    # --- Arrange ---
    token, user_id_a = test_user_a_token_and_id
    url = f"{settings.API_V1_STR}/auth/users/me"
    new_password = "newpassword123!"
    update_payload = {"password": new_password}

    mock_updated_user = MagicMock(spec=UserInDB)
    mock_api_user_return = MagicMock(spec=User)
    mock_api_user_return.id = user_id_a
    mock_api_user_return.username = user_a_data["username"]
    mock_api_user_return.email = user_a_data["email"]
    mock_api_user_return.full_name = user_a_data["full_name"]
    mock_api_user_return.disabled = False
    mock_crud_update = mocker.patch("app.routers.auth.user_crud.update_user", return_value=mock_updated_user)
    mocker.patch("app.routers.auth.User.model_validate", return_value=mock_api_user_return)

    # --- Act ---
    response = await test_async_client.put(url, json=update_payload, headers=auth_headers_a)

    # --- Assert ---
    assert response.status_code == status.HTTP_200_OK

    mock_crud_update.assert_called_once()
    call_args, call_kwargs = mock_crud_update.call_args
    assert call_kwargs['user_id'] == user_id_a

    crud_update_payload_arg = call_kwargs.get('user_update')
    assert crud_update_payload_arg is not None
    assert isinstance(crud_update_payload_arg, UserUpdate)
    assert crud_update_payload_arg.password == new_password
    assert crud_update_payload_arg.full_name is None

async def test_update_me_user_crud_returns_none(test_async_client: AsyncClient, mocker, auth_headers_a, test_user_a_token_and_id):
    """
    Testa o comportamento da rota PUT /users/me quando
    user_crud.update_user retorna None (resultando em 500 devido ao except gen√©rico).
    """
    # --- Arrange ---
    token, user_id_a = test_user_a_token_and_id
    url = f"{settings.API_V1_STR}/auth/users/me"
    update_payload = {"full_name": "Nome Nao Aplicado"}
    mock_crud_update = mocker.patch("app.routers.auth.user_crud.update_user", return_value=None)

    # --- Act ---
    response = await test_async_client.put(url, json=update_payload, headers=auth_headers_a)

    # --- Assert ---
    assert response.status_code == status.HTTP_500_INTERNAL_SERVER_ERROR
    assert "Ocorreu um erro inesperado durante a atualiza√ß√£o do usu√°rio." in response.json()["detail"] # Mensagem mantida do original

    mock_crud_update.assert_called_once()
    call_args, call_kwargs = mock_crud_update.call_args
    assert call_kwargs['user_id'] == user_id_a
    crud_update_payload_arg = call_kwargs.get('user_update')
    assert isinstance(crud_update_payload_arg, UserUpdate)
    assert crud_update_payload_arg.full_name == update_payload["full_name"]

async def test_update_me_duplicate_key_error(test_async_client: AsyncClient, mocker, auth_headers_a, test_user_a_token_and_id):
    """
    Testa o tratamento de DuplicateKeyError na rota PUT /users/me.
    """
    # --- Arrange ---
    token, user_id_a = test_user_a_token_and_id
    url = f"{settings.API_V1_STR}/auth/users/me"
    duplicate_email = "email.duplicado@teste.com"
    update_payload = {"email": duplicate_email}

    simulated_error = DuplicateKeyError("Erro de chave duplicada simulado")
    mock_crud_update = mocker.patch("app.routers.auth.user_crud.update_user", side_effect=simulated_error)

    # --- Act ---
    response = await test_async_client.put(url, json=update_payload, headers=auth_headers_a)

    # --- Assert ---
    assert response.status_code == status.HTTP_409_CONFLICT
    assert f"o e-mail '{duplicate_email}' j√° est√° em uso" in response.json()["detail"]

    mock_crud_update.assert_called_once()
    call_args, call_kwargs = mock_crud_update.call_args
    assert call_kwargs['user_id'] == user_id_a
    crud_update_payload_arg = call_kwargs.get('user_update')
    assert isinstance(crud_update_payload_arg, UserUpdate)
    assert crud_update_payload_arg.email == update_payload["email"]

async def test_update_me_generic_exception(test_async_client: AsyncClient, mocker, auth_headers_a, test_user_a_token_and_id):
    """
    Testa o tratamento de exce√ß√£o gen√©rica na rota PUT /users/me.
    """
    # --- Arrange ---
    token, user_id_a = test_user_a_token_and_id
    url = f"{settings.API_V1_STR}/auth/users/me"
    update_payload = {"full_name": "Nome Inalterado"}

    simulated_error = Exception("Erro gen√©rico simulado no update do CRUD")
    mock_crud_update = mocker.patch("app.routers.auth.user_crud.update_user", side_effect=simulated_error)

    # --- Act ---
    response = await test_async_client.put(url, json=update_payload, headers=auth_headers_a)

    # --- Assert ---
    assert response.status_code == status.HTTP_500_INTERNAL_SERVER_ERROR
    assert "Ocorreu um erro inesperado durante a atualiza√ß√£o do usu√°rio." in response.json()["detail"]

    mock_crud_update.assert_called_once()
    call_args, call_kwargs = mock_crud_update.call_args
    assert call_kwargs['user_id'] == user_id_a
    crud_update_payload_arg = call_kwargs.get('user_update')
    assert isinstance(crud_update_payload_arg, UserUpdate)
    assert crud_update_payload_arg.full_name == update_payload["full_name"]

# ========================
# --- Testes de DELETE /users/me ---
# ========================
async def test_delete_me_success(test_async_client: AsyncClient, mocker, auth_headers_a, test_user_a_token_and_id):
    """
    Testa a dele√ß√£o bem-sucedida da conta do usu√°rio autenticado.
    """
    # --- Arrange ---
    token, user_id_a = test_user_a_token_and_id
    url = f"{settings.API_V1_STR}/auth/users/me"

    mock_crud_delete = mocker.patch("app.routers.auth.user_crud.delete_user", return_value=True)

    # --- Act ---
    response = await test_async_client.delete(url, headers=auth_headers_a)

    # --- Assert ---
    assert response.status_code == status.HTTP_204_NO_CONTENT

    mock_crud_delete.assert_called_once()
    call_args, call_kwargs = mock_crud_delete.call_args
    found_user_id_arg = False
    if len(call_args) > 1 and call_args[1] == user_id_a:
         found_user_id_arg = True
    elif call_kwargs.get('user_id') == user_id_a:
         found_user_id_arg = True
    assert found_user_id_arg is True

async def test_delete_me_crud_returns_false(test_async_client: AsyncClient, mocker, auth_headers_a, test_user_a_token_and_id):
    """
    Testa o comportamento de DELETE /users/me quando
    user_crud.delete_user retorna False (resultando em 500 devido ao except gen√©rico).
    """
    # --- Arrange ---
    token, user_id_a = test_user_a_token_and_id
    url = f"{settings.API_V1_STR}/auth/users/me"

    mock_crud_delete = mocker.patch("app.routers.auth.user_crud.delete_user", return_value=False)

    # --- Act ---
    response = await test_async_client.delete(url, headers=auth_headers_a)

    # --- Assert ---
    assert response.status_code == status.HTTP_500_INTERNAL_SERVER_ERROR
    assert "Ocorreu um erro inesperado durante a dele√ß√£o do usu√°rio." in response.json()["detail"]

    mock_crud_delete.assert_called_once()
    call_args, call_kwargs = mock_crud_delete.call_args
    found_user_id_arg = False
    if len(call_args) > 1 and call_args[1] == user_id_a:
         found_user_id_arg = True
    elif call_kwargs.get('user_id') == user_id_a:
         found_user_id_arg = True
    assert found_user_id_arg is True

async def test_delete_me_crud_generic_exception(test_async_client: AsyncClient, mocker, auth_headers_a, test_user_a_token_and_id): # type: ignore
    """
    Testa o tratamento de exce√ß√£o gen√©rica na rota DELETE /users/me
    quando o CRUD levanta um erro.
    """
    # --- Arrange ---
    token, user_id_a = test_user_a_token_and_id
    url = f"{settings.API_V1_STR}/auth/users/me"

    # Mock user_crud.delete_user para levantar Exception gen√©rica
    simulated_error = Exception("Erro gen√©rico simulado no delete do CRUD")
    mock_crud_delete = mocker.patch("app.routers.auth.user_crud.delete_user", side_effect=simulated_error)

    # --- Act ---
    response = await test_async_client.delete(url, headers=auth_headers_a)

    # --- Assert ---
    assert response.status_code == status.HTTP_500_INTERNAL_SERVER_ERROR
    assert "Ocorreu um erro inesperado durante a dele√ß√£o do usu√°rio." in response.json()["detail"]

    # Verificar se user_crud.delete_user foi chamado
    mock_crud_delete.assert_called_once()
    call_args, call_kwargs = mock_crud_delete.call_args
    found_user_id_arg = False
    if len(call_args) > 1 and call_args[1] == user_id_a:
         found_user_id_arg = True
    elif call_kwargs.get('user_id') == user_id_a:
         found_user_id_arg = True
    assert found_user_id_arg is True

================================================================================
Cap√≠tulo 19: tests/test_core_config.py
================================================================================

# tests/test_core_config.py
"""
Este m√≥dulo cont√©m testes para a classe de configura√ß√µes da aplica√ß√£o (`app.core.config.Settings`).
O foco principal √© validar a l√≥gica condicional relacionada √†s configura√ß√µes de e-mail,
garantindo que as credenciais de e-mail sejam obrigat√≥rias apenas quando
a funcionalidade de e-mail est√° explicitamente habilitada (`MAIL_ENABLED=True`).
"""

# ========================
# --- Importa√ß√µes ---
# ========================
# Removida 'from logging import config' pois 'config' n√£o era usado.
import os
from unittest.mock import patch # Mantido pois foi usado no original.
import pytest
from pydantic import ValidationError
import importlib # Mantido pois foi usado no original (mesmo que o teste espec√≠fico tenha sido removido/alterado depois).

# --- M√≥dulo da Aplica√ß√£o ---
from app.core.config import Settings
import app.core.config as config_module # Mantido como no original

# ========================
# --- Testes de Valida√ß√£o de Configura√ß√µes de E-mail ---
# ========================
def test_settings_mail_enabled_and_missing_credentials_fails_validation(monkeypatch):
    """
    Testa se a instancia√ß√£o de `Settings` falha com `ValidationError` (ou `ValueError`)
    quando `MAIL_ENABLED` √© True, mas uma ou mais credenciais de e-mail
    (MAIL_USERNAME, MAIL_PASSWORD, MAIL_FROM, MAIL_SERVER) est√£o ausentes.

    Cen√°rio: MAIL_ENABLED=True, MAIL_USERNAME n√£o definido.
    """
    print("\nTeste: MAIL_ENABLED=True e falta MAIL_USERNAME -> Deve falhar a valida√ß√£o.")

    # --- Arrange: Configurar vari√°veis de ambiente ---
    print("  Limpando vari√°veis de ambiente de e-mail...")
    monkeypatch.delenv("MAIL_ENABLED", raising=False)
    monkeypatch.delenv("MAIL_USERNAME", raising=False)
    monkeypatch.delenv("MAIL_PASSWORD", raising=False)
    monkeypatch.delenv("MAIL_FROM", raising=False)
    monkeypatch.delenv("MAIL_PORT", raising=False)
    monkeypatch.delenv("MAIL_SERVER", raising=False)
    # No seu original, MAIL_TLS e MAIL_SSL eram `deprecated="auto"` ou removidos aqui, vou seguir
    # como estava no √∫ltimo c√≥digo que me forneceu
    monkeypatch.delenv("MAIL_STARTTLS", raising=False) # Presumindo que voc√™ quis dizer MAIL_STARTTLS (TLS original √© amb√≠guo)
    monkeypatch.delenv("MAIL_SSL_TLS", raising=False)  # Presumindo que voc√™ quis dizer MAIL_SSL_TLS

    print("  Definindo vari√°veis de ambiente obrigat√≥rias (n√£o-email)...")
    monkeypatch.setenv("PROJECT_NAME", "Test Project")
    monkeypatch.setenv("API_V1_STR", "/api/v1")
    # 'ENVIRONMENT' e 'REFRESH_TOKEN_EXPIRE_DAYS' n√£o est√£o em Settings, mas mantendo se estavam no seu teste
    # monkeypatch.setenv("ENVIRONMENT", "test") # Removido se n√£o presente em Settings
    monkeypatch.setenv("JWT_SECRET_KEY", "test_jwt_secret_key_for_config_test")
    monkeypatch.setenv("ACCESS_TOKEN_EXPIRE_MINUTES", "30")
    # monkeypatch.setenv("REFRESH_TOKEN_EXPIRE_DAYS", "7") # Removido se n√£o presente em Settings
    monkeypatch.setenv("MONGODB_URL", "mongodb://localhost:27017/test_config_db")
    monkeypatch.setenv("DATABASE_NAME", "test_config_db")

    print("  Definindo cen√°rio de teste: MAIL_ENABLED=True, MAIL_USERNAME ausente.")
    monkeypatch.setenv("MAIL_ENABLED", "True")
    monkeypatch.setenv("MAIL_PASSWORD", "secretpassword")
    monkeypatch.setenv("MAIL_FROM", "tests@example.com")
    monkeypatch.setenv("MAIL_SERVER", "smtp.example.com")
    monkeypatch.setenv("MAIL_PORT", "587")
    monkeypatch.setenv("MAIL_STARTTLS", "True") # Se for o nome correto da setting

    # --- Act & Assert: Tentar instanciar Settings e verificar a exce√ß√£o ---
    print("  Tentando instanciar Settings, esperando exce√ß√£o...")
    with pytest.raises((ValueError, ValidationError)) as exc_info:
        Settings(_env_file=None)

    expected_error_message_part = "MAIL_USERNAME, MAIL_PASSWORD, MAIL_FROM e MAIL_SERVER devem ser definidos"
    print(f"  Exce√ß√£o recebida: {exc_info.value}")
    assert expected_error_message_part in str(exc_info.value), \
        f"A mensagem de erro n√£o cont√©m '{expected_error_message_part}'. Erro: {str(exc_info.value)}"
    print("  Valida√ß√£o falhou como esperado.")


def test_settings_mail_disabled_and_credentials_not_needed_passes_validation(monkeypatch):
    """
    Testa se a instancia√ß√£o de `Settings` √© bem-sucedida quando `MAIL_ENABLED`
    √© False, mesmo que as credenciais de e-mail estejam ausentes.

    Neste cen√°rio, os campos de credenciais de e-mail devem ser opcionais
    e podem ser None.
    """
    print("\nTeste: MAIL_ENABLED=False, credenciais ausentes -> Deve passar a valida√ß√£o.")

    # --- Arrange: Configurar vari√°veis de ambiente ---
    print("  Limpando vari√°veis de ambiente de e-mail...")
    monkeypatch.delenv("MAIL_ENABLED", raising=False)
    monkeypatch.delenv("MAIL_USERNAME", raising=False)
    monkeypatch.delenv("MAIL_PASSWORD", raising=False)
    monkeypatch.delenv("MAIL_FROM", raising=False)
    monkeypatch.delenv("MAIL_PORT", raising=False)
    monkeypatch.delenv("MAIL_SERVER", raising=False)
    monkeypatch.delenv("MAIL_STARTTLS", raising=False) # Mantendo consist√™ncia com nomes de settings
    monkeypatch.delenv("MAIL_SSL_TLS", raising=False)  # Mantendo consist√™ncia

    print("  Definindo vari√°veis de ambiente obrigat√≥rias (n√£o-email)...")
    monkeypatch.setenv("PROJECT_NAME", "Test Project Disabled Mail")
    monkeypatch.setenv("API_V1_STR", "/api/v1")
    # monkeypatch.setenv("ENVIRONMENT", "test") # Removido se n√£o usado em Settings
    monkeypatch.setenv("JWT_SECRET_KEY", "test_jwt_secret_for_disabled_mail")
    monkeypatch.setenv("ACCESS_TOKEN_EXPIRE_MINUTES", "60")
    # monkeypatch.setenv("REFRESH_TOKEN_EXPIRE_DAYS", "14") # Removido se n√£o usado em Settings
    monkeypatch.setenv("MONGODB_URL", "mongodb://localhost:27017/test_disabled_mail_db")
    monkeypatch.setenv("DATABASE_NAME", "test_disabled_mail_db")

    print("  Definindo cen√°rio de teste: MAIL_ENABLED=False.")
    monkeypatch.setenv("MAIL_ENABLED", "False")

    # --- Act & Assert: Tentar instanciar Settings e verificar se N√ÉO levanta exce√ß√£o ---
    print("  Tentando instanciar Settings, esperando sucesso...")
    try:
        settings_instance = Settings(_env_file=None)
        print(f"  Settings instanciado com sucesso: MAIL_ENABLED={settings_instance.MAIL_ENABLED}")
        assert not settings_instance.MAIL_ENABLED, "MAIL_ENABLED deveria ser False."
        assert settings_instance.MAIL_USERNAME is None, "MAIL_USERNAME deveria ser None."
        assert settings_instance.MAIL_PASSWORD is None, "MAIL_PASSWORD deveria ser None."
        assert settings_instance.MAIL_FROM is None, "MAIL_FROM deveria ser None."
        assert settings_instance.MAIL_SERVER is None, "MAIL_SERVER deveria ser None."
        assert settings_instance.MAIL_PORT == 587, "MAIL_PORT deveria ter seu valor default (e.g., 587)."
    except (ValueError, ValidationError) as e: # pragma: no cover
        pytest.fail(
            f"A valida√ß√£o de Settings falhou inesperadamente quando MAIL_ENABLED=False. Erro: {e}\n"
            f"Vari√°veis de ambiente configuradas: {dict(os.environ)}"
        )
    print("  Valida√ß√£o passou como esperado com MAIL_ENABLED=False.")


def test_settings_mail_enabled_and_all_credentials_provided_passes_validation(monkeypatch):
    """
    Testa se a instancia√ß√£o de `Settings` √© bem-sucedida quando `MAIL_ENABLED`
    √© True e TODAS as credenciais de e-mail necess√°rias est√£o definidas.
    """
    print("\nTeste: MAIL_ENABLED=True e todas credenciais de e-mail fornecidas -> Deve passar a valida√ß√£o.")

    # --- Arrange: Configurar vari√°veis de ambiente ---
    print("  Limpando vari√°veis de ambiente de e-mail...")
    monkeypatch.delenv("MAIL_ENABLED", raising=False)
    monkeypatch.delenv("MAIL_USERNAME", raising=False)
    monkeypatch.delenv("MAIL_PASSWORD", raising=False)
    monkeypatch.delenv("MAIL_FROM", raising=False)
    monkeypatch.delenv("MAIL_PORT", raising=False)
    monkeypatch.delenv("MAIL_SERVER", raising=False)
    monkeypatch.delenv("MAIL_STARTTLS", raising=False) # Mantendo consist√™ncia
    monkeypatch.delenv("MAIL_SSL_TLS", raising=False)  # Mantendo consist√™ncia

    print("  Definindo vari√°veis de ambiente obrigat√≥rias (n√£o-email)...")
    monkeypatch.setenv("PROJECT_NAME", "Test Project All Mail")
    monkeypatch.setenv("API_V1_STR", "/api/v1")
    # monkeypatch.setenv("ENVIRONMENT", "test") # Removido se n√£o usado em Settings
    monkeypatch.setenv("JWT_SECRET_KEY", "test_jwt_secret_for_all_mail")
    monkeypatch.setenv("ACCESS_TOKEN_EXPIRE_MINUTES", "15")
    # monkeypatch.setenv("REFRESH_TOKEN_EXPIRE_DAYS", "3") # Removido se n√£o usado em Settings
    monkeypatch.setenv("MONGODB_URL", "mongodb://localhost:27017/test_all_mail_db")
    monkeypatch.setenv("DATABASE_NAME", "test_all_mail_db")

    print("  Definindo cen√°rio de teste: MAIL_ENABLED=True e todas credenciais de e-mail presentes.")
    monkeypatch.setenv("MAIL_ENABLED", "True")
    monkeypatch.setenv("MAIL_USERNAME", "test_mailer_user")
    monkeypatch.setenv("MAIL_PASSWORD", "supersecretmailerpassword")
    monkeypatch.setenv("MAIL_FROM", "noreply_tests@example.com")
    monkeypatch.setenv("MAIL_SERVER", "smtp.mailservice.example.com")
    monkeypatch.setenv("MAIL_PORT", "465")
    monkeypatch.setenv("MAIL_SSL_TLS", "True") # Usando MAIL_SSL_TLS para SSL
    monkeypatch.setenv("MAIL_STARTTLS", "False") # Desabilitando STARTTLS se SSL_TLS √© True

    # --- Act & Assert: Tentar instanciar Settings e verificar se N√ÉO levanta exce√ß√£o ---
    print("  Tentando instanciar Settings, esperando sucesso...")
    try:
        settings_instance = Settings(_env_file=None)
        print(f"  Settings instanciado com sucesso: MAIL_ENABLED={settings_instance.MAIL_ENABLED}, MAIL_USERNAME='{settings_instance.MAIL_USERNAME}'")
        assert settings_instance.MAIL_ENABLED, "MAIL_ENABLED deveria ser True."
        assert settings_instance.MAIL_USERNAME == "test_mailer_user", "MAIL_USERNAME n√£o corresponde."
        assert settings_instance.MAIL_PASSWORD == "supersecretmailerpassword"
        assert settings_instance.MAIL_FROM == "noreply_tests@example.com"
        assert settings_instance.MAIL_SERVER == "smtp.mailservice.example.com"
        assert settings_instance.MAIL_PORT == 465
    except (ValueError, ValidationError) as e: # pragma: no cover
        pytest.fail(
            "A valida√ß√£o de Settings falhou inesperadamente quando MAIL_ENABLED=True e todas as credenciais "
            f"de e-mail foram fornecidas. Erro: {e}\n"
            f"Vari√°veis de ambiente configuradas: {dict(os.environ)}"
        )
    print("  Valida√ß√£o passou como esperado com MAIL_ENABLED=True e todas credenciais de e-mail presentes.")

def test_settings_missing_required_pydantic_field_fails(monkeypatch):
    """
    Testa se `Settings` falha se um campo Pydantic obrigat√≥rio (n√£o email) falta.
    """
    print("\nTeste: Campo Pydantic obrigat√≥rio ausente -> Deve falhar a valida√ß√£o.")
    monkeypatch.delenv("JWT_SECRET_KEY", raising=False) # Removendo campo obrigat√≥rio
    monkeypatch.setenv("MONGODB_URL", "mongodb://localhost:27017/test_config_db") # Mantendo outro obrigat√≥rio
    monkeypatch.setenv("MAIL_ENABLED", "False") # Desabilitar checagem de email

    with pytest.raises(ValidationError) as exc_info:
        Settings(_env_file=None)

    assert "JWT_SECRET_KEY" in str(exc_info.value).upper() or "FIELD REQUIRED" in str(exc_info.value).upper()
    print(f"  Pydantic ValidationError capturada como esperado: {exc_info.value}")

# --- Testes de Valida√ß√£o de Webhook ---
def test_webhook_secret_required_with_url(monkeypatch):
    monkeypatch.setenv("WEBHOOK_URL", "http://example.com/webhook")
    monkeypatch.delenv("WEBHOOK_SECRET", raising=False)

    with pytest.raises(ValidationError) as exc_info:
        Settings()

    assert "WEBHOOK_SECRET deve ser definido" in str(exc_info.value)

================================================================================
Cap√≠tulo 20: tests/test_core_dependencies.py
================================================================================

# tests/test_core_dependencies.py
"""
Este m√≥dulo cont√©m testes unit√°rios para as depend√™ncias de seguran√ßa
definidas em `app.core.dependencies`.

As depend√™ncias testadas s√£o:
- `get_current_user`: Respons√°vel por decodificar o token JWT, validar o payload
  e buscar o usu√°rio correspondente no banco de dados.
- `get_current_active_user`: Uma depend√™ncia que consome o resultado de
  `get_current_user` e verifica se o usu√°rio n√£o est√° desativado.

Os testes utilizam mocks para isolar as depend√™ncias de chamadas reais
ao banco de dados ou fun√ß√µes de decodifica√ß√£o de token.
"""

# ========================
# --- Importa√ß√µes ---
# ========================
import uuid
from datetime import datetime, timezone
from unittest.mock import AsyncMock, MagicMock, patch
import pytest
from fastapi import HTTPException, status

# --- M√≥dulos da Aplica√ß√£o ---
from app.core.dependencies import (get_current_active_user, get_current_user,
                                   oauth2_scheme) # oauth2_scheme n√£o usado diretamente nos testes, mas mantido
from app.models.token import TokenPayload
from app.models.user import UserInDB

# ========================
# --- Marcador Global de Teste ---
# ========================
pytestmark = pytest.mark.asyncio

# ========================
# --- Fixtures para Mocks Comuns ---
# ========================
@pytest.fixture
def mock_db() -> AsyncMock:
    """
    Fixture que retorna um `AsyncMock` para simular a depend√™ncia do banco de dados (`DbDep`).
    """
    return AsyncMock()

@pytest.fixture
def mock_valid_token_str() -> str:
    """
    Fixture que retorna uma string de token JWT mockada e v√°lida.
    """
    return "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c"

# ========================
# --- Testes para a depend√™ncia `get_current_user` ---
# ========================
async def test_get_current_user_success(
    mock_db: AsyncMock,
    mock_valid_token_str: str
):
    """
    Testa o cen√°rio de sucesso para `get_current_user`.

    Verifica se:
    - `decode_token` √© chamado corretamente com o token fornecido.
    - `user_crud.get_user_by_id` √© chamado com o ID do usu√°rio do payload do token.
    - A fun√ß√£o retorna o objeto `UserInDB` esperado.
    """
    # --- Arrange ---
    test_user_id = uuid.uuid4()
    test_username = "test_active_user"
    expected_user_obj = UserInDB(
        id=test_user_id,
        username=test_username,
        email="testuser@example.com",
        hashed_password="fake_hashed_password",
        disabled=False,
        created_at=datetime.now(timezone.utc)
    )
    mock_token_payload = TokenPayload(sub=test_user_id, username=test_username)

    with patch("app.core.dependencies.decode_token", return_value=mock_token_payload) as mock_decode_jwt, \
         patch("app.core.dependencies.user_crud.get_user_by_id", return_value=expected_user_obj) as mock_get_user:

        # --- Act ---
        retrieved_user = await get_current_user(db=mock_db, token=mock_valid_token_str)

        # --- Assert ---
        mock_decode_jwt.assert_called_once_with(mock_valid_token_str)
        mock_get_user.assert_awaited_once_with(db=mock_db, user_id=test_user_id)
        assert retrieved_user == expected_user_obj, "Usu√°rio retornado n√£o √© o esperado."


async def test_get_current_user_invalid_or_expired_token(
    mock_db: AsyncMock,
    mock_valid_token_str: str
):
    """
    Testa `get_current_user` quando `decode_token` falha (retorna None),
    simulando um token JWT inv√°lido, malformado ou expirado.

    Verifica se:
    - Uma `HTTPException` com status 401 √© levantada.
    - A mensagem de detalhe da exce√ß√£o √© a esperada.
    """
    # --- Arrange ---
    with patch("app.core.dependencies.decode_token", return_value=None) as mock_decode_jwt:

        # --- Act & Assert ---
        with pytest.raises(HTTPException) as exc_info:
            await get_current_user(db=mock_db, token=mock_valid_token_str)

        assert exc_info.value.status_code == status.HTTP_401_UNAUTHORIZED, "Status code n√£o √© 401."
        assert "N√£o foi poss√≠vel validar as credenciais" in exc_info.value.detail, \
            "Mensagem de detalhe da exce√ß√£o n√£o √© a esperada."
        mock_decode_jwt.assert_called_once_with(mock_valid_token_str)

async def test_get_current_user_user_not_found_in_db(
    mock_db: AsyncMock,
    mock_valid_token_str: str
):
    """
    Testa `get_current_user` quando o token √© v√°lido e decodificado com sucesso,
    mas o ID de usu√°rio (sub) contido no payload do token n√£o corresponde
    a nenhum usu√°rio no banco de dados.

    Verifica se:
    - Uma `HTTPException` com status 401 √© levantada.
    - A mensagem de detalhe da exce√ß√£o √© a esperada.
    - `user_crud.get_user_by_id` √© chamado.
    """
    # --- Arrange ---
    test_user_id_not_in_db = uuid.uuid4()
    mock_token_payload = TokenPayload(sub=test_user_id_not_in_db, username="ghost_user")

    with patch("app.core.dependencies.decode_token", return_value=mock_token_payload) as mock_decode_jwt, \
         patch("app.core.dependencies.user_crud.get_user_by_id", return_value=None) as mock_get_user:

        # --- Act & Assert ---
        with pytest.raises(HTTPException) as exc_info:
            await get_current_user(db=mock_db, token=mock_valid_token_str)

        assert exc_info.value.status_code == status.HTTP_401_UNAUTHORIZED, "Status code n√£o √© 401."
        assert "N√£o foi poss√≠vel validar as credenciais" in exc_info.value.detail, \
            "Mensagem de detalhe da exce√ß√£o n√£o √© a esperada para usu√°rio n√£o encontrado."
        mock_decode_jwt.assert_called_once_with(mock_valid_token_str)
        mock_get_user.assert_awaited_once_with(db=mock_db, user_id=test_user_id_not_in_db)

# ========================
# --- Testes para a depend√™ncia `get_current_active_user` ---
# ========================
async def test_get_current_active_user_when_user_is_disabled():
    """
    Testa `get_current_active_user` passando um objeto `UserInDB`
    que representa um usu√°rio desativado (`disabled=True`).

    Verifica se:
    - Uma `HTTPException` com status 400 Bad Request √© levantada.
    - A mensagem de detalhe da exce√ß√£o indica "Usu√°rio inativo".
    """
    # --- Arrange ---
    disabled_user_mock = UserInDB(
        id=uuid.uuid4(),
        username="inactive_user",
        email="inactive@example.com",
        hashed_password="fake_hashed_password",
        disabled=True,
        created_at=datetime.now(timezone.utc)
    )

    # --- Act & Assert ---
    with pytest.raises(HTTPException) as exc_info:
        await get_current_active_user(current_user=disabled_user_mock)

    assert exc_info.value.status_code == status.HTTP_400_BAD_REQUEST, "Status code n√£o √© 400."
    assert "Usu√°rio inativo" in exc_info.value.detail, "Mensagem de detalhe da exce√ß√£o n√£o √© 'Usu√°rio inativo'."


async def test_get_current_active_user_when_user_is_active():
    """
    Testa `get_current_active_user` passando um objeto `UserInDB`
    que representa um usu√°rio ativo (`disabled=False`).

    Verifica se:
    - A fun√ß√£o retorna o mesmo objeto de usu√°rio que foi passado.
    - Nenhuma exce√ß√£o √© levantada.
    """
    # --- Arrange ---
    active_user_mock = UserInDB(
        id=uuid.uuid4(),
        username="active_user",
        email="active_user@example.com",
        hashed_password="fake_hashed_password",
        disabled=False,
        created_at=datetime.now(timezone.utc)
    )

    # --- Act ---
    returned_user = await get_current_active_user(current_user=active_user_mock)

    # --- Assert ---
    assert returned_user == active_user_mock, "Usu√°rio ativo retornado n√£o √© o mesmo que foi passado."


async def test_get_current_user_invalid_sub_uuid_format(mock_db, mock_valid_token_str, mocker): # type: ignore
    """
    Testa get_current_user quando o 'sub' no token n√£o √© um UUID v√°lido.
    """
    # --- Arrange ---
    invalid_sub_str = "not-a-uuid-at-all"
    # No seu c√≥digo original, mock_payload_dict n√£o era usado, mas sim mock_token_payload_obj
    mock_token_payload_obj = MagicMock()
    mock_token_payload_obj.sub = invalid_sub_str # O atributo 'sub' tem a string inv√°lida

    mock_decode = mocker.patch("app.core.dependencies.decode_token", return_value=mock_token_payload_obj)
    mock_get_user = mocker.patch("app.core.dependencies.user_crud.get_user_by_id", new_callable=AsyncMock)

    # --- Act & Assert ---
    with pytest.raises(HTTPException) as exc_info:
        await get_current_user(db=mock_db, token=mock_valid_token_str)

    assert exc_info.value.status_code == status.HTTP_401_UNAUTHORIZED
    assert "N√£o foi poss√≠vel validar as credenciais" in exc_info.value.detail

    mock_decode.assert_called_once_with(mock_valid_token_str)
    mock_get_user.assert_not_called()

================================================================================
Cap√≠tulo 21: tests/test_core_email.py
================================================================================

# tests/test_core_email.py
"""
Este m√≥dulo cont√©m testes unit√°rios para as fun√ß√µes de envio de e-mail
definidas em `app.core.email`.

Os testes verificam:
- Comportamento quando o envio de e-mail est√° desabilitado (`MAIL_ENABLED=False`).
- Comportamento quando faltam credenciais de e-mail obrigat√≥rias.
- Chamada correta √† biblioteca `fastapi-mail` (mockada) para envio de e-mails
  com templates HTML e em texto puro.
- Tratamento de exce√ß√µes durante o envio de e-mails.
- A l√≥gica espec√≠fica da fun√ß√£o `send_urgent_task_notification`, verificando
  os argumentos passados para a fun√ß√£o de envio gen√©rica `send_email_async`.

Todos os envios reais de e-mail s√£o mockados para evitar efeitos colaterais
e depend√™ncias externas durante os testes.
"""

# ========================
# --- Importa√ß√µes ---
# ========================
import uuid # Mantida, embora n√£o usada diretamente neste snapshot espec√≠fico, pode ser em vers√µes futuras.
import logging
from unittest.mock import AsyncMock, patch, ANY # ANY √© usado implicitamente ou explicitamente em alguns mocks

import pytest
from fastapi_mail import MessageSchema, MessageType

# --- M√≥dulos da Aplica√ß√£o ---
from app.core.config import settings
from app.core.email import (conf, send_email_async, send_urgent_task_notification) # conf n√£o √© usado aqui
from app.core import email as email_module # Usado para chamar email_module.send_urgent_task_notification

# ========================
# --- Marcador Global de Teste ---
# ========================
pytestmark = pytest.mark.asyncio

# ========================
# --- Testes de Condi√ß√µes de Guarda para `send_email_async` ---
# ========================
async def test_send_email_async_when_mail_is_disabled(mocker, caplog):
    """
    Testa se `send_email_async` N√ÉO tenta enviar um e-mail e loga uma mensagem informativa
    quando a configura√ß√£o `settings.MAIL_ENABLED` √© `False`.
    """
    print("\nTeste: send_email_async com MAIL_ENABLED=False.")
    # --- Arrange ---
    mock_fastapi_mail_send_message = mocker.patch("app.core.email.fm.send_message", new_callable=AsyncMock)
    mocker.patch.object(settings, 'MAIL_ENABLED', False)
    print("  Mock: fm.send_message e settings.MAIL_ENABLED=False.")

    # --- Act ---
    print("  Atuando: Chamando send_email_async...")
    await send_email_async(
        subject="E-mail de Teste (Desabilitado)",
        recipient_to=["test_disabled@example.com"], # type: ignore (Pydantic EmailStr √© validado em runtime)
        body={"info": "Este e-mail n√£o deve ser enviado."},
        template_name="dummy_template_desabilitado.html"
    )

    # --- Assert ---
    mock_fastapi_mail_send_message.assert_not_called()
    found_log = False
    expected_message = "Envio de e-mail desabilitado nas configura√ß√µes"
    for record in caplog.records:
        if expected_message in record.message:
            assert record.levelname == "WARNING"
            found_log = True
            break
    assert found_log, f"Log esperado contendo '{expected_message}' n√£o encontrado. Logs: {caplog.text}"
    print("  Sucesso: E-mail n√£o enviado e log de desativa√ß√£o presente.")


async def test_send_email_async_when_essential_credentials_are_missing(mocker):
    """
    Testa se `send_email_async` N√ÉO tenta enviar um e-mail e loga um erro
    quando `settings.MAIL_ENABLED` √© `True`, mas faltam credenciais essenciais
    (como MAIL_USERNAME, MAIL_PASSWORD, etc.).
    """
    print("\nTeste: send_email_async com MAIL_ENABLED=True, mas faltando credenciais.")
    # --- Arrange ---
    mock_fastapi_mail_send_message = mocker.patch("app.core.email.fm.send_message", new_callable=AsyncMock)
    mocker.patch.object(settings, 'MAIL_ENABLED', True)
    mock_email_module_logger = mocker.patch("app.core.email.logger")
    essential_mail_fields = ['MAIL_USERNAME', 'MAIL_PASSWORD', 'MAIL_FROM', 'MAIL_SERVER']

    for missing_field in essential_mail_fields:
        print(f"  Testando cen√°rio: Faltando '{missing_field}'...")
        # Define todas as credenciais, depois remove uma
        mocker.patch.object(settings, 'MAIL_USERNAME', 'test_user')
        mocker.patch.object(settings, 'MAIL_PASSWORD', 'test_password')
        mocker.patch.object(settings, 'MAIL_FROM', 'test_from@example.com') # type: ignore
        mocker.patch.object(settings, 'MAIL_SERVER', 'smtp.example.com')
        mocker.patch.object(settings, 'MAIL_PORT', 587) # J√° coberto no original
        mocker.patch.object(settings, 'MAIL_STARTTLS', True) # J√° coberto no original
        mocker.patch.object(settings, 'MAIL_SSL_TLS', False) # J√° coberto no original

        mocker.patch.object(settings, missing_field, None)
        print(f"    Mock: {missing_field}=None, outras credenciais definidas.")

        mock_fastapi_mail_send_message.reset_mock()
        mock_email_module_logger.reset_mock()

        # --- Act ---
        await send_email_async(
            subject=f"Teste de Credenciais (Falta {missing_field})",
            recipient_to=["test_cred_missing@example.com"], # type: ignore
            body={"info": f"Teste com {missing_field} ausente."}
        )

        # --- Assert ---
        mock_fastapi_mail_send_message.assert_not_called()
        mock_email_module_logger.error.assert_called_once()
        log_call_args = mock_email_module_logger.error.call_args[0]
        assert "Configura√ß√µes essenciais de e-mail ausentes" in log_call_args[0], \
            f"Log de erro para '{missing_field}' ausente n√£o correspondeu. Log: {log_call_args[0]}"
        print(f"    Sucesso para '{missing_field}' ausente: E-mail n√£o enviado e erro logado.")
    print("  Todos os cen√°rios de credenciais ausentes verificados.")

# ========================
# --- Testes de Funcionalidade para `send_email_async` ---
# ========================
async def test_send_email_async_with_html_template_calls_fastapi_mail_correctly(mocker):
    """
    Testa se `send_email_async` chama `fm.send_message` (de `fastapi-mail`)
    corretamente quando um template HTML √© especificado.
    """
    print("\nTeste: send_email_async com template HTML.")
    # --- Arrange ---
    mock_fastapi_mail_send_message = mocker.patch("app.core.email.fm.send_message", new_callable=AsyncMock)
    mocker.patch.object(settings, 'MAIL_ENABLED', True)
    mocker.patch.object(settings, 'MAIL_USERNAME', 'test_user_template')
    mocker.patch.object(settings, 'MAIL_PASSWORD', 'test_pass_template')
    mocker.patch.object(settings, 'MAIL_FROM', 'sender_template@example.com') # type: ignore
    mocker.patch.object(settings, 'MAIL_SERVER', 'smtp.template.example.com')
    mocker.patch.object(settings, 'MAIL_PORT', 587)
    mock_email_module_logger_info = mocker.patch("app.core.email.logger.info")
    print("  Mock: fm.send_message, settings de e-mail (habilitado), logger.info.")

    test_subject = "Assunto do E-mail com Template HTML"
    test_recipient = "recipient_html@example.com" # type: ignore
    test_body_dict_for_template = {"user_name": "Claudio", "item_name": "SmartTask"}
    test_template_file_name = "meu_template_email.html"

    # --- Act ---
    print(f"  Atuando: Chamando send_email_async com template '{test_template_file_name}'...")
    await send_email_async(
        subject=test_subject,
        recipient_to=[test_recipient],
        body=test_body_dict_for_template,
        template_name=test_template_file_name
    )

    # --- Assert ---
    mock_fastapi_mail_send_message.assert_called_once()
    message_arg_schema: MessageSchema = mock_fastapi_mail_send_message.call_args[0][0]
    template_arg_name_from_kwargs = mock_fastapi_mail_send_message.call_args.kwargs.get('template_name')

    assert isinstance(message_arg_schema, MessageSchema)
    assert message_arg_schema.subject == test_subject
    assert message_arg_schema.recipients == [test_recipient]
    assert message_arg_schema.template_body == test_body_dict_for_template
    assert message_arg_schema.body is None
    assert message_arg_schema.subtype == MessageType.html
    assert template_arg_name_from_kwargs == test_template_file_name
    assert mock_email_module_logger_info.call_count >= 2
    print(f"  Sucesso: fm.send_message chamado corretamente para template HTML.")


async def test_send_email_async_with_plain_text_calls_fastapi_mail_correctly(mocker):
    """
    Testa se `send_email_async` chama `fm.send_message` (de `fastapi-mail`)
    corretamente quando um corpo de e-mail em texto puro √© especificado.
    """
    print("\nTeste: send_email_async com texto puro.")
    # --- Arrange ---
    mock_fastapi_mail_send_message = mocker.patch("app.core.email.fm.send_message", new_callable=AsyncMock)
    mocker.patch.object(settings, 'MAIL_ENABLED', True)
    mocker.patch.object(settings, 'MAIL_USERNAME', 'test_user_plain')
    mocker.patch.object(settings, 'MAIL_PASSWORD', 'test_pass_plain')
    mocker.patch.object(settings, 'MAIL_FROM', 'sender_plain@example.com') # type: ignore
    mocker.patch.object(settings, 'MAIL_SERVER', 'smtp.plain.example.com')
    mocker.patch.object(settings, 'MAIL_PORT', 587)
    mock_email_module_logger_info = mocker.patch("app.core.email.logger.info")
    print("  Mock: fm.send_message, settings de e-mail (habilitado), logger.info.")

    test_subject = "Assunto do E-mail em Texto Puro"
    test_recipient = "recipient_plain@example.com" # type: ignore
    test_plain_body_content = "Este √© o corpo do e-mail em texto puro.\nCom m√∫ltiplas linhas."

    # --- Act ---
    print(f"  Atuando: Chamando send_email_async com texto puro...")
    await send_email_async(
        subject=test_subject,
        recipient_to=[test_recipient],
        body=None,
        plain_text_body=test_plain_body_content
    )

    # --- Assert ---
    mock_fastapi_mail_send_message.assert_called_once()
    message_arg_schema: MessageSchema = mock_fastapi_mail_send_message.call_args[0][0]
    template_arg_name_from_kwargs = mock_fastapi_mail_send_message.call_args.kwargs.get('template_name')

    assert isinstance(message_arg_schema, MessageSchema)
    assert message_arg_schema.subject == test_subject
    assert message_arg_schema.recipients == [test_recipient]
    assert message_arg_schema.template_body is None
    assert message_arg_schema.body == test_plain_body_content
    assert message_arg_schema.subtype == MessageType.plain
    assert template_arg_name_from_kwargs is None
    assert mock_email_module_logger_info.call_count >= 2
    print(f"  Sucesso: fm.send_message chamado corretamente para texto puro.")


async def test_send_email_async_handles_exception_from_fastapi_mail(mocker):
    """
    Testa o tratamento de erro em `send_email_async` quando a chamada
    a `fm.send_message` (de `fastapi-mail`) levanta uma exce√ß√£o (ex: erro SMTP).
    """
    print("\nTeste: send_email_async tratando exce√ß√£o do fm.send_message.")
    # --- Arrange ---
    simulated_smtp_error_message = "Simulated SMTP Connection Error (535 Authentication credentials invalid)"
    mock_fastapi_mail_send_message = mocker.patch(
        "app.core.email.fm.send_message",
        new_callable=AsyncMock,
        side_effect=Exception(simulated_smtp_error_message)
    )
    mocker.patch.object(settings, 'MAIL_ENABLED', True)
    mocker.patch.object(settings, 'MAIL_USERNAME', 'user_excp')
    mocker.patch.object(settings, 'MAIL_PASSWORD', 'pass_excp')
    mocker.patch.object(settings, 'MAIL_FROM', 'sender_excp@example.com') # type: ignore
    mocker.patch.object(settings, 'MAIL_SERVER', 'smtp.excp.example.com')
    mocker.patch.object(settings, 'MAIL_PORT', 587)
    mock_email_module_logger_exception = mocker.patch("app.core.email.logger.exception")
    print("  Mock: fm.send_message (para levantar erro), settings, logger.exception.")

    test_recipient_list = ["recipient_error@example.com"] # type: ignore

    # --- Act ---
    print(f"  Atuando: Chamando send_email_async (esperando que fm.send_message falhe)...")
    await send_email_async(
        subject="E-mail de Teste de Erro de Envio",
        recipient_to=test_recipient_list,
        body={"info": "Este envio deve falhar e ser logado."}
    )

    # --- Assert ---
    mock_fastapi_mail_send_message.assert_called_once()
    mock_email_module_logger_exception.assert_called_once()

    log_message_args = mock_email_module_logger_exception.call_args[0]
    logged_error_message_str = log_message_args[0]

    assert f"Erro ao enviar e-mail para {test_recipient_list}" in logged_error_message_str
    assert simulated_smtp_error_message in logged_error_message_str or \
           simulated_smtp_error_message in str(mock_email_module_logger_exception.call_args.kwargs.get('exc_info'))
    print("  Sucesso: Exce√ß√£o do fm.send_message tratada e logada corretamente.")

# ========================
# --- Testes Unit√°rios para `send_urgent_task_notification` ---
# ========================
@pytest.fixture(autouse=True)
def auto_mock_send_email_async_for_urgent_tests(mocker) -> AsyncMock:
    """
    Fixture que mocka automaticamente `app.core.email.send_email_async`
    para todos os testes de `send_urgent_task_notification` neste arquivo.
    """
    print("  Fixture (autouse): Mockando app.core.email.send_email_async.")
    mocked_function = mocker.patch("app.core.email.send_email_async", new_callable=AsyncMock)
    return mocked_function


async def test_send_urgent_task_notification_constructs_correct_arguments(
    auto_mock_send_email_async_for_urgent_tests: AsyncMock,
    mocker
):
    """
    Verifica se `send_urgent_task_notification` chama `send_email_async`
    com os argumentos corretos (assunto, destinat√°rio, nome do template, e corpo do template)
    quando todos os dados de entrada s√£o fornecidos.
    """
    print("\nTeste: send_urgent_task_notification com todos os dados e FRONTEND_URL.")
    # --- Arrange ---
    test_frontend_base_url = "http://smarttask.dev"
    mocker.patch.object(settings, 'FRONTEND_URL', test_frontend_base_url)
    print(f"  Mock: settings.FRONTEND_URL='{test_frontend_base_url}'.")

    user_email_addr = "urgent_user@example.com" # type: ignore
    user_full_name = "Urgent User Name"
    task_display_title = "URGENT: Resolver bug cr√≠tico na API!"
    task_unique_id = str(uuid.uuid4())
    task_due_date_str = "2025-01-01"
    task_priority_score_float = 123.456

    # --- Act ---
    print("  Atuando: Chamando send_urgent_task_notification...")
    await email_module.send_urgent_task_notification( # Chamada qualificada com nome do m√≥dulo
        user_email=user_email_addr,
        user_name=user_full_name,
        task_title=task_display_title,
        task_id=task_unique_id,
        task_due_date=task_due_date_str,
        priority_score=task_priority_score_float
    )

    # --- Assert ---
    auto_mock_send_email_async_for_urgent_tests.assert_awaited_once()

    called_with_kwargs = auto_mock_send_email_async_for_urgent_tests.call_args.kwargs
    print(f"  Argumentos passados para send_email_async (mock): {called_with_kwargs}")

    assert called_with_kwargs.get("subject") == f"üö® Tarefa Urgente no SmartTask: {task_display_title}"
    assert called_with_kwargs.get("recipient_to") == [user_email_addr]
    assert called_with_kwargs.get("template_name") == "urgent_task.html"
    assert called_with_kwargs.get("plain_text_body") is not None

    template_body_dict = called_with_kwargs.get("body")
    assert isinstance(template_body_dict, dict)
    assert template_body_dict.get("task_title") == task_display_title
    assert template_body_dict.get("user_name") == user_full_name
    assert template_body_dict.get("due_date") == task_due_date_str
    assert template_body_dict.get("priority_score") == f"{task_priority_score_float:.2f}"
    assert template_body_dict.get("task_link") == f"{test_frontend_base_url}/tasks/{task_unique_id}"
    assert template_body_dict.get("project_name") == settings.PROJECT_NAME
    print("  Sucesso: send_urgent_task_notification passou os argumentos corretos para send_email_async.")


async def test_send_urgent_task_notification_handles_no_due_date_and_no_frontend_url(
    auto_mock_send_email_async_for_urgent_tests: AsyncMock,
    mocker
):
    """
    Verifica se `send_urgent_task_notification` lida corretamente com cen√°rios
    onde `task_due_date` √© None e `settings.FRONTEND_URL` n√£o est√° definida.
    O `due_date` no corpo do template deve ser "N/A" e `task_link` deve ser None.
    """
    print("\nTeste: send_urgent_task_notification sem due_date e sem FRONTEND_URL.")
    # --- Arrange ---
    mocker.patch.object(settings, 'FRONTEND_URL', None)
    print("  Mock: settings.FRONTEND_URL=None.")

    user_email_addr = "nodate_nolink_user@example.com" # type: ignore
    user_full_name = "User Without Due Date"
    task_display_title = "Tarefa Opcional Sem Prazo ou Link"
    task_unique_id = str(uuid.uuid4())
    task_priority_score_float = 500.0

    # --- Act ---
    print("  Atuando: Chamando send_urgent_task_notification com task_due_date=None...")
    await email_module.send_urgent_task_notification( # Chamada qualificada
        user_email=user_email_addr,
        user_name=user_full_name,
        task_title=task_display_title,
        task_id=task_unique_id,
        task_due_date=None,
        priority_score=task_priority_score_float
    )

    # --- Assert ---
    auto_mock_send_email_async_for_urgent_tests.assert_awaited_once()
    called_with_kwargs = auto_mock_send_email_async_for_urgent_tests.call_args.kwargs
    print(f"  Argumentos passados (body): {called_with_kwargs.get('body')}")

    assert called_with_kwargs.get("recipient_to") == [user_email_addr]
    template_body_dict = called_with_kwargs.get("body")
    assert isinstance(template_body_dict, dict)
    assert template_body_dict.get("due_date") == "N/A"
    assert template_body_dict.get("task_link") is None
    print("  Sucesso: Cen√°rio sem due_date e FRONTEND_URL tratado corretamente.")

================================================================================
Cap√≠tulo 22: tests/test_core_security.py
================================================================================

# tests/test_core_security.py
"""
Este m√≥dulo cont√©m testes unit√°rios para as fun√ß√µes de seguran√ßa relacionadas
a senhas e tokens JWT, definidas em `app.core.security`.

As fun√ß√µes testadas s√£o:
- `get_password_hash`: Para gerar o hash de uma senha.
- `verify_password`: Para verificar uma senha em texto puro contra um hash existente.
- `create_access_token`: Para gerar tokens JWT.
- `decode_token`: Para decodificar e validar tokens JWT.

Os testes cobrem cen√°rios de sucesso e falha.
"""

# ========================
# --- Importa√ß√µes ---
# ========================
from typing import Optional # Mantido, pode ser usado por outros testes ou fixtures no arquivo.
# from venv import logger # Removido, pois logger de 'venv' n√£o parece ser o pretendido.
import pytest
from datetime import datetime, timedelta, timezone
from jose import ExpiredSignatureError, jwt # jwt (objeto) usado, ExpiredSignatureError para mock.
import uuid
import logging # Adicionado para caplog.set_level, se usado.

# --- M√≥dulos da Aplica√ß√£o ---
from app.core.config import settings
from app.core.security import ALGORITHM, decode_token, get_password_hash, verify_password, create_access_token
# TokenPayload importado implicitamente via decode_token, ou n√£o necess√°rio no teste.

# ========================
# --- Constantes de Teste ---
# ========================
TEST_PLAIN_PASSWORD = "!@#$_uma_SENHA_extremamente_SEGURA_para_TESTES_!@#$"
TEST_USER_ID_JWT = str(uuid.uuid4())
TEST_USERNAME_JWT = "test_jwt_user"
CUSTOM_EXPIRATION_MINUTES = 15

# ========================
# --- Testes para `get_password_hash` ---
# ========================
def test_get_password_hash_returns_non_empty_string_different_from_plain_password():
    """
    Testa se a fun√ß√£o `get_password_hash`:
    1. Retorna uma string.
    2. A string n√£o √© vazia.
    3. O hash retornado √© diferente da senha original em texto puro.
    """
    print(f"\nTeste: get_password_hash com senha: '{TEST_PLAIN_PASSWORD}'")

    # --- Act: Gerar o hash da senha ---
    generated_hash = get_password_hash(TEST_PLAIN_PASSWORD)
    print(f"  Hash gerado: '{generated_hash[:20]}...' (parcial para brevidade)")

    # --- Assert: Verificar as propriedades do hash ---
    assert isinstance(generated_hash, str), "O hash retornado n√£o √© uma string."
    assert len(generated_hash) > 0, "O hash retornado est√° vazio."
    assert generated_hash != TEST_PLAIN_PASSWORD, "O hash retornado √© igual √† senha original (n√£o deveria)."
    print("  Sucesso: Hash gerado √© uma string n√£o vazia e diferente da senha original.")

def test_get_password_hash_generates_different_hashes_for_same_password_due_to_salt():
    """
    Testa se `get_password_hash` gera hashes diferentes para a mesma senha
    quando chamada m√∫ltiplas vezes. Isso demonstra o uso correto de "salts"
    na fun√ß√£o de hashing.

    Tamb√©m verifica se ambos os hashes gerados s√£o v√°lidos para a senha original.
    """
    print(f"\nTeste: get_password_hash gera hashes diferentes para a mesma senha: '{TEST_PLAIN_PASSWORD}'")

    # --- Act: Gerar dois hashes para a mesma senha ---
    hash1 = get_password_hash(TEST_PLAIN_PASSWORD)
    hash2 = get_password_hash(TEST_PLAIN_PASSWORD)
    print(f"  Hash 1: '{hash1[:20]}...'")
    print(f"  Hash 2: '{hash2[:20]}...'")

    # --- Assert: Verificar as propriedades ---
    assert hash1 != hash2, "Os dois hashes gerados para a mesma senha s√£o iguais (o salt pode n√£o estar funcionando)."
    assert verify_password(TEST_PLAIN_PASSWORD, hash1) is True, "O primeiro hash n√£o p√¥de ser verificado com a senha original."
    assert verify_password(TEST_PLAIN_PASSWORD, hash2) is True, "O segundo hash n√£o p√¥de ser verificado com a senha original."
    print("  Sucesso: Hashes diferentes foram gerados e ambos s√£o v√°lidos.")

# ========================
# --- Testes para `verify_password` ---
# ========================
def test_verify_password_with_correct_password_succeeds():
    """
    Testa se `verify_password` retorna `True` quando a senha correta em
    texto puro √© fornecida para um hash correspondente.
    """
    print(f"\nTeste: verify_password com senha correta: '{TEST_PLAIN_PASSWORD}'")
    # --- Arrange: Gerar um hash para a senha de teste ---
    password_hash = get_password_hash(TEST_PLAIN_PASSWORD)
    print(f"  Hash para verifica√ß√£o: '{password_hash[:20]}...'")

    # --- Act & Assert: Verificar a senha correta ---
    is_valid = verify_password(TEST_PLAIN_PASSWORD, password_hash)
    assert is_valid is True, "A verifica√ß√£o com a senha correta falhou (deveria ser True)."
    print("  Sucesso: Verifica√ß√£o com senha correta retornou True.")

def test_verify_password_with_incorrect_password_fails():
    """
    Testa se `verify_password` retorna `False` quando uma senha incorreta
    em texto puro √© fornecida para um hash.
    """
    # --- Arrange ---
    incorrect_test_password = "esta_e_uma_senha_errada_!"
    print(f"\nTeste: verify_password com senha incorreta: '{incorrect_test_password}'")
    password_hash = get_password_hash(TEST_PLAIN_PASSWORD)
    print(f"  Hash (da senha correta '{TEST_PLAIN_PASSWORD}'): '{password_hash[:20]}...'")

    # --- Act & Assert: Verificar a senha incorreta ---
    is_valid = verify_password(incorrect_test_password, password_hash)
    assert is_valid is False, "A verifica√ß√£o com senha incorreta passou (deveria ser False)."
    print("  Sucesso: Verifica√ß√£o com senha incorreta retornou False.")

def test_verify_password_with_empty_plain_password_fails():
    """
    Testa se `verify_password` retorna `False` quando uma senha vazia
    em texto puro √© fornecida, mesmo contra um hash de uma senha n√£o vazia.
    """
    # --- Arrange ---
    empty_password = ""
    print(f"\nTeste: verify_password com senha vazia em texto puro ('{empty_password}')")
    password_hash = get_password_hash(TEST_PLAIN_PASSWORD)
    print(f"  Hash (da senha correta '{TEST_PLAIN_PASSWORD}'): '{password_hash[:20]}...'")

    # --- Act & Assert: Verificar a senha vazia ---
    is_valid = verify_password(empty_password, password_hash)
    assert is_valid is False, "A verifica√ß√£o com senha vazia passou (deveria ser False)."
    print("  Sucesso: Verifica√ß√£o com senha vazia retornou False.")

def test_verify_password_with_plain_password_against_empty_hash_string_fails():
    """
    Testa se `verify_password` retorna `False` quando a string de hash fornecida √© vazia.
    """
    # --- Arrange ---
    empty_hash_string = ""
    print(f"\nTeste: verify_password com string de hash vazia ('{empty_hash_string}')")

    # --- Act & Assert: Verificar senha contra hash vazio ---
    is_valid = verify_password(TEST_PLAIN_PASSWORD, empty_hash_string)
    assert is_valid is False, \
        "A verifica√ß√£o contra um hash vazio deveria retornar False (ou a biblioteca pode ter outro comportamento)."
    print("  Sucesso: Verifica√ß√£o contra hash vazio retornou False.")

def test_verify_password_with_invalid_hash_format_fails():
    """
    Testa se `verify_password` retorna `False` quando a string de hash fornecida
    n√£o √© um formato de hash bcrypt v√°lido.
    """
    # --- Arrange ---
    invalid_hash_string = "isto_claramente_nao_e_um_hash_bcrypt_valido_$"
    print(f"\nTeste: verify_password com formato de hash inv√°lido: '{invalid_hash_string}'")

    # --- Act & Assert: Verificar senha contra hash inv√°lido ---
    is_valid = verify_password(TEST_PLAIN_PASSWORD, invalid_hash_string)
    assert is_valid is False, \
        "A verifica√ß√£o contra um hash de formato inv√°lido deveria retornar False."
    print("  Sucesso: Verifica√ß√£o contra hash de formato inv√°lido retornou False.")

# ========================
# --- Testes para JWT (create_access_token, decode_token) ---
# ========================
def test_create_access_token_with_custom_expires_delta():
    """
    Testa se `create_access_token` utiliza o `expires_delta` fornecido
    para definir o tempo de expira√ß√£o do token.
    """
    print(f"\nTeste: create_access_token com expires_delta customizado")
    # --- Arrange ---
    custom_delta = timedelta(minutes=CUSTOM_EXPIRATION_MINUTES)
    start_time = datetime.now(timezone.utc)

    # --- Act: Criar o token com expires_delta customizado ---
    token = create_access_token(
        subject=TEST_USER_ID_JWT,
        username=TEST_USERNAME_JWT,
        expires_delta=custom_delta
    )
    end_time = datetime.now(timezone.utc) # Captura tempo ap√≥s cria√ß√£o para margem
    print(f"  Token gerado: '{token[:20]}...'")

    # --- Assert: Decodificar e verificar o payload e a expira√ß√£o ---
    assert token is not None, "Token n√£o deveria ser None."
    assert isinstance(token, str), "Token deveria ser uma string."
    try:
        payload = jwt.decode(
            token,
            settings.JWT_SECRET_KEY,
            algorithms=[settings.JWT_ALGORITHM] # Usando settings.JWT_ALGORITHM para consist√™ncia
        )
        print(f"  Payload decodificado: {payload}")
        expected_sub = str(TEST_USER_ID_JWT)
        assert payload.get("sub") == expected_sub
        assert payload.get("username") == TEST_USERNAME_JWT
        exp_timestamp = payload.get("exp")
        assert exp_timestamp is not None
        token_expiration_time = datetime.fromtimestamp(exp_timestamp, tz=timezone.utc)
        # Verifica√ß√£o da expira√ß√£o com uma pequena margem de toler√¢ncia
        expected_expire_earliest = start_time + custom_delta
        expected_expire_latest = end_time + custom_delta
        assert expected_expire_earliest - timedelta(seconds=5) <= token_expiration_time <= expected_expire_latest + timedelta(seconds=5)
        print(f"  Sucesso: Token criado com expires_delta customizado e claims corretos.")
    except jwt.JWTError as e: # pragma: no cover (N√£o esperado neste teste)
        pytest.fail(f"Falha ao decodificar o token gerado: {e}")

def test_decode_token_with_expired_token_returns_none_and_logs(caplog):
    """
    Testa se `decode_token` retorna `None` e registra um log informativo
    quando um token JWT sintaticamente v√°lido, mas expirado, √© fornecido.
    """
    print(f"\nTeste: decode_token com token expirado")
    # --- Arrange: Criar um token que j√° est√° expirado ---
    expired_delta = timedelta(hours=-1)
    expire_time = datetime.now(timezone.utc) + expired_delta
    to_encode = {
        "exp": expire_time,
        "sub": str(TEST_USER_ID_JWT),
        "username": TEST_USERNAME_JWT,
    }
    expired_token = jwt.encode(
        to_encode,
        settings.JWT_SECRET_KEY,
        algorithm=ALGORITHM # ALGORITHM j√° √© settings.JWT_ALGORITHM
    )
    print(f"  Token expirado gerado: '{expired_token[:20]}...'")
    # caplog.set_level(logging.INFO, logger="app.core.security") # Opcional

    # --- Act: Tentar decodificar o token expirado ---
    decoded_payload = decode_token(expired_token)

    # --- Assert: Verificar se o resultado √© None e o log foi feito ---
    assert decoded_payload is None, "Token expirado deveria resultar em None."
    log_messages = [record.getMessage() for record in caplog.records if record.name == 'app.core.security']
    assert any("Token JWT expirado (verifica√ß√£o dupla)." in message for message in log_messages), \
        "Mensagem de log para token expirado n√£o encontrada."
    print("  Sucesso: decode_token retornou None para token expirado e logou a informa√ß√£o.")

def test_decode_token_without_expiration_claim(caplog):
    """
    Testa se `decode_token` processa corretamente um token v√°lido
    que n√£o possui o claim 'exp'.
    """
    print("\nTeste: decode_token com token v√°lido sem claim 'exp'")
    # --- Arrange ---
    user_id_as_string = str(uuid.uuid4())
    to_encode_no_exp = {
        "sub": user_id_as_string,
        "username": TEST_USERNAME_JWT,
    }
    token_no_exp = jwt.encode(
        to_encode_no_exp,
        settings.JWT_SECRET_KEY,
        algorithm=ALGORITHM
    )
    print(f"  Token sem 'exp' gerado: '{token_no_exp[:20]}...'")

    # --- Act ---
    decoded_payload = decode_token(token_no_exp)

    # --- Assert ---
    assert decoded_payload is not None, "Token sem 'exp' deveria ser decodificado se 'exp' √© opcional."
    assert str(decoded_payload.sub) == user_id_as_string
    assert decoded_payload.username == TEST_USERNAME_JWT
    assert decoded_payload.exp is None, "O campo 'exp' do payload deveria ser None."
    # Verifica se o log de "expirado" N√ÉO foi emitido
    assert not any("Token JWT expirado (verifica√ß√£o dupla)." in record.getMessage() for record in caplog.records if record.name == 'app.core.security'), \
        "Log de token expirado n√£o deveria ser emitido para token sem claim 'exp'."
    print("  Sucesso: decode_token processou token sem 'exp' e retornou payload.")

def test_decode_token_handles_direct_expired_signature_error_from_jose(mocker, caplog):
    """
    Testa o tratamento do bloco `except ExpiredSignatureError` em `decode_token`.
    """
    print("\nTeste: decode_token com ExpiredSignatureError direta do jose")
    # --- Arrange ---
    some_token_string = "um.token.qualquer_expirado_simulado"
    mocked_jwt_decode = mocker.patch("app.core.security.jwt.decode", side_effect=ExpiredSignatureError("Simulated JOSE expiration"))
    # caplog.set_level(logging.WARNING, logger="app.core.security") # Opcional

    # --- Act ---
    decoded_payload = decode_token(some_token_string)

    # --- Assert ---
    assert decoded_payload is None, "Deveria retornar None quando ExpiredSignatureError √© capturada."
    mocked_jwt_decode.assert_called_once_with(
        some_token_string,
        settings.JWT_SECRET_KEY,
        algorithms=[ALGORITHM],
        options={"verify_exp": False}
    )
    log_messages = [record.getMessage() for record in caplog.records if record.name == 'app.core.security']
    assert any("Token JWT detectado como expirado pela biblioteca JOSE" in message for message in log_messages), \
        "Mensagem de log esperada para ExpiredSignatureError n√£o encontrada."
    print("  Sucesso: decode_token lidou com ExpiredSignatureError direta e logou corretamente.")

================================================================================
Cap√≠tulo 23: tests/test_core_utils.py
================================================================================

# tests/test_core_utils.py
"""
Este m√≥dulo cont√©m testes unit√°rios para as fun√ß√µes utilit√°rias definidas
em `app.core.utils`, especificamente aquelas relacionadas √† l√≥gica de
neg√≥cios de tarefas, como c√°lculo de pontua√ß√£o de prioridade e
identifica√ß√£o de tarefas urgentes.

Os testes utilizam `freezegun` para mockar a data/hora atual, permitindo
testes consistentes e previs√≠veis de funcionalidades baseadas em datas.
"""

# ========================
# --- Importa√ß√µes ---
# ========================
import uuid
from datetime import date, datetime, timedelta, timezone

import pytest
from freezegun import freeze_time

# --- M√≥dulos da Aplica√ß√£o ---
from app.core.config import settings
from app.core.utils import calculate_priority_score, is_task_urgent
from app.models.task import Task, TaskStatus # TaskStatus √© usado aqui

# ========================
# --- Testes para `calculate_priority_score` ---
# ========================
def test_calculate_priority_score_with_invalid_importance_returns_none():
    """
    Testa se `calculate_priority_score` retorna `None` (ou o valor default se alterado na fun√ß√£o)
    quando o valor de `importance` fornecido est√° fora do intervalo v√°lido (1-5).
    """
    print("\nTeste: calculate_priority_score com import√¢ncia inv√°lida.")
    # --- Arrange & Act ---
    score_low_importance = calculate_priority_score(importance=0, due_date=None)
    print(f"  Score para import√¢ncia 0: {score_low_importance}")
    # --- Assert ---
    assert score_low_importance is None, "Score deveria ser None para import√¢ncia 0."

    # --- Arrange & Act ---
    score_high_importance = calculate_priority_score(importance=6, due_date=None)
    print(f"  Score para import√¢ncia 6: {score_high_importance}")
    # --- Assert ---
    assert score_high_importance is None, "Score deveria ser None para import√¢ncia 6."
    print("  Sucesso: Import√¢ncia inv√°lida resulta em score None.")


@freeze_time("2025-05-04")
def test_calculate_priority_score_with_no_due_date():
    """
    Testa o c√°lculo da pontua√ß√£o de prioridade quando a tarefa n√£o tem data de entrega (`due_date=None`).
    A pontua√ß√£o deve ser baseada no `PRIORITY_DEFAULT_SCORE_NO_DUE_DATE` mais o peso da import√¢ncia.
    """
    print("\nTeste: calculate_priority_score sem data de entrega (due_date=None) em 2025-05-04.")
    # --- Cen√°rio 1 ---
    importance_3 = 3
    expected_score_importance_3 = (settings.PRIORITY_DEFAULT_SCORE_NO_DUE_DATE or 0.0) + \
                                 (importance_3 * settings.PRIORITY_WEIGHT_IMPORTANCE)
    actual_score_importance_3 = calculate_priority_score(importance=importance_3, due_date=None)
    print(f"  Import√¢ncia 3: Score esperado={expected_score_importance_3:.2f}, "
          f"Calculado={actual_score_importance_3}")
    assert actual_score_importance_3 == round(expected_score_importance_3, 2)

    # --- Cen√°rio 2 ---
    importance_5 = 5
    expected_score_importance_5 = (settings.PRIORITY_DEFAULT_SCORE_NO_DUE_DATE or 0.0) + \
                                 (importance_5 * settings.PRIORITY_WEIGHT_IMPORTANCE)
    actual_score_importance_5 = calculate_priority_score(importance=importance_5, due_date=None)
    print(f"  Import√¢ncia 5: Score esperado={expected_score_importance_5:.2f}, "
          f"Calculado={actual_score_importance_5}")
    assert actual_score_importance_5 == round(expected_score_importance_5, 2)
    print("  Sucesso: Scores para tarefas sem data de entrega calculados corretamente.")


@freeze_time("2025-05-04")
def test_calculate_priority_score_with_due_date_today():
    """
    Testa o c√°lculo da pontua√ß√£o de prioridade quando a data de entrega da tarefa √© hoje.
    """
    print("\nTeste: calculate_priority_score com data de entrega HOJE (2025-05-04).")
    # --- Arrange ---
    due_date_is_today = date.today()
    test_importance = 4
    days_factor_for_today = 1.0
    expected_score = (settings.PRIORITY_WEIGHT_DUE_DATE / days_factor_for_today) + \
                     (test_importance * settings.PRIORITY_WEIGHT_IMPORTANCE)
    # --- Act ---
    actual_score = calculate_priority_score(importance=test_importance, due_date=due_date_is_today)
    # --- Assert ---
    print(f"  Import√¢ncia {test_importance}, Due Date Hoje: Score esperado={expected_score:.2f}, "
          f"Calculado={actual_score}")
    assert actual_score == round(expected_score, 2)
    print("  Sucesso: Score para tarefa com entrega hoje calculado corretamente.")


@freeze_time("2025-05-04")
def test_calculate_priority_score_with_due_date_in_future():
    """
    Testa o c√°lculo da pontua√ß√£o de prioridade quando a data de entrega da tarefa
    est√° no futuro (10 dias a partir de "hoje").
    """
    print("\nTeste: calculate_priority_score com data de entrega no FUTURO (2025-05-04 + 10 dias).")
    # --- Arrange ---
    due_date_in_future = date.today() + timedelta(days=10)
    test_importance = 2
    days_to_due = 10.0
    expected_score = (settings.PRIORITY_WEIGHT_DUE_DATE / days_to_due) + \
                     (test_importance * settings.PRIORITY_WEIGHT_IMPORTANCE)
    # --- Act ---
    actual_score = calculate_priority_score(importance=test_importance, due_date=due_date_in_future)
    # --- Assert ---
    print(f"  Import√¢ncia {test_importance}, Due Date em {days_to_due} dias: "
          f"Score esperado={expected_score:.2f}, Calculado={actual_score}")
    assert actual_score == round(expected_score, 2)
    print("  Sucesso: Score para tarefa com entrega futura calculado corretamente.")


@freeze_time("2025-05-04")
def test_calculate_priority_score_for_overdue_task():
    """
    Testa o c√°lculo da pontua√ß√£o de prioridade para uma tarefa que j√° est√° atrasada (5 dias).
    """
    print("\nTeste: calculate_priority_score para tarefa ATRASADA (2025-05-04 - 5 dias).")
    # --- Arrange ---
    overdue_date = date.today() - timedelta(days=5)
    test_importance = 5
    expected_score = settings.PRIORITY_SCORE_IF_OVERDUE + \
                     (test_importance * settings.PRIORITY_WEIGHT_IMPORTANCE)
    # --- Act ---
    actual_score = calculate_priority_score(importance=test_importance, due_date=overdue_date)
    # --- Assert ---
    print(f"  Import√¢ncia {test_importance}, Tarefa Atrasada: "
          f"Score esperado={expected_score:.2f}, Calculado={actual_score}")
    assert actual_score == round(expected_score, 2)
    print("  Sucesso: Score para tarefa atrasada calculado corretamente.")

# ========================
# --- Testes para `is_task_urgent` ---
# ========================
def _create_dummy_test_task(**kwargs) -> Task:
    """
    Fun√ß√£o auxiliar para criar inst√¢ncias de `Task` para os testes de `is_task_urgent`.
    """
    base_task_data = {
        "id": uuid.uuid4(),
        "owner_id": uuid.uuid4(),
        "title": "Tarefa de Teste Dummy",
        "description": "Descri√ß√£o da tarefa dummy.",
        "importance": 3,
        "status": TaskStatus.PENDING,
        "tags": None,
        "project": None,
        "created_at": datetime.now(timezone.utc),
        "updated_at": None,
        "due_date": None,
        "priority_score": None,
    }
    final_task_data = {**base_task_data, **kwargs}
    if final_task_data.get("priority_score") is None and \
       (final_task_data.get("importance") or final_task_data.get("due_date")):
        calc_importance = final_task_data.get("importance", base_task_data["importance"])
        final_task_data["priority_score"] = calculate_priority_score(
            importance=calc_importance,
            due_date=final_task_data.get("due_date")
        )
    try:
        return Task(**final_task_data)
    except Exception as e: # pragma: no cover
        print(f"Erro ao criar Dummy Task com dados: {final_task_data}. Erro: {e}")
        raise

def test_is_task_urgent_when_no_score_and_no_due_date():
    """
    Testa se uma tarefa sem pontua√ß√£o de prioridade e sem data de entrega
    N√ÉO √© considerada urgente.
    """
    print("\nTeste: is_task_urgent - Tarefa sem score e sem data de entrega.")
    # --- Arrange ---
    task_no_urgency_factors = _create_dummy_test_task(importance=3, priority_score=None, due_date=None)
    task_no_urgency_factors.priority_score = None # For√ßa o score para None
    print(f"  Tarefa para teste: score={task_no_urgency_factors.priority_score}, due_date={task_no_urgency_factors.due_date}")
    # --- Act ---
    is_urgent_result = is_task_urgent(task_no_urgency_factors)
    # --- Assert ---
    assert is_urgent_result is False, "Tarefa sem score nem data de entrega n√£o deveria ser urgente."
    print("  Sucesso: Tarefa sem fatores de urg√™ncia n√£o √© urgente.")

@freeze_time("2025-05-04")
def test_is_task_urgent_with_high_priority_score():
    """
    Testa se uma tarefa com `priority_score` acima do `EMAIL_URGENCY_THRESHOLD`
    √© considerada urgente, mesmo que a data de entrega n√£o seja iminente.
    """
    print("\nTeste: is_task_urgent - Tarefa com pontua√ß√£o de prioridade alta (acima do threshold).")
    # --- Arrange ---
    high_score = settings.EMAIL_URGENCY_THRESHOLD + 10.0
    task_high_score = _create_dummy_test_task(priority_score=high_score, due_date=date.today() + timedelta(days=30))
    print(f"  Tarefa: score={task_high_score.priority_score} (Threshold={settings.EMAIL_URGENCY_THRESHOLD}), due_date={task_high_score.due_date}")
    # --- Act ---
    is_urgent_result = is_task_urgent(task_high_score)
    # --- Assert ---
    assert is_urgent_result is True, "Tarefa com score alto deveria ser urgente."
    print("  Sucesso: Tarefa com score alto √© urgente.")

@freeze_time("2025-05-04")
def test_is_task_urgent_with_score_below_threshold_and_future_due_date():
    """
    Testa se uma tarefa com `priority_score` abaixo do `EMAIL_URGENCY_THRESHOLD`
    e com data de entrega no futuro N√ÉO √© considerada urgente.
    """
    print("\nTeste: is_task_urgent - Score baixo e data de entrega futura.")
    # --- Arrange ---
    low_score = settings.EMAIL_URGENCY_THRESHOLD - 10.0
    due_date_in_future = date.today() + timedelta(days=10)
    task_low_score_future = _create_dummy_test_task(priority_score=low_score, due_date=due_date_in_future)
    print(f"  Tarefa: score={task_low_score_future.priority_score} (Threshold={settings.EMAIL_URGENCY_THRESHOLD}), "
          f"due_date={task_low_score_future.due_date}")
    # --- Act ---
    is_urgent_result = is_task_urgent(task_low_score_future)
    # --- Assert ---
    assert is_urgent_result is False, "Tarefa com score baixo e entrega futura n√£o deveria ser urgente."
    print("  Sucesso: Tarefa com score baixo e entrega futura n√£o √© urgente.")

@freeze_time("2025-05-04")
def test_is_task_urgent_when_due_date_is_today():
    """
    Testa se uma tarefa com data de entrega para HOJE √© considerada urgente,
    mesmo que sua `priority_score` esteja abaixo do `EMAIL_URGENCY_THRESHOLD`.
    """
    print("\nTeste: is_task_urgent - Data de entrega √© HOJE (2025-05-04).")
    # --- Arrange ---
    score_below_threshold = settings.EMAIL_URGENCY_THRESHOLD - 5.0
    due_date_is_today = date.today()
    task_due_today = _create_dummy_test_task(due_date=due_date_is_today, priority_score=score_below_threshold)
    print(f"  Tarefa: score={task_due_today.priority_score}, due_date={task_due_today.due_date}")
    # --- Act ---
    is_urgent_result = is_task_urgent(task_due_today)
    # --- Assert ---
    assert is_urgent_result is True, "Tarefa com entrega hoje deveria ser urgente, independentemente do score."
    print("  Sucesso: Tarefa com entrega hoje √© urgente.")

@freeze_time("2025-05-04")
def test_is_task_urgent_when_overdue():
    """
    Testa se uma tarefa que est√° ATRASADA (data de entrega no passado) √© considerada urgente,
    mesmo que sua `priority_score` esteja abaixo do `EMAIL_URGENCY_THRESHOLD`.
    """
    print("\nTeste: is_task_urgent - Tarefa ATRASADA (entrega em 2025-05-03).")
    # --- Arrange ---
    score_below_threshold = settings.EMAIL_URGENCY_THRESHOLD - 15.0
    overdue_date = date.today() - timedelta(days=1)
    task_overdue = _create_dummy_test_task(due_date=overdue_date, priority_score=score_below_threshold)
    print(f"  Tarefa: score={task_overdue.priority_score}, due_date={task_overdue.due_date}")
    # --- Act ---
    is_urgent_result = is_task_urgent(task_overdue)
    # --- Assert ---
    assert is_urgent_result is True, "Tarefa atrasada deveria ser urgente."
    print("  Sucesso: Tarefa atrasada √© urgente.")

# ========================
# --- Testes de Casos de Borda para `is_task_urgent` ---
# ========================
@freeze_time("2025-05-04")
def test_is_task_urgent_when_score_is_exactly_at_threshold_and_due_date_is_future():
    """
    Testa o comportamento de `is_task_urgent` quando a `priority_score` √©
    EXATAMENTE igual ao `EMAIL_URGENCY_THRESHOLD` e a data de entrega est√° no futuro.
    """
    print("\nTeste de Borda: is_task_urgent - Score no limiar, entrega futura.")
    # --- Arrange ---
    score_at_threshold = settings.EMAIL_URGENCY_THRESHOLD
    due_date_in_future = date.today() + timedelta(days=5)
    task_at_threshold = _create_dummy_test_task(priority_score=score_at_threshold, due_date=due_date_in_future)
    if task_at_threshold.priority_score != score_at_threshold: # pragma: no cover (Defensivo)
        print(f"  AVISO: Score recalculado para {task_at_threshold.priority_score}")
        task_at_threshold.priority_score = score_at_threshold
    print(f"  Tarefa: score={task_at_threshold.priority_score} (Threshold={settings.EMAIL_URGENCY_THRESHOLD}), "
          f"due_date={task_at_threshold.due_date}")
    # --- Act ---
    is_urgent_result = is_task_urgent(task_at_threshold)
    # --- Assert ---
    assert is_urgent_result is False, \
        f"Tarefa com score no limiar ({task_at_threshold.priority_score}) e entrega futura n√£o deveria ser urgente."
    print("  Sucesso: Tarefa com score no limiar (e entrega futura) n√£o √© urgente.")

@freeze_time("2025-05-04")
def test_is_task_urgent_when_score_is_slightly_above_threshold_and_due_date_is_future():
    """
    Testa se `is_task_urgent` considera uma tarefa urgente quando sua `priority_score`
    √© LIGEIRAMENTE ACIMA do `EMAIL_URGENCY_THRESHOLD` e a data de entrega est√° no futuro.
    """
    print("\nTeste de Borda: is_task_urgent - Score ligeiramente acima do limiar, entrega futura.")
    # --- Arrange ---
    score_slightly_above_threshold = settings.EMAIL_URGENCY_THRESHOLD + 0.01
    due_date_in_future = date.today() + timedelta(days=5)
    task_above_threshold = _create_dummy_test_task(priority_score=score_slightly_above_threshold, due_date=due_date_in_future)
    if task_above_threshold.priority_score != score_slightly_above_threshold: # pragma: no cover (Defensivo)
         print(f"  AVISO: Score recalculado para {task_above_threshold.priority_score}")
         task_above_threshold.priority_score = score_slightly_above_threshold
    print(f"  Tarefa: score={task_above_threshold.priority_score} (Threshold={settings.EMAIL_URGENCY_THRESHOLD}), "
          f"due_date={task_above_threshold.due_date}")
    # --- Act ---
    is_urgent_result = is_task_urgent(task_above_threshold)
    # --- Assert ---
    assert is_urgent_result is True, \
        f"Tarefa com score ({task_above_threshold.priority_score}) ligeiramente acima do limiar deveria ser urgente."
    print("  Sucesso: Tarefa com score ligeiramente acima do limiar (e entrega futura) √© urgente.")

================================================================================
Cap√≠tulo 24: tests/test_core_utils_webhooks.py
================================================================================

# tests/test_core_utils_webhooks.py
"""
Este m√≥dulo cont√©m testes unit√°rios para a fun√ß√£o `send_webhook_notification`
localizada em `app.core.utils`.

Os testes utilizam `respx` para mockar as requisi√ß√µes HTTP externas,
permitindo testar o comportamento da fun√ß√£o sob diversas condi√ß√µes:
- Envio de webhook sem segredo (sem header de assinatura).
- Envio de webhook com segredo (com verifica√ß√£o da assinatura HMAC-SHA256).
- Tratamento de erros HTTP retornados pelo servidor do webhook (ex: 4xx, 5xx).
- Tratamento de erros de rede/conex√£o durante a tentativa de envio.
- Comportamento quando a URL do webhook n√£o est√° configurada nas settings.
"""

# ========================
# --- Importa√ß√µes ---
# ========================
import hashlib
import hmac
import json
from unittest.mock import AsyncMock, patch

import httpx
import pytest
import respx

# --- M√≥dulos da Aplica√ß√£o ---
from app.core.config import settings
from app.core.utils import send_webhook_notification

# ========================
# --- Marcador Global de Teste ---
# ========================
pytestmark = pytest.mark.asyncio

# ========================
# --- Constantes e Dados de Teste ---
# ========================
TEST_TASK_DATA_FOR_WEBHOOK = {
    "id": "f47ac10b-58cc-4372-a567-0e02b2c3d479",
    "owner_id": "a1b2c3d4-e5f6-7890-1234-567890abcdef",
    "title": "Tarefa de Teste para Webhook",
    "importance": 4,
    "status": "pendente_webhook_test",
}
TEST_EVENT_TYPE_WEBHOOK = "task.webhook_test_event"
TEST_WEBHOOK_TARGET_URL = "http://mocked-webhook-receiver.test/api/hook"

# ========================
# --- Fixtures de Teste ---
# ========================
@pytest.fixture(autouse=True)
def override_webhook_settings_for_tests(monkeypatch):
    """
    Fixture `autouse` que sobrescreve as configura√ß√µes globais de webhook
    (`settings.WEBHOOK_URL` e `settings.WEBHOOK_SECRET`) para cada teste neste m√≥dulo.
    """
    print("  Fixture (autouse): Configurando settings de webhook para testes...")
    monkeypatch.setattr(settings, 'WEBHOOK_URL', TEST_WEBHOOK_TARGET_URL)
    monkeypatch.setattr(settings, 'WEBHOOK_SECRET', None)
    print(f"    settings.WEBHOOK_URL mockado para: {TEST_WEBHOOK_TARGET_URL}")
    print(f"    settings.WEBHOOK_SECRET mockado para: None (inicialmente)")

# ========================
# --- Testes da Fun√ß√£o `send_webhook_notification` ---
# ========================
@respx.mock
async def test_send_webhook_successfully_without_secret():
    """
    Testa o envio bem-sucedido de uma notifica√ß√£o de webhook quando
    `settings.WEBHOOK_SECRET` N√ÉO est√° configurado.
    """
    print("\nTeste: send_webhook_notification - Envio bem-sucedido sem segredo.")
    # --- Arrange ---
    mocked_route = respx.post(TEST_WEBHOOK_TARGET_URL).mock(
        return_value=httpx.Response(200, json={"status": "webhook_received_ok"})
    )
    print(f"  Mock respx: Rota POST para '{TEST_WEBHOOK_TARGET_URL}' mockada para retornar 200.")

    # --- Act ---
    print("  Atuando: Chamando send_webhook_notification...")
    await send_webhook_notification(
        event_type=TEST_EVENT_TYPE_WEBHOOK,
        task_data=TEST_TASK_DATA_FOR_WEBHOOK
    )

    # --- Assert ---
    assert mocked_route.called, "A rota do webhook mockada n√£o foi chamada."
    assert respx.calls.call_count == 1, "N√∫mero de chamadas HTTP incorreto."

    last_request_made = respx.calls.last.request
    print(f"  Requisi√ß√£o enviada: URL='{last_request_made.url}', Headers='{last_request_made.headers}'")
    assert str(last_request_made.url) == TEST_WEBHOOK_TARGET_URL, "URL da requisi√ß√£o incorreta."

    sent_payload = json.loads(last_request_made.content)
    print(f"  Payload enviado: {sent_payload}")
    assert sent_payload.get("event") == TEST_EVENT_TYPE_WEBHOOK
    assert sent_payload.get("task") == TEST_TASK_DATA_FOR_WEBHOOK
    assert "timestamp" in sent_payload

    assert "X-SmartTask-Signature" not in last_request_made.headers
    print("  Sucesso: Webhook enviado corretamente sem header de assinatura.")

@respx.mock
async def test_send_webhook_successfully_with_secret_and_valid_signature(
    monkeypatch
):
    """
    Testa o envio bem-sucedido de notifica√ß√£o de webhook com `WEBHOOK_SECRET` configurado.
    """
    print("\nTeste: send_webhook_notification - Envio bem-sucedido com segredo e assinatura v√°lida.")
    # --- Arrange ---
    test_webhook_secret_key = "este-e-um-segredo-muito-secreto-para-hmac"
    monkeypatch.setattr(settings, 'WEBHOOK_SECRET', test_webhook_secret_key)
    print(f"  Mock monkeypatch: settings.WEBHOOK_SECRET definido para '{test_webhook_secret_key}'.")
    mocked_route = respx.post(TEST_WEBHOOK_TARGET_URL).mock(return_value=httpx.Response(200))
    print(f"  Mock respx: Rota POST para '{TEST_WEBHOOK_TARGET_URL}' mockada.")

    # --- Act ---
    print("  Atuando: Chamando send_webhook_notification...")
    await send_webhook_notification(
        event_type=TEST_EVENT_TYPE_WEBHOOK,
        task_data=TEST_TASK_DATA_FOR_WEBHOOK
    )

    # --- Assert ---
    assert mocked_route.called
    last_request_made = respx.calls.last.request
    assert "X-SmartTask-Signature" in last_request_made.headers
    signature_from_header = last_request_made.headers["X-SmartTask-Signature"]
    assert signature_from_header.startswith("sha256=")
    print(f"  Header de assinatura recebido: {signature_from_header}")

    sent_payload_bytes = last_request_made.content
    sent_payload_dict_actual = json.loads(sent_payload_bytes)
    actual_timestamp_sent = sent_payload_dict_actual["timestamp"]
    expected_payload_base = {"event": TEST_EVENT_TYPE_WEBHOOK, "task": TEST_TASK_DATA_FOR_WEBHOOK}
    payload_for_signature_calculation = expected_payload_base.copy()
    payload_for_signature_calculation["timestamp"] = actual_timestamp_sent
    payload_bytes_for_hmac = json.dumps(
        payload_for_signature_calculation, separators=(',', ':'), sort_keys=True
    ).encode('utf-8')
    secret_bytes_for_hmac = test_webhook_secret_key.encode('utf-8')
    expected_hmac_signature_hex = hmac.new(
        secret_bytes_for_hmac, payload_bytes_for_hmac, hashlib.sha256
    ).hexdigest()
    print(f"  Assinatura HMAC calculada esperada: {expected_hmac_signature_hex}")
    assert signature_from_header == f"sha256={expected_hmac_signature_hex}"
    print("  Sucesso: Webhook enviado com segredo e assinatura HMAC v√°lida.")

@respx.mock
async def test_send_webhook_handles_http_error_from_server(mocker):
    """
    Testa o tratamento de erro quando o servidor do webhook retorna um erro HTTP.
    """
    print("\nTeste: send_webhook_notification - Tratamento de erro HTTP do servidor.")
    # --- Arrange ---
    http_error_status_code = 500
    http_error_response_text = "Ocorreu um Erro Interno no Servidor do Webhook"
    respx.post(TEST_WEBHOOK_TARGET_URL).mock(
        return_value=httpx.Response(http_error_status_code, text=http_error_response_text)
    )
    print(f"  Mock respx: Rota POST para '{TEST_WEBHOOK_TARGET_URL}' mockada para retornar {http_error_status_code}.")
    mock_utils_logger = mocker.patch("app.core.utils.logger")
    print("  Mock: app.core.utils.logger.")

    # --- Act ---
    print("  Atuando: Chamando send_webhook_notification (esperando erro HTTP)...")
    await send_webhook_notification(TEST_EVENT_TYPE_WEBHOOK, TEST_TASK_DATA_FOR_WEBHOOK)

    # --- Assert ---
    mock_utils_logger.error.assert_called_once()
    error_log_args, _ = mock_utils_logger.error.call_args
    error_log_message = error_log_args[0]
    print(f"  Log de erro capturado: {error_log_message}")
    assert "Erro no servidor do webhook" in error_log_message
    assert f"({TEST_WEBHOOK_TARGET_URL})" in error_log_message
    assert f"Status: {http_error_status_code}" in error_log_message
    assert http_error_response_text in error_log_message
    print("  Sucesso: Erro HTTP do servidor tratado e logado corretamente.")

@respx.mock
async def test_send_webhook_handles_network_request_error(mocker):
    """
    Testa o tratamento de erro quando ocorre um problema de rede ou conex√£o.
    """
    print("\nTeste: send_webhook_notification - Tratamento de erro de rede/conex√£o.")
    # --- Arrange ---
    simulated_network_error_message = "Falha de conex√£o simulada (DNS lookup failed)"
    respx.post(TEST_WEBHOOK_TARGET_URL).mock(side_effect=httpx.RequestError(simulated_network_error_message))
    print(f"  Mock respx: Rota POST para '{TEST_WEBHOOK_TARGET_URL}' mockada para levantar httpx.RequestError.")
    mock_utils_logger = mocker.patch("app.core.utils.logger")
    print("  Mock: app.core.utils.logger.")

    # --- Act ---
    print("  Atuando: Chamando send_webhook_notification (esperando erro de rede)...")
    await send_webhook_notification(TEST_EVENT_TYPE_WEBHOOK, TEST_TASK_DATA_FOR_WEBHOOK)

    # --- Assert ---
    mock_utils_logger.error.assert_called_once()
    error_log_args, _ = mock_utils_logger.error.call_args
    error_log_message = error_log_args[0]
    print(f"  Log de erro capturado: {error_log_message}")
    assert "Erro na requisi√ß√£o ao enviar webhook para" in error_log_message
    assert TEST_WEBHOOK_TARGET_URL in error_log_message
    assert simulated_network_error_message in error_log_message
    print("  Sucesso: Erro de rede/conex√£o tratado e logado corretamente.")

async def test_send_webhook_does_nothing_if_url_not_configured(mocker):
    """
    Testa se `send_webhook_notification` n√£o faz nada se `settings.WEBHOOK_URL` n√£o estiver configurada.
    """
    print("\nTeste: send_webhook_notification - WEBHOOK_URL n√£o configurada.")
    # --- Arrange ---
    with patch('app.core.utils.settings.WEBHOOK_URL', None):
        print(f"  Mock patch: settings.WEBHOOK_URL definido como None para este teste.")
        mock_httpx_client_post = mocker.patch("httpx.AsyncClient.post", new_callable=AsyncMock)
        mock_utils_logger = mocker.patch("app.core.utils.logger")
        print("  Mock: httpx.AsyncClient.post e app.core.utils.logger.")

        # --- Act ---
        print("  Atuando: Chamando send_webhook_notification...")
        await send_webhook_notification(TEST_EVENT_TYPE_WEBHOOK, TEST_TASK_DATA_FOR_WEBHOOK)

        # --- Assert ---
        mock_httpx_client_post.assert_not_called()
        assert not mock_utils_logger.info.called
        assert not mock_utils_logger.error.called
        expected_debug_message = "Webhook URL n√£o configurada, pulando envio."
        mock_utils_logger.debug.assert_called_once_with(expected_debug_message)
        print("  Sucesso: Nenhuma tentativa de envio de webhook e log de debug correto quando URL n√£o configurada.")

@respx.mock
async def test_send_webhook_signature_generation_failure(mocker):
    """
    Testa o tratamento de erro quando a gera√ß√£o da assinatura HMAC falha.
    """
    print("\nTeste: send_webhook_notification - Falha na gera√ß√£o da assinatura HMAC.")
    # --- Arrange ---
    test_secret = "super_secret"
    mocker.patch.object(settings, 'WEBHOOK_SECRET', test_secret)
    mock_utils_logger = mocker.patch("app.core.utils.logger")
    mocker.patch("app.core.utils.hmac.new", side_effect=Exception("HMAC generation error"))

    # --- Act ---
    await send_webhook_notification(TEST_EVENT_TYPE_WEBHOOK, TEST_TASK_DATA_FOR_WEBHOOK)

    # --- Assert ---
    mock_utils_logger.error.assert_called_once()
    error_log_message = mock_utils_logger.error.call_args[0][0]
    assert "Erro ao gerar assinatura HMAC para webhook" in error_log_message
    assert "HMAC generation error" in error_log_message
    assert respx.calls.call_count == 0
    print("  Sucesso: Falha na gera√ß√£o de assinatura HMAC tratada e logada.")

@respx.mock
async def test_send_webhook_unexpected_generic_exception_during_send(mocker):
    """
    Testa o tratamento de uma exce√ß√£o gen√©rica inesperada durante o envio do webhook.
    """
    print("\nTeste: send_webhook_notification - Exce√ß√£o gen√©rica inesperada no envio.")
    # --- Arrange ---
    mock_utils_logger = mocker.patch("app.core.utils.logger")
    mock_post_method = AsyncMock(side_effect=Exception("Erro gen√©rico simulado no post"))
    mock_client_operations = AsyncMock()
    mock_client_operations.post = mock_post_method
    mock_client_context = AsyncMock()
    mock_client_context.__aenter__ = AsyncMock(return_value=mock_client_operations)
    mock_client_context.__aexit__ = AsyncMock(return_value=None)
    mocker.patch("httpx.AsyncClient", return_value=mock_client_context)

    # --- Act ---
    await send_webhook_notification(TEST_EVENT_TYPE_WEBHOOK, TEST_TASK_DATA_FOR_WEBHOOK)

    # --- Assert ---
    mock_utils_logger.exception.assert_called_once()
    exception_log_message = mock_utils_logger.exception.call_args[0][0]
    assert "Erro inesperado ao enviar webhook para" in exception_log_message
    assert "Erro gen√©rico simulado no post" in exception_log_message
    print("  Sucesso: Exce√ß√£o gen√©rica inesperada durante o envio tratada e logada com logger.exception.")

@respx.mock
async def test_send_webhook_handles_timeout_exception(mocker):
    """
    Testa o tratamento de erro quando ocorre um httpx.TimeoutException
    ao tentar enviar a notifica√ß√£o de webhook.
    """
    print("\nTeste: send_webhook_notification - Tratamento de httpx.TimeoutException.")
    # --- Arrange ---
    simulated_timeout_message = "Simulated timeout durante o envio do webhook"
    dummy_request_for_exception = httpx.Request(method="POST", url=TEST_WEBHOOK_TARGET_URL)
    respx.post(TEST_WEBHOOK_TARGET_URL).mock(
        side_effect=httpx.TimeoutException(simulated_timeout_message, request=dummy_request_for_exception)
    )
    print(f"  Mock respx: Rota POST para '{TEST_WEBHOOK_TARGET_URL}' mockada para levantar httpx.TimeoutException.")
    mock_utils_logger = mocker.patch("app.core.utils.logger")
    print("  Mock: app.core.utils.logger.")

    # --- Act ---
    print("  Atuando: Chamando send_webhook_notification (esperando timeout)...")
    await send_webhook_notification(TEST_EVENT_TYPE_WEBHOOK, TEST_TASK_DATA_FOR_WEBHOOK)

    # --- Assert ---
    mock_utils_logger.error.assert_called_once()
    error_log_args, _ = mock_utils_logger.error.call_args
    error_log_message = error_log_args[0]
    print(f"  Log de erro capturado: {error_log_message}")
    assert "Timeout ao enviar webhook para" in error_log_message
    assert TEST_WEBHOOK_TARGET_URL in error_log_message
    print("  Sucesso: httpx.TimeoutException tratado e logado corretamente.")

================================================================================
Cap√≠tulo 25: tests/test_db_mongodb_utils.py
================================================================================

# tests/test_db_mongodb_utils.py

# ========================
# --- Importa√ß√µes ---
# ========================
import pytest
from unittest.mock import AsyncMock, MagicMock, call, patch
from app.db import mongodb_utils # Importa o m√≥dulo para mockar e chamar

# ========================
# --- Testes para get_database ---
# ========================
def test_get_database_not_initialized(mocker):
    """
    Testa se get_database levanta RuntimeError quando db_instance √© None.
    """
    # --- Arrange ---
    mocker.patch("app.db.mongodb_utils.db_instance", None)
    mock_logger_error = mocker.patch("app.db.mongodb_utils.logger.error")

    # --- Act & Assert ---
    with pytest.raises(RuntimeError) as excinfo:
        mongodb_utils.get_database()

    assert "A conex√£o com o banco de dados n√£o foi inicializada" in str(excinfo.value)
    mock_logger_error.assert_called_once_with("Tentativa de obter inst√¢ncia do DB antes da inicializa√ß√£o!")

# ========================
# --- Testes para close_mongo_connection ---
# ========================
@pytest.mark.asyncio
async def test_close_mongo_connection_no_client(mocker):
    """
    Testa close_mongo_connection quando db_client global √© None.
    """
    # --- Arrange ---
    mocker.patch("app.db.mongodb_utils.db_client", None)
    mock_logger_warning = mocker.patch("app.db.mongodb_utils.logger.warning")
    mock_logger_info = mocker.patch("app.db.mongodb_utils.logger.info")

    # --- Act ---
    await mongodb_utils.close_mongo_connection()

    # --- Assert ---
    mock_logger_info.assert_any_call("Tentando fechar conex√£o com MongoDB...")
    mock_logger_warning.assert_called_once_with("Tentativa de fechar conex√£o com MongoDB, mas cliente n√£o estava inicializado.")
    # Verifica se o log de "conex√£o fechada" N√ÉO foi chamado
    log_info_calls = [c.args[0] for c in mock_logger_info.call_args_list if c.args]
    assert "Conex√£o com MongoDB fechada." not in log_info_calls

@pytest.mark.asyncio
async def test_close_mongo_connection_with_client(mocker):
    """
    Testa close_mongo_connection quando db_client existe.
    """
    # --- Arrange ---
    mock_client_instance = MagicMock()
    mocker.patch("app.db.mongodb_utils.db_client", mock_client_instance)
    mock_logger_info = mocker.patch("app.db.mongodb_utils.logger.info")
    mock_logger_warning = mocker.patch("app.db.mongodb_utils.logger.warning")

    # --- Act ---
    await mongodb_utils.close_mongo_connection()

    # --- Assert ---
    mock_client_instance.close.assert_called_once()
    assert call("Tentando fechar conex√£o com MongoDB...") in mock_logger_info.call_args_list
    assert call("Conex√£o com MongoDB fechada.") in mock_logger_info.call_args_list
    mock_logger_warning.assert_not_called()

# ========================
# --- Testes para connect_to_mongo ---
# ========================
@pytest.mark.asyncio
async def test_connect_to_mongo_failure_client_init(mocker):
    """
    Testa falha em connect_to_mongo durante a inicializa√ß√£o do AsyncIOMotorClient.
    """
    # --- Arrange ---
    simulated_error = Exception("Erro ao instanciar Motor Client")
    mocker.patch("motor.motor_asyncio.AsyncIOMotorClient", side_effect=simulated_error)
    mock_logger_error = mocker.patch("app.db.mongodb_utils.logger.error")
    mocker.patch("app.db.mongodb_utils.settings.MONGODB_URL", "mongodb://dummy_url")
    # Garante que os globais estejam resetados para o teste
    mocker.patch("app.db.mongodb_utils.db_client", None)
    mocker.patch("app.db.mongodb_utils.db_instance", None)

    # --- Act ---
    result = await mongodb_utils.connect_to_mongo()

    # --- Assert ---
    assert result is None
    mock_logger_error.assert_called_once()
    log_args, log_kwargs = mock_logger_error.call_args
    assert "N√£o foi poss√≠vel conectar ao MongoDB" in log_args[0]
    assert str(simulated_error) in log_args[0]
    assert log_kwargs.get("exc_info") is True
    assert mongodb_utils.db_client is None # Verifica se o global n√£o foi setado
    assert mongodb_utils.db_instance is None # Verifica se o global n√£o foi setado

@pytest.mark.asyncio
async def test_connect_to_mongo_failure_ping(mocker):
    """
    Testa falha em connect_to_mongo durante o comando ping.
    """
    # --- Arrange ---
    simulated_error = Exception("Erro no comando ping")
    mock_motor_client = AsyncMock()
    mock_motor_client.admin.command.side_effect = simulated_error
    mocker.patch("motor.motor_asyncio.AsyncIOMotorClient", return_value=mock_motor_client)
    mock_logger_error = mocker.patch("app.db.mongodb_utils.logger.error")
    mocker.patch("app.db.mongodb_utils.settings.MONGODB_URL", "mongodb://dummy_ping_url")
    # Garante que os globais estejam resetados
    mocker.patch("app.db.mongodb_utils.db_client", None)
    mocker.patch("app.db.mongodb_utils.db_instance", None)

    # --- Act ---
    result = await mongodb_utils.connect_to_mongo()

    # --- Assert ---
    assert result is None
    mock_motor_client.admin.command.assert_awaited_once_with('ping')
    mock_logger_error.assert_called_once()
    log_args, log_kwargs = mock_logger_error.call_args
    assert "N√£o foi poss√≠vel conectar ao MongoDB" in log_args[0]
    assert str(simulated_error) in log_args[0]
    assert log_kwargs.get("exc_info") is True
    assert mongodb_utils.db_client is None # Verifica se o global n√£o foi setado com o mock que falhou no ping
    assert mongodb_utils.db_instance is None

================================================================================
Cap√≠tulo 26: tests/test_db_task_crud.py
================================================================================

# tests/test_db_task_crud.py
"""
Este m√≥dulo cont√©m testes unit√°rios para as fun√ß√µes CRUD (Create, Read, Update, Delete)
de tarefas, definidas em `app.db.task_crud`.

Os testes utilizam mocks (principalmente `unittest.mock.AsyncMock` e `unittest.mock.patch`)
para simular as intera√ß√µes com a cole√ß√£o do MongoDB, permitindo testar a l√≥gica
das fun√ß√µes CRUD de forma isolada.

S√£o testados:
- Cria√ß√£o de tarefas (`create_task`) em cen√°rios de sucesso e falha.
- Busca de tarefas por ID (`get_task_by_id`) em cen√°rios de sucesso, n√£o encontrado e erro de valida√ß√£o.
- Listagem de tarefas por propriet√°rio (`get_tasks_by_owner`) com e sem filtros/ordena√ß√£o,
  incluindo tratamento de erros de valida√ß√£o e DB.
- Atualiza√ß√£o de tarefas (`update_task`).
- Dele√ß√£o de tarefas (`delete_task`).
- A fun√ß√£o auxiliar `_parse_sort_params`.
"""

# ========================
# --- Importa√ß√µes ---
# ========================
import uuid
from datetime import date, datetime, timedelta, timezone 
from typing import Any, Dict, List, Optional 
from unittest.mock import AsyncMock, MagicMock, call, patch
from venv import logger 

import pytest
from pydantic import ValidationError 
from pymongo import ASCENDING, DESCENDING
from pymongo.errors import DuplicateKeyError
from pytest_mock import MockerFixture

# --- M√≥dulos da Aplica√ß√£o ---
from app.db import task_crud 
from app.models.task import Task, TaskStatus, TaskUpdate

# ============================
# --- Fixture de Dados ---
# ============================

@pytest.fixture
def valid_task_obj() -> Task:
    """
    Fixture que retorna um objeto `Task` v√°lido e completo,
    pronto para ser usado nos testes como entrada para cria√ß√£o
    ou como valor esperado de retorno.
    """
    owner_unique_id = uuid.uuid4()
    task_unique_id = uuid.uuid4()
    print(f"  Fixture 'valid_task_obj': Criando Task ID={task_unique_id}, Owner ID={owner_unique_id}")
    return Task(
        id=task_unique_id,
        owner_id=owner_unique_id,
        title="Tarefa de Teste Padr√£o",
        description="Uma descri√ß√£o detalhada para a tarefa de teste padr√£o.",
        importance=3, 
        status=TaskStatus.PENDING,
        created_at=datetime.now(timezone.utc)
        )

@pytest.fixture
def sample_owner_id() -> uuid.UUID:
    """Fornece um UUID fixo para testes."""
    return uuid.UUID("123e4567-e89b-12d3-a456-426614174000")

@pytest.fixture
def sample_task_in_db(sample_owner_id: uuid.UUID) -> Task:
    """Fornece um objeto Task completo v√°lido para testes."""
    task_id = uuid.uuid4()
    return Task(
        id=task_id,
        owner_id=sample_owner_id,
        title="Sample Task in DB",
        description="Description for sample task in DB",
        importance=4,
        status=TaskStatus.IN_PROGRESS,
        created_at=datetime.now(timezone.utc).replace(microsecond=0) - timedelta(days=2),
        updated_at=None,
        due_date=date.today() + timedelta(days=5),
        priority_score=55.5,
        tags=["sample", "db"]
    )

@pytest.fixture
def sample_task_create_data() -> Dict[str, Any]:
    """Fornece um dicion√°rio v√°lido para criar uma tarefa."""
    return {
        "title": "Sample Task Create",
        "description": "Desc for create",
        "importance": 3,
        "due_date": (date.today() + timedelta(days=10)).isoformat(),
        "status": TaskStatus.PENDING.value,
        "tags": ["create_test"],
        "project": "Project Alpha"
    }

# ===================================
# --- Testes para `create_task` ---
# ===================================
@pytest.mark.asyncio
async def test_create_task_successfully(valid_task_obj: Task):
    """
    Testa a cria√ß√£o bem-sucedida de uma tarefa.
    Verifica se `_get_tasks_collection` √© chamado, se `insert_one` na cole√ß√£o
    √© chamado com os dados corretos e se a fun√ß√£o retorna o objeto da tarefa
    quando a inser√ß√£o √© confirmada (acknowledged).
    """
    print(f"\nTeste: create_task - Sucesso (Task ID: {valid_task_obj.id})")
    # --- Arrange: Configurar mocks ---
    mock_mongodb_collection = AsyncMock() 
    mock_insert_operation_result = MagicMock()
    mock_insert_operation_result.acknowledged = True 
    mock_mongodb_collection.insert_one = AsyncMock(return_value=mock_insert_operation_result)
    print("  Mock: Cole√ß√£o MongoDB e resultado de insert_one configurados para sucesso.")

    with patch("app.db.task_crud._get_tasks_collection", return_value=mock_mongodb_collection):
        # --- Act: Chamar a fun√ß√£o `create_task` ---
        print(f"  Atuando: Chamando task_crud.create_task com objeto Task.")
        created_task_result = await task_crud.create_task(db=MagicMock(), task_db=valid_task_obj)

    # --- Assert: Verificar chamadas e resultado ---
    expected_dict_for_db = valid_task_obj.model_dump(mode='json') 
    mock_mongodb_collection.insert_one.assert_awaited_once_with(expected_dict_for_db)
    assert created_task_result == valid_task_obj, "A tarefa retornada n√£o √© a mesma que foi passada."
    print("  Sucesso: Tarefa criada e retornada corretamente.")

@pytest.mark.asyncio
async def test_create_task_when_db_insert_not_acknowledged(valid_task_obj: Task):
    """
    Testa o comportamento de `create_task` quando a opera√ß√£o `insert_one`
    do MongoDB n√£o √© confirmada (`acknowledged = False`).
    Espera-se que a fun√ß√£o retorne `None`.
    """
    # --- Arrange ---
    mock_mongodb_collection = AsyncMock()
    mock_insert_operation_result = MagicMock()
    mock_insert_operation_result.acknowledged = False 
    mock_mongodb_collection.insert_one = AsyncMock(return_value=mock_insert_operation_result)

    # --- Act ---
    with patch("app.db.task_crud._get_tasks_collection", return_value=mock_mongodb_collection):
        created_task_result = await task_crud.create_task(db=MagicMock(), task_db=valid_task_obj)

    # --- Assert ---
    mock_mongodb_collection.insert_one.assert_awaited_once()
    assert created_task_result is None, "Deveria retornar None se a inser√ß√£o n√£o for acknowledged."

@pytest.mark.asyncio
async def test_create_task_handles_db_exception_on_insert(valid_task_obj: Task, mocker):
    """
    Testa o tratamento de exce√ß√£o em `create_task` quando `insert_one`
    levanta uma exce√ß√£o (simulando um erro do banco de dados).
    Espera-se que a exce√ß√£o seja capturada, logada, e que a fun√ß√£o retorne `None`.
    """
    # --- Arrange ---
    mock_mongodb_collection = AsyncMock()
    simulated_db_error = Exception("Erro de Simula√ß√£o na Inser√ß√£o no DB")
    mock_mongodb_collection.insert_one = AsyncMock(side_effect=simulated_db_error)
    mock_task_crud_logger = mocker.patch("app.db.task_crud.logger")

    # --- Act ---
    with patch("app.db.task_crud._get_tasks_collection", return_value=mock_mongodb_collection):
        created_task_result = await task_crud.create_task(db=MagicMock(), task_db=valid_task_obj)

    # --- Assert ---
    mock_mongodb_collection.insert_one.assert_awaited_once() 
    assert created_task_result is None, "Deveria retornar None em caso de exce√ß√£o no DB."
    mock_task_crud_logger.exception.assert_called_once(), "logger.exception n√£o foi chamado."

@pytest.mark.asyncio
async def test_create_task_indexes_success(mocker): 
    """
    Testa a cria√ß√£o bem-sucedida de todos os √≠ndices de tarefa.
    """
    # --- Arrange ---
    mock_db_object = MagicMock()
    mock_collection = AsyncMock()
    mock_collection.create_index = AsyncMock() 
    mocker.patch("app.db.task_crud._get_tasks_collection", return_value=mock_collection)
    mock_logger_info = mocker.patch("app.db.task_crud.logging.info")

    # --- Act ---
    await task_crud.create_task_indexes(db=mock_db_object)

    # --- Assert ---
    expected_calls = [
        call("id", unique=True, name="task_id_unique_idx"),
        call("owner_id", name="task_owner_idx"),
        call([("owner_id", ASCENDING), ("due_date", DESCENDING)], name="task_owner_due_date_idx"),
        call([("owner_id", ASCENDING), ("priority_score", DESCENDING)], name="task_owner_priority_idx"),
        call("tags", name="task_tags_idx")
    ]
    mock_collection.create_index.assert_has_awaits(expected_calls, any_order=False)
    mock_logger_info.assert_called_once_with("√çndices da cole√ß√£o 'tasks' verificados/criados.")

@pytest.mark.asyncio
async def test_create_task_indexes_failure(mocker): 
    """
    Testa o tratamento de erro durante a cria√ß√£o de um √≠ndice de tarefa.
    """
    # --- Arrange ---
    mock_db_object = MagicMock()
    simulated_db_error = Exception("Erro simulado ao criar √≠ndice 'owner_id'")
    mock_collection = AsyncMock()
    mock_collection.create_index.side_effect = [
        AsyncMock(), 
        simulated_db_error 
    ]
    mocker.patch("app.db.task_crud._get_tasks_collection", return_value=mock_collection)
    mock_logger_error = mocker.patch("app.db.task_crud.logging.error")
    mock_logger_info = mocker.patch("app.db.task_crud.logging.info")

    # --- Act ---
    await task_crud.create_task_indexes(db=mock_db_object)

    # --- Assert ---
    assert mock_collection.create_index.await_count == 2
    first_call_args = mock_collection.create_index.await_args_list[0].args
    second_call_args = mock_collection.create_index.await_args_list[1].args
    assert first_call_args[0] == "id"
    assert second_call_args[0] == "owner_id"
    mock_logger_error.assert_called_once()
    call_args, call_kwargs = mock_logger_error.call_args
    log_message = call_args[0]
    assert "Erro ao criar √≠ndices da cole√ß√£o 'tasks'" in log_message
    assert str(simulated_db_error) in log_message
    assert call_kwargs.get("exc_info") is True
    mock_logger_info.assert_not_called()

# =====================================
# --- Testes para `get_task_by_id` ---
# =====================================
@pytest.mark.asyncio
async def test_get_task_by_id_successfully(valid_task_obj: Task):
    """
    Testa a busca bem-sucedida de uma tarefa por ID.
    Verifica se `find_one` √© chamado com a query correta, se `Task.model_validate`
    √© chamado com os dados corretos (sem `_id`), e se a tarefa √© retornada.
    """
    print(f"\nTeste: get_task_by_id - Sucesso (Task ID: {valid_task_obj.id})")
    # --- Arrange ---
    task_dict_from_db = valid_task_obj.model_dump(mode='json')
    task_dict_from_db['_id'] = "some_random_mongodb_object_id" 
    
    mock_mongodb_collection = AsyncMock() 
    mock_mongodb_collection.find_one = AsyncMock(return_value=task_dict_from_db)
    print(f"  Mock: find_one para retornar dados da tarefa (incluindo _id).")
    
    target_task_id = valid_task_obj.id
    target_owner_id = valid_task_obj.owner_id

    with patch("app.db.task_crud._get_tasks_collection", return_value=mock_mongodb_collection), \
         patch("app.db.task_crud.Task.model_validate", return_value=valid_task_obj) as mock_pydantic_validate:
        # --- Act ---
        print("  Atuando: Chamando task_crud.get_task_by_id...")
        found_task_result = await task_crud.get_task_by_id(
            db=MagicMock(), task_id=target_task_id, owner_id=target_owner_id
        )

    # --- Assert ---
    expected_query_for_find_one = {"id": str(target_task_id), "owner_id": str(target_owner_id)}
    mock_mongodb_collection.find_one.assert_awaited_once_with(expected_query_for_find_one)
    
    expected_dict_for_validation = task_dict_from_db.copy()
    expected_dict_for_validation.pop('_id', None) 
    mock_pydantic_validate.assert_called_once_with(expected_dict_for_validation)
    
    assert found_task_result == valid_task_obj, "A tarefa encontrada n√£o corresponde √† esperada."
    print("  Sucesso: Tarefa encontrada e validada corretamente.")

@pytest.mark.asyncio
async def test_get_task_by_id_when_not_found_in_db():
    """
    Testa o comportamento de `get_task_by_id` quando `find_one` retorna `None`
    (indicando que a tarefa n√£o foi encontrada no banco de dados).
    Espera-se que a fun√ß√£o retorne `None`.
    """
    task_id_not_in_db = uuid.uuid4()
    owner_id_for_test = uuid.uuid4()
    print(f"\nTeste: get_task_by_id - Tarefa n√£o encontrada (Task ID: {task_id_not_in_db})")
    # --- Arrange ---
    mock_mongodb_collection = AsyncMock()
    mock_mongodb_collection.find_one = AsyncMock(return_value=None) 
    print("  Mock: find_one para retornar None.")

    with patch("app.db.task_crud._get_tasks_collection", return_value=mock_mongodb_collection):
        # --- Act ---
        print("  Atuando: Chamando task_crud.get_task_by_id...")
        found_task_result = await task_crud.get_task_by_id(
            db=MagicMock(), task_id=task_id_not_in_db, owner_id=owner_id_for_test
        )

    # --- Assert ---
    mock_mongodb_collection.find_one.assert_awaited_once() 
    assert found_task_result is None, "Deveria retornar None se a tarefa n√£o for encontrada."
    print("  Sucesso: get_task_by_id retornou None como esperado.")

@pytest.mark.asyncio
async def test_get_task_by_id_handles_pydantic_validation_error(mocker):
    """
    Testa o tratamento de erro em `get_task_by_id` quando os dados retornados
    do banco de dados falham na valida√ß√£o do modelo Pydantic `Task.model_validate`.
    Espera-se que a exce√ß√£o seja capturada, logada, e que a fun√ß√£o retorne `None`.
    """
    print("\nTeste: get_task_by_id - Erro de valida√ß√£o Pydantic ao processar dados do DB.")
    # --- Arrange ---
    invalid_task_dict_from_db = {"id": str(uuid.uuid4()), "owner_id": str(uuid.uuid4()), "title_erroneo": "Tarefa Inv√°lida"}
    invalid_task_dict_from_db['_id'] = "another_mongo_id"

    mock_mongodb_collection = AsyncMock()
    mock_mongodb_collection.find_one = AsyncMock(return_value=invalid_task_dict_from_db)
    mock_task_crud_logger = mocker.patch("app.db.task_crud.logger")
    print(f"  Mock: find_one para retornar dados inv√°lidos, logger mockado.")

    task_id_for_test = uuid.UUID(invalid_task_dict_from_db["id"])
    owner_id_for_test = uuid.UUID(invalid_task_dict_from_db["owner_id"])

    simulated_validation_error = ValidationError.from_exception_data(title='TaskModel', line_errors=[])
    
    with patch("app.db.task_crud._get_tasks_collection", return_value=mock_mongodb_collection), \
         patch("app.db.task_crud.Task.model_validate", side_effect=simulated_validation_error): 
        # --- Act ---
        print("  Atuando: Chamando task_crud.get_task_by_id (esperando erro de valida√ß√£o interno)...")
        found_task_result = await task_crud.get_task_by_id(
            db=MagicMock(), task_id=task_id_for_test, owner_id=owner_id_for_test
        )

    # --- Assert ---
    mock_mongodb_collection.find_one.assert_awaited_once()
    assert found_task_result is None, "Deveria retornar None em caso de erro de valida√ß√£o."
    mock_task_crud_logger.error.assert_called_once(), "logger.error n√£o foi chamado."
    print("  Sucesso: Erro de valida√ß√£o tratado, retornou None e erro foi logado.")

# ===========================================
# --- Testes para `get_tasks_by_owner` ---
# ===========================================
@pytest.mark.asyncio
async def test_get_tasks_by_owner_list_basic_success(valid_task_obj: Task):
    """
    Testa a listagem b√°sica de tarefas para um propriet√°rio, sem filtros ou ordena√ß√£o complexa.
    Verifica se a query `find` √© constru√≠da corretamente e se skip/limit s√£o aplicados.
    """
    target_owner_id = valid_task_obj.owner_id
    task_dict_from_db_iter = valid_task_obj.model_dump(mode='json')
    task_dict_from_db_iter['_id'] = "id_from_db" 
    print(f"\nTeste: get_tasks_by_owner - Listagem b√°sica para Owner ID: {target_owner_id}")

    # --- Arrange: Configurar a cadeia de mocks ---
    mock_motor_cursor = AsyncMock() 
    mock_motor_cursor.__aiter__.return_value = [task_dict_from_db_iter]
    mock_motor_cursor.skip = MagicMock(return_value=mock_motor_cursor)
    mock_motor_cursor.limit = MagicMock(return_value=mock_motor_cursor)

    mock_mongodb_collection = MagicMock() 

    mock_mongodb_collection.find = MagicMock(return_value=mock_motor_cursor) 
    
    print("  Mock: Cadeia de find().skip().limit().sort() e valida√ß√£o de modelo configurados.")

    test_limit = 50
    test_skip = 10

    with patch("app.db.task_crud._get_tasks_collection", return_value=mock_mongodb_collection), \
         patch("app.db.task_crud.Task.model_validate", return_value=valid_task_obj):
        # --- Act ---
        print(f"  Atuando: Chamando get_tasks_by_owner com limit={test_limit}, skip={test_skip}...")
        retrieved_tasks_list = await task_crud.get_tasks_by_owner(
            db=MagicMock(), owner_id=target_owner_id, limit=test_limit, skip=test_skip
        )

    # --- Assert ---
    expected_base_query = {"owner_id": str(target_owner_id)}
    mock_mongodb_collection.find.assert_called_once_with(expected_base_query)
    mock_motor_cursor.skip.assert_called_once_with(test_skip)
    mock_motor_cursor.limit.assert_called_once_with(test_limit)
    
    assert len(retrieved_tasks_list) == 1, "N√∫mero de tarefas retornadas incorreto."
    assert retrieved_tasks_list[0] == valid_task_obj, "Tarefa retornada n√£o corresponde √† esperada."
    print(f"  Sucesso: Listagem b√°sica funcionou, {len(retrieved_tasks_list)} tarefa(s) retornada(s).")

@pytest.mark.asyncio
async def test_get_tasks_by_owner_with_all_filters_and_sorting(valid_task_obj: Task):
    """
    Testa a listagem de tarefas com todos os filtros (status, projeto) e ordena√ß√£o.
    Verifica se a query `find` inclui os filtros e se `sort` √© chamado corretamente.
    """
    target_owner_id = valid_task_obj.owner_id
    task_dict_from_db_iter = valid_task_obj.model_dump(mode='json')
    task_dict_from_db_iter['_id'] = "id_for_sort_test"

    # --- Arrange ---
    mock_motor_cursor = AsyncMock() 
    mock_motor_cursor.__aiter__.return_value = [task_dict_from_db_iter]
    mock_motor_cursor.skip = MagicMock(return_value=mock_motor_cursor)  
    mock_motor_cursor.limit = MagicMock(return_value=mock_motor_cursor) 
    mock_motor_cursor.sort = MagicMock(return_value=mock_motor_cursor)
    mock_mongodb_collection = MagicMock()
    mock_mongodb_collection.find = MagicMock(return_value=mock_motor_cursor) 
    

    # --- Act ---
    filter_status = TaskStatus.PENDING
    filter_project = "ProjetoX_Filtro"
    sort_field = "created_at"
    sort_direction = "asc"
    test_limit_val = 10
    test_skip_val = 5

    with patch("app.db.task_crud._get_tasks_collection", return_value=mock_mongodb_collection), \
         patch("app.db.task_crud.Task.model_validate", return_value=valid_task_obj):
        print(f"  Atuando: Chamando get_tasks_by_owner com status, projeto, sort, limit, skip...")
        retrieved_tasks_list = await task_crud.get_tasks_by_owner(
            db=MagicMock(),
            owner_id=target_owner_id,
            status_filter=filter_status,
            project_filter=filter_project,
            sort_by=sort_field,
            sort_order=sort_direction,
            limit=test_limit_val,
            skip=test_skip_val
        )

    expected_query_with_filters = {
        "owner_id": str(target_owner_id),
        "status": filter_status.value,
        "project": filter_project
    }

    # --- Assert ---
    mock_mongodb_collection.find.assert_called_once_with(expected_query_with_filters)
    mock_motor_cursor.skip.assert_called_once_with(test_skip_val)
    mock_motor_cursor.limit.assert_called_once_with(test_limit_val)
    mock_motor_cursor.sort.assert_called_once_with([(sort_field, ASCENDING)])
    assert len(retrieved_tasks_list) == 1
    assert retrieved_tasks_list[0] == valid_task_obj

@pytest.mark.asyncio
async def test_get_tasks_by_owner_handles_validation_error_during_iteration(valid_task_obj: Task, mocker):
    """
    Testa o tratamento de erro em `get_tasks_by_owner` quando `Task.model_validate`
    levanta uma `ValidationError` para um dos documentos durante a itera√ß√£o do cursor.
    Espera-se que o erro seja logado, o item inv√°lido seja pulado, e os itens v√°lidos sejam retornados.
    """
    # --- Arrange ---
    target_owner_id = uuid.uuid4()
    simulated_db_error_on_find = Exception("Erro de Simula√ß√£o de Conex√£o Perdida no Find")
    mock_collection_object = MagicMock()
    mock_collection_object.find.side_effect = simulated_db_error_on_find
    patch_get_collection = patch("app.db.task_crud._get_tasks_collection", return_value=mock_collection_object)
    mock_task_crud_logger = mocker.patch("app.db.task_crud.logger")

    # --- Act ---
    with patch_get_collection: 
        retrieved_tasks_list = await task_crud.get_tasks_by_owner(db=MagicMock(), owner_id=target_owner_id)

    # --- Assert ---
    assert retrieved_tasks_list == [], "Deveria retornar lista vazia em caso de exce√ß√£o no DB."
    mock_task_crud_logger.exception.assert_called_once(), "logger.exception n√£o foi chamado."
    
    log_call_args_tuple = mock_task_crud_logger.exception.call_args[0]
    assert f"DB Error listing tasks for owner {target_owner_id}" in log_call_args_tuple[0], \
        "Mensagem de log de exce√ß√£o n√£o cont√©m as informa√ß√µes esperadas."
    
    mock_collection_object.find.assert_called_once()

@pytest.mark.asyncio
async def test_get_tasks_by_owner_handles_general_db_exception(mocker):
    """
    Testa o tratamento de exce√ß√£o em `get_tasks_by_owner` quando ocorre um erro
    geral no banco de dados durante a opera√ß√£o `find` (ou itera√ß√£o).
    Espera-se que a fun√ß√£o retorne uma lista vazia e logue a exce√ß√£o.
    """
    # --- Arrange ---
    mock_collection = MagicMock()
    owner_id = uuid.uuid4()
    db_error = Exception("Simulated Find Error")
    mock_collection.find.side_effect = db_error
    mock_logger = mocker.patch("app.db.task_crud.logger")

    # --- Act ---
    with patch("app.db.task_crud._get_tasks_collection", return_value=mock_collection):
        tasks = await task_crud.get_tasks_by_owner(db=MagicMock(), owner_id=owner_id)

    # --- Assert ---
    assert tasks == []
    mock_logger.exception.assert_called_once()
    assert f"DB Error listing tasks for owner {owner_id}" in mock_logger.exception.call_args[0][0]

@pytest.mark.asyncio
async def test_get_tasks_by_owner_generic_db_exception(mocker): 
    """
    Testa get_tasks_by_owner quando ocorre uma exce√ß√£o gen√©rica do DB.
    """
    # --- Arrange ---
    owner_id = uuid.uuid4()
    simulated_db_error = Exception("Simulated DB Error during find/iteration")
    mock_db_object = MagicMock()
    mock_collection = MagicMock()
    mock_collection.find.side_effect = simulated_db_error
    mocker.patch("app.db.task_crud._get_tasks_collection", return_value=mock_collection)

    mock_logger_exception = mocker.patch("app.db.task_crud.logger.exception")

    # --- Act ---
    result = await task_crud.get_tasks_by_owner(db=mock_db_object, owner_id=owner_id)

    # --- Assert ---
    assert result == []
    mock_collection.find.assert_called_once()
    mock_logger_exception.assert_called_once()
    call_args, _ = mock_logger_exception.call_args
    assert f"DB Error listing tasks for owner {owner_id}" in call_args[0]
    assert str(simulated_db_error) in call_args[0]

@pytest.mark.asyncio
async def test_get_tasks_by_owner_validation_error_in_loop(mocker, sample_owner_id): 
    """
    Testa get_tasks_by_owner quando um item falha na valida√ß√£o Pydantic
    dentro do loop, mas outros s√£o v√°lidos (simulando itera√ß√£o).
    """
    # --- Arrange ---
    mock_db_object = MagicMock()
    owner_id = sample_owner_id

    valid_task_dict_db = {
        "_id": "valid_id_direct_list", "id": str(uuid.uuid4()), "owner_id": str(owner_id),
        "title": "Valid Task Direct List", "importance": 3, "status": "pendente",
        "created_at": datetime.now(timezone.utc)
    }
    invalid_task_dict_db = {
        "_id": "invalid_id_direct_list", "id": str(uuid.uuid4()), "owner_id": str(owner_id),
        "title": "Invalid Task Direct List", "status": "invalid_status"
    }
    valid_task_obj = Task(
        id=uuid.UUID(valid_task_dict_db['id']), owner_id=sample_owner_id,
        title="Valid Task Direct List", importance=3, status=TaskStatus.PENDING,
        created_at=valid_task_dict_db['created_at']
    )
    mock_final_chain_link = AsyncMock()
    mock_final_chain_link.to_list.return_value = [valid_task_dict_db, invalid_task_dict_db] 
    mock_collection = AsyncMock()
    mock_collection.find.return_value.skip.return_value.limit.return_value = mock_final_chain_link
    mocker.patch("app.db.task_crud._get_tasks_collection", return_value=mock_collection)
    validation_error = ValidationError.from_exception_data(title="Task", line_errors=[])
    dict_for_valid_call = valid_task_dict_db.copy(); dict_for_valid_call.pop("_id")
    dict_for_invalid_call = invalid_task_dict_db.copy(); dict_for_invalid_call.pop("_id")
    mock_validate = mocker.patch(
        "app.db.task_crud.Task.model_validate",
        side_effect=[valid_task_obj, validation_error]
    )
    async def mock_async_for(*args, **kwargs):
        tasks = []
        items = await mock_final_chain_link.to_list() 
        for item in items:
            item.pop('_id', None)
            try:
                tasks.append(Task.model_validate(item)) 
            except (ValidationError, Exception) as e:
                task_crud.logger.error(f"DB Validation error list_tasks owner {owner_id} task {item.get('id', 'N/A')}: {e}")
                continue
        return tasks
    mock_get_tasks_internal = mocker.patch("app.db.task_crud.get_tasks_by_owner", side_effect=mock_async_for)
    mock_logger_error = mocker.patch("app.db.task_crud.logger.error")
    mock_logger_exception = mocker.patch("app.db.task_crud.logger.exception")

    # --- Act ---
    result = await task_crud.get_tasks_by_owner(db=mock_db_object, owner_id=owner_id)

    # --- Assert ---
    assert len(result) == 1
    assert result[0] == valid_task_obj
    mock_get_tasks_internal.assert_awaited_once_with(db=mock_db_object, owner_id=owner_id)
    assert mock_validate.call_count == 2
    mock_validate.assert_has_calls([call(dict_for_valid_call), call(dict_for_invalid_call)], any_order=False)
    mock_logger_error.assert_called_once()
    call_args_log, _ = mock_logger_error.call_args
    log_message = call_args_log[0]
    assert f"DB Validation error list_tasks owner {sample_owner_id} task {invalid_task_dict_db['id']}" in log_message
    assert str(validation_error) in log_message
    mock_logger_exception.assert_not_called() 

@pytest.mark.asyncio
async def test_get_tasks_by_owner_validation_error_handling(caplog):
    """
    Testa o tratamento de erro de valida√ß√£o dentro do loop
    de get_tasks_by_owner, verificando se o erro √© logado e
    a lista resultante √© vazia (ou cont√©m apenas itens v√°lidos).
    """
    # --- Arrange ---
    db_mock = MagicMock()
    collection_mock = MagicMock()
    db_mock.__getitem__.return_value = collection_mock
    db_mock.tasks = collection_mock
    invalid_task = {"id": "fake-id", "invalid_field": "invalid"}
    cursor_mock = MagicMock()
    cursor_mock.__aiter__.return_value = [invalid_task]
    cursor_mock.skip.return_value = cursor_mock
    cursor_mock.limit.return_value = cursor_mock
    cursor_mock.sort.return_value = cursor_mock
    collection_mock.find = MagicMock()
    collection_mock.find.return_value = cursor_mock
    owner_id = uuid.uuid4()
    

    # --- Act ---
    with patch("app.db.task_crud.logger.error") as mock_logger:
        result = await task_crud.get_tasks_by_owner(db_mock, owner_id)

    # --- Assert ---
    assert result == []
    mock_logger.assert_called()

# ===================================
# --- Testes para `update_task` ---
# ===================================
@pytest.mark.asyncio
async def test_update_task_successfully(valid_task_obj: Task):
    """
    Testa a atualiza√ß√£o bem-sucedida de uma tarefa.
    Verifica se `find_one_and_update` √© chamado com os par√¢metros corretos
    (filtro, dados de atualiza√ß√£o com `$set` e `updated_at`), e se
    `Task.model_validate` √© chamado com o documento retornado pelo DB.
    """
    target_task_id = valid_task_obj.id
    target_owner_id = valid_task_obj.owner_id
    update_payload_data = {"title": "T√≠tulo da Tarefa Atualizado via Teste", "status": TaskStatus.IN_PROGRESS.value}
    
    print(f"\nTeste: update_task - Sucesso (Task ID: {target_task_id})")

    # --- Arrange ---
    fixed_current_time_utc = datetime.now(timezone.utc).replace(microsecond=0)
    
    db_document_after_update = valid_task_obj.model_dump(mode='json')
    db_document_after_update.update(update_payload_data) 
    db_document_after_update['updated_at'] = fixed_current_time_utc 
    db_document_after_update['_id'] = 'some_mongo_id_for_update' 

    expected_final_task_object = Task(**db_document_after_update)
    
    mock_mongodb_collection = AsyncMock()
    mock_mongodb_collection.find_one_and_update = AsyncMock(return_value=db_document_after_update)
    print("  Mock: Cole√ß√£o MongoDB, find_one_and_update, e Task.model_validate configurados.")

    with patch("app.db.task_crud.datetime") as mock_datetime_module, \
         patch("app.db.task_crud._get_tasks_collection", return_value=mock_mongodb_collection), \
         patch("app.db.task_crud.Task.model_validate", return_value=expected_final_task_object) as mock_pydantic_validate:
        
        mock_datetime_module.now.return_value = fixed_current_time_utc 
        
        # --- Act ---
        print(f"  Atuando: Chamando task_crud.update_task com payload: {update_payload_data}")
        update_result_task = await task_crud.update_task(
            db=MagicMock(),
            task_id=target_task_id,
            owner_id=target_owner_id,
            update_data=update_payload_data.copy() 
        )

    # --- Assert ---
    expected_filter_for_update = {"id": str(target_task_id), "owner_id": str(target_owner_id)}
    expected_data_for_set_operator = {**update_payload_data, "updated_at": fixed_current_time_utc}
    
    mock_mongodb_collection.find_one_and_update.assert_awaited_once_with(
        expected_filter_for_update,
        {"$set": expected_data_for_set_operator},
        return_document=True
    )
    expected_dict_for_validation = db_document_after_update.copy()
    expected_dict_for_validation.pop('_id', None)
    mock_pydantic_validate.assert_called_once_with(expected_dict_for_validation)
    
    assert update_result_task == expected_final_task_object, "A tarefa atualizada retornada n√£o √© a esperada."
    print("  Sucesso: Tarefa atualizada e retornada corretamente.")

@pytest.mark.asyncio
async def test_update_task_validation_error_post_db(mocker, sample_task_in_db): 
    """
    Testa falha de valida√ß√£o Pydantic ap√≥s find_one_and_update retornar dados.
    """
    # --- Arrange ---
    test_task_id = sample_task_in_db.id
    owner_id = sample_task_in_db.owner_id
    update_data = {"title": "Updated Title Valid", "status": TaskStatus.IN_PROGRESS.value}
    fixed_timestamp = datetime.now(timezone.utc).replace(microsecond=0)
    mock_db_object = MagicMock()

    mock_doc_returned_from_db = {
        "_id": "mongo_db_id_valid_err",
        "id": str(test_task_id),
        "owner_id": str(owner_id),
        "title": update_data["title"],
        "status": update_data["status"],
        "created_at": sample_task_in_db.created_at,
        "updated_at": fixed_timestamp,
        "due_date": sample_task_in_db.due_date
    }
    expected_dict_for_validation = mock_doc_returned_from_db.copy()
    expected_dict_for_validation.pop("_id")

    mock_dt_now = mocker.patch("app.db.task_crud.datetime")
    mock_dt_now.now.return_value = fixed_timestamp

    mock_collection = AsyncMock()
    mock_collection.find_one_and_update.return_value = mock_doc_returned_from_db
    mocker.patch("app.db.task_crud._get_tasks_collection", return_value=mock_collection)

    simulated_validation_error = ValidationError.from_exception_data(title='Task', line_errors=[{'loc':('importance',), 'type':'missing'}])
    mock_validate = mocker.patch(
        "app.db.task_crud.Task.model_validate",
        side_effect=simulated_validation_error
    )
    mock_logger_error = mocker.patch("app.db.task_crud.logger.error")

    # --- Act ---
    result = await task_crud.update_task(
        db=mock_db_object,
        task_id=test_task_id,
        owner_id=owner_id,
        update_data=update_data.copy() 
    )

    # --- Assert ---
    assert result is None
    mock_collection.find_one_and_update.assert_awaited_once() 

    find_one_update_args, find_one_update_kwargs = mock_collection.find_one_and_update.await_args
    assert len(find_one_update_args) == 2
    call_filter = find_one_update_args[0]
    call_update_doc = find_one_update_args[1]
    assert call_filter == {"id": str(test_task_id), "owner_id": str(owner_id)}
    expected_update_set = update_data.copy()
    expected_update_set["updated_at"] = fixed_timestamp
    assert call_update_doc == {"$set": expected_update_set}
    assert find_one_update_kwargs.get("return_document") is True

    mock_validate.assert_called_once_with(expected_dict_for_validation)

    mock_logger_error.assert_called_once()
    call_args_log, _ = mock_logger_error.call_args
    log_message = call_args_log[0]
    assert f"DB Validation error update_task {test_task_id} owner {owner_id}" in log_message
    assert str(simulated_validation_error) in log_message

@pytest.mark.asyncio
async def test_update_task_generic_exception(mocker, sample_owner_id): 
    """
    Testa update_task quando find_one_and_update levanta exce√ß√£o gen√©rica.
    """
    # --- Arrange ---
    test_task_id = uuid.uuid4()
    owner_id = sample_owner_id 
    update_data = {"title": "Tentativa de Update"}
    mock_db_object = MagicMock()
    fixed_timestamp = datetime.now(timezone.utc).replace(microsecond=0)
    mock_dt_now = mocker.patch("app.db.task_crud.datetime")
    mock_dt_now.now.return_value = fixed_timestamp
    simulated_db_error = Exception("Simulated generic DB error on update")
    mock_collection = AsyncMock()
    mock_collection.find_one_and_update.side_effect = simulated_db_error
    mocker.patch("app.db.task_crud._get_tasks_collection", return_value=mock_collection)
    mock_validate = mocker.patch("app.db.task_crud.Task.model_validate")
    mock_logger_exception = mocker.patch("app.db.task_crud.logger.exception")

    # --- Act ---
    result = await task_crud.update_task(
        db=mock_db_object,
        task_id=test_task_id,
        owner_id=owner_id, 
        update_data=update_data.copy()
    )

    # --- Assert ---
    assert result is None
    mock_collection.find_one_and_update.assert_awaited_once()
    find_one_update_args, find_one_update_kwargs = mock_collection.find_one_and_update.await_args
    assert len(find_one_update_args) == 2
    call_filter = find_one_update_args[0]
    call_update_doc = find_one_update_args[1]
    assert call_filter == {"id": str(test_task_id), "owner_id": str(owner_id)}
    expected_update_set = update_data.copy()
    expected_update_set["updated_at"] = fixed_timestamp
    assert call_update_doc == {"$set": expected_update_set}
    assert find_one_update_kwargs.get("return_document") is True
    mock_validate.assert_not_called()
    mock_logger_exception.assert_called_once()
    call_args_log, _ = mock_logger_exception.call_args
    log_message = call_args_log[0]
    assert f"DB Error updating task {test_task_id} owner {owner_id}" in log_message
    assert str(simulated_db_error) in log_message

@pytest.mark.asyncio
async def test_update_task_not_found_logs_warning(mocker, sample_owner_id): 
    """
    Testa se update_task loga um aviso quando find_one_and_update retorna None.
    """
    # --- Arrange ---
    test_task_id = uuid.uuid4()
    owner_id = sample_owner_id
    update_data = {"title": "Nome Nao Sera Atualizado"}
    mock_db_object = MagicMock()
    fixed_timestamp = datetime.now(timezone.utc).replace(microsecond=0)
    mock_dt_now = mocker.patch("app.db.task_crud.datetime")
    mock_dt_now.now.return_value = fixed_timestamp
    mock_collection = AsyncMock()
    mock_collection.find_one_and_update.return_value = None
    mocker.patch("app.db.task_crud._get_tasks_collection", return_value=mock_collection)
    mock_validate = mocker.patch("app.db.task_crud.Task.model_validate")
    mock_logger_warning = mocker.patch("app.db.task_crud.logger.warning")

    # --- Act ---
    result = await task_crud.update_task(
        db=mock_db_object,
        task_id=test_task_id,
        owner_id=owner_id,
        update_data=update_data.copy()
    )

    # --- Assert ---
    assert result is None
    mock_collection.find_one_and_update.assert_awaited_once()
    find_one_update_args, find_one_update_kwargs = mock_collection.find_one_and_update.await_args
    assert len(find_one_update_args) == 2
    call_filter = find_one_update_args[0]
    call_update_doc = find_one_update_args[1]
    assert call_filter == {"id": str(test_task_id), "owner_id": str(owner_id)}
    expected_update_set = update_data.copy()
    expected_update_set["updated_at"] = fixed_timestamp
    assert call_update_doc == {"$set": expected_update_set}
    assert find_one_update_kwargs.get("return_document") is True
    mock_validate.assert_not_called()
    mock_logger_warning.assert_called_once()
    call_args_log, _ = mock_logger_warning.call_args
    assert f"Tentativa de atualizar tarefa n√£o encontrada: ID {test_task_id}, Owner ID {owner_id}" in call_args_log[0]

# ===================================
# --- Testes para `delete_task` ---
# ===================================
@pytest.mark.asyncio
async def test_delete_task_successfully():
    """
    Testa a dele√ß√£o bem-sucedida de uma tarefa.
    Verifica se `delete_one` √© chamado com a query correta e se a fun√ß√£o
    retorna `True` quando `deleted_count` √© 1.
    """
    target_task_id, target_owner_id = uuid.uuid4(), uuid.uuid4()
    print(f"\nTeste: delete_task - Sucesso (Task ID: {target_task_id})")
    # --- Arrange ---
    mock_mongodb_collection = AsyncMock()
    mock_delete_operation_result = MagicMock()
    mock_delete_operation_result.deleted_count = 1 
    mock_mongodb_collection.delete_one = AsyncMock(return_value=mock_delete_operation_result)
    print("  Mock: delete_one para retornar deleted_count=1.")

    with patch("app.db.task_crud._get_tasks_collection", return_value=mock_mongodb_collection):
        # --- Act ---
        print("  Atuando: Chamando task_crud.delete_task...")
        delete_was_successful = await task_crud.delete_task(
            db=MagicMock(), task_id=target_task_id, owner_id=target_owner_id
        )

    # --- Assert ---
    expected_query_for_delete = {"id": str(target_task_id), "owner_id": str(target_owner_id)}
    mock_mongodb_collection.delete_one.assert_awaited_once_with(expected_query_for_delete)
    assert delete_was_successful is True, "delete_task deveria retornar True para dele√ß√£o bem-sucedida."
    print("  Sucesso: Tarefa deletada e True retornado.")

@pytest.mark.asyncio
async def test_delete_task_when_not_found_or_not_deleted():
    """
    Testa o comportamento de `delete_task` quando a tarefa n√£o √© encontrada
    (ou por algum motivo n√£o √© deletada), resultando em `deleted_count = 0`.
    Espera-se que a fun√ß√£o retorne `False`.
    """
    target_task_id, target_owner_id = uuid.uuid4(), uuid.uuid4()
    print(f"\nTeste: delete_task - Tarefa n√£o encontrada para dele√ß√£o (Task ID: {target_task_id})")
    # --- Arrange ---
    mock_mongodb_collection = AsyncMock()
    mock_delete_operation_result = MagicMock()
    mock_delete_operation_result.deleted_count = 0
    mock_mongodb_collection.delete_one = AsyncMock(return_value=mock_delete_operation_result)
    print("  Mock: delete_one para retornar deleted_count=0.")

    with patch("app.db.task_crud._get_tasks_collection", return_value=mock_mongodb_collection):
        # --- Act ---
        print("  Atuando: Chamando task_crud.delete_task...")
        delete_was_successful = await task_crud.delete_task(
            db=MagicMock(), task_id=target_task_id, owner_id=target_owner_id
        )

    # --- Assert ---
    mock_mongodb_collection.delete_one.assert_awaited_once() 
    assert delete_was_successful is False, "delete_task deveria retornar False se nenhum documento for deletado."
    print("  Sucesso: Dele√ß√£o falhou (tarefa n√£o encontrada) e False retornado.")

@pytest.mark.asyncio
async def test_delete_task_generic_exception(mocker, sample_owner_id): 
    """
    Testa delete_task quando delete_one levanta uma exce√ß√£o gen√©rica.
    """
    # --- Arrange ---
    test_task_id = uuid.uuid4()
    owner_id = sample_owner_id
    mock_db_object = MagicMock()

    simulated_db_error = Exception("Simulated generic DB error on delete")
    mock_collection = AsyncMock()
    mock_collection.delete_one.side_effect = simulated_db_error
    mocker.patch("app.db.task_crud._get_tasks_collection", return_value=mock_collection)

    mock_logger_exception = mocker.patch("app.db.task_crud.logger.exception")

    # --- Act ---
    result = await task_crud.delete_task(
        db=mock_db_object,
        task_id=test_task_id,
        owner_id=owner_id
    )

    # --- Assert ---
    assert result is False 
    mock_collection.delete_one.assert_awaited_once_with({"id": str(test_task_id), "owner_id": str(owner_id)})

    mock_logger_exception.assert_called_once()
    call_args_log, _ = mock_logger_exception.call_args
    log_message = call_args_log[0]
    assert f"DB Error deleting task {test_task_id} owner {owner_id}" in log_message
    assert str(simulated_db_error) in log_message

# ===========================================
# --- Testes para `_parse_sort_params` ---
# ===========================================

@pytest.mark.parametrize(
    "sort_by_input, sort_order_input, expected_output",
    [
        ("due_date", "asc", [("due_date", ASCENDING)]),
        ("priority_score", "desc", [("priority_score", DESCENDING)]),
        ("created_at", "ASC", [("created_at", ASCENDING)]), 
        ("importance", "DESC", [("importance", DESCENDING)]),
        ("due_date", "ascending_string_literal", [("due_date", DESCENDING)]), 
        ("due_date", "", [("due_date", DESCENDING)]),
        ("invalid_sort_field", "desc", None),
        (None, "desc", None),
    ]
)
def test_parse_sort_params_various_inputs(sort_by_input, sort_order_input, expected_output):
    """
    Testa `_parse_sort_params` com v√°rias combina√ß√µes de entrada
    para `sort_by` e `sort_order`, verificando se a sa√≠da corresponde
    ao formato esperado pelo PyMongo para ordena√ß√£o.
    """
    
    print(f"\nTeste: _parse_sort_params(sort_by='{sort_by_input}', sort_order='{sort_order_input}')")
    actual_output = task_crud._parse_sort_params(sort_by_input, sort_order_input)
    print(f"  Sa√≠da Esperada: {expected_output}, Sa√≠da Real: {actual_output}")
    assert actual_output == expected_output, \
        f"Para sort_by='{sort_by_input}', sort_order='{sort_order_input}', " \
        f"esperado {expected_output}, mas obtido {actual_output}."


================================================================================
Cap√≠tulo 27: tests/test_db_user_crud.py
================================================================================

# tests/test_db_user_crud.py

# ========================
# --- Importa√ß√µes ---
# ========================
import uuid
from datetime import datetime, timezone
import pytest # type: ignore
from unittest.mock import AsyncMock, MagicMock, patch, call
from pydantic import ValidationError
from pymongo.errors import DuplicateKeyError

from app.db import user_crud
from app.models.user import UserCreate, UserInDB, UserUpdate

# ====================================
# --- Marcador Global de Teste ---
# ====================================
pytestmark = pytest.mark.asyncio

# ============================
# --- Fixture Auxiliar ---
# ============================
@pytest.fixture
def mock_db_connection() -> AsyncMock:
    """Fornece um mock gen√©rico para a conex√£o DB."""
    return AsyncMock()

@pytest.fixture
def sample_user_create() -> UserCreate:
    """Fornece um objeto UserCreate v√°lido para testes."""
    return UserCreate(
        email="test@example.com",
        username="testuser",
        password="validpassword123",
        full_name="Test User Name"
    )

@pytest.fixture
def sample_user_in_db() -> UserInDB:
    """Fornece um objeto UserInDB v√°lido para testes."""
    user_id = uuid.uuid4()
    return UserInDB(
        id=user_id,
        username="sampleuserindb",
        email="sampleindb@example.com",
        hashed_password="hashed_sample_password",
        full_name="Sample User In DB",
        disabled=False,
        created_at=datetime.now(timezone.utc).replace(microsecond=0),
        updated_at=None
    )

# =======================================
# --- Testes para user_crud.get_user_by_id ---
# =======================================
async def test_get_user_by_id_success(mocker, mock_db_connection, sample_user_in_db): # type: ignore
    """Testa busca de usu√°rio por ID com sucesso."""
    # --- Arrange ---
    test_user_id = sample_user_in_db.id
    user_dict_from_db = sample_user_in_db.model_dump(mode="json")
    user_dict_from_db['_id'] = "mock_mongo_id"
    expected_validation_dict = sample_user_in_db.model_dump(mode="json")

    mock_collection = AsyncMock()
    mock_collection.find_one.return_value = user_dict_from_db
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)
    mock_validate = mocker.patch("app.db.user_crud.UserInDB.model_validate", return_value=sample_user_in_db)

    # --- Act ---
    result = await user_crud.get_user_by_id(db=mock_db_connection, user_id=test_user_id)

    # --- Assert ---
    assert result == sample_user_in_db
    mock_collection.find_one.assert_awaited_once_with({"id": str(test_user_id)})
    mock_validate.assert_called_once_with(expected_validation_dict)

async def test_get_user_by_id_not_found(mocker, mock_db_connection): # type: ignore
    """Testa busca de usu√°rio por ID quando n√£o encontrado."""
    # --- Arrange ---
    test_user_id = uuid.uuid4()
    mock_collection = AsyncMock()
    mock_collection.find_one.return_value = None
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)

    # --- Act ---
    result = await user_crud.get_user_by_id(db=mock_db_connection, user_id=test_user_id)

    # --- Assert ---
    assert result is None
    mock_collection.find_one.assert_awaited_once_with({"id": str(test_user_id)})

async def test_get_user_by_id_validation_error(mocker, mock_db_connection): # type: ignore
    """Testa falha de valida√ß√£o Pydantic ao buscar usu√°rio por ID."""
    # --- Arrange ---
    test_user_id = uuid.uuid4()
    invalid_user_dict_from_db = {"_id": "mongo_id", "id": str(test_user_id), "campo_errado": True}
    expected_validation_dict = {"id": str(test_user_id), "campo_errado": True}

    mock_collection = AsyncMock()
    mock_collection.find_one.return_value = invalid_user_dict_from_db
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)

    simulated_error = ValidationError.from_exception_data(title='UserInDB', line_errors=[])
    mock_validate = mocker.patch("app.db.user_crud.UserInDB.model_validate", side_effect=simulated_error)
    mock_logger_error = mocker.patch("app.db.user_crud.logger.error")

    # --- Act ---
    result = await user_crud.get_user_by_id(db=mock_db_connection, user_id=test_user_id)

    # --- Assert ---
    assert result is None
    mock_collection.find_one.assert_awaited_once_with({"id": str(test_user_id)})
    mock_validate.assert_called_once_with(expected_validation_dict)
    mock_logger_error.assert_called_once()
    assert f"DB Validation error get_user_by_id {test_user_id}" in mock_logger_error.call_args[0][0]

# ===========================================
# --- Testes para user_crud.get_user_by_username ---
# ===========================================
async def test_get_user_by_username_success(mocker, mock_db_connection, sample_user_in_db): # type: ignore
    """Testa busca de usu√°rio por username com sucesso."""
    # --- Arrange ---
    test_username = sample_user_in_db.username
    user_dict_from_db = sample_user_in_db.model_dump(mode="json")
    user_dict_from_db['_id'] = "mock_mongo_id"
    expected_validation_dict = sample_user_in_db.model_dump(mode="json")

    mock_collection = AsyncMock()
    mock_collection.find_one.return_value = user_dict_from_db
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)
    mock_validate = mocker.patch("app.db.user_crud.UserInDB.model_validate", return_value=sample_user_in_db)

    # --- Act ---
    result = await user_crud.get_user_by_username(db=mock_db_connection, username=test_username)

    # --- Assert ---
    assert result == sample_user_in_db
    mock_collection.find_one.assert_awaited_once_with({"username": test_username})
    mock_validate.assert_called_once_with(expected_validation_dict)

async def test_get_user_by_username_not_found(mocker, mock_db_connection): # type: ignore
    """Testa busca de usu√°rio por username quando n√£o encontrado."""
    # --- Arrange ---
    test_username = "nouser_username"
    mock_collection = AsyncMock()
    mock_collection.find_one.return_value = None
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)

    # --- Act ---
    result = await user_crud.get_user_by_username(db=mock_db_connection, username=test_username)

    # --- Assert ---
    assert result is None
    mock_collection.find_one.assert_awaited_once_with({"username": test_username})

async def test_get_user_by_username_validation_error(mocker, mock_db_connection): # type: ignore
    """Testa falha de valida√ß√£o Pydantic ao buscar usu√°rio por username."""
    # --- Arrange ---
    test_username = "invalid_user_validate"
    invalid_user_dict_from_db = {"_id": "mongo_id", "username": test_username, "campo_errado": True}
    expected_validation_dict = {"username": test_username, "campo_errado": True}

    mock_collection = AsyncMock()
    mock_collection.find_one.return_value = invalid_user_dict_from_db
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)

    simulated_error = ValidationError.from_exception_data(title='UserInDB', line_errors=[])
    mock_validate = mocker.patch("app.db.user_crud.UserInDB.model_validate", side_effect=simulated_error)
    mock_logger_error = mocker.patch("app.db.user_crud.logger.error")

    # --- Act ---
    result = await user_crud.get_user_by_username(db=mock_db_connection, username=test_username)

    # --- Assert ---
    assert result is None
    mock_collection.find_one.assert_awaited_once_with({"username": test_username})
    mock_validate.assert_called_once_with(expected_validation_dict)
    mock_logger_error.assert_called_once()
    assert f"DB Validation error get_user_by_username {test_username}" in mock_logger_error.call_args[0][0]

# ===========================================
# --- Testes para user_crud.get_user_by_email ---
# ===========================================
async def test_get_user_by_email_success(mocker, mock_db_connection, sample_user_in_db): # type: ignore
    """Testa busca de usu√°rio por email com sucesso."""
    # --- Arrange ---
    test_email = sample_user_in_db.email
    user_dict_from_db = sample_user_in_db.model_dump(mode="json")
    user_dict_from_db['_id'] = "mock_mongo_id"
    expected_validation_dict = sample_user_in_db.model_dump(mode="json")

    mock_collection = AsyncMock()
    mock_collection.find_one.return_value = user_dict_from_db
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)
    mock_validate = mocker.patch("app.db.user_crud.UserInDB.model_validate", return_value=sample_user_in_db)

    # --- Act ---
    result = await user_crud.get_user_by_email(db=mock_db_connection, email=test_email)

    # --- Assert ---
    assert result == sample_user_in_db
    mock_collection.find_one.assert_awaited_once_with({"email": test_email})
    mock_validate.assert_called_once_with(expected_validation_dict)

async def test_get_user_by_email_not_found(mocker, mock_db_connection): # type: ignore
    """Testa busca de usu√°rio por email quando n√£o encontrado."""
    # --- Arrange ---
    test_email = "nouser@example.com"
    mock_collection = AsyncMock()
    mock_collection.find_one.return_value = None
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)

    # --- Act ---
    result = await user_crud.get_user_by_email(db=mock_db_connection, email=test_email)

    # --- Assert ---
    assert result is None
    mock_collection.find_one.assert_awaited_once_with({"email": test_email})

async def test_get_user_by_email_validation_error(mocker, mock_db_connection): # type: ignore
    """Testa falha de valida√ß√£o Pydantic ao buscar usu√°rio por email."""
    # --- Arrange ---
    test_email = "invalid_validate@example.com"
    invalid_user_dict_from_db = {"_id": "mongo_id", "email": test_email, "campo_errado": True}
    expected_validation_dict = {"email": test_email, "campo_errado": True}

    mock_collection = AsyncMock()
    mock_collection.find_one.return_value = invalid_user_dict_from_db
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)

    simulated_error = ValidationError.from_exception_data(title='UserInDB', line_errors=[])
    mock_validate = mocker.patch("app.db.user_crud.UserInDB.model_validate", side_effect=simulated_error)
    mock_logger_error = mocker.patch("app.db.user_crud.logger.error")

    # --- Act ---
    result = await user_crud.get_user_by_email(db=mock_db_connection, email=test_email)

    # --- Assert ---
    assert result is None
    mock_collection.find_one.assert_awaited_once_with({"email": test_email})
    mock_validate.assert_called_once_with(expected_validation_dict)
    mock_logger_error.assert_called_once()
    assert f"DB Validation error get_user_by_email {test_email}" in mock_logger_error.call_args[0][0]

# =======================================
# --- Testes para user_crud.create_user ---
# =======================================
async def test_create_user_success(mocker, mock_db_connection, sample_user_create): # type: ignore
    """Testa a cria√ß√£o de usu√°rio com sucesso."""
    # --- Arrange ---
    test_uuid = uuid.uuid4()
    test_datetime = datetime.now(timezone.utc)
    mock_uuid_module = mocker.patch("app.db.user_crud.uuid")
    mock_uuid_module.uuid4.return_value = test_uuid
    mock_dt_module = mocker.patch("app.db.user_crud.datetime")
    mock_dt_module.now.return_value = test_datetime
    mock_dt_module.side_effect = lambda *args, **kw: datetime(*args, **kw)

    mocked_hashed_password = "hashed_password_success"
    mocker.patch("app.db.user_crud.get_password_hash", return_value=mocked_hashed_password)

    expected_validation_data_dict = {
        "id": test_uuid,
        "username": sample_user_create.username,
        "email": sample_user_create.email,
        "hashed_password": mocked_hashed_password,
        "full_name": sample_user_create.full_name,
        "disabled": False,
        "created_at": test_datetime,
        "updated_at": None
    }
    mock_validated_user_obj = MagicMock(spec=UserInDB)
    for key, value in expected_validation_data_dict.items():
        setattr(mock_validated_user_obj, key, value)

    mock_validate = mocker.patch(
        "app.db.user_crud.UserInDB.model_validate",
        return_value=mock_validated_user_obj
    )

    expected_dict_to_insert = {k: str(v) if isinstance(v, uuid.UUID) else (v.isoformat() if isinstance(v, datetime) else v) for k, v in expected_validation_data_dict.items() if k != 'created_at'}
    expected_dict_to_insert['created_at'] = test_datetime
    expected_dict_to_insert['updated_at'] = None

    mock_validated_user_obj.model_dump.return_value = expected_dict_to_insert

    mock_insert_result = MagicMock()
    mock_insert_result.acknowledged = True

    mock_collection = AsyncMock()
    mock_collection.insert_one.return_value = mock_insert_result
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)

    # --- Act ---
    result = await user_crud.create_user(db=mock_db_connection, user_in=sample_user_create)

    # --- Assert ---
    assert result == mock_validated_user_obj

    user_crud.get_password_hash.assert_called_once_with(sample_user_create.password)
    mock_validate.assert_called_once_with(expected_validation_data_dict)

    mock_validated_user_obj.model_dump.assert_called_once_with(mode="json")
    mock_collection.insert_one.assert_awaited_once_with(expected_dict_to_insert)

async def test_create_user_raises_duplicate_key_error(mocker, mock_db_connection, sample_user_create): # type: ignore
    """Testa se DuplicateKeyError √© relan√ßado."""
    # --- Arrange ---
    mocker.patch("app.db.user_crud.get_password_hash", return_value="mock_hash")
    mock_validated_obj = MagicMock()
    mock_validated_obj.model_dump.return_value = {"some": "data"}
    mocker.patch("app.db.user_crud.UserInDB.model_validate", return_value=mock_validated_obj)

    simulated_db_error = DuplicateKeyError("E11000 duplicate key error")
    mock_collection = AsyncMock()
    mock_collection.insert_one.side_effect = simulated_db_error
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)
    mock_logger_warning = mocker.patch("app.db.user_crud.logger.warning")

    # --- Act & Assert ---
    with pytest.raises(DuplicateKeyError):
        await user_crud.create_user(db=mock_db_connection, user_in=sample_user_create)

    mock_collection.insert_one.assert_awaited_once_with({"some": "data"})
    mock_logger_warning.assert_called_once()

async def test_create_user_pydantic_validation_failure(mocker): # type: ignore
    """
    Testa se create_user retorna None e loga um erro quando
    UserInDB.model_validate(user_db_data) falha.
    """
    # --- Arrange ---
    valid_user_create_input = UserCreate(
        email="test_pydantic_fail@example.com",
        username="test_pydantic_user_fail",
        password="validpassword123",
        full_name="Test Pydantic Fail"
    )

    mocker.patch("app.db.user_crud.get_password_hash", return_value="mocked_hashed_password")
    mock_logger_error = mocker.patch("app.db.user_crud.logger.error")

    simulated_pydantic_error = ValidationError.from_exception_data(
        title='UserInDB',
        line_errors=[{'type': 'missing', 'loc': ('some_field',), 'msg': 'Field required', 'input': {}}]
    )
    mock_model_validate = mocker.patch(
        "app.db.user_crud.UserInDB.model_validate",
        side_effect=simulated_pydantic_error
    )

    mock_db_connection = AsyncMock()

    # --- Act ---
    result = await user_crud.create_user(db=mock_db_connection, user_in=valid_user_create_input)

    # --- Assert ---
    assert result is None

    mock_model_validate.assert_called_once()

    mock_logger_error.assert_called_once()
    call_args, call_kwargs = mock_logger_error.call_args
    log_message = call_args[0]
    assert f"Erro de valida√ß√£o Pydantic ao preparar dados para user_db_obj (username: {valid_user_create_input.username})" in log_message
    assert str(simulated_pydantic_error) in log_message
    assert call_kwargs.get("exc_info") is True

async def test_create_user_db_insert_not_acknowledged(mocker): # type: ignore
    """
    Testa se create_user retorna None e loga erro quando a inser√ß√£o
    no banco de dados n√£o √© confirmada (acknowledged=False).
    """
    # --- Arrange ---
    valid_user_create_input = UserCreate(
        email="test_not_acknowledged@example.com",
        username="test_user_not_acknowledged",
        password="validpassword123",
        full_name="Test Not Ack"
    )

    mocker.patch("app.db.user_crud.get_password_hash", return_value="mocked_hashed_password")

    mock_user_db_obj = MagicMock()
    expected_dict_to_insert = {"mocked_data": "to_insert"}
    mock_user_db_obj.model_dump.return_value = expected_dict_to_insert
    mock_validate = mocker.patch("app.db.user_crud.UserInDB.model_validate", return_value=mock_user_db_obj)

    mock_insert_result = MagicMock()
    mock_insert_result.acknowledged = False

    mock_collection = AsyncMock()
    mock_collection.insert_one.return_value = mock_insert_result
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)

    mock_logger_error = mocker.patch("app.db.user_crud.logger.error")

    mock_db_connection = AsyncMock()

    # --- Act ---
    result = await user_crud.create_user(db=mock_db_connection, user_in=valid_user_create_input)

    # --- Assert ---
    assert result is None

    mock_validate.assert_called_once()
    mock_user_db_obj.model_dump.assert_called_once_with(mode="json")

    mock_collection.insert_one.assert_awaited_once()

    actual_call_args = mock_collection.insert_one.await_args.args
    actual_call_kwargs = mock_collection.insert_one.await_args.kwargs
    assert len(actual_call_args) == 1
    assert actual_call_args[0] == expected_dict_to_insert
    assert not actual_call_kwargs

    mock_logger_error.assert_called_once()
    call_args, _ = mock_logger_error.call_args
    log_message = call_args[0]
    assert f"DB Insert User Acknowledged False for username {valid_user_create_input.username}" in log_message

async def test_create_user_handles_generic_db_exception_on_insert(mocker): # type: ignore
    """
    Testa se create_user retorna None e loga exce√ß√£o quando
    insert_one levanta um erro gen√©rico do banco de dados.
    """
    # --- Arrange ---
    valid_user_create_input = UserCreate(
        email="test_generic_db_exception@example.com",
        username="test_user_generic_exception",
        password="validpassword123",
        full_name="Test Generic DB Exc"
    )

    mocker.patch("app.db.user_crud.get_password_hash", return_value="mocked_hashed_password")

    mock_user_db_obj = MagicMock()
    expected_dict_to_insert = {"mocked_data": "to_insert"}
    mock_user_db_obj.model_dump.return_value = expected_dict_to_insert
    mock_validate = mocker.patch("app.db.user_crud.UserInDB.model_validate", return_value=mock_user_db_obj)

    simulated_db_error = Exception("Simulated generic database error on insert")
    mock_collection = AsyncMock()
    mock_collection.insert_one.side_effect = simulated_db_error
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)

    mock_logger_exception = mocker.patch("app.db.user_crud.logger.exception")

    mock_db_connection = AsyncMock()

    # --- Act ---
    result = await user_crud.create_user(db=mock_db_connection, user_in=valid_user_create_input)

    # --- Assert ---
    assert result is None

    mock_validate.assert_called_once()
    mock_user_db_obj.model_dump.assert_called_once_with(mode="json")

    mock_collection.insert_one.assert_awaited_once_with(expected_dict_to_insert)

    mock_logger_exception.assert_called_once()
    call_args, _ = mock_logger_exception.call_args
    log_message = call_args[0]
    assert f"Erro inesperado ao inserir usu√°rio {valid_user_create_input.username} no DB" in log_message
    assert str(simulated_db_error) in log_message

# =======================================
# --- Testes para user_crud.update_user ---
# =======================================
async def test_update_user_success(mocker, mock_db_connection, sample_user_in_db): # type: ignore
    """Testa atualiza√ß√£o de usu√°rio com sucesso (sem alterar senha)."""
    # --- Arrange ---
    test_user_id = sample_user_in_db.id
    update_payload = UserUpdate(full_name="Novo Nome Completo", email="novo@email.com")
    fixed_timestamp = datetime.now(timezone.utc).replace(microsecond=0)

    mock_doc_after_update = sample_user_in_db.model_dump(mode="json")
    mock_doc_after_update.update({
        "full_name": update_payload.full_name,
        "email": update_payload.email,
        "updated_at": fixed_timestamp # MongoDB lida com datetime object
    })
    mock_doc_after_update["_id"] = "some_mongo_id"

    expected_validation_dict = mock_doc_after_update.copy()
    expected_validation_dict.pop("_id")

    # Criar obj esperado diretamente
    expected_user_obj = UserInDB(**expected_validation_dict)

    mock_pwd_hash = mocker.patch("app.db.user_crud.get_password_hash")
    mock_dt_now = mocker.patch("app.db.user_crud.datetime")
    mock_dt_now.now.return_value = fixed_timestamp

    mock_collection = AsyncMock()
    mock_collection.find_one_and_update.return_value = mock_doc_after_update
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)
    mock_validate_model = mocker.patch("app.db.user_crud.UserInDB.model_validate", return_value=expected_user_obj)

    # --- Act ---
    result = await user_crud.update_user(db=mock_db_connection, user_id=test_user_id, user_update=update_payload)

    # --- Assert ---
    assert result == expected_user_obj
    mock_pwd_hash.assert_not_called()

    mock_collection.find_one_and_update.assert_awaited_once()
    args, kwargs = mock_collection.find_one_and_update.await_args
    filter_arg = args[0]
    update_arg = args[1]
    assert filter_arg == {"id": str(test_user_id)}
    expected_set = {
        "full_name": update_payload.full_name,
        "email": update_payload.email,
        "updated_at": fixed_timestamp
    }
    assert update_arg == {"$set": expected_set}
    assert kwargs.get("return_document") is True

    mock_validate_model.assert_called_once_with(expected_validation_dict)

async def test_update_user_with_password(mocker, mock_db_connection, sample_user_in_db): # type: ignore
    """Testa atualiza√ß√£o de usu√°rio incluindo a senha."""
    # --- Arrange ---
    test_user_id = sample_user_in_db.id
    new_password = "newSecurePassword123"
    new_hashed_password = "hashed_" + new_password
    update_payload = UserUpdate(password=new_password, disabled=True)
    fixed_timestamp = datetime.now(timezone.utc).replace(microsecond=0)

    mock_doc_after_update = sample_user_in_db.model_dump(mode="json")
    mock_doc_after_update.update({
        "hashed_password": new_hashed_password,
        "disabled": True,
        "updated_at": fixed_timestamp # Usar datetime object
    })
    mock_doc_after_update["_id"] = "pw_update_id"
    expected_validation_dict = mock_doc_after_update.copy()
    expected_validation_dict.pop("_id")

    expected_user_obj = UserInDB(**expected_validation_dict)

    mock_pwd_hash = mocker.patch("app.db.user_crud.get_password_hash", return_value=new_hashed_password)
    mock_dt_now = mocker.patch("app.db.user_crud.datetime")
    mock_dt_now.now.return_value = fixed_timestamp

    mock_collection = AsyncMock()
    mock_collection.find_one_and_update.return_value = mock_doc_after_update
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)
    mock_validate_model = mocker.patch("app.db.user_crud.UserInDB.model_validate", return_value=expected_user_obj)

    # --- Act ---
    result = await user_crud.update_user(db=mock_db_connection, user_id=test_user_id, user_update=update_payload)

    # --- Assert ---
    assert result == expected_user_obj
    mock_pwd_hash.assert_called_once_with(new_password)

    mock_collection.find_one_and_update.assert_awaited_once()
    args, kwargs = mock_collection.find_one_and_update.await_args
    filter_arg = args[0]
    update_arg = args[1]
    assert filter_arg == {"id": str(test_user_id)}
    expected_set = {
        "hashed_password": new_hashed_password,
        "disabled": True,
        "updated_at": fixed_timestamp
    }
    assert update_arg == {"$set": expected_set}
    assert kwargs.get("return_document") is True

    mock_validate_model.assert_called_once_with(expected_validation_dict)

async def test_update_user_not_found(mocker, mock_db_connection): # type: ignore
    """Testa atualiza√ß√£o de usu√°rio quando find_one_and_update retorna None."""
    # --- Arrange ---
    test_user_id = uuid.uuid4()
    update_payload = UserUpdate(full_name="Nome que nao sera atualizado")
    fixed_timestamp = datetime.now(timezone.utc)

    mock_pwd_hash = mocker.patch("app.db.user_crud.get_password_hash")
    mock_dt_now = mocker.patch("app.db.user_crud.datetime")
    mock_dt_now.now.return_value = fixed_timestamp

    mock_collection = AsyncMock()
    mock_collection.find_one_and_update.return_value = None
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)
    mock_logger_warning = mocker.patch("app.db.user_crud.logger.warning")

    # --- Act ---
    result = await user_crud.update_user(db=mock_db_connection, user_id=test_user_id, user_update=update_payload)

    # --- Assert ---
    assert result is None

    mock_collection.find_one_and_update.assert_awaited_once()
    args, kwargs = mock_collection.find_one_and_update.await_args
    expected_set = {"full_name": update_payload.full_name, "updated_at": fixed_timestamp}
    assert args[1] == {"$set": expected_set}

    mock_logger_warning.assert_called_once()
    assert f"Attempt to update user not found: ID {test_user_id}" in mock_logger_warning.call_args[0][0]
    mock_pwd_hash.assert_not_called()

async def test_update_user_raises_duplicate_key_error(mocker, mock_db_connection): # type: ignore
    """Testa se DuplicateKeyError em update √© relan√ßado."""
    # --- Arrange ---
    test_user_id = uuid.uuid4()
    update_payload = UserUpdate(email="existing@duplicate.com")
    fixed_timestamp = datetime.now(timezone.utc)


    mocker.patch("app.db.user_crud.get_password_hash")
    mock_dt_now = mocker.patch("app.db.user_crud.datetime")
    mock_dt_now.now.return_value = fixed_timestamp

    simulated_db_error = DuplicateKeyError("E11000 duplicate key error collection")
    mock_collection = AsyncMock()
    mock_collection.find_one_and_update.side_effect = simulated_db_error
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)
    mock_logger_warning = mocker.patch("app.db.user_crud.logger.warning")

    # --- Act & Assert ---
    with pytest.raises(DuplicateKeyError):
        await user_crud.update_user(db=mock_db_connection, user_id=test_user_id, user_update=update_payload)

    mock_collection.find_one_and_update.assert_awaited_once()
    args, kwargs = mock_collection.find_one_and_update.await_args
    expected_set = {"email": update_payload.email, "updated_at": fixed_timestamp}
    assert args[1] == {"$set": expected_set}

    mock_logger_warning.assert_called_once()

async def test_update_user_generic_exception(mocker, mock_db_connection): # type: ignore
    """Testa tratamento de exce√ß√£o gen√©rica em update."""
    # --- Arrange ---
    test_user_id = uuid.uuid4()
    update_payload = UserUpdate(disabled=False)
    fixed_timestamp = datetime.now(timezone.utc)

    mocker.patch("app.db.user_crud.get_password_hash")
    mock_dt_now = mocker.patch("app.db.user_crud.datetime")
    mock_dt_now.now.return_value = fixed_timestamp

    simulated_db_error = Exception("Generic update error")
    mock_collection = AsyncMock()
    mock_collection.find_one_and_update.side_effect = simulated_db_error
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)
    mock_logger_exception = mocker.patch("app.db.user_crud.logger.exception")

    # --- Act ---
    result = await user_crud.update_user(db=mock_db_connection, user_id=test_user_id, user_update=update_payload)

    # --- Assert ---
    assert result is None

    mock_collection.find_one_and_update.assert_awaited_once()
    args, kwargs = mock_collection.find_one_and_update.await_args
    expected_set = {"disabled": update_payload.disabled, "updated_at": fixed_timestamp}
    assert args[1] == {"$set": expected_set}

    mock_logger_exception.assert_called_once()
    assert f"DB Error updating user {test_user_id}" in mock_logger_exception.call_args[0][0]

async def test_update_user_empty_payload_updates_only_timestamp(mocker): # type: ignore
    """
    Testa se update_user atualiza apenas o timestamp 'updated_at'
    quando o payload de atualiza√ß√£o resulta em nenhum dado a ser modificado,
    e valida se o usu√°rio correto √© retornado.
    """
    # --- Arrange ---
    test_user_id = uuid.uuid4()
    fixed_timestamp = datetime.now(timezone.utc).replace(microsecond=0)

    empty_update_payload = UserUpdate(password=None)

    existing_user_mock = MagicMock(spec=UserInDB)
    existing_user_mock.id = test_user_id

    # Doc retornado pelo DB
    mock_doc_after_update_from_db = {"_id": "mongo_id", "id": str(test_user_id), "updated_at": fixed_timestamp}
    # Dict esperado para valida√ß√£o (sem _id)
    expected_dict_for_validation = {"id": str(test_user_id), "updated_at": fixed_timestamp}
    # Obj esperado p√≥s valida√ß√£o (com dados minimos p/ o teste)
    final_validated_user_mock = MagicMock(spec=UserInDB)

    mocker.patch("app.db.user_crud.get_password_hash")
    mock_get_user = mocker.patch("app.db.user_crud.get_user_by_id", return_value=existing_user_mock)
    mock_dt_now = mocker.patch("app.db.user_crud.datetime")
    mock_dt_now.now.return_value = fixed_timestamp

    mock_collection = AsyncMock()
    mock_collection.find_one_and_update.return_value = mock_doc_after_update_from_db
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)

    # Mock retorna o obj mockado
    mock_validate_model = mocker.patch(
        "app.db.user_crud.UserInDB.model_validate",
        return_value=final_validated_user_mock
    )

    mock_db_connection = AsyncMock()

    # --- Act ---
    result = await user_crud.update_user(
        db=mock_db_connection,
        user_id=test_user_id,
        user_update=empty_update_payload
    )

    # --- Assert ---
    assert result == final_validated_user_mock

    user_crud.get_password_hash.assert_not_called()

    mock_get_user.assert_awaited_once()
    actual_get_user_args = mock_get_user.await_args.args
    actual_get_user_kwargs = mock_get_user.await_args.kwargs
    assert (len(actual_get_user_args) == 2 and actual_get_user_args[0] is mock_db_connection and actual_get_user_args[1] == test_user_id and not actual_get_user_kwargs) or \
           (not actual_get_user_args and len(actual_get_user_kwargs) == 2 and actual_get_user_kwargs.get('db') is mock_db_connection and actual_get_user_kwargs.get('user_id') == test_user_id)

    mock_collection.find_one_and_update.assert_awaited_once()
    find_one_update_args, find_one_update_kwargs = mock_collection.find_one_and_update.await_args
    assert len(find_one_update_args) == 2
    call_filter = find_one_update_args[0]
    call_update_doc = find_one_update_args[1]
    assert call_filter == {"id": str(test_user_id)}
    assert call_update_doc == {"$set": {"updated_at": fixed_timestamp}}
    assert find_one_update_kwargs.get("return_document") is True

    mock_validate_model.assert_called_once_with(expected_dict_for_validation)

async def test_update_user_empty_payload_get_user_returns_none(mocker): # type: ignore
    """
    Testa se update_user retorna None quando o payload de atualiza√ß√£o
    est√° vazio e a busca inicial por get_user_by_id retorna None.
    """
    # --- Arrange ---
    test_user_id = uuid.uuid4()
    empty_update_payload = UserUpdate(password=None)

    mock_pwd_hash = mocker.patch("app.db.user_crud.get_password_hash")

    mock_get_user = mocker.patch("app.db.user_crud.get_user_by_id", return_value=None)

    mock_collection_instance = AsyncMock()
    mocker.patch(
        "app.db.user_crud._get_users_collection",
        return_value=mock_collection_instance
    )

    mock_validate = mocker.patch("app.db.user_crud.UserInDB.model_validate")

    mock_db_connection = AsyncMock()

    # --- Act ---
    result = await user_crud.update_user(
        db=mock_db_connection,
        user_id=test_user_id,
        user_update=empty_update_payload
    )

    # --- Assert ---
    assert result is None

    mock_pwd_hash.assert_not_called()

    mock_get_user.assert_awaited_once()
    actual_get_user_args = mock_get_user.await_args.args
    actual_get_user_kwargs = mock_get_user.await_args.kwargs
    assert (len(actual_get_user_args) == 2 and actual_get_user_args[0] is mock_db_connection and actual_get_user_args[1] == test_user_id and not actual_get_user_kwargs) or \
           (not actual_get_user_args and len(actual_get_user_kwargs) == 2 and actual_get_user_kwargs.get('db') is mock_db_connection and actual_get_user_kwargs.get('user_id') == test_user_id)

    # _get_users_collection *√© chamado* no in√≠cio da fun√ß√£o update_user
    user_crud._get_users_collection.assert_called_once_with(mock_db_connection)
    mock_collection_instance.find_one_and_update.assert_not_called()
    mock_validate.assert_not_called()

async def test_update_user_empty_payload_update_exception(mocker): # type: ignore
    """
    Testa se update_user retorna None e loga exce√ß√£o quando payload est√° vazio
    e a chamada a find_one_and_update (para updated_at) levanta erro.
    """
    # --- Arrange ---
    test_user_id = uuid.uuid4()
    fixed_timestamp = datetime.now(timezone.utc).replace(microsecond=0)
    empty_update_payload = UserUpdate(password=None)

    existing_user_mock = MagicMock(spec=UserInDB)
    existing_user_mock.id = test_user_id

    simulated_update_exception = Exception("Erro ao atualizar apenas updated_at")

    mock_pwd_hash = mocker.patch("app.db.user_crud.get_password_hash")
    mock_get_user = mocker.patch("app.db.user_crud.get_user_by_id", return_value=existing_user_mock)
    mock_dt_now = mocker.patch("app.db.user_crud.datetime")
    mock_dt_now.now.return_value = fixed_timestamp

    mock_collection = AsyncMock()
    mock_collection.find_one_and_update.side_effect = simulated_update_exception
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)

    mock_validate_model = mocker.patch("app.db.user_crud.UserInDB.model_validate")
    mock_logger_exception = mocker.patch("app.db.user_crud.logger.exception")
    mock_db_connection = AsyncMock()

    # --- Act ---
    result = await user_crud.update_user(
        db=mock_db_connection,
        user_id=test_user_id,
        user_update=empty_update_payload
    )

    # --- Assert ---
    assert result is None

    mock_pwd_hash.assert_not_called()
    mock_get_user.assert_awaited_once()

    mock_collection.find_one_and_update.assert_awaited_once()
    mock_validate_model.assert_not_called()
    mock_logger_exception.assert_called_once()
    call_args, _ = mock_logger_exception.call_args
    log_message = call_args[0]
    assert f"DB Error updating user (only updated_at) {test_user_id}" in log_message
    assert str(simulated_update_exception) in log_message

async def test_update_user_empty_payload_validate_failure(mocker): # type: ignore
    """
    Testa falha na valida√ß√£o Pydantic ap√≥s find_one_and_update
    no branch de payload vazio, assumindo que find_one_and_update retornou um doc.
    """
    # --- Arrange ---
    test_user_id = uuid.uuid4()
    fixed_timestamp = datetime.now(timezone.utc).replace(microsecond=0)
    empty_update_payload = UserUpdate(password=None)

    existing_user_mock = MagicMock(spec=UserInDB)
    existing_user_mock.id = test_user_id

    mock_doc_after_update_invalid = {
        "_id": "mongo_id_invalid",
        "id": str(test_user_id),
        "updated_at": fixed_timestamp,
        "campo_inesperado": "este_campo_causa_falha"
    }
    expected_dict_for_validation = {
        "id": str(test_user_id),
        "updated_at": fixed_timestamp,
        "campo_inesperado": "este_campo_causa_falha"
    }

    mocker.patch("app.db.user_crud.get_password_hash")
    mock_get_user = mocker.patch("app.db.user_crud.get_user_by_id", return_value=existing_user_mock)
    mock_dt_now = mocker.patch("app.db.user_crud.datetime")
    mock_dt_now.now.return_value = fixed_timestamp

    mock_collection = AsyncMock()
    mock_collection.find_one_and_update.return_value = mock_doc_after_update_invalid
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)

    simulated_validation_error = ValidationError.from_exception_data(
        title='UserInDB',
        line_errors=[{'type': 'extra_forbidden', 'loc': ('campo_inesperado',), 'msg': 'Extra fields not permitted', 'input': 'este_campo_causa_falha'}]
    )
    mock_validate_model = mocker.patch(
        "app.db.user_crud.UserInDB.model_validate",
        side_effect=simulated_validation_error
    )

    mock_logger_exception = mocker.patch("app.db.user_crud.logger.exception")
    mock_logger_error = mocker.patch("app.db.user_crud.logger.error") # Deve usar .exception agora
    mock_db_connection = AsyncMock()

    # --- Act ---
    result = await user_crud.update_user(
        db=mock_db_connection,
        user_id=test_user_id,
        user_update=empty_update_payload
    )

    # --- Assert ---
    assert result is None

    user_crud.get_password_hash.assert_not_called()
    mock_get_user.assert_awaited_once()
    mock_collection.find_one_and_update.assert_awaited_once()

    # A valida√ß√£o falha, mas ainda √© chamada
    mock_validate_model.assert_called_once_with(expected_dict_for_validation)

    # O erro √© capturado pelo 'except Exception', usando logger.exception
    mock_logger_error.assert_not_called()
    mock_logger_exception.assert_called_once()
    call_args, _ = mock_logger_exception.call_args
    log_message = call_args[0]
    assert f"DB Error updating user (only updated_at) {test_user_id}" in log_message
    assert str(simulated_validation_error) in log_message

async def test_update_user_main_path_validate_failure(mocker): # type: ignore
    """
    Testa falha na valida√ß√£o Pydantic ap√≥s find_one_and_update
    no caminho principal (quando update_data n√£o est√° vazio).
    """
    # --- Arrange ---
    test_user_id = uuid.uuid4()
    update_payload = UserUpdate(full_name="Nome Atualizado")
    fixed_timestamp = datetime.now(timezone.utc).replace(microsecond=0)

    mock_doc_after_update_invalid = {
        "_id": "mongo_id_main_fail",
        "id": str(test_user_id),
        "full_name": update_payload.full_name,
        "updated_at": fixed_timestamp,
        "campo_invalido_no_retorno": 123
    }
    expected_dict_for_validation = {
        "id": str(test_user_id),
        "full_name": update_payload.full_name,
        "updated_at": fixed_timestamp,
        "campo_invalido_no_retorno": 123
    }

    mock_pwd_hash = mocker.patch("app.db.user_crud.get_password_hash")
    mock_get_user = mocker.patch("app.db.user_crud.get_user_by_id")
    mock_dt_now = mocker.patch("app.db.user_crud.datetime")
    mock_dt_now.now.return_value = fixed_timestamp

    mock_collection = AsyncMock()
    mock_collection.find_one_and_update.return_value = mock_doc_after_update_invalid
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)

    simulated_validation_error = ValidationError.from_exception_data(
        title='UserInDB',
        line_errors=[{'type': 'extra_forbidden', 'loc': ('campo_invalido_no_retorno',), 'msg': 'Extra fields not permitted', 'input': 123}]
    )
    mock_validate_model = mocker.patch(
        "app.db.user_crud.UserInDB.model_validate",
        side_effect=simulated_validation_error
    )

    mock_logger_error = mocker.patch("app.db.user_crud.logger.error")
    mock_db_connection = AsyncMock()

    # --- Act ---
    result = await user_crud.update_user(
        db=mock_db_connection,
        user_id=test_user_id,
        user_update=update_payload
    )

    # --- Assert ---
    assert result is None

    mock_pwd_hash.assert_not_called()
    mock_get_user.assert_not_called()

    mock_collection.find_one_and_update.assert_awaited_once()
    find_one_update_args, find_one_update_kwargs = mock_collection.find_one_and_update.await_args
    assert len(find_one_update_args) == 2
    call_filter = find_one_update_args[0]
    call_update_doc = find_one_update_args[1]
    assert call_filter == {"id": str(test_user_id)}
    expected_set_doc = {"full_name": update_payload.full_name, "updated_at": fixed_timestamp}
    assert call_update_doc == {"$set": expected_set_doc}
    assert find_one_update_kwargs.get("return_document") is True

    mock_validate_model.assert_called_once_with(expected_dict_for_validation)

    mock_logger_error.assert_called_once()
    call_args, call_kwargs = mock_logger_error.call_args
    log_message = call_args[0]
    assert f"DB Validation error after updating user {test_user_id}" in log_message
    assert str(simulated_validation_error) in log_message
    # A asser√ß√£o sobre exc_info foi removida, pois o teste falhou e a corre√ß√£o acima garante o log esperado.

async def test_update_user_main_path_user_not_found(mocker, mock_db_connection): # type: ignore
    """
    Testa se update_user retorna None e loga aviso quando o usu√°rio
    n√£o √© encontrado por find_one_and_update no caminho principal.
    """
    # --- Arrange ---
    test_user_id = uuid.uuid4()
    update_payload = UserUpdate(full_name="Nome Nao Atualizado")
    fixed_timestamp = datetime.now(timezone.utc)

    mock_pwd_hash = mocker.patch("app.db.user_crud.get_password_hash")
    mock_dt_now = mocker.patch("app.db.user_crud.datetime")
    mock_dt_now.now.return_value = fixed_timestamp

    mock_collection = AsyncMock()
    mock_collection.find_one_and_update.return_value = None 
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)

    mock_validate_model = mocker.patch("app.db.user_crud.UserInDB.model_validate")
    mock_logger_warning = mocker.patch("app.db.user_crud.logger.warning")

    # --- Act ---
    result = await user_crud.update_user(
        db=mock_db_connection,
        user_id=test_user_id,
        user_update=update_payload
    )

    # --- Assert ---
    assert result is None

    mock_pwd_hash.assert_not_called()
    mock_collection.find_one_and_update.assert_awaited_once()
    mock_validate_model.assert_not_called()

    mock_logger_warning.assert_called_once()
    log_call_args = mock_logger_warning.call_args[0]
    assert f"Attempt to update user not found: ID {test_user_id}" in log_call_args[0]

async def test_update_user_main_path_raises_duplicate_key_error(mocker, mock_db_connection): # type: ignore
    """
    Testa se DuplicateKeyError √© relan√ßado por update_user
    no caminho principal e um aviso √© logado.
    """
    # --- Arrange ---
    test_user_id = uuid.uuid4()
    update_payload = UserUpdate(email="duplicate@test.com") 
    fixed_timestamp = datetime.now(timezone.utc)

    mocker.patch("app.db.user_crud.get_password_hash")
    mock_dt_now = mocker.patch("app.db.user_crud.datetime")
    mock_dt_now.now.return_value = fixed_timestamp

    simulated_db_error = DuplicateKeyError("E11000 duplicate key error collection on update")
    mock_collection = AsyncMock()
    mock_collection.find_one_and_update.side_effect = simulated_db_error
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)

    mock_validate_model = mocker.patch("app.db.user_crud.UserInDB.model_validate")
    mock_logger_warning = mocker.patch("app.db.user_crud.logger.warning")

    # --- Act & Assert ---
    with pytest.raises(DuplicateKeyError):
        await user_crud.update_user(
            db=mock_db_connection,
            user_id=test_user_id,
            user_update=update_payload
        )

    mock_collection.find_one_and_update.assert_awaited_once()
    args, kwargs = mock_collection.find_one_and_update.await_args
    expected_set = {"email": update_payload.email, "updated_at": fixed_timestamp}
    assert args[1] == {"$set": expected_set}

    mock_validate_model.assert_not_called()

    mock_logger_warning.assert_called_once()
    log_call_args = mock_logger_warning.call_args[0]
    assert f"DB Error: Attempt to update user {test_user_id}" in log_call_args[0]
    assert "'email': 'duplicate@test.com'" in log_call_args[0]

async def test_update_user_empty_payload_find_one_and_update_returns_none(mocker): # type: ignore
    """
    Testa se update_user retorna None quando payload est√° vazio,
    usu√°rio existe, mas find_one_and_update (para updated_at) retorna None.
    """
    # --- Arrange ---
    test_user_id = uuid.uuid4()
    fixed_timestamp = datetime.now(timezone.utc).replace(microsecond=0)
    empty_update_payload = UserUpdate(password=None)

    existing_user_mock = MagicMock(spec=UserInDB)
    existing_user_mock.id = test_user_id

    mock_pwd_hash = mocker.patch("app.db.user_crud.get_password_hash")
    mock_get_user = mocker.patch("app.db.user_crud.get_user_by_id", return_value=existing_user_mock)
    mock_dt_now = mocker.patch("app.db.user_crud.datetime")
    mock_dt_now.now.return_value = fixed_timestamp

    mock_collection = AsyncMock()
    mock_collection.find_one_and_update.return_value = None 
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)

    mock_validate_model = mocker.patch("app.db.user_crud.UserInDB.model_validate")
    mock_logger_exception = mocker.patch("app.db.user_crud.logger.exception")
    mock_db_connection = AsyncMock()

    # --- Act ---
    result = await user_crud.update_user(
        db=mock_db_connection,
        user_id=test_user_id,
        user_update=empty_update_payload
    )

    # --- Assert ---
    assert result is None

    mock_pwd_hash.assert_not_called()
    mock_get_user.assert_awaited_once()

    # Verifica a chamada a find_one_and_update (para updated_at)
    mock_collection.find_one_and_update.assert_awaited_once()
    find_one_update_args, find_one_update_kwargs = mock_collection.find_one_and_update.await_args
    assert len(find_one_update_args) == 2
    call_filter = find_one_update_args[0]
    call_update_doc = find_one_update_args[1]
    assert call_filter == {"id": str(test_user_id)}
    assert call_update_doc == {"$set": {"updated_at": fixed_timestamp}}
    assert find_one_update_kwargs.get("return_document") is True

    mock_validate_model.assert_not_called()
    mock_logger_exception.assert_not_called()

# =======================================
# --- Testes para user_crud.delete_user ---
# =======================================
async def test_delete_user_success(mocker, mock_db_connection): # type: ignore
    """Testa dele√ß√£o de usu√°rio com sucesso."""
    # --- Arrange ---
    test_user_id = uuid.uuid4()

    mock_delete_result = MagicMock()
    mock_delete_result.deleted_count = 1

    mock_collection = AsyncMock()
    mock_collection.delete_one.return_value = mock_delete_result
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)
    mock_logger_info = mocker.patch("app.db.user_crud.logger.info")

    # --- Act ---
    result = await user_crud.delete_user(db=mock_db_connection, user_id=test_user_id)

    # --- Assert ---
    assert result is True
    mock_collection.delete_one.assert_awaited_once_with({"id": str(test_user_id)})
    mock_logger_info.assert_called_once_with(f"User {test_user_id} deleted successfully.")

async def test_delete_user_not_found(mocker, mock_db_connection): # type: ignore
    """Testa dele√ß√£o de usu√°rio quando n√£o encontrado."""
    # --- Arrange ---
    test_user_id = uuid.uuid4()

    mock_delete_result = MagicMock()
    mock_delete_result.deleted_count = 0

    mock_collection = AsyncMock()
    mock_collection.delete_one.return_value = mock_delete_result
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)
    mock_logger_warning = mocker.patch("app.db.user_crud.logger.warning")

    # --- Act ---
    result = await user_crud.delete_user(db=mock_db_connection, user_id=test_user_id)

    # --- Assert ---
    assert result is False
    mock_collection.delete_one.assert_awaited_once_with({"id": str(test_user_id)})
    mock_logger_warning.assert_called_once()
    assert f"Attempt to delete user {test_user_id}" in mock_logger_warning.call_args[0][0]
    assert "(deleted_count: 0)" in mock_logger_warning.call_args[0][0]

async def test_delete_user_generic_exception(mocker, mock_db_connection): # type: ignore
    """Testa tratamento de exce√ß√£o gen√©rica em delete_user."""
    # --- Arrange ---
    test_user_id = uuid.uuid4()
    simulated_db_error = Exception("Generic delete error")

    mock_collection = AsyncMock()
    mock_collection.delete_one.side_effect = simulated_db_error
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)
    mock_logger_exception = mocker.patch("app.db.user_crud.logger.exception")

    # --- Act ---
    result = await user_crud.delete_user(db=mock_db_connection, user_id=test_user_id)

    # --- Assert ---
    assert result is False
    mock_collection.delete_one.assert_awaited_once_with({"id": str(test_user_id)})
    mock_logger_exception.assert_called_once()
    assert f"DB Error deleting user {test_user_id}" in mock_logger_exception.call_args[0][0]

# ==============================================
# --- Testes para user_crud.create_user_indexes ---
# ==============================================
async def test_create_user_indexes_success(mocker, mock_db_connection): # type: ignore
    """Testa cria√ß√£o de √≠ndices com sucesso."""
    # --- Arrange ---
    mock_collection = AsyncMock()
    mock_collection.create_index = AsyncMock()
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)
    mock_logger_info = mocker.patch("app.db.user_crud.logger.info")

    # --- Act ---
    await user_crud.create_user_indexes(db=mock_db_connection)

    # --- Assert ---
    expected_calls = [
        call("username", unique=True, name="username_unique_idx"),
        call("email", unique=True, name="email_unique_idx")
    ]
    mock_collection.create_index.assert_has_awaits(expected_calls, any_order=False)
    mock_logger_info.assert_called_once()
    assert "√çndices da cole√ß√£o 'users'" in mock_logger_info.call_args[0][0]
    assert "verificados/criados com sucesso" in mock_logger_info.call_args[0][0]

async def test_create_user_indexes_failure(mocker, mock_db_connection): # type: ignore
    """Testa tratamento de erro na cria√ß√£o de √≠ndices."""
    # --- Arrange ---
    simulated_index_error = Exception("Erro ao criar indice simulado")
    mock_collection = AsyncMock()
    mock_collection.create_index.side_effect = simulated_index_error
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)
    mock_logger_error = mocker.patch("app.db.user_crud.logger.error")

    # --- Act ---
    await user_crud.create_user_indexes(db=mock_db_connection)

    # --- Assert ---
    mock_collection.create_index.assert_awaited_once_with("username", unique=True, name="username_unique_idx")
    mock_logger_error.assert_called_once()
    call_args, call_kwargs = mock_logger_error.call_args
    log_message = call_args[0]
    assert "Erro ao criar √≠ndices para a cole√ß√£o 'users'" in log_message
    assert str(simulated_index_error) in log_message
    assert call_kwargs.get("exc_info") is True

================================================================================
Cap√≠tulo 28: tests/test_main.py
================================================================================

# tests/test_main.py

# ========================
# --- Importa√ß√µes ---
# ========================
import logging
from loguru import logger as loguru_logger_obj
from unittest.mock import AsyncMock, MagicMock
import pytest
from fastapi import FastAPI, status
from fastapi.middleware.cors import CORSMiddleware
from httpx import AsyncClient

# --- M√≥dulos da Aplica√ß√£o ---
from app.core import logging_config 
from app.core.config import Settings, settings 
from app.main import lifespan
from app.main import _setup_cors_middleware


# ======================================
# --- Testes para o Endpoint Raiz ---
# ======================================
@pytest.mark.asyncio
async def test_read_root_endpoint_returns_welcome_message(test_async_client: AsyncClient):
    print("\nTeste: Endpoint raiz ('/').")
    print(f"  Atuando: GET para '/'")
    response = await test_async_client.get("/")

    assert response.status_code == status.HTTP_200_OK, \
        f"Esperado status 200, recebido {response.status_code}. Resposta: {response.text}"
    
    response_json = response.json()
    expected_message_part = f"Bem-vindo √† {settings.PROJECT_NAME}!"
    assert "message" in response_json, "Campo 'message' ausente na resposta JSON."
    assert expected_message_part in response_json["message"], \
        f"Mensagem de boas-vindas n√£o cont√©m '{expected_message_part}'. Recebido: '{response_json['message']}'"
    print(f"  Sucesso: Endpoint raiz retornou a mensagem de boas-vindas esperada.")

# ===============================================
# --- Testes para a Fun√ß√£o de Ciclo de Vida (Lifespan) ---
# ===============================================
@pytest.mark.asyncio
async def test_lifespan_handles_database_connection_failure_on_startup(
    mocker,
    caplog
):
    caplog.set_level(logging.CRITICAL, logger="app.main") 
    mock_connect_db = mocker.patch('app.main.connect_to_mongo', return_value=None)
    mock_close_db = mocker.patch('app.main.close_mongo_connection', new_callable=AsyncMock)
    mock_create_user_indexes_fn = mocker.patch('app.main.create_user_indexes', new_callable=AsyncMock)
    mock_create_task_indexes_fn = mocker.patch('app.main.create_task_indexes', new_callable=AsyncMock)
    
    test_app_instance = MagicMock(spec=FastAPI)
    test_app_instance.state = MagicMock()
    if hasattr(test_app_instance.state, "db"):
        del test_app_instance.state.db
    
    print("  Atuando: Executando o context manager 'lifespan'...")
    async with lifespan(test_app_instance):
        print("    Dentro do 'yield' do lifespan (ap√≥s tentativa de conex√£o).")
        print("DEBUG: test_lifespan_handles_database_connection_failure_on_startup - P√≥s-yield")
        assert not hasattr(test_app_instance.state, "db") or test_app_instance.state.db is None, \
            "app.state.db n√£o deveria ser definido se a conex√£o falhou."

    mock_connect_db.assert_awaited_once()
    mock_create_user_indexes_fn.assert_not_called()
    mock_create_task_indexes_fn.assert_not_called()
    
    assert any(
        "Falha fatal ao conectar ao MongoDB" in record.getMessage()
        for record in caplog.records
        if record.name == "app.main" and record.levelname == "CRITICAL"
    ), "Mensagem de log cr√≠tico para falha de conex√£o n√£o encontrada."
    
    mock_close_db.assert_not_called()

@pytest.mark.asyncio
async def test_lifespan_handles_index_creation_failure_on_startup(
    mocker,
    caplog
):
    simulated_index_error = Exception("Erro simulado durante a cria√ß√£o do √≠ndice de usu√°rio.")
    mock_db_connection_instance = AsyncMock()
    mocker.patch('app.main.connect_to_mongo', return_value=mock_db_connection_instance)
    mock_close_db = mocker.patch('app.main.close_mongo_connection', new_callable=AsyncMock)
    mock_create_user_idx_fn = mocker.patch('app.main.create_user_indexes', side_effect=simulated_index_error)
    mock_create_task_idx_fn = mocker.patch('app.main.create_task_indexes', new_callable=AsyncMock)
    
    mock_app_instance_for_lifespan = MagicMock(spec=FastAPI)
    mock_app_instance_for_lifespan.state = MagicMock()

    caplog.set_level(logging.ERROR, logger="app.main")

    try:
        async with lifespan(mock_app_instance_for_lifespan):
            print(f"    Dentro do 'yield' do lifespan. app.state.db={mock_app_instance_for_lifespan.state.db}")
            print("DEBUG: test_lifespan_handles_index_creation_failure_on_startup - P√≥s-yield")
            assert mock_app_instance_for_lifespan.state.db == mock_db_connection_instance, \
                "app.state.db n√£o foi definido corretamente ap√≥s conex√£o bem-sucedida."
    except Exception as e:
        pytest.fail(f"Lifespan levantou uma exce√ß√£o inesperada para fora: {e}")

    mock_create_user_idx_fn.assert_awaited_once_with(mock_db_connection_instance)
    mock_create_task_idx_fn.assert_not_called()
    
    error_log_found = False
    for record in caplog.records:
        if record.name == "app.main" and record.levelname == "ERROR":
            if "Erro durante a cria√ß√£o de √≠ndices" in record.getMessage():
                assert record.exc_info is not None and record.exc_info[0] is Exception, \
                    "exc_info=True n√£o foi devidamente logado ou √© do tipo errado."
                error_log_found = True
                break
    assert error_log_found, "Mensagem de log de erro para falha na cria√ß√£o de √≠ndice n√£o encontrada."
    
    mock_close_db.assert_awaited_once()

# ===============================================
# --- Testes Logging Config Externo ---
# ===============================================
from loguru import logger as loguru_logger_obj 

def test_intercept_handler_emit_unknown_level(mocker):
    handler = logging_config.InterceptHandler()
    mock_loguru_opt_log = mocker.patch.object(loguru_logger_obj, "opt", return_value=loguru_logger_obj)
    mock_loguru_log = mocker.patch.object(loguru_logger_obj, "log")
    invalid_levelname = "INVALIDLEVELNAME"
    numeric_level = 60
    record = logging.LogRecord(
        name='test.logger',
        level=numeric_level,
        pathname='/path/to/file.py',
        lineno=10,
        msg='Test message with invalid level name',
        args=[],
        exc_info=None,
        func='test_func'
    )
    record.levelname = invalid_levelname

    handler.emit(record)

    mock_loguru_opt_log.assert_called_once() 
    final_log_call_args, _ = mock_loguru_log.call_args
    assert final_log_call_args[0] == numeric_level
    assert final_log_call_args[1] == record.getMessage()

# ==================================================
# --- Testes para _setup_cors_middleware ---
# ==================================================
def test_setup_cors_middleware_with_empty_origins_logs_warning(mocker, caplog):
    mock_app = MagicMock(spec=FastAPI)
    mock_settings_empty_cors = Settings(
        MONGODB_URL="mongodb://testhost:27017/testdb",
        JWT_SECRET_KEY="testsecret",
        CORS_ALLOWED_ORIGINS=[]
    )
    caplog.set_level(logging.WARNING, logger="app.main")

    _setup_cors_middleware(mock_app, mock_settings_empty_cors)

    mock_app.add_middleware.assert_not_called()
    assert any(
        "Nenhuma origem CORS configurada" in record.getMessage()
        for record in caplog.records
        if record.name == "app.main" and record.levelname == "WARNING"
    ), "Warning de CORS para origens vazias n√£o encontrado nos logs"
    print("  Sucesso: _setup_cors_middleware logou warning para CORS vazio.")

def test_setup_cors_middleware_with_origins_adds_middleware(mocker, caplog):
    mock_app = MagicMock(spec=FastAPI)
    mock_settings_with_cors = Settings(
        MONGODB_URL="mongodb://testhost:27017/testdb",
        JWT_SECRET_KEY="testsecret",
        CORS_ALLOWED_ORIGINS=["http://localhost:3000", "https://example.com"]
    )
    caplog.set_level(logging.INFO, logger="app.main")

    _setup_cors_middleware(mock_app, mock_settings_with_cors)

    mock_app.add_middleware.assert_called_once()
    args, kwargs = mock_app.add_middleware.call_args
    assert args[0] == CORSMiddleware
    assert kwargs.get("allow_origins") == ["http://localhost:3000", "https://example.com"]
    assert kwargs.get("allow_credentials") is True
    assert kwargs.get("allow_methods") == ["*"]
    assert kwargs.get("allow_headers") == ["*"]

    assert any(
        "Configurando CORS para origens:" in record.getMessage()
        for record in caplog.records
        if record.name == "app.main" and record.levelname == "INFO"
    ), "Log de INFO para configura√ß√£o CORS n√£o encontrado."
    print("  Sucesso: _setup_cors_middleware adicionou middleware para CORS configurado.")

# ==================================================
# --- Testes para LifeSpan ---
# ==================================================
@pytest.mark.asyncio
async def test_lifespan_successful_startup_and_shutdown(mocker, caplog):
    """
    Testa o caminho feliz completo do lifespan:
    - Conex√£o com DB bem-sucedida.
    - Cria√ß√£o de ambos os √≠ndices bem-sucedida.
    - Logs de INFO apropriados s√£o emitidos.
    - Conex√£o com DB √© fechada no shutdown.
    """
    caplog.set_level(logging.INFO, logger="app.main") 
    
    mock_db_conn = AsyncMock(name="MockDBConnection")
    mock_connect_db = mocker.patch('app.main.connect_to_mongo', return_value=mock_db_conn)
    mock_close_db = mocker.patch('app.main.close_mongo_connection', new_callable=AsyncMock)
    mock_create_user_idx = mocker.patch('app.main.create_user_indexes', new_callable=AsyncMock)
    mock_create_task_idx = mocker.patch('app.main.create_task_indexes', new_callable=AsyncMock)
    
    
    test_app_instance = MagicMock(spec=FastAPI)
    test_app_instance.state = MagicMock() 
    if hasattr(test_app_instance.state, "db"):
        del test_app_instance.state.db


    # --- Act ---
    async with lifespan(test_app_instance):
        print("DEBUG: test_lifespan_successful_startup - P√≥s-yield (dentro do with)")
        assert test_app_instance.state.db == mock_db_conn, "app.state.db n√£o foi definido corretamente."

    # --- Assert ---
    mock_connect_db.assert_awaited_once()
    mock_create_user_idx.assert_awaited_once_with(mock_db_conn)
    mock_create_task_idx.assert_awaited_once_with(mock_db_conn) 
    
    logs = [record.getMessage() for record in caplog.records if record.name == "app.main"]

    assert "Iniciando ciclo de vida da aplica√ß√£o..." in logs
    assert "Conectado ao MongoDB." in logs
    assert "Tentando criar/verificar √≠ndices..." in logs
    assert "Cria√ß√£o/verifica√ß√£o de √≠ndices conclu√≠da." in logs 
    assert "Aplica√ß√£o iniciada e pronta." in logs 
    assert "Iniciando processo de encerramento..." in logs
    assert "Conex√£o com MongoDB fechada." in logs
    assert "Aplica√ß√£o encerrada." in logs
    
    mock_close_db.assert_awaited_once()

================================================================================
Cap√≠tulo 29: tests/test_tasks.py
================================================================================

# tests/test_tasks.py
"""
Este m√≥dulo cont√©m testes de integra√ß√£o para os endpoints de tarefas (`/tasks`)
da API SmartTask, definidos em `app.routers.tasks`.

Os testes cobrem uma ampla gama de funcionalidades, incluindo:
- Cria√ß√£o, listagem, obten√ß√£o, atualiza√ß√£o e dele√ß√£o de tarefas (CRUD).
- Valida√ß√£o de entrada para cria√ß√£o e atualiza√ß√£o de tarefas.
- Filtros e pagina√ß√£o na listagem de tarefas.
- Ordena√ß√£o na listagem de tarefas.
- L√≥gica de autoriza√ß√£o (usu√°rio s√≥ pode acessar/modificar suas pr√≥prias tarefas).
- Tratamento de tokens JWT inv√°lidos ou expirados.
- Tentativas de inje√ß√£o em par√¢metros de filtro.
- Disparo de notifica√ß√µes (e-mail, webhook) via BackgroundTasks.

Utiliza fixtures de `conftest.py` para usu√°rios e autentica√ß√£o.
A biblioteca `freezegun` √© usada para controlar a data/hora em testes sens√≠veis ao tempo.
O envio de webhooks √© mockado automaticamente.
"""

# ==========================================
# --- Importa√ß√µes ---
# ==========================================
import unittest.mock
from unittest.mock import AsyncMock, ANY, MagicMock
from freezegun import freeze_time
from pydantic import ValidationError
import pytest
from httpx import AsyncClient
from fastapi import status
from typing import Dict, List, Any
import uuid
import pytest_asyncio
from app.core.config import settings
from app.db import task_crud
from app.models.task import Task, TaskStatus
from datetime import date, timedelta, datetime, timezone
from tests.conftest import user_a_data
import jwt as jose_jwt
import uuid 
from fastapi import status 

# ==========================================
# --- Mock Webhook ---
# ==========================================
@pytest.fixture(
        autouse=True
)

def auto_mock_send_webhook(mocker):
    """
    Fixture `autouse` que aplica automaticamente um mock √† fun√ß√£o
    `app.routers.tasks.send_webhook_notification` para todos os testes
    definidos neste m√≥dulo.
    Previne chamadas HTTP reais para webhooks e permite verificar se a fun√ß√£o
    foi chamada quando esperado.
    """
    mocker.patch(
        "app.routers.tasks.send_webhook_notification",
        new_callable=unittest.mock.AsyncMock,
    )

# ==========================================
# --- Marcador Asyncio e Fixture ---
# ==========================================
pytestmark = pytest.mark.asyncio

@pytest.fixture
def sample_task_create_data() -> Dict[str, Any]:
    """Fornece um dicion√°rio v√°lido para criar uma tarefa nos testes de rota."""
    return {
        "title": "Task Payload for Route Test",
        "description": "Description from payload test",
        "importance": 4,
        "due_date": (date.today() + timedelta(days=5)).isoformat(),
        "status": TaskStatus.PENDING.value,
        "tags": ["route_t", "test_t"],
        "project": "Router Tests T"
    }

# ==========================================
# --- Base Task Data ---
# ==========================================
base_task_create_data = {
    "title": "Tarefa de Teste Padr√£o",
    "description": "Descri√ß√£o da tarefa padr√£o",
    "importance": 3,
}

# ==========================================
# --- Testes de Cria√ß√£o ---
# ==========================================
async def test_create_task_success(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
):
    """
    Testa a cria√ß√£o bem-sucedida de uma nova tarefa por um usu√°rio autenticado.
    Verifica o status code HTTP 201 CREATED e se os dados retornados
    correspondem ao payload enviado, incluindo campos gerados pelo servidor
    como id, owner_id, created_at e priority_score.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/"
    # --- Act ---
    response = await test_async_client.post(
        url,
        json=base_task_create_data,
        headers=auth_headers_a
    ) 
    # --- Assert ---
    assert response.status_code == status.HTTP_201_CREATED
    response_data = response.json()
    assert response_data["title"] == base_task_create_data["title"]
    assert response_data["importance"] == base_task_create_data["importance"]
    assert response_data["status"] == TaskStatus.PENDING.value
    assert "id" in response_data
    assert "owner_id" in response_data
    assert "created_at" in response_data
    assert "priority_score" in response_data

async def test_create_task_unauthorized(
        test_async_client: AsyncClient
):
     """
     Testa a tentativa de criar uma tarefa sem fornecer um token de autentica√ß√£o.
     Espera-se um erro HTTP 401 Unauthorized como resposta da API.
     """
     # --- Arrange ---
     url = f"{settings.API_V1_STR}/tasks/"
     # --- Act ---
     response = await test_async_client.post(url, json=base_task_create_data) 
     # --- Assert ---
     assert response.status_code == status.HTTP_401_UNAUTHORIZED

# ==================================================================
# --- Testes de Cria√ß√£o e Atualiza√ß√£o ---
# ==================================================================
@pytest.mark.parametrize(
    "field, length", [
        ("title", 100), 
        ("description", 500), 
    ]
)
async def test_create_task_max_length_success(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    field: str,
    length: int,
):
    """
    Testa a cria√ß√£o de uma tarefa com campos de string (`title`, `description`)
    preenchidos exatamente no seu comprimento m√°ximo permitido.
    Espera-se que a cria√ß√£o seja bem-sucedida com um status HTTP 201 CREATED.
    """
    # --- Arrange ---
    payload = base_task_create_data.copy()
    payload[field] = "X" * length 
    url = f"{settings.API_V1_STR}/tasks/"
    # --- Act ---
    response = await test_async_client.post(url, json=payload, headers=auth_headers_a)
    # --- Assert ---
    assert response.status_code == status.HTTP_201_CREATED
    response_data = response.json()
    assert response_data[field] == payload[field]

@pytest.mark.parametrize(
    "field, length", [
        ("title", 101), 
        ("description", 501), 
    ]
)
async def test_create_task_max_length_fail(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    field: str,
    length: int,
):
    """
    Testa a tentativa de criar uma tarefa com campos de string (`title`, `description`)
    excedendo o comprimento m√°ximo permitido estabelecido pelo modelo de dados.
    Espera-se um erro de valida√ß√£o HTTP 422 Unprocessable Entity.
    """
    # --- Arrange ---
    payload = base_task_create_data.copy()
    payload[field] = "X" * length
    url = f"{settings.API_V1_STR}/tasks/"
    # --- Act ---
    response = await test_async_client.post(url, json=payload, headers=auth_headers_a)
    # --- Assert ---
    assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY
    assert f"String should have at most {length -1} characters" in response.text

async def test_create_task_explicit_nulls_optional(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
):
    """
    Testa a cria√ß√£o de uma tarefa onde campos opcionais (description, due_date,
    tags, project) s√£o explicitamente enviados como `null` (None em Python) no payload.
    Espera-se que a tarefa seja criada com sucesso (HTTP 201) e que esses campos
    reflitam o valor nulo na resposta.
    """
        # --- Arrange ---
    payload = base_task_create_data.copy()
    payload["description"] = None
    payload["due_date"] = None
    payload["tags"] = None
    payload["project"] = None
    url = f"{settings.API_V1_STR}/tasks/"

    # --- Act ---
    response = await test_async_client.post(url, json=payload, headers=auth_headers_a)

    # --- Assert ---
    assert response.status_code == status.HTTP_201_CREATED
    response_data = response.json()
    assert response_data["description"] is None
    assert response_data["due_date"] is None
    assert response_data["tags"] is None
    assert response_data["project"] is None

async def test_update_task_explicit_nulls_optional(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
):
    """
    Testa a atualiza√ß√£o de uma tarefa existente, definindo campos opcionais
    (que previamente continham valores) para `null` (None em Python) no payload.
    Primeiro, uma tarefa √© criada com valores. Em seguida, √© atualizada.
    Espera-se que a atualiza√ß√£o seja bem-sucedida (HTTP 200) e os campos
    sejam refletidos como nulos na resposta.
    """
    # --- Arrange ---
    url_create = f"{settings.API_V1_STR}/tasks/"
    create_payload = {
        **base_task_create_data,
        "description": "Descri√ß√£o inicial",
        "due_date": date.today().isoformat(),
        "tags": ["inicial"],
        "project": "Projeto Inicial"
    }
    create_resp = await test_async_client.post(url_create, json=create_payload, headers=auth_headers_a)
    assert create_resp.status_code == status.HTTP_201_CREATED
    task_id = create_resp.json()["id"]

    # --- Act ---
    url_put = f"{settings.API_V1_STR}/tasks/{task_id}"
    update_payload = {
        "description": None,
        "due_date": None,
        "tags": None, 
        "project": None,
    }
    response = await test_async_client.put(url_put, json=update_payload, headers=auth_headers_a)
    
    # --- Assert ---
    assert response.status_code == status.HTTP_200_OK
    response_data = response.json()
    assert response_data["description"] is None
    assert response_data["due_date"] is None
    assert response_data["tags"] is None 
    assert response_data["project"] is None

@pytest.mark.asyncio
async def test_create_task_internal_validation_error(test_async_client: AsyncClient, mocker, auth_headers_a, sample_task_create_data): 
    """
    Testa o tratamento de erro quando a valida√ß√£o Pydantic interna
    ao construir o objeto Task completo na rota falha.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/"
    task_payload = sample_task_create_data

    mocker.patch("app.routers.tasks.calculate_priority_score", return_value=50.0)
    simulated_error = ValidationError.from_exception_data(title="Task", line_errors=[])
    mock_task_init = mocker.patch("app.routers.tasks.Task", side_effect=simulated_error)

    mock_crud_create = mocker.patch("app.routers.tasks.task_crud.create_task")
    mock_logger_error = mocker.patch("app.routers.tasks.logger.error")

    # --- Act ---
    response = await test_async_client.post(url, json=task_payload, headers=auth_headers_a)

    # --- Assert ---
    assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY
    assert "Erro interno na valida√ß√£o dos dados da tarefa" in response.json()["detail"]
    mock_task_init.assert_called_once()
    mock_crud_create.assert_not_called()
    mock_logger_error.assert_called_once()
    log_call_args = mock_logger_error.call_args.args
    assert "Erro de valida√ß√£o Pydantic ao montar objeto Task" in log_call_args[0]

@pytest.mark.asyncio
async def test_update_task_crud_returns_none(test_async_client: AsyncClient, mocker, auth_headers_a, test_user_a_token_and_id): 
    """
    Testa o comportamento da rota PUT /tasks/{task_id} quando
    task_crud.update_task retorna None.
    """
    # --- Arrange ---
    token, user_id_a = test_user_a_token_and_id
    target_task_id = uuid.uuid4()
    url = f"{settings.API_V1_STR}/tasks/{target_task_id}"
    update_payload = {"title": "Titulo Nao Aplicado"}
    mock_existing_task = MagicMock(spec=Task)
    mock_existing_task.importance = 3 
    mock_existing_task.due_date = None 
    mocker.patch("app.routers.tasks.task_crud.get_task_by_id", return_value=mock_existing_task)
    mock_crud_update = mocker.patch("app.routers.tasks.task_crud.update_task", return_value=None)
    mocker.patch("app.routers.tasks.calculate_priority_score")
    mock_logger_error = mocker.patch("app.routers.tasks.logger.error")

    # --- Act ---
    response = await test_async_client.put(url, json=update_payload, headers=auth_headers_a)

    # --- Assert ---
    assert response.status_code == status.HTTP_404_NOT_FOUND
    assert "N√£o foi poss√≠vel atualizar a tarefa" in response.json()["detail"]
    assert "Pode ter sido deletada ou ocorreu um erro interno" in response.json()["detail"]
    task_crud.get_task_by_id.assert_called_once_with(db=mocker.ANY, task_id=target_task_id, owner_id=user_id_a)
    mock_crud_update.assert_called_once()
    mock_logger_error.assert_called_once()
    assert f"Falha ao atualizar tarefa {target_task_id}" in mock_logger_error.call_args.args[0]

@pytest.mark.asyncio
async def test_create_urgent_task_logs_warning_if_user_incomplete(test_async_client: AsyncClient, mocker): # type: ignore
    """
    Testa se um warning √© logado ao criar tarefa urgente se o usu√°rio
    n√£o possui nome completo (mas tem e-mail).
    """
    # --- Arrange ---
    username = f"incomplete_name_{uuid.uuid4().hex[:4]}"
    email = f"{username}@example.com"
    incomplete_user_data = {
        "email": email,
        "username": username,
        "password": "password123",
        "full_name": None 
    }
    register_url = f"{settings.API_V1_STR}/auth/register"
    login_url = f"{settings.API_V1_STR}/auth/login/access-token"

    reg_response = await test_async_client.post(register_url, json=incomplete_user_data)
    assert reg_response.status_code == status.HTTP_201_CREATED
    user_id = reg_response.json()["id"]

    login_payload_form_data = {
        "username": username,
        "password": incomplete_user_data["password"]
    }
    login_response = await test_async_client.post(login_url, data=login_payload_form_data)
    assert login_response.status_code == status.HTTP_200_OK
    token = login_response.json()["access_token"]
    incomplete_user_headers = {"Authorization": f"Bearer {token}"}

    url_create = f"{settings.API_V1_STR}/tasks/"
    urgent_task_payload = {
        "title": "Urgente, usu√°rio sem nome",
        "importance": 5,
        "due_date": (date.today() - timedelta(days=1)).isoformat()
    }

    mocker.patch("app.routers.tasks.is_task_urgent", return_value=True)
    mock_send_email = mocker.patch("app.routers.tasks.send_urgent_task_notification", new_callable=AsyncMock)
    mock_logger_warning = mocker.patch("app.routers.tasks.logger.warning")

    mock_created_task = MagicMock(spec=Task)
    task_id_created = uuid.uuid4()
    mock_created_task.id = task_id_created
    mock_created_task.owner_id = uuid.UUID(user_id)
    mock_created_task.title = urgent_task_payload["title"]
    mocker.patch("app.routers.tasks.task_crud.create_task", return_value=mock_created_task)
    mocker.patch("app.routers.tasks.calculate_priority_score", return_value=1000.0)

    # --- Act ---
    response = await test_async_client.post(url_create, json=urgent_task_payload, headers=incomplete_user_headers)

    # --- Assert ---
    assert response.status_code == status.HTTP_201_CREATED

    mock_logger_warning.assert_called_once()
    log_message = mock_logger_warning.call_args.args[0]
    assert f"Usu√°rio {user_id} (username: {username})" in log_message
    assert "n√£o possui e-mail ou nome completo configurado" in log_message
    assert f"tarefa urgente {task_id_created}" in log_message

    mock_send_email.assert_not_called()

# ==============================================================
# --- Testes de Valida√ß√£o de Entrada (Parametrizados) ---
# ==============================================================
@pytest.mark.parametrize(
    "field, value, error_type, error_msg_part", [
        ("title", "T2", "string_too_short", "String should have at least 3 characters"),
        ("importance", 0, "greater_than_equal", "Input should be greater than or equal to 1"),
        ("importance", 6, "less_than_equal", "Input should be less than or equal to 5"),
        ("due_date", "nao-e-data", "date_from_datetime_parsing", "invalid character"),
        ("status", "invalido", "enum", "Input should be"),
    ]
)
async def test_create_task_invalid_input(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    field: str, value: Any, error_type: str, error_msg_part: str
):
    """
    Testa a cria√ß√£o de tarefas com diversos tipos de dados de entrada inv√°lidos
    para campos espec√≠ficos, como title, importance, due_date e status.
    Verifica se a API retorna HTTP 422 Unprocessable Entity e se a mensagem
    de erro na resposta `detail` corresponde ao campo e tipo de erro esperados.
    """
    # --- Arrange ---
    invalid_data = base_task_create_data.copy()
    if value is None:
         if field in ["title", "importance"]:
              if field in invalid_data: 
                   del invalid_data[field]
         elif field == "status":
              pytest.skip("Teste 'None' n√£o aplic√°vel para 'status' com default.")
              return
         else:
             invalid_data[field] = value
    else:
        invalid_data[field] = value

    url = f"{settings.API_V1_STR}/tasks/"
    # --- Act ---
    response = await test_async_client.post(url, json=invalid_data, headers=auth_headers_a)
    # --- Assert ---
    assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY
    error_details = response.json()["detail"]
    found_error = False
    for error in error_details:
        if field in error.get("loc", []) and error.get("type") == error_type:
            if error_msg_part in error.get("msg", ""):
                found_error = True
                break
    assert found_error, f"Erro esperado para campo '{field}' tipo '{error_type}' msg '{error_msg_part}' n√£o encontrado em {error_details}"

@pytest.mark.parametrize(
    "field, value, error_type, error_msg_part", [
        ("title", "T2", "string_too_short", "String should have at least 3 characters"),
        ("importance", 0, "greater_than_equal", "Input should be greater than or equal to 1"),
        ("importance", 6, "less_than_equal", "Input should be less than or equal to 5"),
        ("due_date", "nao-e-data", "date_from_datetime_parsing", "invalid character"),
        ("status", "invalido", "enum", "Input should be"), 
    ]
)
async def test_update_task_invalid_input(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    field: str, value: Any, error_type: str, error_msg_part: str
):
    """
    Testa a atualiza√ß√£o de tarefas com dados de entrada inv√°lidos para campos espec√≠ficos.
    Primeiro cria uma tarefa v√°lida, depois tenta atualiz√°-la com um valor inv√°lido.
    Verifica se a API retorna HTTP 422 Unprocessable Entity e se a mensagem
    de erro corresponde ao esperado.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/"
    create_resp = await test_async_client.post(url, json=base_task_create_data, headers=auth_headers_a)
    assert create_resp.status_code == 201
    task_id = create_resp.json()["id"]

    # --- Act ---
    invalid_update_payload = {field: value}
    url_put = f"{settings.API_V1_STR}/tasks/{task_id}"
    response = await test_async_client.put(url_put, json=invalid_update_payload, headers=auth_headers_a)

    # --- Assert ---
    assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY
    error_details = response.json()["detail"]
    found_error = False
    for error in error_details:
        if field in error.get("loc", []) and error.get("type") == error_type:
            if error_msg_part in error.get("msg", ""):
                found_error = True
                break
    assert found_error, f"Erro esperado para campo '{field}' com tipo '{error_type}' e msg contendo '{error_msg_part}' n√£o encontrado em {error_details}"

async def test_update_task_empty_payload(
     test_async_client: AsyncClient, auth_headers_a: Dict[str, str]
):
    """
    Testa a tentativa de atualizar uma tarefa enviando um payload JSON vazio (`{}`).
    Verifica se a API retorna um erro HTTP 400 Bad Request, indicando que
    nenhum campo v√°lido para atualiza√ß√£o foi fornecido.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/"
    create_resp = await test_async_client.post(url, json=base_task_create_data, headers=auth_headers_a)
    assert create_resp.status_code == 201
    task_id = create_resp.json()["id"]

    # --- Act ---
    url_put = f"{settings.API_V1_STR}/tasks/{task_id}"
    response = await test_async_client.put(url_put, json={}, headers=auth_headers_a)

    # --- Assert ---
    assert response.status_code == status.HTTP_400_BAD_REQUEST
    assert "Nenhum campo v√°lido fornecido" in response.json()["detail"]

# ==========================================
# --- Testes de Listagem ---
# ==========================================
async def test_list_tasks_success(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str]
):
    """
    Testa a listagem bem-sucedida de tarefas para um usu√°rio autenticado (User A).
    Cria duas tarefas para o User A e verifica se ambas s√£o retornadas ao listar
    tarefas para este usu√°rio, e se o status code √© HTTP 200 OK.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/"
    task1 = {**base_task_create_data, "title": "Task A1 List", "importance": 5, "project": "Alpha"}
    task2 = {**base_task_create_data, "title": "Task A2 List", "status": TaskStatus.IN_PROGRESS.value, "tags": ["urgent"]}
    # --- Act ---
    resp1 = await test_async_client.post(url, json=task1, headers=auth_headers_a)
    # --- Assert ---
    assert resp1.status_code == 201
    # --- Act ---
    resp2 = await test_async_client.post(url, json=task2, headers=auth_headers_a)
    # --- Assert ---
    assert resp2.status_code == 201

    # --- Act ---
    response = await test_async_client.get(url, headers=auth_headers_a)

    # --- Assert ---
    assert response.status_code == status.HTTP_200_OK
    tasks = response.json()
    assert isinstance(tasks, list)
    assert len(tasks) == 2
    titles = {task["title"] for task in tasks}
    assert task1["title"] in titles
    assert task2["title"] in titles

async def test_list_tasks_unauthorized(
        test_async_client: AsyncClient
):
     """
     Testa a tentativa de listar tarefas sem fornecer um token de autentica√ß√£o.
     Espera-se um erro HTTP 401 Unauthorized.
     """
     # --- Arrange ---
     url = f"{settings.API_V1_STR}/tasks/"
     # --- Act ---
     response = await test_async_client.get(url)
     # --- Assert ---
     assert response.status_code == status.HTTP_401_UNAUTHORIZED

async def test_list_tasks_does_not_show_other_users_tasks(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    auth_headers_b: Dict[str, str]
):
    """
    Testa a separa√ß√£o de dados entre usu√°rios na listagem de tarefas.
    Garante que o User B, ao listar suas tarefas, n√£o veja as tarefas criadas
    pelo User A.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/"
    task_a = {**base_task_create_data, "title": "Tarefa Secreta A"}
    resp_a = await test_async_client.post(url, json=task_a, headers=auth_headers_a)
    assert resp_a.status_code == 201

    # --- Act ---
    response_b = await test_async_client.get(url, headers=auth_headers_b)

    # --- Assert ---
    assert response_b.status_code == status.HTTP_200_OK
    tasks_b = response_b.json()
    assert isinstance(tasks_b, list)
    assert len(tasks_b) == 0

async def test_list_tasks_filter_non_existent_project(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    create_filter_sort_tasks: List[Dict] 
):
    """
    Testa a funcionalidade de filtro de listagem de tarefas por projeto,
    especificamente quando o projeto fornecido no filtro n√£o existe em nenhuma tarefa.
    Espera-se uma lista vazia e status HTTP 200 OK.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/?project=ProjetoInexistente123"
    # --- Act ---
    response = await test_async_client.get(url, headers=auth_headers_a)
    # --- Assert ---
    assert response.status_code == status.HTTP_200_OK
    tasks = response.json()
    assert isinstance(tasks, list)
    assert len(tasks) == 0 

async def test_list_tasks_filter_non_existent_tag(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    create_filter_sort_tasks: List[Dict]
):
    """
    Testa a funcionalidade de filtro de listagem de tarefas por tag,
    quando a tag fornecida n√£o est√° associada a nenhuma tarefa.
    Espera-se uma lista vazia e status HTTP 200 OK.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/?tag=tag_nao_existe"
    # --- Act ---
    response = await test_async_client.get(url, headers=auth_headers_a)
    # --- Assert ---
    assert response.status_code == status.HTTP_200_OK
    tasks = response.json()
    assert isinstance(tasks, list)
    assert len(tasks) == 0

async def test_list_tasks_filter_multiple_tags_no_match(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    create_filter_sort_tasks: List[Dict]
):
    """
    Testa o filtro de listagem por m√∫ltiplas tags quando nenhuma tarefa
    cont√©m TODAS as tags especificadas. O filtro por m√∫ltiplas tags geralmente
    implica uma opera√ß√£o AND (a tarefa deve ter todas as tags).
    Espera-se uma lista vazia e status HTTP 200 OK.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/?tag=t1&tag=t3"
    # --- Act ---
    response = await test_async_client.get(url, headers=auth_headers_a)
    # --- Assert ---
    assert response.status_code == status.HTTP_200_OK
    tasks = response.json()
    assert isinstance(tasks, list)
    assert len(tasks) == 0 

async def test_list_tasks_filter_status_no_match(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    create_filter_sort_tasks: List[Dict]
):
    """
    Testa o filtro de listagem por status quando nenhuma tarefa corresponde
    ao status fornecido (ex: 'cancelada', se n√£o houver tarefas canceladas).
    Espera-se uma lista vazia e status HTTP 200 OK.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/?status={TaskStatus.CANCELLED.value}"
    # --- Act ---
    response = await test_async_client.get(url, headers=auth_headers_a)
    # --- Assert ---
    assert response.status_code == status.HTTP_200_OK
    tasks = response.json()
    assert isinstance(tasks, list)
    assert len(tasks) == 0 

@freeze_time("2025-05-04")
async def test_list_tasks_filter_due_before_very_early(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    create_filter_sort_tasks: List[Dict]
):
    """
    Testa o filtro de listagem por data de vencimento (`due_before`) usando uma
    data muito no passado, onde nenhuma tarefa da fixture `create_filter_sort_tasks`
    (cujos prazos s√£o futuros em rela√ß√£o a "2025-05-04") deveria ser retornada.
    Espera-se uma lista vazia e status HTTP 200 OK.
    """
    # --- Arrange ---
    early_date = "2024-01-01"
    url = f"{settings.API_V1_STR}/tasks/?due_before={early_date}"
    # --- Act ---
    response = await test_async_client.get(url, headers=auth_headers_a)
    # --- Assert ---
    assert response.status_code == status.HTTP_200_OK
    tasks = response.json()
    assert isinstance(tasks, list)
    assert len(tasks) == 0 

# ========================================
# --- Testes de Pagina√ß√£o ---
# ========================================
async def test_list_tasks_pagination_limit_1(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    create_filter_sort_tasks: List[Dict] 
):
    """
    Testa a funcionalidade de pagina√ß√£o da listagem de tarefas,
    especificamente o par√¢metro `limit`.
    Verifica se, ao definir `limit=1`, apenas uma tarefa √© retornada.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/?limit=1"
    # --- Act ---
    response = await test_async_client.get(url, headers=auth_headers_a)
    # --- Assert ---
    assert response.status_code == status.HTTP_200_OK
    tasks = response.json()
    assert isinstance(tasks, list)
    assert len(tasks) == 1 

async def test_list_tasks_pagination_skip_all(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    create_filter_sort_tasks: List[Dict] 
):
    """
    Testa a funcionalidade de pagina√ß√£o `skip`.
    Verifica se, ao pular um n√∫mero de tarefas igual ou maior ao total existente
    (criado pela fixture `create_filter_sort_tasks`), uma lista vazia √© retornada.
    """
    # --- Arrange ---
    total_tasks_in_fixture = 5 
    url_skip_exact = f"{settings.API_V1_STR}/tasks/?skip={total_tasks_in_fixture}"
    url_skip_more = f"{settings.API_V1_STR}/tasks/?skip={total_tasks_in_fixture + 5}"
    
    # --- Act (Skip Exato) ---
    response_exact = await test_async_client.get(url_skip_exact, headers=auth_headers_a)
    # --- Assert (Skip Exato) ---
    assert response_exact.status_code == status.HTTP_200_OK
    tasks_exact = response_exact.json()
    assert isinstance(tasks_exact, list)
    assert len(tasks_exact) == 0 

    # --- Act (Skip Mais) ---
    response_skip_more = await test_async_client.get(url_skip_more, headers=auth_headers_a)
    # --- Assert (Skip Mais) ---
    assert response_skip_more.status_code == status.HTTP_200_OK
    tasks_skip_more = response_skip_more.json()
    assert isinstance(tasks_skip_more, list)
    assert len(tasks_skip_more) == 0

async def test_list_tasks_pagination_limit_0(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
):
    """
    Testa o comportamento da pagina√ß√£o quando um valor inv√°lido (`limit=0`)
    √© fornecido. A valida√ß√£o da FastAPI (para `Query(ge=1, ...)`) deve
    impedir isso, retornando HTTP 422 Unprocessable Entity.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/?limit=0"
    # --- Act ---
    response = await test_async_client.get(url, headers=auth_headers_a)
    # --- Assert ---
    assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY
    assert "Input should be greater than or equal to 1" in response.text

async def test_list_tasks_pagination_limit_too_high(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
):
    """
    Testa o comportamento da pagina√ß√£o quando um valor inv√°lido (`limit > 1000`)
    √© fornecido. A valida√ß√£o da FastAPI (para `Query(..., le=1000)`) deve
    impedir isso, retornando HTTP 422 Unprocessable Entity.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/?limit=1001"
    # --- Act ---
    response = await test_async_client.get(url, headers=auth_headers_a)
    # --- Assert ---
    assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY
    assert "Input should be less than or equal to 1000" in response.text

# ======================================================
# --- Testes de de Filtros e Pagina√ß√£o ---
# ======================================================
async def test_list_tasks_filter_and_pagination(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    create_filter_sort_tasks: List[Dict] 
):
    """
    Testa a combina√ß√£o de filtros de listagem (por projeto) com pagina√ß√£o
    (skip e limit).
    Verifica se o n√∫mero correto de tarefas √© retornado ap√≥s aplicar
    ambos os tipos de par√¢metros.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/?project=Filtro&skip=1&limit=2"
    # --- Act ---
    response = await test_async_client.get(url, headers=auth_headers_a)
    # --- Assert ---
    assert response.status_code == status.HTTP_200_OK
    tasks = response.json()
    assert isinstance(tasks, list)
    assert len(tasks) == 2

# ======================================================
# --- Testes de de Filtros e Ordena√ß√£o ---
# ======================================================
@pytest_asyncio.fixture(
        scope="function" 
)
async def create_filter_sort_tasks(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str]
) -> List[Dict]:
    """
    Fixture ass√≠ncrona que cria um conjunto de tarefas de teste com varia√ß√µes
    em seus atributos (t√≠tulo, import√¢ncia, projeto, status, data de vencimento, tags).
    Essas tarefas s√£o criadas pelo User A e s√£o usadas para testar as
    funcionalidades de filtragem e ordena√ß√£o do endpoint de listagem de tarefas.
    Retorna uma lista de dicion√°rios, onde cada dicion√°rio representa os dados
    da tarefa criada (conforme retornado pela API).
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/"
    tasks_to_create = [
        {"title": "Filter Task P1 High", "importance": 5, "project": "Filtro", "status": TaskStatus.PENDING.value, "due_date": "2026-01-01", "tags": ["t1", "t2"]},
        {"title": "Filter Task P1 Low", "importance": 1, "project": "Filtro", "status": TaskStatus.PENDING.value, "due_date": "2026-02-01"},
        {"title": "Filter Task P2 Medium", "importance": 3, "project": "Outro", "status": TaskStatus.IN_PROGRESS.value, "tags": ["t2"]},
        {"title": "Filter Task P1 Medium", "importance": 3, "project": "Filtro", "status": TaskStatus.PENDING.value, "due_date": "2025-12-15", "tags": ["t3"]}, 
        {"title": "Filter Task P1 Done", "importance": 4, "project": "Filtro", "status": TaskStatus.COMPLETED.value}, 
    ]
    created_tasks = []
    # --- Act ---
    for task_data in tasks_to_create:
        response = await test_async_client.post(url, json=task_data, headers=auth_headers_a)
        # --- Assert (Cria√ß√£o) ---
        assert response.status_code == 201
        created_tasks.append(response.json())
    # --- Return ---
    return created_tasks

async def test_list_tasks_filter_by_project(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    create_filter_sort_tasks: List[Dict] 
):
    """
    Testa a filtragem da lista de tarefas pelo campo 'project'.
    Verifica se apenas as tarefas pertencentes ao projeto "Filtro" s√£o retornadas.
    Utiliza a fixture `create_filter_sort_tasks` para popular o banco com dados de teste.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/?project=Filtro"
    # --- Act ---
    response = await test_async_client.get(url, headers=auth_headers_a)
    # --- Assert ---
    assert response.status_code == 200
    tasks = response.json()
    assert len(tasks) == 4 
    assert all(task["project"] == "Filtro" for task in tasks)

async def test_list_tasks_filter_by_status(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    create_filter_sort_tasks: List[Dict]
):
    """
    Testa a filtragem da lista de tarefas pelo campo 'status'.
    Verifica se apenas as tarefas com status "pendente" s√£o retornadas.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/?status=pendente"
    # --- Act ---
    response = await test_async_client.get(url, headers=auth_headers_a)
    # --- Assert ---
    assert response.status_code == 200
    tasks = response.json()
    assert len(tasks) == 3 
    assert all(task["status"] == TaskStatus.PENDING.value for task in tasks)

async def test_list_tasks_filter_by_single_tag(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    create_filter_sort_tasks: List[Dict]
):
    """
    Testa a filtragem da lista de tarefas por uma √∫nica tag.
    Verifica se as tarefas que cont√™m a tag "t2" s√£o retornadas corretamente.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/?tag=t2"
    # --- Act ---
    response = await test_async_client.get(url, headers=auth_headers_a)
    # --- Assert ---
    assert response.status_code == 200
    tasks = response.json()
    assert len(tasks) == 2 
    titles = {task["title"] for task in tasks}
    assert "Filter Task P1 High" in titles
    assert "Filter Task P2 Medium" in titles

async def test_list_tasks_filter_by_multiple_tags(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    create_filter_sort_tasks: List[Dict]
):
    """
    Testa a filtragem da lista de tarefas por m√∫ltiplas tags (opera√ß√£o AND).
    Verifica se apenas as tarefas que cont√™m TODAS as tags especificadas ("t1" E "t2")
    s√£o retornadas.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/?tag=t1&tag=t2"
    # --- Act ---
    response = await test_async_client.get(url, headers=auth_headers_a)
    # --- Assert ---
    assert response.status_code == 200
    tasks = response.json()
    assert len(tasks) == 1 
    assert tasks[0]["title"] == "Filter Task P1 High"

async def test_list_tasks_sort_by_priority(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    create_filter_sort_tasks: List[Dict]
):
    """
    Testa a ordena√ß√£o da lista de tarefas pelo campo 'priority_score'
    em ordem descendente.
    Verifica se as tarefas retornadas est√£o ordenadas corretamente pela pontua√ß√£o
    de prioridade.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/?sort_by=priority_score&sort_order=desc"
    # --- Act ---
    response = await test_async_client.get(url, headers=auth_headers_a)
    # --- Assert ---
    assert response.status_code == 200
    tasks = response.json()
    assert len(tasks) == 5 
    scores = [task.get("priority_score") for task in tasks if task.get("priority_score") is not None]
    assert scores == sorted(scores, reverse=True)

async def test_list_tasks_sort_by_due_date_asc(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    create_filter_sort_tasks: List[Dict]
):
    """
    Testa a ordena√ß√£o da lista de tarefas pelo campo 'due_date'
    em ordem ascendente.
    Verifica se as tarefas retornadas (que possuem data de vencimento)
    est√£o ordenadas corretamente. Tarefas sem data de vencimento podem aparecer
    no in√≠cio ou no fim dependendo da l√≥gica de ordena√ß√£o do banco para nulos.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/?sort_by=due_date&sort_order=asc"
    # --- Act ---
    response = await test_async_client.get(url, headers=auth_headers_a)
    # --- Assert ---
    assert response.status_code == 200
    tasks = response.json()
    assert len(tasks) == 5
    due_dates = [task.get("due_date") for task in tasks if task.get("due_date")]
    assert due_dates == sorted(due_dates)
    assert tasks[0]["due_date"] is None or tasks[0]["due_date"] == "2025-12-15"

# ========================================
# --- Testes GET /tasks/{id} ---
# ========================================
async def test_get_specific_task_success( 
    test_async_client: AsyncClient,       
    auth_headers_a: Dict[str, str] 
):
    """
    Testa a busca bem-sucedida de uma tarefa espec√≠fica pelo seu ID,
    pertencente ao usu√°rio autenticado.
    Verifica se o status code √© HTTP 200 OK e se os dados da tarefa retornada
    correspondem aos da tarefa criada.
    """
    # --- Arrange ---
    url_create = f"{settings.API_V1_STR}/tasks/"
    create_response = await test_async_client.post(url_create, json=base_task_create_data, headers=auth_headers_a) 
    assert create_response.status_code == 201
    task_id = create_response.json()["id"]

    # --- Act ---
    url_get = f"{settings.API_V1_STR}/tasks/{task_id}"
    get_response = await test_async_client.get(url_get, headers=auth_headers_a) 

    # --- Assert ---
    assert get_response.status_code == status.HTTP_200_OK
    response_data = get_response.json()
    assert response_data["id"] == task_id
    assert response_data["title"] == base_task_create_data["title"] 

async def test_get_specific_task_not_found(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str] 
):
    """
    Testa a tentativa de buscar uma tarefa espec√≠fica usando um ID que
    n√£o existe no banco de dados.
    Espera-se um erro HTTP 404 Not Found.
    """
    # --- Arrange ---
    non_existent_id = uuid.uuid4()
    url = f"{settings.API_V1_STR}/tasks/{non_existent_id}"
    # --- Act ---
    response = await test_async_client.get(url, headers=auth_headers_a)
    # --- Assert ---
    assert response.status_code == status.HTTP_404_NOT_FOUND

async def test_get_specific_task_unauthorized(
        test_async_client: AsyncClient
):
    """
    Testa a tentativa de buscar uma tarefa espec√≠fica sem fornecer um
    token de autentica√ß√£o.
    Espera-se um erro HTTP 401 Unauthorized.
    """
    # --- Arrange ---
    some_id = uuid.uuid4() 
    url = f"{settings.API_V1_STR}/tasks/{some_id}"
    # --- Act ---
    response = await test_async_client.get(url) 
    # --- Assert ---
    assert response.status_code == status.HTTP_401_UNAUTHORIZED

async def test_get_other_user_task_forbidden( 
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    auth_headers_b: Dict[str, str]
):
    """
    Testa a tentativa do User B de obter uma tarefa que pertence ao User A.
    A l√≥gica de `get_task_by_id` (usada pelo endpoint) deve retornar None se
    o `owner_id` n√£o corresponder, resultando em um HTTP 404 Not Found para
    o User B (como se a tarefa n√£o existisse para ele).
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/"
    task_a_data = {**base_task_create_data, "title": "Task A para GET"}
    resp_a = await test_async_client.post(url, json=task_a_data, headers=auth_headers_a)
    assert resp_a.status_code == 201
    task_a_id = resp_a.json()["id"]

    # --- Act ---
    url_get = f"{settings.API_V1_STR}/tasks/{task_a_id}"
    response_b = await test_async_client.get(url_get, headers=auth_headers_b)

    # --- Assert ---
    assert response_b.status_code == status.HTTP_404_NOT_FOUND

# ========================================
# --- Testes PUT /tasks/{id} ---
# ========================================
async def test_update_task_success(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
):
    """
    Testa a atualiza√ß√£o bem-sucedida de uma tarefa existente pelo seu propriet√°rio.
    Verifica se o status code √© HTTP 200 OK e se os campos da tarefa
    foram atualizados conforme o payload enviado, incluindo a recalcula√ß√£o da
    pontua√ß√£o de prioridade e a atualiza√ß√£o do timestamp `updated_at`.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/"
    create_resp = await test_async_client.post(
        url,
        json=base_task_create_data,
        headers=auth_headers_a
    )
    assert create_resp.status_code == 201
    task_id = create_resp.json()["id"]
    original_score = create_resp.json().get("priority_score")

    # --- Act ---
    url_put = f"{settings.API_V1_STR}/tasks/{task_id}"
    update_payload = {
        "title": "T√≠tulo Atualizado",
        "status": TaskStatus.COMPLETED.value,
        "importance": 5
    } 
    response = await test_async_client.put(
        url_put,
        json=update_payload,
        headers=auth_headers_a
    )

    # --- Assert ---
    assert response.status_code == status.HTTP_200_OK
    data = response.json()
    assert data["id"] == task_id
    assert data["title"] == update_payload["title"]
    assert data["status"] == update_payload["status"]
    assert data["importance"] == update_payload["importance"]
    assert "updated_at" in data and data["updated_at"] is not None
    assert "priority_score" in data
    assert data["priority_score"] != original_score

async def test_update_task_not_found(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str]
):
    """
    Testa a tentativa de atualizar uma tarefa que n√£o existe (ID inv√°lido).
    Espera-se um erro HTTP 404 Not Found.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/{uuid.uuid4()}" 
    # --- Act ---
    response = await test_async_client.put(url, json={"title": "Inexistente"}, headers=auth_headers_a)
    # --- Assert ---
    assert response.status_code == status.HTTP_404_NOT_FOUND

async def test_update_other_user_task_forbidden( 
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    auth_headers_b: Dict[str, str]
):
    """
    Testa a tentativa do User B de atualizar uma tarefa que pertence ao User A.
    A l√≥gica deve impedir essa opera√ß√£o, resultando em um HTTP 404 Not Found
    (como se a tarefa n√£o existisse para o User B).
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/"
    resp_a = await test_async_client.post(url, json=base_task_create_data, headers=auth_headers_a)
    assert resp_a.status_code == 201
    task_a_id = resp_a.json()["id"]

    # --- Act ---
    url_put = f"{settings.API_V1_STR}/tasks/{task_a_id}"
    response_b = await test_async_client.put(url_put, json={"title": "Hackeado?"}, headers=auth_headers_b)

    # --- Assert ---
    assert response_b.status_code == status.HTTP_404_NOT_FOUND

# ==========================================
# --- Testes DELETE /tasks/{id} ---
# ==========================================
async def test_delete_task_success(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str]
):
    """
    Testa a dele√ß√£o bem-sucedida de uma tarefa pelo seu propriet√°rio.
    Verifica se o status code √© HTTP 204 No Content e se uma tentativa
    posterior de obter a tarefa deletada resulta em HTTP 404 Not Found.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/"
    create_resp = await test_async_client.post(url, json=base_task_create_data, headers=auth_headers_a)
    assert create_resp.status_code == 201
    task_id = create_resp.json()["id"]

    # --- Act ---
    url_delete = f"{settings.API_V1_STR}/tasks/{task_id}"
    delete_response = await test_async_client.delete(url_delete, headers=auth_headers_a)

    # --- Assert (Delete) ---
    assert delete_response.status_code == status.HTTP_204_NO_CONTENT

    # --- Assert (Verificar Get posterior falha) ---
    url_get = f"{settings.API_V1_STR}/tasks/{task_id}"
    get_response = await test_async_client.get(url_get, headers=auth_headers_a)
    assert get_response.status_code == status.HTTP_404_NOT_FOUND

async def test_delete_task_not_found(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str]
):
    """
    Testa a tentativa de deletar uma tarefa que n√£o existe (ID inv√°lido).
    Espera-se um erro HTTP 404 Not Found.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/{uuid.uuid4()}" 
    # --- Act ---
    response = await test_async_client.delete(url, headers=auth_headers_a)
    # --- Assert ---
    assert response.status_code == status.HTTP_404_NOT_FOUND

async def test_delete_other_user_task_forbidden( 
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    auth_headers_b: Dict[str, str]
):
    """
    Testa a tentativa do User B de deletar uma tarefa que pertence ao User A.
    A opera√ß√£o deve ser impedida, resultando em HTTP 404 Not Found.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/"
    resp_a = await test_async_client.post(url, json=base_task_create_data, headers=auth_headers_a)
    assert resp_a.status_code == 201
    task_a_id = resp_a.json()["id"]

    # --- Act ---
    url_delete = f"{settings.API_V1_STR}/tasks/{task_a_id}"
    response_b = await test_async_client.delete(url_delete, headers=auth_headers_b)

    # --- Assert ---
    # No seu c√≥digo original, o teste espera `assert response_b.status_code == status.HTTP_404_NOT_FOUND`
    # Esta linha foi comentada no original, mas a l√≥gica da docstring e do nome sugere que a asser√ß√£o deveria estar aqui.
    # Para seguir estritamente, mantenho como no original, mas uma asser√ß√£o √© esperada aqui.
    # (O seu c√≥digo original aqui n√£o tinha a asser√ß√£o de status code final)

# ==========================================
# --- Testes de Seguran√ßa (JWT) ---
# ==========================================
async def test_access_tasks_invalid_token_format(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str], 
    mocker
):
    """
    Testa o acesso ao endpoint de listagem de tarefas (`/tasks/`) com um token JWT
    que est√° mal formatado (n√£o √© um JWT v√°lido).
    Espera-se um erro HTTP 401 Unauthorized e um log de erro espec√≠fico
    da camada de seguran√ßa.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/"
    invalid_headers = {"Authorization": "Bearer tokeninvalido.nao.jwt"}
    mock_sec_logger = mocker.patch("app.core.security.logger")
    # --- Act ---
    response = await test_async_client.get(url, headers=invalid_headers)
    # --- Assert ---
    assert response.status_code == status.HTTP_401_UNAUTHORIZED
    assert "validar as credenciais" in response.json()["detail"]
    mock_sec_logger.error.assert_called_once()
    assert "Not enough segments" in mock_sec_logger.error.call_args[0][0]

async def test_access_tasks_token_wrong_secret(
    test_async_client: AsyncClient,
    mocker 
):
    """
    Testa o acesso ao endpoint de listagem de tarefas (`/tasks/`) com um token JWT
    que foi assinado com uma chave secreta incorreta.
    Espera-se um erro HTTP 401 Unauthorized e um log de erro indicando falha
    na verifica√ß√£o da assinatura.
    """
    # --- Arrange ---
    from app.core.security import create_access_token 

    user_id_dummy = uuid.uuid4()
    username_dummy = "dummyuser"

    wrong_secret = "outra-chave-secreta-bem-diferente"
    assert wrong_secret != settings.JWT_SECRET_KEY 

    import jwt as jose_jwt
    to_encode = {"sub": str(user_id_dummy),
                "username": username_dummy,
                "exp": datetime.now(timezone.utc) + timedelta(minutes=15)
                }
    token_really_wrong_key = jose_jwt.encode(to_encode, wrong_secret, algorithm=settings.JWT_ALGORITHM)
    mock_sec_logger = mocker.patch("app.core.security.logger")
    url = f"{settings.API_V1_STR}/tasks/"
    invalid_headers = {"Authorization": f"Bearer {token_really_wrong_key}"}
    # --- Act ---
    response = await test_async_client.get(url, headers=invalid_headers)
    # --- Assert ---
    assert response.status_code == status.HTTP_401_UNAUTHORIZED
    assert "validar as credenciais" in response.json()["detail"]
    mock_sec_logger.error.assert_called_once()
    assert "Signature verification failed" in mock_sec_logger.error.call_args[0][0]


@freeze_time("2025-05-04 18:35:00")
async def test_access_tasks_expired_token(
    test_async_client: AsyncClient,
    test_user_a_token_and_id: tuple[str, uuid.UUID], 
    mocker
):
    """
    Testa o acesso ao endpoint de listagem de tarefas (`/tasks/`) com um token JWT
    que j√° expirou.
    Espera-se um erro HTTP 401 Unauthorized e um log de erro indicando
    que a assinatura expirou.
    """
    # --- Arrange ---

    _, user_id = test_user_a_token_and_id 

    past_time = datetime.now(timezone.utc) - timedelta(minutes=30) 
    expired_payload = {
        "sub": str(user_id), 
        "username": user_a_data["username"],
        "exp": past_time 
    }
    expired_token = jose_jwt.encode(
        expired_payload,
        settings.JWT_SECRET_KEY,
        algorithm=settings.JWT_ALGORITHM
    )
    url = f"{settings.API_V1_STR}/tasks/"
    invalid_headers = {"Authorization": f"Bearer {expired_token}"}
    # --- Act ---
    response = await test_async_client.get(url, headers=invalid_headers)
    # --- Assert ---
    assert response.status_code == status.HTTP_401_UNAUTHORIZED
    assert "N√£o autenticado" in response.json().get("detail", "") or \
           "Credenciais inv√°lidas" in response.json().get("detail", "") or \
           "Token expirado" in response.json().get("detail", "") or \
           "validar as credenciais" in response.json().get("detail", "")

# ================================================================
# --- Testes de Tentativas de Inje√ß√£o em Filtros de Listagem ---
# ================================================================
@pytest.mark.parametrize(
    "param_name, injected_value", [
        ("project", {"$ne": "some_project"}), 
        ("project", "; --"), 
        ("project", "' OR '1'='1"), 
        ("tag", {"$ne": "some_tag"}), 
        ("tag", "*"),
        ("tag", "t1; DROP TABLE tasks; --"), 
    ]
)
async def test_list_tasks_filter_injection_attempt_string(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    param_name: str, 
    injected_value: Any, 
):
    """
    Testa tentativas de inje√ß√£o de query MongoDB (ou SQL-like) nos par√¢metros
    de filtro de string (`project`, `tag`) do endpoint de listagem de tarefas.
    A API deve tratar esses inputs como strings literais ou rejeit√°-los com
    HTTP 422 Unprocessable Entity se o tipo de dado esperado for estritamente string
    e o valor injetado for, por exemplo, um dicion√°rio (como `{"$ne": ...}`).
    Se um valor que parece uma string maliciosa passar e resultar em 200 OK,
    o teste verifica se nenhuma tarefa inesperada √© retornada (a lista deve ser vazia
    ou o filtro deve ser tratado literalmente).
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/?{param_name}={str(injected_value)}" 
    # --- Act ---
    response = await test_async_client.get(url, headers=auth_headers_a)
    # --- Assert ---
    assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY \
        or response.status_code == status.HTTP_200_OK, \
        f"Recebido status inesperado {response.status_code} para inje√ß√£o em '{param_name}'"

    if response.status_code == status.HTTP_200_OK:
        tasks = response.json()
        assert isinstance(tasks, list)

async def test_list_tasks_filter_regex_injection(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    create_filter_sort_tasks: List[Dict] 
):
    """
    Testa especificamente uma tentativa de inje√ß√£o de express√£o regular MongoDB (`/.*/)
    no par√¢metro de filtro 'project'.
    Espera-se que o Pydantic/FastAPI trate o input como uma string literal e,
    portanto, n√£o encontre tarefas (ou apenas tarefas cujo nome do projeto seja
    literalmente "/.*/").
    """
    # --- Arrange ---
    payload_str = "/.*/" 
    url = f"{settings.API_V1_STR}/tasks/?project={payload_str}"
    # --- Act ---
    response = await test_async_client.get(url, headers=auth_headers_a)
    # --- Assert ---
    assert response.status_code == status.HTTP_200_OK
    tasks = response.json()
    assert isinstance(tasks, list)
    found_literal_match = any(task.get("project") == payload_str for task in tasks)
    assert not found_literal_match or len(tasks) == 0, \
           "Inje√ß√£o de Regex parece ter encontrado resultados inesperados ou foi tratada literalmente de forma incorreta."
    
# ================================================
# --- Testes de Notifica√ß√£o Imediata de E-mail ---
# ================================================
@freeze_time("2025-05-04") 
async def test_create_task_triggers_immediate_urgent_email(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    mocker, 
):
    """
    Testa se a cria√ß√£o de uma tarefa que √© identificada como urgente
    (pela fun√ß√£o `is_task_urgent`) dispara corretamente a fun√ß√£o de background
    `send_urgent_task_notification`.
    Utiliza mocks para controlar o resultado de `is_task_urgent` e para
    verificar a chamada a `send_urgent_task_notification`.
    """
    # --- Arrange ---
    mock_send_email = mocker.patch(
        "app.routers.tasks.send_urgent_task_notification",
        new_callable=AsyncMock
    )
    mocker.patch("app.routers.tasks.is_task_urgent", return_value=True) 

    urgent_task_payload = {
        "title": "Tarefa Super Urgente Imediata",
        "description": "Precisa de email agora",
        "importance": 5,
        "due_date": (date.today() - timedelta(days=1)).isoformat() 
    }
    url = f"{settings.API_V1_STR}/tasks/"
    # --- Act ---
    response = await test_async_client.post(url, json=urgent_task_payload, headers=auth_headers_a)

    # --- Assert ---
    assert response.status_code == status.HTTP_201_CREATED
    created_task_data = response.json()
    mock_send_email.assert_called_once()
    call_args = mock_send_email.call_args.kwargs
    assert call_args["user_email"] == user_a_data["email"] 
    assert call_args["task_title"] == urgent_task_payload["title"]
    assert call_args["task_id"] == created_task_data["id"]

@freeze_time("2025-05-04") 
async def test_create_task_does_not_trigger_immediate_non_urgent_email(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    mocker, 
):
    """
    Testa se a cria√ß√£o de uma tarefa que N√ÉO √© identificada como urgente
    (pela fun√ß√£o `is_task_urgent` mockada para retornar False) N√ÉO dispara
    a fun√ß√£o de background `send_urgent_task_notification`.
    """
    # --- Arrange ---
    mock_send_email = mocker.patch(
        "app.routers.tasks.send_urgent_task_notification",
        new_callable=AsyncMock
    )
    mocker.patch("app.routers.tasks.is_task_urgent", return_value=False) 

    non_urgent_task_payload = {
        "title": "Tarefa N√£o Urgente Imediata",
        "description": "Sem pressa",
        "importance": 1,
        "due_date": (date.today() + timedelta(days=30)).isoformat() 
    }
    url = f"{settings.API_V1_STR}/tasks/"
    # --- Act ---
    response = await test_async_client.post(url, json=non_urgent_task_payload, headers=auth_headers_a)

    # --- Assert ---
    assert response.status_code == status.HTTP_201_CREATED
    mock_send_email.assert_not_called()

================================================================================
Cap√≠tulo 30: tests/test_worker.py
================================================================================

# tests/test_worker.py

# ========================
# --- Importa√ß√µes ---
# ========================
import pytest # type: ignore
import uuid
from datetime import date, datetime, timedelta, timezone
from unittest.mock import AsyncMock, MagicMock, call, patch
from pydantic import ValidationError
import app.worker 
from importlib import reload

# --- M√≥dulos da Aplica√ß√£o ---
from app.worker import check_and_notify_urgent_tasks
from app.models.task import Task, TaskStatus
from app.models.user import UserInDB
from app.core.config import settings


# =================================================================
# --- Fixtures de Dados de Teste para Usu√°rios e Tarefas ---
# =================================================================
@pytest.fixture
def user_active_with_email() -> UserInDB:
    return UserInDB(
        id=uuid.uuid4(),
        username="testworkeruser",
        email="worker@example.com",
        full_name="Worker Test User",
        hashed_password="fakehash",
        disabled=False,
        created_at=datetime.now(timezone.utc)
    )

@pytest.fixture
def user_disabled_fixture() -> UserInDB: 
    return UserInDB(
        id=uuid.uuid4(),
        username="disableduser",
        email="disabled@example.com",
        full_name="Disabled User",
        hashed_password="fakehash",
        disabled=True,
        created_at=datetime.now(timezone.utc)
    )

@pytest.fixture
def task_urgent_score(user_active_with_email: UserInDB) -> Task:
    return Task(
        id=uuid.uuid4(),
        owner_id=user_active_with_email.id,
        title="Urgent High Score Task",
        importance=5,
        status=TaskStatus.PENDING,
        created_at=datetime.now(timezone.utc) - timedelta(days=1),
        priority_score=settings.EMAIL_URGENCY_THRESHOLD + 50.0,
        due_date=date.today() + timedelta(days=10)
    )

@pytest.fixture
def task_urgent_overdue(user_active_with_email: UserInDB) -> Task:
    return Task(
        id=uuid.uuid4(),
        owner_id=user_active_with_email.id,
        title="Urgent Overdue Task",
        importance=1,
        status=TaskStatus.PENDING,
        created_at=datetime.now(timezone.utc) - timedelta(days=5),
        priority_score=10.0,
        due_date=date.today() - timedelta(days=1)
    )

@pytest.fixture
def task_urgent_due_today(user_active_with_email: UserInDB) -> Task:
    return Task(
        id=uuid.uuid4(),
        owner_id=user_active_with_email.id,
        title="Urgent Due Today Task",
        importance=2,
        status=TaskStatus.IN_PROGRESS,
        created_at=datetime.now(timezone.utc) - timedelta(days=2),
        priority_score=20.0,
        due_date=date.today()
    )

@pytest.fixture
def task_not_urgent(user_active_with_email: UserInDB) -> Task:
    return Task(
        id=uuid.uuid4(),
        owner_id=user_active_with_email.id,
        title="Not Urgent Task",
        importance=3,
        status=TaskStatus.PENDING,
        created_at=datetime.now(timezone.utc),
        priority_score=settings.EMAIL_URGENCY_THRESHOLD - 10.0,
        due_date=date.today() + timedelta(days=5)
    )

@pytest.fixture
def task_completed(user_active_with_email: UserInDB) -> Task:
    return Task(
        id=uuid.uuid4(),
        owner_id=user_active_with_email.id,
        title="Completed Urgent Task",
        importance=5,
        status=TaskStatus.COMPLETED,
        created_at=datetime.now(timezone.utc) - timedelta(days=10),
        priority_score=settings.EMAIL_URGENCY_THRESHOLD + 100.0,
        due_date=date.today() - timedelta(days=2)
    )

@pytest.fixture
def task_disabled_user(user_disabled_fixture: UserInDB) -> Task: 
    return Task(
        id=uuid.uuid4(),
        owner_id=user_disabled_fixture.id,
        title="Disabled User Urgent Task",
        importance=5,
        status=TaskStatus.PENDING,
        created_at=datetime.now(timezone.utc),
        priority_score=settings.EMAIL_URGENCY_THRESHOLD + 50.0
    )

# =============================================================
# --- Testes para a fun√ß√£o `check_and_notify_urgent_tasks` ---
# =============================================================
@pytest.mark.asyncio
async def test_worker_no_urgent_tasks(mocker): 
    """
    Testa o comportamento da fun√ß√£o do worker ARQ quando o banco
    de dados simulado n√£o retorna nenhuma tarefa urgente.
    """
    # ========================
    # --- Arrange ---
    # ========================
    mock_db = MagicMock()
    mock_tasks_collection = MagicMock()
    mock_db.__getitem__.return_value = mock_tasks_collection

    mock_cursor = AsyncMock()
    mock_cursor.__aiter__.return_value = []
    mock_tasks_collection.find.return_value = mock_cursor

    mock_get_user = mocker.patch("app.worker.user_crud.get_user_by_id", new_callable=AsyncMock)
    mock_send_email = mocker.patch("app.worker.send_urgent_task_notification", new_callable=AsyncMock)

    ctx = {"db": mock_db}
    # ========================
    # --- Act ---
    # ========================
    await check_and_notify_urgent_tasks(ctx)

    # ========================
    # --- Assert ---
    # ========================
    mock_tasks_collection.find.assert_called_once()
    mock_get_user.assert_not_called()
    mock_send_email.assert_not_called()

@pytest.mark.asyncio
async def test_worker_one_urgent_task_active_user(mocker, user_active_with_email, task_urgent_score): 
    """
    Testa o cen√°rio onde o worker encontra uma tarefa urgente
    pertencente a um usu√°rio ativo e com e-mail.
    """
    # ========================
    # --- Arrange ---
    # ========================
    mock_db = MagicMock()
    mock_tasks_collection = MagicMock()
    mock_users_collection = MagicMock()
    def db_getitem_side_effect(key):
        if key == "tasks": return mock_tasks_collection
        if key == "users": return mock_users_collection
        raise KeyError(key)
    mock_db.__getitem__.side_effect = db_getitem_side_effect

    task_dict = task_urgent_score.model_dump(mode='json')
    mock_cursor = AsyncMock()
    mock_cursor.__aiter__.return_value = [task_dict]
    mock_tasks_collection.find.return_value = mock_cursor

    mock_get_user = mocker.patch(
        "app.worker.user_crud.get_user_by_id",
        new_callable=AsyncMock,
        return_value=user_active_with_email
    )
    mock_send_email = mocker.patch("app.worker.send_urgent_task_notification", new_callable=AsyncMock)

    ctx = {"db": mock_db}
    # ========================
    # --- Act ---
    # ========================
    await check_and_notify_urgent_tasks(ctx)

    # ========================
    # --- Assert ---
    # ========================
    mock_tasks_collection.find.assert_called_once()
    mock_get_user.assert_called_once_with(mock_db, task_urgent_score.owner_id)
    mock_send_email.assert_called_once()

    call_args = mock_send_email.call_args.kwargs
    assert call_args['user_email'] == user_active_with_email.email
    assert call_args['user_name'] == user_active_with_email.full_name
    assert call_args['task_title'] == task_urgent_score.title
    assert call_args['task_id'] == str(task_urgent_score.id)

@pytest.mark.asyncio
async def test_worker_mix_urgent_non_urgent_completed(mocker, user_active_with_email, task_not_urgent, task_urgent_overdue, task_completed): 
    """
    Testa o worker com uma mistura de tarefas.
    """
    # ========================
    # --- Arrange ---
    # ========================
    mock_db = MagicMock()
    mock_tasks_collection = MagicMock()
    mock_users_collection = MagicMock()
    def db_getitem_side_effect(key):
        if key == "tasks": return mock_tasks_collection
        if key == "users": return mock_users_collection
        raise KeyError(key)
    mock_db.__getitem__.side_effect = db_getitem_side_effect

    # Simular que a query `find` retorna apenas a tarefa urgente e n√£o completada
    filtered_task_dict = task_urgent_overdue.model_dump(mode='json')
    mock_cursor = AsyncMock()
    mock_cursor.__aiter__.return_value = [filtered_task_dict]
    mock_tasks_collection.find.return_value = mock_cursor

    mock_get_user = mocker.patch(
        "app.worker.user_crud.get_user_by_id",
        new_callable=AsyncMock,
        return_value=user_active_with_email
    )
    mock_send_email = mocker.patch("app.worker.send_urgent_task_notification", new_callable=AsyncMock)

    ctx = {"db": mock_db}
    # ========================
    # --- Act ---
    # ========================
    await check_and_notify_urgent_tasks(ctx)

    # ========================
    # --- Assert ---
    # ========================
    mock_tasks_collection.find.assert_called_once()
    mock_get_user.assert_called_once_with(mock_db, task_urgent_overdue.owner_id)
    mock_send_email.assert_called_once()
    call_args = mock_send_email.call_args.kwargs
    assert call_args['task_title'] == task_urgent_overdue.title

@pytest.mark.asyncio
async def test_worker_urgent_task_disabled_user(mocker, user_disabled_fixture, task_disabled_user): 
    """
    Testa que nenhuma notifica√ß√£o √© enviada se o usu√°rio estiver desativado.
    """
    # ========================
    # --- Arrange ---
    # ========================
    mock_db = MagicMock()
    mock_tasks_collection = MagicMock()
    mock_users_collection = MagicMock()
    def db_getitem_side_effect(key):
        if key == "tasks": return mock_tasks_collection
        if key == "users": return mock_users_collection
        raise KeyError(key)
    mock_db.__getitem__.side_effect = db_getitem_side_effect

    mock_cursor = AsyncMock()
    mock_cursor.__aiter__.return_value = [task_disabled_user.model_dump(mode='json')]
    mock_tasks_collection.find.return_value = mock_cursor

    mock_get_user = mocker.patch(
        "app.worker.user_crud.get_user_by_id",
        new_callable=AsyncMock,
        return_value=user_disabled_fixture
    )
    mock_send_email = mocker.patch("app.worker.send_urgent_task_notification", new_callable=AsyncMock)

    ctx = {"db": mock_db}
    # ========================
    # --- Act ---
    # ========================
    await check_and_notify_urgent_tasks(ctx)

    # ========================
    # --- Assert ---
    # ========================
    mock_tasks_collection.find.assert_called_once()
    mock_get_user.assert_called_once_with(mock_db, user_disabled_fixture.id)
    mock_send_email.assert_not_called()

@pytest.mark.asyncio
async def test_worker_multiple_urgent_tasks(mocker, user_active_with_email, task_urgent_score, task_urgent_overdue, task_urgent_due_today): 
    """
    Testa o cen√°rio com m√∫ltiplas tarefas urgentes para usu√°rios ativos.
    """
    # ========================
    # --- Arrange ---
    # ========================
    mock_db = MagicMock()
    mock_tasks_collection = MagicMock()
    mock_users_collection = MagicMock()
    def db_getitem_side_effect(key):
        if key == "tasks": return mock_tasks_collection
        if key == "users": return mock_users_collection
        raise KeyError(key)
    mock_db.__getitem__.side_effect = db_getitem_side_effect

    urgent_tasks_list_dicts = [
        task_urgent_score.model_dump(mode='json'),
        task_urgent_overdue.model_dump(mode='json'),
        task_urgent_due_today.model_dump(mode='json')
    ]
    mock_cursor = AsyncMock()
    mock_cursor.__aiter__.return_value = urgent_tasks_list_dicts
    mock_tasks_collection.find.return_value = mock_cursor

    mock_get_user = mocker.patch(
        "app.worker.user_crud.get_user_by_id",
        new_callable=AsyncMock,
        return_value=user_active_with_email
    )
    mock_send_email = mocker.patch("app.worker.send_urgent_task_notification", new_callable=AsyncMock)

    ctx = {"db": mock_db}
    # ========================
    # --- Act ---
    # ========================
    await check_and_notify_urgent_tasks(ctx)

    # ========================
    # --- Assert ---
    # ========================
    assert mock_tasks_collection.find.call_count == 1
    assert mock_get_user.call_count == len(urgent_tasks_list_dicts)
    assert mock_send_email.call_count == len(urgent_tasks_list_dicts)

    expected_call_args_score = {
        'user_email': user_active_with_email.email,
        'user_name': user_active_with_email.full_name,
        'task_title': task_urgent_score.title,
        'task_id': str(task_urgent_score.id),
        'task_due_date': str(task_urgent_score.due_date),
        'priority_score': task_urgent_score.priority_score
    }
    expected_call_args_overdue = {
        'user_email': user_active_with_email.email,
        'user_name': user_active_with_email.full_name,
        'task_title': task_urgent_overdue.title,
        'task_id': str(task_urgent_overdue.id),
        'task_due_date': str(task_urgent_overdue.due_date),
        'priority_score': task_urgent_overdue.priority_score
    }
    expected_call_args_today = {
        'user_email': user_active_with_email.email,
        'user_name': user_active_with_email.full_name,
        'task_title': task_urgent_due_today.title,
        'task_id': str(task_urgent_due_today.id),
        'task_due_date': str(task_urgent_due_today.due_date),
        'priority_score': task_urgent_due_today.priority_score
    }
    mock_send_email.assert_has_calls([
        call(**expected_call_args_score),
        call(**expected_call_args_overdue),
        call(**expected_call_args_today)
    ], any_order=True)

@pytest.mark.asyncio
async def test_worker_db_unavailable(mocker): 
    """
    Testa o comportamento do worker quando 'db' n√£o est√° no contexto.
    """
    # ========================
    # --- Arrange ---
    # ========================
    mock_send_email = mocker.patch("app.worker.send_urgent_task_notification", new_callable=AsyncMock)
    mock_logger = mocker.patch("app.worker.logger")

    ctx = {}
    # ========================
    # --- Act ---
    # ========================
    await check_and_notify_urgent_tasks(ctx)

    # ========================
    # --- Assert ---
    # ========================
    mock_send_email.assert_not_called()
    mock_logger.error.assert_called_once_with(
        "Conex√£o com o banco de dados n√£o dispon√≠vel no contexto ARQ."
    )

@pytest.mark.asyncio
async def test_worker_user_not_found(mocker, task_urgent_score): 
    """
    Testa o caso onde uma tarefa urgente √© encontrada, mas o usu√°rio
    propriet√°rio n√£o √© encontrado no banco de dados.
    """
    # ========================
    # --- Arrange ---
    # ========================
    mock_db = MagicMock()
    mock_tasks_collection = MagicMock()
    mock_users_collection = MagicMock()
    def db_getitem_side_effect(key):
        if key == "tasks": return mock_tasks_collection
        if key == "users": return mock_users_collection
        raise KeyError(key)
    mock_db.__getitem__.side_effect = db_getitem_side_effect

    urgent_task_dict = task_urgent_score.model_dump(mode='json')
    mock_cursor = AsyncMock()
    mock_cursor.__aiter__.return_value = [urgent_task_dict]
    mock_tasks_collection.find.return_value = mock_cursor

    mock_get_user = mocker.patch(
        "app.worker.user_crud.get_user_by_id",
        new_callable=AsyncMock,
        return_value=None
    )
    mock_send_email = mocker.patch("app.worker.send_urgent_task_notification", new_callable=AsyncMock)
    mock_logger_warning = mocker.patch("app.worker.logger.warning")

    ctx = {"db": mock_db}

    # ========================
    # --- Act ---
    # ========================
    await check_and_notify_urgent_tasks(ctx)

    # ========================
    # --- Assert ---
    # ========================
    mock_tasks_collection.find.assert_called_once()
    mock_get_user.assert_called_once_with(mock_db, task_urgent_score.owner_id)
    mock_send_email.assert_not_called()
    mock_logger_warning.assert_called_once()
    log_message = mock_logger_warning.call_args[0][0]
    assert f"Usu√°rio com ID '{task_urgent_score.owner_id}' associado √† tarefa urgente '{task_urgent_score.id}' n√£o foi encontrado" in log_message

@pytest.mark.asyncio
async def test_worker_user_missing_details(mocker, user_active_with_email, task_urgent_due_today): 
    """
    Testa o caso onde o usu√°rio √© encontrado, mas falta email ou nome.
    """
    # ========================
    # --- Arrange ---
    # ========================
    for missing_field in ["email", "full_name"]:
        mock_db = MagicMock()
        mock_tasks_collection = MagicMock()
        mock_users_collection = MagicMock()
        def db_getitem_side_effect(key):
            if key == "tasks": return mock_tasks_collection
            if key == "users": return mock_users_collection
            raise KeyError(key)
        mock_db.__getitem__.side_effect = db_getitem_side_effect

        urgent_task_dict = task_urgent_due_today.model_dump(mode='json')
        mock_cursor = AsyncMock()
        mock_cursor.__aiter__.return_value = [urgent_task_dict]
        mock_tasks_collection.find.return_value = mock_cursor

        user_missing_details_mock = user_active_with_email.model_copy(deep=True)
        setattr(user_missing_details_mock, missing_field, None)

        mock_get_user = mocker.patch(
            "app.worker.user_crud.get_user_by_id",
            new_callable=AsyncMock,
            return_value=user_missing_details_mock
        )
        mock_send_email = mocker.patch("app.worker.send_urgent_task_notification", new_callable=AsyncMock)
        mock_logger_warning = mocker.patch("app.worker.logger.warning")

        ctx = {"db": mock_db}

        # ========================
        # --- Act ---
        # ========================
        await check_and_notify_urgent_tasks(ctx)

        # ========================
        # --- Assert ---
        # ========================
        mock_tasks_collection.find.assert_called_once()
        mock_get_user.assert_called_once_with(mock_db, task_urgent_due_today.owner_id)
        mock_send_email.assert_not_called()
        mock_logger_warning.assert_called_once()
        log_message = mock_logger_warning.call_args[0][0]
        assert f"Usu√°rio '{user_missing_details_mock.username}'" in log_message
        assert "n√£o possui e-mail ou nome completo configurado" in log_message

        mocker.resetall()

@pytest.mark.asyncio
async def test_worker_task_processing_exception(mocker, user_active_with_email, task_urgent_score, task_urgent_overdue): 
    """
    Testa o tratamento de exce√ß√£o dentro do loop de processamento de tarefas.
    """
    # ========================
    # --- Arrange ---
    # ========================
    mock_db = MagicMock()
    mock_tasks_collection = MagicMock()
    mock_users_collection = MagicMock()
    def db_getitem_side_effect(key):
        if key == "tasks": return mock_tasks_collection
        if key == "users": return mock_users_collection
        raise KeyError(key)
    mock_db.__getitem__.side_effect = db_getitem_side_effect

    invalid_task_dict = task_urgent_score.model_dump(mode='json')
    invalid_task_dict.pop("title")
    invalid_task_dict["_id"] = "temp_id"
    dict_for_invalid_call = invalid_task_dict.copy()
    dict_for_invalid_call.pop('_id', None)

    valid_task_dict = task_urgent_overdue.model_dump(mode='json')
    valid_task_dict["_id"] = "valid_id"
    dict_for_valid_call = valid_task_dict.copy()
    dict_for_valid_call.pop('_id', None)


    mock_cursor = AsyncMock()
    mock_cursor.__aiter__.return_value = [valid_task_dict, invalid_task_dict]
    mock_tasks_collection.find.return_value = mock_cursor

    mock_get_user = mocker.patch(
        "app.worker.user_crud.get_user_by_id",
        new_callable=AsyncMock,
        return_value=user_active_with_email
    )

    validation_error = ValidationError.from_exception_data(title="Task", line_errors=[{'type': 'missing', 'loc':('title',)}])
    mock_model_validate = mocker.patch(
        "app.worker.Task.model_validate",
        side_effect=[task_urgent_overdue, validation_error]
    )

    mock_send_email = mocker.patch("app.worker.send_urgent_task_notification", new_callable=AsyncMock)
    mock_logger_exception = mocker.patch("app.worker.logger.exception")

    ctx = {"db": mock_db}

    # ========================
    # --- Act ---
    # ========================
    await check_and_notify_urgent_tasks(ctx)

    # ========================
    # --- Assert ---
    # ========================
    mock_tasks_collection.find.assert_called_once()
    assert mock_get_user.call_count == 1
    mock_get_user.assert_called_with(mock_db, task_urgent_overdue.owner_id)
    assert mock_model_validate.call_count == 2 
    mock_send_email.assert_called_once() 
    mock_logger_exception.assert_called_once()
    log_message = mock_logger_exception.call_args[0][0]
    assert f"Erro ao processar tarefa urgente (ID no dict: {invalid_task_dict.get('id')})" in log_message
    assert str(validation_error) in log_message

@pytest.mark.asyncio
async def test_startup_generic_exception(mocker): 
    """
    Testa o tratamento de erro no startup do worker quando
    connect_to_mongo lan√ßa uma exce√ß√£o gen√©rica.
    """
    # ========================
    # --- Arrange ---
    # ========================
    simulated_connect_error = Exception("Erro gen√©rico na conex√£o inicial")
    mock_connect = mocker.patch("app.worker.connect_to_mongo", side_effect=simulated_connect_error)
    mock_logger_error = mocker.patch("app.worker.logger.error")
    ctx = {}

    # ========================
    # --- Act & Assert ---
    # ========================
    with pytest.raises(Exception, match="Erro gen√©rico na conex√£o inicial"):
        await app.worker.startup(ctx)

    mock_connect.assert_awaited_once()
    mock_logger_error.assert_not_called()
    assert ctx.get("db") is None

@pytest.mark.asyncio
async def test_worker_send_email_exception(mocker, user_active_with_email, task_urgent_score): 
    """
    Testa o tratamento de exce√ß√£o gen√©rica ao tentar enviar email no worker.
    """
    # ========================
    # --- Arrange ---
    # ========================
    mock_db = MagicMock()
    mock_tasks_collection = MagicMock()
    mock_users_collection = MagicMock()
    def db_getitem_side_effect(key):
        if key == "tasks": return mock_tasks_collection
        if key == "users": return mock_users_collection
        raise KeyError(key)
    mock_db.__getitem__.side_effect = db_getitem_side_effect
    urgent_task_dict = task_urgent_score.model_dump(mode='json')
    urgent_task_dict['_id'] = "task_email_exc_id"
    mock_cursor = AsyncMock()
    mock_cursor.__aiter__.return_value = [urgent_task_dict]
    mock_tasks_collection.find.return_value = mock_cursor
    mock_get_user = mocker.patch(
        "app.worker.user_crud.get_user_by_id",
        new_callable=AsyncMock,
        return_value=user_active_with_email
    )
    mocker.patch("app.worker.Task.model_validate", return_value=task_urgent_score)
    simulated_email_error = Exception("Erro simulado no envio de email")
    mock_send_email = mocker.patch(
        "app.worker.send_urgent_task_notification",
        new_callable=AsyncMock,
        side_effect=simulated_email_error
    )
    mock_logger_exception = mocker.patch("app.worker.logger.exception")
    ctx = {"db": mock_db}

    # ========================
    # --- Act ---
    # ========================
    await check_and_notify_urgent_tasks(ctx)

    # ========================
    # --- Assert ---
    # ========================
    mock_tasks_collection.find.assert_called_once()
    mock_get_user.assert_called_once_with(mock_db, task_urgent_score.owner_id)
    mock_send_email.assert_called_once()
    mock_logger_exception.assert_called_once()
    log_message = mock_logger_exception.call_args.args[0]
    assert f"Erro ao processar tarefa urgente (ID no dict: {task_urgent_score.id})" in log_message
    assert str(simulated_email_error) in log_message

def test_worker_settings_no_redis_url(mocker): 
    """
    Testa se WorkerSettings levanta ValueError quando settings.REDIS_URL √© None.
    """
    # ========================
    # --- Arrange ---
    # ========================
    mocker.patch("app.worker.settings.REDIS_URL", None)
    mock_logger_error = mocker.patch("app.worker.logger.error")

    # ========================
    # --- Act & Assert ---
    # ========================
    with pytest.raises(ValueError) as excinfo:
        reload(app.worker)

    assert "REDIS_URL n√£o est√° definida nas configura√ß√µes" in str(excinfo.value)
    mock_logger_error.assert_called_with("Configura√ß√£o cr√≠tica ausente: REDIS_URL n√£o est√° definida. Worker ARQ n√£o pode iniciar.")

# =============================================================
# --- Testes para a fun√ß√£o `shutdown` ---
# =============================================================

@pytest.mark.asyncio
async def test_shutdown_with_db(mocker): 
    """Testa a fun√ß√£o shutdown quando existe conex√£o DB no contexto."""
    # ========================
    # --- Arrange ---
    # ========================
    mock_close_conn = mocker.patch("app.worker.close_mongo_connection", new_callable=AsyncMock)
    mock_logger_info = mocker.patch("app.worker.logger.info")
    mock_db = MagicMock() 
    ctx = {"db": mock_db}

    # ========================
    # --- Act ---
    # ========================
    await app.worker.shutdown(ctx) 

    # ========================
    # --- Assert ---
    # ========================
    mock_logger_info.assert_any_call("Worker ARQ: Iniciando rotinas de shutdown...")
    mock_close_conn.assert_awaited_once()
    mock_logger_info.assert_any_call("Worker ARQ: Conex√£o com MongoDB fechada.")

@pytest.mark.asyncio
async def test_shutdown_without_db(mocker): 
    """Testa a fun√ß√£o shutdown quando n√£o existe conex√£o DB no contexto."""
    # ========================
    # --- Arrange ---
    # ========================
    mock_close_conn = mocker.patch("app.worker.close_mongo_connection", new_callable=AsyncMock)
    mock_logger_info = mocker.patch("app.worker.logger.info")
    ctx = {"db": None} 

    # ========================
    # --- Act ---
    # ========================
    await app.worker.shutdown(ctx)

    # ========================
    # --- Assert ---
    # ========================
    mock_logger_info.assert_any_call("Worker ARQ: Iniciando rotinas de shutdown...")
    mock_close_conn.assert_not_called()
    mock_logger_info.assert_any_call("Worker ARQ: Nenhuma conex√£o com MongoDB para fechar (n√£o estava dispon√≠vel ou j√° fechada).")

# =============================================================
# --- Testes para a StartUp ---
# =============================================================
@pytest.mark.asyncio
async def test_startup_success(mocker): 
    """
    Testa o caminho de sucesso da fun√ß√£o startup.
    """
    # ========================
    # --- Arrange ---
    # ========================
    mock_db_connection = MagicMock()
    mock_connect = mocker.patch("app.worker.connect_to_mongo", return_value=mock_db_connection)
    mock_logger_info = mocker.patch("app.worker.logger.info")
    mock_logger_error = mocker.patch("app.worker.logger.error") 
    ctx = {} 

    # ========================
    # --- Act ---
    # ========================
    await app.worker.startup(ctx)

    # ========================
    # --- Assert ---
    # ========================
    mock_connect.assert_awaited_once()
    assert ctx.get("db") == mock_db_connection 
    mock_logger_info.assert_any_call("Worker ARQ: Iniciando rotinas de startup...")
    mock_logger_info.assert_any_call("Worker ARQ: Conex√£o com MongoDB estabelecida e armazenada no contexto.")
    mock_logger_error.assert_not_called()

@pytest.mark.asyncio
async def test_startup_connect_returns_none(mocker): 
    """
    Testa o caminho de falha da fun√ß√£o startup quando connect_to_mongo retorna None.
    """
    # ========================
    # --- Arrange ---
    # ========================
    mock_connect = mocker.patch("app.worker.connect_to_mongo", return_value=None) 
    mock_logger_info = mocker.patch("app.worker.logger.info")
    mock_logger_error = mocker.patch("app.worker.logger.error")
    ctx = {}

    # ========================
    # --- Act ---
    # ========================
    await app.worker.startup(ctx)

    # ========================
    # --- Assert ---
    # ========================
    mock_connect.assert_awaited_once()
    assert ctx.get("db") is None 
    mock_logger_info.assert_called_once_with("Worker ARQ: Iniciando rotinas de startup...") 
    mock_logger_error.assert_called_once_with(
        "Worker ARQ: Falha cr√≠tica ao conectar ao MongoDB durante o startup. "
        "A conex√£o n√£o estar√° dispon√≠vel para as tarefas."
    )

