================================================================================
CÓDIGO-FONTE DO PROJETO
================================================================================

SUMÁRIO
--------------------------------------------------------------------------------
Capítulo 1: app/core/config.py
Capítulo 2: app/core/dependencies.py
Capítulo 3: app/core/email.py
Capítulo 4: app/core/logging_config.py
Capítulo 5: app/core/security.py
Capítulo 6: app/core/utils.py
Capítulo 7: app/db/mongodb_utils.py
Capítulo 8: app/db/task_crud.py
Capítulo 9: app/db/user_crud.py
Capítulo 10: app/main.py
Capítulo 11: app/models/task.py
Capítulo 12: app/models/token.py
Capítulo 13: app/models/user.py
Capítulo 14: app/routers/auth.py
Capítulo 15: app/routers/tasks.py
Capítulo 16: app/worker.py
Capítulo 17: tests/conftest.py
Capítulo 18: tests/test_auth.py
Capítulo 19: tests/test_core_config.py
Capítulo 20: tests/test_core_dependencies.py
Capítulo 21: tests/test_core_email.py
Capítulo 22: tests/test_core_security.py
Capítulo 23: tests/test_core_utils.py
Capítulo 24: tests/test_core_utils_webhooks.py
Capítulo 25: tests/test_db_mongodb_utils.py
Capítulo 26: tests/test_db_task_crud.py
Capítulo 27: tests/test_db_user_crud.py
Capítulo 28: tests/test_main.py
Capítulo 29: tests/test_tasks.py
Capítulo 30: tests/test_worker.py


================================================================================
Capítulo 1: app/core/config.py
================================================================================

# app/core/config.py
"""
Configurações da aplicação lidas do ambiente usando Pydantic BaseSettings.
Procura variáveis de ambiente ou variáveis em um arquivo .env.
"""

# ========================
# --- Importações ---
# ========================
import os
import logging
from typing import Optional, List
from pydantic_settings import BaseSettings
from pydantic import EmailStr, Field, RedisDsn, ValidationError, model_validator, HttpUrl
from dotenv import load_dotenv

# ========================
# --- Configuração do Logger ---
# ========================
logger = logging.getLogger(__name__)

# ========================
# --- Carregamento do .env.test ---
# ========================
base_dir = os.path.dirname(os.path.dirname(os.path.dirname(__file__)))
env_file = ".env.test" if os.getenv("ENVIRONMENT") == "test" else ".env"
dotenv_path = os.path.join(base_dir, env_file)
load_dotenv(dotenv_path=dotenv_path)


# ========================
# --- Definição das Configurações ---
# ========================
class Settings(BaseSettings):
    """
    Configurações da aplicação lidas do ambiente usando Pydantic BaseSettings.
    """
    # --- Config Gerais ---
    PROJECT_NAME: str = Field("SmartTask API", description="Nome do Projeto")
    API_V1_STR: str = Field("/api/v1", description="Prefixo para a versão 1 da API")

    # --- Configurações MongoDB ---
    MONGODB_URL: str = Field(..., description="URL de conexão completa do MongoDB (obrigatória)")
    DATABASE_NAME: str = Field("smarttask_db", description="Nome do banco de dados MongoDB")

    # --- Configurações JWT ---
    JWT_SECRET_KEY: str = Field(..., description="Chave secreta forte para assinar tokens JWT (obrigatória)")
    JWT_ALGORITHM: str = Field("HS256", description="Algoritmo de assinatura JWT")
    ACCESS_TOKEN_EXPIRE_MINUTES: int = Field(60 * 24 * 7, description="Validade do token de acesso em minutos (padrão: 7 dias)")

    # --- Configurações de Prioridade ---
    PRIORITY_WEIGHT_DUE_DATE: float = Field(
        100.0,
        description="Peso para o componente de prazo no cálculo de prioridade."
    )
    PRIORITY_WEIGHT_IMPORTANCE: float = Field(
        10.0,
        description="Peso (multiplicador) para o componente de importância no cálculo de prioridade."
    )
    PRIORITY_DEFAULT_SCORE_NO_DUE_DATE: Optional[float] = Field(
        0.0,
        description="Pontuação base de prazo para tarefas sem data de vencimento (pode ser None ou 0.0)."
    )
    PRIORITY_SCORE_IF_OVERDUE: float = Field(
        1000.0,
        description="Pontuação (ou fator aditivo/multiplicativo) especial para tarefas atrasadas."
    )

    # --- Configuração Webhook ---
    WEBHOOK_URL: Optional[HttpUrl] = Field(
        default=None,
        description="URL opcional para enviar notificações de eventos de tarefas (webhooks)."
    )
    WEBHOOK_SECRET: Optional[str] = Field(
        default=None,
        description="Segredo opcional usado para assinar payloads de webhook para verificação (HMAC-SHA256)."
    )

    # --- Configurações de E-mail ---
    MAIL_ENABLED: bool = Field(
            default=False,
            description="Flag para habilitar/desabilitar envio de e-mails globalmente."
    )
    MAIL_USERNAME: Optional[str] = Field(default=None, description="Usuário do servidor SMTP.")
    MAIL_PASSWORD: Optional[str] = Field(default=None, description="Senha do servidor SMTP.")
    MAIL_FROM: Optional[EmailStr] = Field(
        default=None,
        description="Endereço de e-mail remetente."
    )
    MAIL_FROM_NAME: Optional[str] = Field(
        default="SmartTask Notificações",
        description="Nome do remetente exibido no e-mail."
    )
    MAIL_PORT: int = Field(
        default=587,
        description="Porta do servidor SMTP."
    )
    MAIL_SERVER: Optional[str] = Field(
        default=None,
        description="Endereço do servidor SMTP."
    )
    MAIL_STARTTLS: bool = Field(default=True, description="Usar STARTTLS para conexão SMTP.")
    MAIL_SSL_TLS: bool = Field(default=False, description="Usar SSL/TLS direto para conexão SMTP.")
    USE_CREDENTIALS: bool = Field(default=True, description="Usar credenciais (username/password) para SMTP.")
    VALIDATE_CERTS: bool = Field(default=True, description="Validar certificados SSL/TLS do servidor SMTP.")

    # --- Configurações Adicionais Específicas ---
    EMAIL_TEMPLATES_DIR: str = Field(default="app/email-templates/build", description="Diretório de templates de e-mail compilados.")
    EMAIL_URGENCY_THRESHOLD: float = Field(
        default=100.0,
        description="Limiar de priority_score para considerar uma tarefa urgente para notificação por e-mail."
    )
    FRONTEND_URL: Optional[str] = Field(default=None, description="URL base do frontend para links no e-mail (se houver).")

    # --- Configuração Redis ---
    REDIS_URL: Optional[RedisDsn] = Field(
        default=None,
        description="URL de conexão do Redis para filas de tarefas (ARQ)."
    )

    # --- Configuração de Logging ---
    LOG_LEVEL: str = Field(default="INFO", description="Nível de log (DEBUG, INFO, WARNING, ERROR, CRITICAL)")

    # --- Configurações CORS ---
    # A conversão de string separada por vírgula para List[str] é feita automaticamente pelo Pydantic v2
    CORS_ALLOWED_ORIGINS: List[str] = Field(default=[], description="Lista de origens CORS permitidas (separadas por vírgula no .env)")

    # --- Configuração do Modelo Pydantic BaseSettings ---
    model_config = {
        "case_sensitive": False,
    }

    # --- Validadores ---
    @model_validator(mode='after')
    def check_mail_config(self) -> 'Settings':
        """Valida se as credenciais de e-mail estão presentes quando habilitado."""
        if self.MAIL_ENABLED and not all([self.MAIL_USERNAME, self.MAIL_PASSWORD, self.MAIL_FROM, self.MAIL_SERVER]):
            raise ValueError(
                "Se MAIL_ENABLED for True, MAIL_USERNAME, MAIL_PASSWORD, MAIL_FROM e MAIL_SERVER devem ser definidos."
            )
        return self

    @model_validator(mode='after')
    def check_webhook_config(self) -> 'Settings':
        """Validações adicionais para configuração do webhook, se necessário."""
        if self.WEBHOOK_URL and not self.WEBHOOK_SECRET:
            raise ValueError("WEBHOOK_SECRET deve ser definido quando WEBHOOK_URL estiver ativa.")
        return self

# ========================
# --- Criação da Instância ---
# ========================
try:
    # Pydantic BaseSettings lê do ambiente ou .env na instanciação
    settings = Settings()
except ValidationError as e:# pragma: no cover
    logger.critical(f"Erro fatal de validação ao carregar configurações: {e}") # pragma: no cover
    raise e # pragma: no cover
except ValueError as e:# pragma: no cover
    logger.critical(f"Erro fatal de validação na configuração (check_mail_config?): {e}") # pragma: no cover
    raise e # pragma: no cover
except Exception as e:# pragma: no cover
    logger.critical(f"Erro inesperado ao carregar configurações: {e}", exc_info=True) # pragma: no cover
    raise e # pragma: no cover

================================================================================
Capítulo 2: app/core/dependencies.py
================================================================================

# app/core/dependencies.py
"""
Define as dependências reutilizáveis para a aplicação FastAPI,
especialmente aquelas relacionadas à autenticação e acesso ao banco de dados.
"""

# ========================
# --- Importações ---
# ========================
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from motor.motor_asyncio import AsyncIOMotorDatabase
from typing import Annotated
import uuid

# --- Módulos da Aplicação ---
from app.db.mongodb_utils import get_database
from app.core.security import decode_token
from app.db import user_crud
from app.models.user import UserInDB

# ========================
# --- Esquema OAuth2 ---
# ========================
# Define o esquema OAuth2 para obter o token do header 'Authorization: Bearer <token>'.
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/v1/auth/login/access-token")

# ========================
# --- Tipos de Dependência ---
# ========================
DbDep = Annotated[AsyncIOMotorDatabase, Depends(get_database)]
TokenDep = Annotated[str, Depends(oauth2_scheme)]

# ========================
# --- Dependência: Usuário Atual ---
# ========================
async def get_current_user(
    db: DbDep,
    token: TokenDep
) -> UserInDB:
    """
    Dependência para obter o usuário atual com base no token JWT fornecido.

    Processo:
    1. Extrai e valida o token do header.
    2. Decodifica o token e obtém o payload ('sub' como ID do usuário).
    3. Converte 'sub' para UUID e busca o usuário no banco de dados.
    4. Levanta HTTPException 401 se a validação falhar.

    Args:
        db: Instância do banco de dados.
        token: Token JWT do header.

    Returns:
        O objeto UserInDB correspondente ao token.

    Raises:
        HTTPException: Status 401 se as credenciais não puderem ser validadas.
    """
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Não foi possível validar as credenciais",
        headers={"WWW-Authenticate": "Bearer"},
    )

    token_payload = decode_token(token)

    if token_payload is None or token_payload.sub is None:
        raise credentials_exception

    try:
        user_id = uuid.UUID(str(token_payload.sub))
    except ValueError:
        raise credentials_exception

    user = await user_crud.get_user_by_id(db=db, user_id=user_id)
    if user is None:
        raise credentials_exception

    return user

# ========================
# --- Dependência: Usuário Ativo Atual ---
# ========================
async def get_current_active_user(
    current_user: Annotated[UserInDB, Depends(get_current_user)]
) -> UserInDB:
    """
    Dependência que reutiliza `get_current_user` e garante que o usuário não está desativado.

    Args:
        current_user: Usuário retornado por `get_current_user`.

    Returns:
        O objeto UserInDB se o usuário estiver ativo.

    Raises:
        HTTPException: Status 400 se o usuário estiver desativado.
    """
    if current_user.disabled:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Usuário inativo")
    return current_user

# ========================
# --- Tipos Anotados para Rotas ---
# ========================
# Injeta um usuário ativo validado (UserInDB) nos endpoints.
CurrentUser = Annotated[UserInDB, Depends(get_current_active_user)]

================================================================================
Capítulo 3: app/core/email.py
================================================================================

# app/core/email.py
"""
Este módulo lida com o envio de e-mails, utilizando a biblioteca FastAPI-Mail.
Inclui a configuração da conexão SMTP e funções para enviar e-mails
de forma assíncrona, tanto com templates HTML quanto com texto puro.
"""

# ========================
# --- Importações ---
# ========================
import logging
from pathlib import Path
from typing import List, Optional, Dict, Any
from fastapi_mail import FastMail, MessageSchema, ConnectionConfig, MessageType
from pydantic import EmailStr

# --- Módulos da Aplicação ---
from app.core.config import settings

# ========================
# --- Configuração do Logger ---
# ========================
logger = logging.getLogger(__name__)

# ========================
# --- Configuração FastMail ---
# ========================
# Cria a configuração de conexão para o FastMail com base nas settings.
conf = ConnectionConfig(
    MAIL_USERNAME=settings.MAIL_USERNAME or "",
    MAIL_PASSWORD=settings.MAIL_PASSWORD or "",
    MAIL_FROM=settings.MAIL_FROM or "default@example.com",
    MAIL_PORT=settings.MAIL_PORT,
    MAIL_SERVER=settings.MAIL_SERVER or "",
    MAIL_FROM_NAME=settings.MAIL_FROM_NAME or "Default Sender",
    MAIL_STARTTLS=settings.MAIL_STARTTLS,
    MAIL_SSL_TLS=settings.MAIL_SSL_TLS,
    USE_CREDENTIALS=settings.USE_CREDENTIALS,
    VALIDATE_CERTS=settings.VALIDATE_CERTS,
    TEMPLATE_FOLDER=Path(settings.EMAIL_TEMPLATES_DIR) if settings.EMAIL_TEMPLATES_DIR else None,
)

# ========================
# --- Instância do FastMail ---
# ========================
fm = FastMail(conf)

# ========================
# --- Função Principal de Envio ---
# ========================
async def send_email_async(
    subject: str,
    recipient_to: List[EmailStr],
    body: Dict[str, Any],
    template_name: Optional[str] = None,
    plain_text_body: Optional[str] = None
):
    """
    Envia um e-mail de forma assíncrona.

    Verifica se o envio de e-mail está habilitado e se as credenciais
    necessárias estão configuradas antes de tentar o envio.

    Args:
        subject: Assunto do e-mail.
        recipient_to: Lista de e-mails dos destinatários.
        body: Dicionário com variáveis para o template HTML (se usado).
        template_name: Nome do arquivo do template HTML.
        plain_text_body: Conteúdo em texto puro (usado se template_name não for fornecido).
    """
    if not settings.MAIL_ENABLED:
        logger.warning("Envio de e-mail desabilitado nas configurações (MAIL_ENABLED=false).")
        return

    if not all([settings.MAIL_USERNAME, settings.MAIL_PASSWORD, settings.MAIL_FROM, settings.MAIL_SERVER]):
        logger.error("Configurações essenciais de e-mail ausentes. Não foi possível enviar.")
        return

    message = MessageSchema(
        subject=subject,
        recipients=recipient_to,
        template_body=body if template_name else None,
        body=plain_text_body if not template_name else None,
        subtype=MessageType.html if template_name else MessageType.plain,
    )

    try:
        logger.info(f"Tentando enviar e-mail para {recipient_to} com assunto '{subject}'...")
        await fm.send_message(message, template_name=template_name)
        logger.info(f"E-mail enviado com sucesso para {recipient_to}.")
    except Exception as e:
        logger.exception(f"Erro ao enviar e-mail para {recipient_to}: {e}")

# ========================
# --- Funções Utilitárias Específicas ---
# ========================
async def send_urgent_task_notification(
    user_email: EmailStr,
    user_name: str,
    task_title: str,
    task_id: str,
    task_due_date: Optional[str],
    priority_score: float
):
    """
    Prepara e envia uma notificação específica para tarefas urgentes.

    Args:
        user_email: Email do destinatário.
        user_name: Nome do destinatário.
        task_title: Título da tarefa urgente.
        task_id: ID da tarefa (para link).
        task_due_date: Data de vencimento formatada (ou None).
        priority_score: Pontuação de prioridade da tarefa.
    """
    subject = f"🚨 Tarefa Urgente no SmartTask: {task_title}"
    task_link = f"{settings.FRONTEND_URL}/tasks/{task_id}" if settings.FRONTEND_URL else None

    email_body_data = {
        "task_title": task_title,
        "user_name": user_name,
        "due_date": task_due_date or "N/A",
        "priority_score": f"{priority_score:.2f}",
        "task_link": task_link,
        "project_name": settings.PROJECT_NAME
    }
    template_name = "urgent_task.html"
    plain_text_body = (
        f"Olá {user_name},\n"
        f"A tarefa '{task_title}' no {settings.PROJECT_NAME} é considerada urgente.\n"
        f"Prioridade: {priority_score:.2f}, Vencimento: {task_due_date or 'N/A'}.\n"
    )
    if task_link:
        plain_text_body += f"Acesse a tarefa aqui: {task_link}"

    await send_email_async(
        subject=subject,
        recipient_to=[user_email],
        body=email_body_data,
        template_name=template_name,
        plain_text_body=plain_text_body
    )

================================================================================
Capítulo 4: app/core/logging_config.py
================================================================================

# app/core/logging_config.py
"""
Este módulo configura o sistema de logging da aplicação utilizando Loguru.
Inclui um InterceptHandler para redirecionar logs do sistema de logging
padrão do Python para o Loguru, garantindo um formato de log consistente.
"""

# ========================
# --- Importações ---
# ========================
import logging
import sys
from loguru import logger as loguru_logger

# ========================
# --- Handler de Intercepção ---
# ========================
class InterceptHandler(logging.Handler):
    """
    Handler do `logging` que redireciona mensagens para o Loguru.
    Permite que logs emitidos por bibliotecas que usam o `logging` padrão
    sejam formatados e gerenciados pelo Loguru.
    """
    def emit(self, record: logging.LogRecord) -> None:
        """
        Recebe um registro de log padrão e o envia para o Loguru,
        tentando manter o nível de log e informações de rastreamento.
        """
        try:
            level = loguru_logger.level(record.levelname).name
        except ValueError:
            level = record.levelno

        frame, depth = logging.currentframe(), 2
        while hasattr(frame, "f_code") and frame.f_code.co_filename == logging.__file__:
            frame = frame.f_back # pragma: no cover
            if frame is None: # pragma: no cover
                break # pragma: no cover
            depth += 1 # pragma: no cover

        loguru_logger.opt(depth=depth, exception=record.exc_info).log(level, record.getMessage())

# ========================
# --- Função de Setup ---
# ========================
def setup_logging(log_level: str = "INFO"):
    """
    Configura o sistema de logging global da aplicação.

    - Remove handlers padrão do Loguru para evitar duplicação.
    - Adiciona um novo handler Loguru para `sys.stderr` com formato e nível configuráveis.
    - Configura o `logging` padrão do Python para usar o `InterceptHandler`,
      canalizando todos os logs para o Loguru.
    - Desabilita ou ajusta propagação para loggers específicos (Uvicorn, httpx)
      para evitar logs excessivos ou duplicados.

    Args:
        log_level: Nível mínimo de log a ser exibido (ex: "INFO", "DEBUG").
    """
    log_level = log_level.upper()

    loguru_logger.remove() # Limpa handlers pré-existentes do Loguru

    # Adiciona o handler principal para stderr
    loguru_logger.add(
        sys.stderr,
        level=log_level,
        format="<green>{time:YYYY-MM-DD HH:mm:ss}</green> | <level>{level: <8}</level> | <cyan>{name}</cyan>:<cyan>{function}</cyan>:<cyan>{line}</cyan> - <level>{message}</level>",
        enqueue=True,    # Torna o logging assíncrono e seguro para threads/processos
        diagnose=False   # Desabilita diagnósticos detalhados de exceções por padrão
    )

    # Configura o logging padrão do Python para usar o InterceptHandler
    logging.basicConfig(handlers=[InterceptHandler()], level=0, force=True)

    # Ajustes específicos para loggers de bibliotecas comuns
    logging.getLogger("uvicorn.access").disabled = True # Desabilita logs de acesso do Uvicorn
    logging.getLogger("uvicorn.error").propagate = False # Evita duplicação de erros do Uvicorn

    # Desabilita logs de httpx, pois podem ser muito verbosos.
    # Se precisar depurar httpx, comente ou ajuste esta linha.
    loguru_logger.disable("httpx")

================================================================================
Capítulo 5: app/core/security.py
================================================================================

# app/core/security.py
"""
Módulo responsável pelas funcionalidades de segurança da aplicação,
incluindo hashing de senhas e gerenciamento de tokens JWT (JSON Web Token)
para autenticação e autorização.
"""

# ========================
# --- Importações ---
# ========================
import logging
from datetime import datetime, timedelta, timezone
from typing import Any, Union, Optional
from passlib.context import CryptContext
from jose import ExpiredSignatureError, jwt, JWTError
from pydantic import ValidationError

# --- Módulos da Aplicação ---
from app.core.config import settings
from app.models.token import TokenPayload

# ========================
# --- Configuração do Logger ---
# ========================
logger = logging.getLogger(__name__)

# ========================
# --- Configuração Hashing de Senha ---
# ========================
# Contexto Passlib para hashing e verificação de senhas usando bcrypt.
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

# ========================
# --- Constantes JWT ---
# ========================
ALGORITHM = settings.JWT_ALGORITHM
ACCESS_TOKEN_EXPIRE_MINUTES = settings.ACCESS_TOKEN_EXPIRE_MINUTES

# ========================
# --- Funções de Senha ---
# ========================
def verify_password(plain_password: str, hashed_password: str) -> bool:
    """
    Verifica se uma senha em texto plano corresponde a um hash armazenado.

    Args:
        plain_password: A senha fornecida pelo usuário (texto plano).
        hashed_password: O hash da senha armazenado.

    Returns:
        True se a senha corresponder ao hash, False caso contrário.
    """
    try:
        return pwd_context.verify(plain_password, hashed_password)
    except ValueError:
        # Ocorre se o formato do hash for inválido para o passlib
        logger.warning("Tentativa de verificar senha com hash em formato inválido.")
        return False

def get_password_hash(password: str) -> str:
    """
    Gera um hash seguro (bcrypt) para uma senha fornecida.

    Args:
        password: A senha em texto plano a ser hasheada.

    Returns:
        A string do hash bcrypt gerado.
    """
    return pwd_context.hash(password)

# ========================
# --- Funções JWT ---
# ========================
def create_access_token(
    subject: Union[str, Any],
    username: str,
    expires_delta: Optional[timedelta] = None
) -> str:
    """
    Cria um novo token de acesso JWT.

    Args:
        subject: Identificador único do usuário (normalmente ID).
        username: Nome de usuário.
        expires_delta: Duração opcional para a validade do token.
                       Se None, usa o padrão `ACCESS_TOKEN_EXPIRE_MINUTES`.

    Returns:
        O token JWT codificado como uma string.
    """
    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)

    subject_str = str(subject) # Garante que 'sub' seja string no payload

    to_encode = {
        "exp": expire,
        "sub": subject_str,
        "username": username
    }
    encoded_jwt = jwt.encode(to_encode, settings.JWT_SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

def decode_token(token: str) -> Optional[TokenPayload]:
    """
    Decodifica e valida um token JWT.

    Verifica assinatura, expiração e estrutura do payload (via Pydantic).
    A verificação de expiração padrão do `jwt.decode` é desabilitada
    para que a lógica de verificação dupla de expiração seja executada.

    Args:
        token: A string do token JWT.

    Returns:
        Objeto TokenPayload se o token for válido e não expirado, None caso contrário.
    """
    try:
        payload = jwt.decode(
            token,
            settings.JWT_SECRET_KEY,
            algorithms=[ALGORITHM],
            options={"verify_exp": False} # Desabilita verif. de expiração da lib JWT
        )
        # Valida o payload contra o modelo Pydantic TokenPayload
        token_data = TokenPayload.model_validate(payload)

        # Verificação dupla da expiração
        if token_data.exp is not None:
            token_expiration_time = datetime.fromtimestamp(token_data.exp, tz=timezone.utc)
            if datetime.now(timezone.utc) > token_expiration_time:
                logger.info("Token JWT expirado (verificação dupla).")
                return None
        else:
            # Se 'exp' é opcional no TokenPayload e está ausente
            pass # Tratar como válido neste ponto, se permitido pelo modelo.
                 # Se 'exp' for obrigatório no TokenPayload, model_validate já falharia.
        return token_data
    except ExpiredSignatureError:
        # Este bloco seria alcançado se options={"verify_exp": True} fosse usado
        # e a própria lib jose pegasse a expiração, ou outro erro inesperado da lib.
        logger.warning("Token JWT detectado como expirado pela biblioteca JOSE antes da verificação dupla.")
        return None
    except (JWTError, ValidationError, KeyError) as e:
        # Captura erros de assinatura/formato JWT, erros de validação Pydantic do payload,
        # ou ausência de chaves esperadas se a validação Pydantic não for suficiente.
        logger.error(f"Erro ao decodificar/validar token: {e}", exc_info=True)
        return None

================================================================================
Capítulo 6: app/core/utils.py
================================================================================

# app/core/utils.py
"""
Módulo contendo funções utilitárias diversas para a aplicação SmartTask.
Inclui cálculos de prioridade para tarefas, verificação de urgência de tarefas,
e envio de notificações via webhook.
"""

# ========================
# --- Importações ---
# ========================
import json
import hmac
import hashlib
import math # Embora math não seja usado explicitamente, é uma importação comum em utils.
import logging
from datetime import date, datetime, timezone
from typing import Any, Dict, Optional
# TYPE_CHECKING removido se não usado para imports condicionais de tipo.
import httpx

# --- Módulos da Aplicação ---
from app.models.task import Task # Importação direta do modelo Task
from app.core.config import settings

# ========================
# --- Configuração do Logger ---
# ========================
logger = logging.getLogger(__name__)

# ========================
# --- Função de Cálculo de Prioridade ---
# ========================
def calculate_priority_score(
    importance: int,
    due_date: Optional[date]
) -> Optional[float]:
    """
    Calcula a pontuação de prioridade de uma tarefa.

    A pontuação é baseada na importância fornecida e na data de vencimento,
    utilizando pesos configuráveis através das settings da aplicação.

    Args:
        importance: Nível de importância da tarefa (inteiro, 1-5).
        due_date: Data de vencimento da tarefa (objeto date ou None).

    Returns:
        A pontuação de prioridade calculada (float), ou None se a importância for inválida.
    """
    if not 1 <= importance <= 5:
        logger.warning(f"Cálculo de prioridade recebido com importância inválida: {importance}")
        return None

    # --- Score de Importância ---
    importance_score = importance * settings.PRIORITY_WEIGHT_IMPORTANCE

    # --- Score de Prazo ---
    due_date_score = 0.0
    if due_date:
        today = date.today()
        days_remaining = (due_date - today).days

        if days_remaining < 0:
            due_date_score = settings.PRIORITY_SCORE_IF_OVERDUE
            logger.debug(f"Tarefa atrasada ({days_remaining} dias), score de overdue: {due_date_score}")
        elif days_remaining == 0:
            due_date_score = settings.PRIORITY_WEIGHT_DUE_DATE / 1.0
            logger.debug(f"Tarefa vence hoje, score de prazo: {due_date_score}")
        elif days_remaining > 0:
            effective_days = max(1, days_remaining) # Evita divisão por zero ou por dias < 1
            due_date_score = settings.PRIORITY_WEIGHT_DUE_DATE / effective_days
            logger.debug(f"Tarefa vence em {days_remaining} dias, score de prazo: {due_date_score}")

    elif settings.PRIORITY_DEFAULT_SCORE_NO_DUE_DATE is not None:
        due_date_score = settings.PRIORITY_DEFAULT_SCORE_NO_DUE_DATE
        logger.debug(f"Tarefa sem prazo, score default de prazo: {due_date_score}")

    # --- Combinar Scores ---
    total_score = round(due_date_score + importance_score, 2)
    logger.debug(f"Score final calculado: {total_score} (prazo={due_date_score}, importancia={importance_score})")
    return total_score

# ========================
# --- Função de Tarefa Urgente ---
# ========================
def is_task_urgent(task: Task) -> bool:
    """
    Verifica se uma tarefa é considerada urgente para fins de notificação.

    Args:
        task: O objeto Task a ser verificado.

    Returns:
        True se a tarefa for considerada urgente, False caso contrário.
    """
    if task.priority_score is None and task.due_date is None:
        return False # Tarefa sem score nem prazo não pode ser urgente pelos critérios atuais

    if task.priority_score is not None and task.priority_score > settings.EMAIL_URGENCY_THRESHOLD:
        return True

    if task.due_date:
        today = date.today()
        if (task.due_date - today).days <= 0: # Vence hoje ou está atrasada
            return True
    return False

# ========================
# --- Função de Envio de Webhook ---
# ========================
async def send_webhook_notification(
    event_type: str,
    task_data: Dict[str, Any]
):
    """
    Envia uma notificação via webhook para a URL configurada.

    Inclui assinatura HMAC-SHA256 se WEBHOOK_SECRET estiver definido.

    Args:
        event_type: String identificando o tipo do evento (ex: 'task.created').
        task_data: Dicionário com os dados da tarefa.
    """
    if not settings.WEBHOOK_URL:
        logger.debug("Webhook URL não configurada, pulando envio.")
        return

    webhook_url_str = str(settings.WEBHOOK_URL)
    payload = {
        "event": event_type,
        "task": task_data,
        "timestamp": datetime.now(timezone.utc).isoformat()
    }
    headers = {
        "Content-Type": "application/json",
        "User-Agent": "SmartTask-Webhook-Client/1.0"
    }

    # --- Segurança: Assinatura ---
    if settings.WEBHOOK_SECRET:
        try:
            payload_bytes = json.dumps(payload, separators=(',', ':'), sort_keys=True).encode('utf-8')
            secret_bytes = settings.WEBHOOK_SECRET.encode('utf-8')
            signature = hmac.new(secret_bytes, payload_bytes, hashlib.sha256).hexdigest()
            headers["X-SmartTask-Signature"] = f"sha256={signature}"
        except Exception as e:
            logger.error(f"Erro ao gerar assinatura HMAC para webhook: {e}", exc_info=True)
            return # Não envia se a assinatura falhar

    # --- Envio da Requisição HTTP ---
    try:
        async with httpx.AsyncClient() as client:
            logger.info(f"Enviando webhook evento '{event_type}' para {webhook_url_str}")
            response = await client.post(
                webhook_url_str,
                json=payload,
                headers=headers,
                timeout=10.0
            )
            response.raise_for_status() # Levanta exceção para status de erro HTTP (4xx, 5xx)
            logger.info(f"Webhook enviado com sucesso para {webhook_url_str}. Status: {response.status_code}")

    except httpx.TimeoutException:
        logger.error(f"Timeout ao enviar webhook para {webhook_url_str}") # pragma: no cover
    except httpx.RequestError as exc:
        logger.error(f"Erro na requisição ao enviar webhook para {webhook_url_str}: {exc}")
    except httpx.HTTPStatusError as exc:
        logger.error(
            f"Erro no servidor do webhook ({webhook_url_str}). "
            f"Status: {exc.response.status_code}. Resposta: {exc.response.text[:200]}..."
        )
    except Exception as e:
        logger.exception(f"Erro inesperado ao enviar webhook para {webhook_url_str}: {e}")

================================================================================
Capítulo 7: app/db/mongodb_utils.py
================================================================================

# app/db/mongodb_utils.py
"""
Este módulo gerencia a conexão com o banco de dados MongoDB.
Inclui funções para conectar, fechar a conexão e obter a instância do banco de dados.
Utiliza a biblioteca Motor para interações assíncronas com o MongoDB.
"""

# ========================
# --- Importações ---
# ========================
import logging
from typing import Optional
import motor.motor_asyncio
from motor.motor_asyncio import AsyncIOMotorClient, AsyncIOMotorDatabase 

# --- Módulos da Aplicação ---
from app.core.config import settings

# ========================
# --- Configuração do Logger ---
# ========================
logger = logging.getLogger(__name__)

# ========================
# --- Variáveis Globais de Conexão ---
# ========================
# Estas variáveis mantêm o estado da conexão MongoDB para a aplicação.
db_client: Optional[AsyncIOMotorClient] = None
db_instance: Optional[AsyncIOMotorDatabase] = None

# ========================
# --- Função de Conexão ---
# ========================
async def connect_to_mongo() -> Optional[AsyncIOMotorDatabase]:
    """
    Estabelece a conexão com o MongoDB.

    Cria um cliente AsyncIOMotorClient, verifica a conexão com um comando 'ping',
    e define as variáveis globais `db_client` e `db_instance`.

    Returns:
        A instância AsyncIOMotorDatabase se a conexão for bem-sucedida, None caso contrário.
    """
    global db_client, db_instance
    logger.info("Tentando conectar ao MongoDB...")
    try:
        db_client = motor.motor_asyncio.AsyncIOMotorClient(
            settings.MONGODB_URL,
            serverSelectionTimeoutMS=5000 # Timeout para seleção do servidor
        )
        # Verifica a conexão
        await db_client.admin.command('ping')
        logger.info("Comando ping para MongoDB bem-sucedido.")

        db_instance = db_client[settings.DATABASE_NAME]
        logger.info(f"Conectado com sucesso ao banco de dados: {settings.DATABASE_NAME}")
        return db_instance

    except Exception as e:
        logger.error(f"Não foi possível conectar ao MongoDB: {e}", exc_info=True)
        db_client = None
        db_instance = None
        return None

# ========================
# --- Função de Fechamento de Conexão ---
# ========================
async def close_mongo_connection():
    """
    Fecha a conexão com o MongoDB.
    Verifica se o cliente `db_client` foi inicializado antes de tentar fechar.
    """
    global db_client # Indica que estamos referenciando a variável global
    logger.info("Tentando fechar conexão com MongoDB...")
    if db_client:
        db_client.close()
        logger.info("Conexão com MongoDB fechada.")
        # Opcionalmente, resetar db_client e db_instance para None após fechar:
        # db_client = None
        # db_instance = None
    else:
        logger.warning("Tentativa de fechar conexão com MongoDB, mas cliente não estava inicializado.")

# ========================
# --- Função de Acesso ao DB ---
# ========================
def get_database() -> AsyncIOMotorDatabase:
    """
    Retorna a instância global do banco de dados MongoDB.

    Usada como dependência FastAPI ou chamada por outras partes da aplicação.

    Raises:
        RuntimeError: Se chamada antes de `connect_to_mongo` inicializar `db_instance`.

    Returns:
        A instância AsyncIOMotorDatabase.
    """
    if db_instance is None:
        # Este log de erro é importante para diagnóstico
        logger.error("Tentativa de obter instância do DB antes da inicialização!")
        raise RuntimeError("A conexão com o banco de dados não foi inicializada.")
    return db_instance

================================================================================
Capítulo 8: app/db/task_crud.py
================================================================================

# app/db/task_crud.py
"""
Módulo contendo as funções CRUD (Create, Read, Update, Delete)
para interagir com a coleção de tarefas no MongoDB.
Inclui também funções auxiliares e para criação de índices.
"""

# ========================
# --- Importações ---
# ========================
import logging
import uuid
from datetime import date, datetime, timezone
from typing import List, Optional, Dict, Any, Tuple
from motor.motor_asyncio import AsyncIOMotorDatabase, AsyncIOMotorCollection
from pymongo import ASCENDING, DESCENDING
from pydantic import ValidationError

# --- Módulos da Aplicação ---
from app.models.task import Task, TaskCreate, TaskUpdate, TaskStatus

# =====================================
# --- Configurações e Constantes ---
# =====================================

logger = logging.getLogger(__name__)

TASKS_COLLECTION = "tasks"

# =========================================
# --- Funções Auxiliares (Internas) ---
# =========================================

def _get_tasks_collection(db: AsyncIOMotorDatabase) -> AsyncIOMotorCollection:
    """Retorna a coleção de tarefas do banco de dados."""
    return db[TASKS_COLLECTION]

def _parse_sort_params(sort_by: Optional[str], sort_order: str) -> Optional[List[Tuple[str, int]]]:
    """
    Converte os parâmetros de ordenação de string para o formato do PyMongo.

    Args:
        sort_by: Campo pelo qual ordenar.
        sort_order: Ordem da ordenação ("asc" ou "desc").

    Returns:
        Lista de tuplas para ordenação do PyMongo ou None se o campo não for válido.
    """
    if sort_order.lower() == "asc":
        mongo_order = ASCENDING
    else:
        mongo_order = DESCENDING

    if sort_by in ["priority_score", "due_date", "created_at", "importance"]:
        return [(sort_by, mongo_order)]
    return None

# =======================================
# --- Operações CRUD para Tarefas ---
# =======================================

async def create_task(db: AsyncIOMotorDatabase, task_db: Task) -> Optional[Task]:
    """
    Cria uma nova tarefa no banco de dados.

    A tarefa já deve chegar validada e com campos como ID e owner_id preenchidos.

    Args:
        db: Instância da conexão com o banco de dados.
        task_db: Objeto Task contendo os dados da tarefa a ser criada.

    Returns:
        O objeto Task criado se sucesso, None caso contrário.
    """
    collection = _get_tasks_collection(db)
    task_db_dict = task_db.model_dump(mode="json")
    try:
        insert_result = await collection.insert_one(task_db_dict)
        if insert_result.acknowledged:
            return task_db
        else:
            logger.warning(f"Criação da tarefa para owner {task_db.owner_id} não foi reconhecida pelo DB (acknowledged=False).")
            return None
    except Exception as e:
        logger.exception(f"DB Error creating task for owner {task_db.owner_id}: {e}")
        return None

async def get_task_by_id(db: AsyncIOMotorDatabase, task_id: uuid.UUID, owner_id: uuid.UUID) -> Optional[Task]:
    """
    Busca uma tarefa específica pelo seu ID e pelo ID do proprietário.

    Args:
        db: Instância da conexão com o banco de dados.
        task_id: ID da tarefa a ser buscada.
        owner_id: ID do proprietário da tarefa.

    Returns:
        O objeto Task encontrado ou None se a tarefa não existir ou erro de validação.
    """
    collection = _get_tasks_collection(db)
    task_dict = await collection.find_one({"id": str(task_id), "owner_id": str(owner_id)})
    if task_dict:
        task_dict.pop('_id', None)
        try:
            return Task.model_validate(task_dict)
        except (ValidationError, Exception) as e:
            logger.error(f"DB Validation error get_task_by_id {task_id} for owner {owner_id}: {e}")
            return None
    return None

async def get_tasks_by_owner(
    db: AsyncIOMotorDatabase,
    owner_id: uuid.UUID,
    *,
    status_filter: Optional[TaskStatus] = None,
    due_before: Optional[date] = None,
    project_filter: Optional[str] = None,
    tags_filter: Optional[List[str]] = None,
    sort_by: Optional[str] = None,
    sort_order: str = "desc",
    limit: int = 100,
    skip: int = 0
) -> List[Task]:
    """
    Busca tarefas de um proprietário com filtros, ordenação e paginação.

    Args:
        db: Instância da conexão com o banco de dados.
        owner_id: ID do proprietário das tarefas.
        status_filter: Filtra tarefas pelo status.
        due_before: Filtra tarefas com data de entrega anterior ou igual à data fornecida.
        project_filter: Filtra tarefas por nome do projeto.
        tags_filter: Filtra tarefas que contenham todas as tags listadas.
        sort_by: Campo para ordenação.
        sort_order: Ordem da ordenação ("asc" ou "desc").
        limit: Número máximo de tarefas a retornar.
        skip: Número de tarefas a pular (para paginação).

    Returns:
        Uma lista de objetos Task. Retorna lista vazia em caso de erro ou nenhuma tarefa encontrada.
    """
    collection = _get_tasks_collection(db)
    query: Dict[str, Any] = {"owner_id": str(owner_id)}

    if status_filter:
        query["status"] = status_filter.value
    if due_before:
        due_before_dt = datetime.combine(due_before, datetime.min.time(), tzinfo=timezone.utc)
        query["due_date"] = {"$lte": due_before_dt}
    if project_filter:
        query["project"] = project_filter
    if tags_filter:
        query["tags"] = {"$all": tags_filter}

    sort_list = _parse_sort_params(sort_by, sort_order)

    validated_tasks = []
    try:
        tasks_cursor = collection.find(query).skip(skip).limit(limit)
        if sort_list:
            tasks_cursor = tasks_cursor.sort(sort_list)

        async for task_dict in tasks_cursor:
            task_dict.pop('_id', None)
            try:
                validated_tasks.append(Task.model_validate(task_dict))
            except (ValidationError, Exception) as e:
                logger.error(f"DB Validation error list_tasks owner {owner_id} task {task_dict.get('id', 'N/A')}: {e}")
                continue
        return validated_tasks
    except Exception as e:
        logger.exception(f"DB Error listing tasks for owner {owner_id}: {e}")
        return []


async def update_task(
    db: AsyncIOMotorDatabase,
    task_id: uuid.UUID,
    owner_id: uuid.UUID,
    update_data: Dict[str, Any]
) -> Optional[Task]:
    """
    Atualiza uma tarefa existente de um proprietário específico.

    Os dados de atualização devem ser fornecidos em um dicionário pronto para o
    operador '$set' do MongoDB. O campo 'updated_at' é automaticamente atualizado.

    Args:
        db: Instância da conexão com o banco de dados.
        task_id: ID da tarefa a ser atualizada.
        owner_id: ID do proprietário da tarefa.
        update_data: Dicionário com os campos a serem atualizados.

    Returns:
        O objeto Task atualizado ou None se a tarefa não for encontrada ou ocorrer um erro.
    """
    collection = _get_tasks_collection(db)
    update_data["updated_at"] = datetime.now(timezone.utc)

    try:
        updated_task_dict_raw = await collection.find_one_and_update(
            {"id": str(task_id), "owner_id": str(owner_id)},
            {"$set": update_data},
            return_document=True
        )

        if updated_task_dict_raw:
            updated_task_dict_raw.pop('_id', None)
            try:
                return Task.model_validate(updated_task_dict_raw)
            except (ValidationError, Exception) as e:
                logger.error(f"DB Validation error update_task {task_id} owner {owner_id}: {e}")
                return None
        else:
            logger.warning(f"Tentativa de atualizar tarefa não encontrada: ID {task_id}, Owner ID {owner_id}")
            return None
    except Exception as e:
        logger.exception(f"DB Error updating task {task_id} owner {owner_id}: {e}")
        return None


async def delete_task(db: AsyncIOMotorDatabase, task_id: uuid.UUID, owner_id: uuid.UUID) -> bool:
    """
    Deleta uma tarefa específica pelo seu ID e pelo ID do proprietário.

    Args:
        db: Instância da conexão com o banco de dados.
        task_id: ID da tarefa a ser deletada.
        owner_id: ID do proprietário da tarefa.

    Returns:
        True se a tarefa foi deletada com sucesso (1 documento afetado), False caso contrário.
    """
    collection = _get_tasks_collection(db)
    try:
        delete_result = await collection.delete_one({"id": str(task_id), "owner_id": str(owner_id)})
        return delete_result.deleted_count == 1
    except Exception as e:
        logger.exception(f"DB Error deleting task {task_id} owner {owner_id}: {e}")
        return False

# ===================================================
# --- Criação de Índices do Banco de Dados ---
# ===================================================

async def create_task_indexes(db: AsyncIOMotorDatabase):
    """
    Cria os índices necessários na coleção de tarefas para otimizar consultas.

    Os índices são criados apenas se ainda não existirem.
    Esta função é tipicamente chamada durante a inicialização da aplicação.

    Args:
        db: Instância da conexão com o banco de dados.
    """
    collection = _get_tasks_collection(db)
    try:
        await collection.create_index("id", unique=True, name="task_id_unique_idx")
        await collection.create_index("owner_id", name="task_owner_idx")
        await collection.create_index(
            [("owner_id", ASCENDING), ("due_date", DESCENDING)],
            name="task_owner_due_date_idx"
        )
        await collection.create_index(
            [("owner_id", ASCENDING), ("priority_score", DESCENDING)],
            name="task_owner_priority_idx"
        )
        await collection.create_index("tags", name="task_tags_idx")
        logging.info("Índices da coleção 'tasks' verificados/criados.")
    except Exception as e:
        logging.error(f"Erro ao criar índices da coleção 'tasks': {e}", exc_info=True)

================================================================================
Capítulo 9: app/db/user_crud.py
================================================================================

# app/db/user_crud.py
"""
Módulo contendo as funções CRUD (Create, Read, Update, Delete)
para interagir com a coleção de usuários no MongoDB.
Inclui também funções para criação de índices.
"""

# ========================
# --- Importações ---
# ========================
import logging
import uuid
from datetime import datetime, timezone
from typing import Optional
from motor.motor_asyncio import AsyncIOMotorDatabase, AsyncIOMotorCollection
from pydantic import ValidationError
from pymongo.errors import DuplicateKeyError

# --- Módulos da Aplicação ---
from app.models.user import UserCreate, UserInDB, UserUpdate
from app.core.security import get_password_hash

# ========================
# --- Configurações e Constantes ---
# ========================
logger = logging.getLogger(__name__)
USERS_COLLECTION = "users"

# ========================
# --- Funções Auxiliares (Internas) ---
# ========================
def _get_users_collection(db: AsyncIOMotorDatabase) -> AsyncIOMotorCollection:
    """Retorna a coleção de usuários do banco de dados."""
    return db[USERS_COLLECTION]

# ========================
# --- Operações CRUD para Usuários ---
# ========================
async def get_user_by_id(db: AsyncIOMotorDatabase, user_id: uuid.UUID) -> Optional[UserInDB]:
    """
    Busca um usuário pelo seu ID (UUID).

    Args:
        db: Instância da conexão com o banco de dados.
        user_id: O ID do usuário a ser buscado.

    Returns:
        Um objeto UserInDB se o usuário for encontrado e válido, None caso contrário.
    """
    collection = _get_users_collection(db)
    user_dict = await collection.find_one({"id": str(user_id)})
    if user_dict:
        user_dict.pop('_id', None)
        try:
            return UserInDB.model_validate(user_dict)
        except Exception as e:
            logger.error(f"DB Validation error get_user_by_id {user_id}: {e}")
            return None
    return None

async def get_user_by_username(db: AsyncIOMotorDatabase, username: str) -> Optional[UserInDB]:
    """
    Busca um usuário pelo seu nome de usuário.

    Args:
        db: Instância da conexão com o banco de dados.
        username: O nome de usuário a ser buscado.

    Returns:
        Um objeto UserInDB se o usuário for encontrado e válido, None caso contrário.
    """
    collection = _get_users_collection(db)
    user_dict = await collection.find_one({"username": username})
    if user_dict:
        user_dict.pop('_id', None)
        try:
            return UserInDB.model_validate(user_dict)
        except Exception as e:
            logger.error(f"DB Validation error get_user_by_username {username}: {e}")
            return None
    return None

async def get_user_by_email(db: AsyncIOMotorDatabase, email: str) -> Optional[UserInDB]:
    """
    Busca um usuário pelo seu endereço de e-mail.

    Args:
        db: Instância da conexão com o banco de dados.
        email: O endereço de e-mail a ser buscado.

    Returns:
        Um objeto UserInDB se o usuário for encontrado e válido, None caso contrário.
    """
    collection = _get_users_collection(db)
    user_dict = await collection.find_one({"email": email})
    if user_dict:
        user_dict.pop('_id', None)
        try:
            return UserInDB.model_validate(user_dict)
        except Exception as e:
            logger.error(f"DB Validation error get_user_by_email {email}: {e}")
            return None
    return None

async def create_user(db: AsyncIOMotorDatabase, user_in: UserCreate) -> Optional[UserInDB]:
    """
    Cria um novo usuário no banco de dados.

    Gera um UUID para o usuário, hasheia a senha e define campos padrão
    como 'disabled', 'created_at' e 'updated_at'.

    Args:
        db: Instância da conexão com o banco de dados.
        user_in: Objeto UserCreate com os dados do usuário a ser criado.

    Returns:
        Um objeto UserInDB representando o usuário criado se sucesso, None em caso de erro.
        Pode levantar DuplicateKeyError se username ou email já existirem e houver
        índices de unicidade configurados.
    """
    hashed_password = get_password_hash(user_in.password)
    user_db_data = {
        "id": uuid.uuid4(),
        "username": user_in.username,
        "email": user_in.email,
        "hashed_password": hashed_password,
        "full_name": user_in.full_name,
        "disabled": False,
        "created_at": datetime.now(timezone.utc),
        "updated_at": None
    }

    try:
        user_db_obj = UserInDB.model_validate(user_db_data)
    except Exception as validation_error:
        logger.error(f"Erro de validação Pydantic ao preparar dados para user_db_obj (username: {user_in.username}): {validation_error}", exc_info=True)
        return None

    user_db_dict = user_db_obj.model_dump(mode="json")
    collection = _get_users_collection(db)

    try:
        insert_result = await collection.insert_one(user_db_dict)
        if not insert_result.acknowledged: # pragma: no cover
            logger.error(f"DB Insert User Acknowledged False for username {user_in.username}")
            return None
        return user_db_obj
    except DuplicateKeyError:
        logger.warning(f"Tentativa de criar usuário com username ou email duplicado: {user_in.username} / {user_in.email}")
        raise
    except Exception as e:
        logger.exception(f"Erro inesperado ao inserir usuário {user_in.username} no DB: {e}")
        return None

async def update_user(db: AsyncIOMotorDatabase, user_id: uuid.UUID, user_update: UserUpdate) -> Optional[UserInDB]:
    """
    Atualiza os dados de um usuário existente.

    Apenas os campos fornecidos no objeto `user_update` serão alterados.
    O campo `updated_at` é automaticamente atualizado. Se a senha for
    alterada, ela será hasheada.

    Args:
        db: Instância da conexão com o banco de dados.
        user_id: O ID do usuário a ser atualizado.
        user_update: Objeto UserUpdate contendo os dados a serem atualizados.

    Returns:
        O objeto UserInDB atualizado se sucesso, None se o usuário não for encontrado ou erro.
        Pode levantar DuplicateKeyError se a atualização tentar definir um username/email
        que já exista e pertença a outro usuário.
    """
    collection = _get_users_collection(db)
    update_data = user_update.model_dump(exclude_unset=True)

    if "password" in update_data:
        if update_data["password"] is not None:
            update_data["hashed_password"] = get_password_hash(update_data.pop("password"))
        elif "password" in update_data and update_data["password"] is None: # Este elif é redundante com a condição externa.
            update_data.pop("password") # Evita 'password: null' se for passado explicitamente como None

    if not update_data and "hashed_password" not in update_data :
        existing_user = await get_user_by_id(db, user_id)
        if existing_user:
            try:
                updated_doc = await collection.find_one_and_update(
                    {"id": str(user_id)},
                    {"$set": {"updated_at": datetime.now(timezone.utc)}},
                    return_document=True
                )
                if updated_doc:
                    updated_doc.pop('_id', None)
                    return UserInDB.model_validate(updated_doc)
                return None
            except Exception as e:
                logger.exception(f"DB Error updating user (only updated_at) {user_id}: {e}")
                return None
        return existing_user # Retorna o usuário existente se nada mais for atualizado

    update_data["updated_at"] = datetime.now(timezone.utc)

    try:
        updated_user_doc = await collection.find_one_and_update(
            {"id": str(user_id)},
            {"$set": update_data},
            return_document=True
        )

        if updated_user_doc:
            updated_user_doc.pop('_id', None)
            try:
                return UserInDB.model_validate(updated_user_doc)
            except ValidationError as e:
                logger.error(f"DB Validation error after updating user {user_id}: {e}")
                return None
        else:
            logger.warning(f"Attempt to update user not found: ID {user_id}")
            return None
    except DuplicateKeyError:
        logger.warning(f"DB Error: Attempt to update user {user_id} resulted in duplicate key for data: { {k: v for k, v in update_data.items() if k not in ['hashed_password', 'updated_at']} }")
        raise
    except Exception as e:
        logger.exception(f"DB Error updating user {user_id}: {e}")
        return None

async def delete_user(db: AsyncIOMotorDatabase, user_id: uuid.UUID) -> bool:
    """
    Deleta um usuário do banco de dados pelo seu ID.

    Args:
        db: Instância da conexão com o banco de dados.
        user_id: O ID do usuário a ser deletado.

    Returns:
        True se o usuário foi deletado com sucesso (1 documento afetado), False caso contrário.
    """
    collection = _get_users_collection(db)
    try:
        delete_result = await collection.delete_one({"id": str(user_id)})
        if delete_result.deleted_count == 1:
            logger.info(f"User {user_id} deleted successfully.")
            return True
        else:
            logger.warning(f"Attempt to delete user {user_id}, but user was not found or not deleted (deleted_count: {delete_result.deleted_count}).")
            return False
    except Exception as e:
        logger.exception(f"DB Error deleting user {user_id}: {e}")
        return False

# ========================
# --- Configuração de Índices do Banco de Dados ---
# ========================
async def create_user_indexes(db: AsyncIOMotorDatabase):
    """
    Cria os índices necessários na coleção de usuários para otimizar consultas
    e garantir unicidade de campos como username e email.

    Os índices são criados apenas se ainda não existirem.
    Esta função é tipicamente chamada durante a inicialização da aplicação.

    Args:
        db: Instância da conexão com o banco de dados.
    """
    collection = _get_users_collection(db)
    try:
        await collection.create_index("username", unique=True, name="username_unique_idx")
        await collection.create_index("email", unique=True, name="email_unique_idx")
        logger.info("Índices da coleção 'users' ('username', 'email') verificados/criados com sucesso.")
    except Exception as e:
        logger.error(f"Erro ao criar índices para a coleção 'users': {e}", exc_info=True)

================================================================================
Capítulo 10: app/main.py
================================================================================

# app/main.py
"""
Ponto de entrada principal e configuração da aplicação FastAPI SmartTask.
Define a instância da aplicação, middlewares, rotas, ciclo de vida (lifespan)
e o endpoint raiz. Também inclui o setup de logging inicial.
"""

# ========================
# --- Importações ---
# ========================
import logging
import sys
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from contextlib import asynccontextmanager

# --- Módulos da Aplicação ---
from app.routers import tasks
from app.routers import auth
from app.db.mongodb_utils import connect_to_mongo, close_mongo_connection
from app.db.user_crud import create_user_indexes
from app.db.task_crud import create_task_indexes
from app.core.config import Settings, settings # settings importado, Settings para type hint
from app.core.logging_config import setup_logging # InterceptHandler não precisa ser importado aqui

# ========================
# --- Configuração de Logging ---
# ========================
setup_logging(log_level=settings.LOG_LEVEL)
logger = logging.getLogger(__name__)

# ========================
# --- Função de Setup do Middleware CORS ---
# ========================
def _setup_cors_middleware(app_instance: FastAPI, current_settings: Settings):
    """Configura o middleware CORS para a aplicação."""
    if current_settings.CORS_ALLOWED_ORIGINS:
        logger.info(f"Configurando CORS para origens: {current_settings.CORS_ALLOWED_ORIGINS}")
        app_instance.add_middleware(
            CORSMiddleware,
            allow_origins=current_settings.CORS_ALLOWED_ORIGINS,
            allow_credentials=True,
            allow_methods=["*"],
            allow_headers=["*"],
        )
    else:
        logger.warning(
            "Nenhuma origem CORS configurada (settings.CORS_ALLOWED_ORIGINS está vazia). "
            "API pode não ser acessível de frontends em outros domínios."
        )

# ========================
# --- Ciclo de Vida (Lifespan) ---
# ========================
@asynccontextmanager
async def lifespan(app: FastAPI):
    """
    Gerencia o ciclo de vida da aplicação.

    Conecta ao MongoDB e cria índices no startup.
    Fecha a conexão com o MongoDB no shutdown.
    """
    logger.info("Iniciando ciclo de vida da aplicação...")
    db_connection = await connect_to_mongo()

    if db_connection is None:
        logger.critical("Falha fatal ao conectar ao MongoDB na inicialização. App pode não funcionar corretamente.")
        yield
        logger.info("Encerrando ciclo de vida (conexão DB falhou no início).")
        return

    app.state.db = db_connection # Armazena a conexão no estado da app
    logger.info("Conectado ao MongoDB.")

    try:
        db_instance = app.state.db
        logger.info("Tentando criar/verificar índices...")
        await create_user_indexes(db_instance)
        await create_task_indexes(db_instance)
        logger.info("Criação/verificação de índices concluída.")
    except Exception as e:
        logger.error(f"Erro durante a criação de índices: {e}", exc_info=True)

    logger.info("Aplicação iniciada e pronta.") # pragma: no cover
    yield # pragma: no cover

    # Código abaixo é executado no shutdown da aplicação
    logger.info("Iniciando processo de encerramento...")
    await close_mongo_connection()
    logger.info("Conexão com MongoDB fechada.")
    logger.info("Aplicação encerrada.")

# ========================
# --- Instância FastAPI ---
# ========================
app = FastAPI(
    title=settings.PROJECT_NAME,
    description="API RESTful para gerenciamento de tarefas com prioridade inteligente.",
    version="0.1.0",
    contact={
        "name": "Eng. Soft. Cláudio",
        "url": "https://www.linkedin.com/in/claudiodelimatosta/",
        "email": "claudiodelimatosta@gmail.com",
    },
    license_info={
        "name": "MIT License",
        "url": "https://opensource.org/licenses/MIT",
    },
    lifespan=lifespan
)

# ========================
# --- Configuração de Middlewares ---
# ========================
_setup_cors_middleware(app, settings)

# ========================
# --- Rotas (Routers) ---
# ========================
app.include_router(auth.router, prefix=settings.API_V1_STR + "/auth", tags=["Authentication"])
app.include_router(tasks.router, prefix=settings.API_V1_STR, tags=["Tasks"])

# ========================
# --- Endpoint Raiz ---
# ========================
@app.get("/", tags=["Root"])
async def read_root():
    """Endpoint raiz para verificar se a API está online."""
    return {"message": f"Bem-vindo à {settings.PROJECT_NAME}!"}

# ========================
# --- Execução (Uvicorn) ---
# ========================
if __name__ == "__main__": # pragma: no cover
    import uvicorn # pragma: no cover
    logger.info("Iniciando servidor Uvicorn para desenvolvimento...") # pragma: no cover
    uvicorn.run( # pragma: no cover
        "main:app", # pragma: no cover
        host="0.0.0.0", # pragma: no cover
        port=8000, # pragma: no cover
        reload=True, # pragma: no cover
        log_level=settings.LOG_LEVEL.lower() # pragma: no cover
    )

================================================================================
Capítulo 11: app/models/task.py
================================================================================

# app/models/task.py
"""
Este módulo define os modelos Pydantic utilizados para representar Tarefas (Tasks)
na aplicação. Inclui modelos para a criação, atualização, e representação
de tarefas como armazenadas e retornadas pelo banco de dados, além de
definições auxiliares como o status da tarefa.
"""

# ========================
# --- Importações ---
# ========================
import uuid
from datetime import date, datetime, timezone
from enum import Enum
from typing import List, Optional

from pydantic import BaseModel, Field, ConfigDict

# ========================
# --- Enumerações de Status ---
# ========================
class TaskStatus(str, Enum):
    """Define os possíveis status de uma tarefa."""
    PENDING = "pendente"        # Tarefa aguardando para ser iniciada.
    IN_PROGRESS = "em_progresso" # Tarefa atualmente em execução.
    COMPLETED = "concluída"     # Tarefa finalizada com sucesso.
    CANCELLED = "cancelada"     # Tarefa cancelada.

# ========================
# --- Modelos Pydantic de Tarefa ---
# ========================

# --- Modelo Base ---
class TaskBase(BaseModel):
    """
    Modelo base contendo os campos comuns e essenciais de uma tarefa.
    Serve como fundação para outros modelos de tarefa mais específicos.
    """
    title: str = Field(..., title="Título da Tarefa", min_length=3, max_length=100)
    description: Optional[str] = Field(None, title="Descrição Detalhada", max_length=500)
    importance: int = Field(..., ge=1, le=5, title="Importância (1-5)")
    due_date: Optional[date] = Field(None, title="Data de Vencimento")
    status: TaskStatus = Field(default=TaskStatus.PENDING, title="Status da Tarefa")
    tags: Optional[List[str]] = Field(None, title="Etiquetas/Tags")
    project: Optional[str] = Field(None, title="Projeto Associado")

    model_config = {
        "json_schema_extra": {
            "examples": [
                {
                    "title": "Finalizar relatório mensal",
                    "description": "Compilar dados e escrever o relatório final.",
                    "importance": 4,
                    "due_date": "2024-08-15",
                    "status": "pendente",
                    "tags": ["relatorios", "financeiro"],
                    "project": "Relatórios Q3"
                }
            ]
        }
    }

# --- Modelos para Operações ---
class TaskCreate(TaskBase):
    """
    Modelo utilizado para a criação de uma nova tarefa.
    Herda todos os campos de `TaskBase`.
    """
    pass

class TaskUpdate(BaseModel):
    """
    Modelo utilizado para atualizar uma tarefa existente.
    Todos os campos são opcionais, permitindo atualizações parciais.
    """
    title: Optional[str] = Field(None, title="Título da Tarefa", min_length=3, max_length=100)
    description: Optional[str] = Field(None, title="Descrição Detalhada", max_length=500)
    importance: Optional[int] = Field(None, ge=1, le=5, title="Importância (1-5)")
    due_date: Optional[date] = Field(None, title="Data de Vencimento")
    status: Optional[TaskStatus] = Field(None, title="Status da Tarefa")
    tags: Optional[List[str]] = Field(None, title="Etiquetas/Tags")
    project: Optional[str] = Field(None, title="Projeto Associado")
    priority_score: Optional[float] = Field(None, title="Pontuação de Prioridade (Ajustável)")

    model_config = {
         "json_schema_extra": {
            "examples": [
                {
                    "title": "Revisar relatório mensal v2",
                    "status": TaskStatus.IN_PROGRESS.value, # Usar .value para enum em exemplo
                    "importance": 5
                }
            ]
        }
    }

# --- Modelos para Representação no Banco de Dados e Respostas ---
class TaskInDBBase(TaskBase):
    """
    Modelo base para tarefas como são armazenadas e recuperadas do banco de dados.
    Estende `TaskBase` adicionando campos gerenciados pelo sistema.
    """
    id: uuid.UUID = Field(..., title="ID Único da Tarefa")
    owner_id: uuid.UUID = Field(..., title="ID do Proprietário da Tarefa")
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc), title="Data de Criação")
    updated_at: Optional[datetime] = Field(None, title="Data da Última Atualização")
    priority_score: Optional[float] = Field(None, title="Pontuação de Prioridade Calculada")

    model_config = ConfigDict(from_attributes=True)

class Task(TaskInDBBase):
    """
    Modelo completo representando uma tarefa, incluindo todos os campos.
    Tipicamente usado para retornar dados de tarefas da API.
    """
    model_config = ConfigDict(
         from_attributes=True,
         json_schema_extra={
             "examples": [
                {
                    "id": "f47ac10b-58cc-4372-a567-0e02b2c3d479",
                    "owner_id": "a1b2c3d4-e5f6-7890-1234-567890abcdef",
                    "title": "Finalizar relatório mensal",
                    "description": "Compilar dados e escrever o relatório final.",
                    "importance": 4,
                    "due_date": "2024-08-15",
                    "status": "pendente", # TaskStatus.PENDING.value se fosse enviar para API como string
                    "tags": ["relatorios", "financeiro"],
                    "project": "Relatórios Q3",
                    "created_at": "2024-07-28T10:00:00Z",
                    "updated_at": None,
                    "priority_score": 75.5 # Exemplo de score
                }
            ]
         }
     )

================================================================================
Capítulo 12: app/models/token.py
================================================================================

# app/models/token.py
"""
Este módulo define os modelos Pydantic relacionados à autenticação por token,
especificamente para a estrutura do token JWT retornado ao cliente e
para o payload contido dentro do token JWT.
"""

# ========================
# --- Importações ---
# ========================
import uuid
from typing import Optional

from pydantic import BaseModel, Field

# ========================
# --- Modelos Pydantic Token ---
# ========================
class Token(BaseModel):
    """
    Modelo de resposta para um token de acesso JWT.
    Este é o formato retornado ao cliente após uma autenticação bem-sucedida.
    """
    access_token: str = Field(..., title="Token de Acesso JWT")
    token_type: str = Field(default="bearer", title="Tipo do Token")

class TokenPayload(BaseModel):
    """
    Modelo para os dados (payload/claims) contidos dentro de um token JWT.
    Representa as informações decodificadas do token.
    """
    sub: uuid.UUID = Field(..., title="ID do Usuário (Subject)")
    username: str = Field(..., title="Nome de Usuário")
    exp: Optional[int] = Field(None, title="Timestamp de Expiração")

================================================================================
Capítulo 13: app/models/user.py
================================================================================

# app/models/user.py
"""
Este módulo define os modelos Pydantic para a entidade Usuário (User).
Inclui modelos para criação, atualização, e diferentes representações
de dados do usuário, como a forma como são armazenados no banco de dados
e como são retornados nas respostas da API.
"""

# ========================
# --- Importações ---
# ========================
import uuid
from datetime import datetime, timezone
from typing import Optional

from pydantic import BaseModel, EmailStr, Field, ConfigDict

# ========================
# --- Modelos Pydantic de User ---
# ========================

# --- Modelo Base ---
class UserBase(BaseModel):
    """
    Modelo base contendo os atributos comuns a todas as variações de usuário.
    Define os campos que podem ser esperados na maioria das representações de um usuário.
    """
    email: EmailStr = Field(..., title="Endereço de E-mail", description="Deve ser um e-mail válido e único.")
    username: str = Field(
        ...,
        title="Nome de Usuário",
        min_length=3,
        max_length=50,
        pattern="^[a-zA-Z0-9_]+$",
        description="Nome de usuário único (letras, números, underscore)."
    )
    full_name: Optional[str] = Field(None, title="Nome Completo", max_length=100)
    disabled: bool = Field(default=False, title="Status Desativado", description="Indica se o usuário está desativado.")

# --- Modelo para Criação de Usuário ---
class UserCreate(BaseModel):
    """
    Modelo para os dados necessários ao criar um novo usuário.
    Este é o formato esperado no payload da API para registro de usuários.
    """
    email: EmailStr = Field(..., title="Endereço de E-mail")
    username: str = Field(..., title="Nome de Usuário", min_length=3, max_length=50, pattern="^[a-zA-Z0-9_]+$")
    password: str = Field(..., title="Senha", min_length=8, description="Senha (será hasheada antes de salvar).")
    full_name: Optional[str] = Field(None, title="Nome Completo", max_length=100)

    model_config = {
        "json_schema_extra": {
            "examples": [
                {
                    "email": "userTest@example.com",
                    "username": "userTest",
                    "password": "averysecurepassword",
                    "full_name": "User Test"
                }
            ]
        }
    }

# --- Modelo para Atualização de Usuário ---
class UserUpdate(BaseModel):
    """
    Modelo para os dados que podem ser atualizados em um usuário existente.
    Todos os campos são opcionais, permitindo atualizações parciais.
    """
    email: Optional[EmailStr] = Field(None, title="Endereço de E-mail")
    password: Optional[str] = Field(None, title="Nova Senha", min_length=8, description="Nova senha (se fornecida).")
    full_name: Optional[str] = Field(None, title="Nome Completo", max_length=100)
    disabled: Optional[bool] = Field(None, title="Status Desativado")

    model_config = {
        "json_schema_extra": {
            "examples": [
                {
                    "full_name": "User Test Updated Name",
                    "email": "usertest.updated@example.com",
                    "disabled": False
                },
                {
                    "password": "mynewverysecurepassword123"
                }
            ]
        }
    }

# --- Modelos para Representação no Banco de Dados e Respostas da API ---
class UserInDBBase(UserBase):
    """
    Modelo base para usuários como são armazenados e recuperados do banco de dados.
    Inclui campos gerenciados pelo sistema como ID, senha hasheada e timestamps.
    """
    id: uuid.UUID = Field(..., title="ID Único do Usuário")
    hashed_password: str = Field(..., title="Senha Hasheada")
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc), title="Data de Criação")
    updated_at: Optional[datetime] = Field(None, title="Data da Última Atualização")

    model_config = ConfigDict(from_attributes=True)

class User(UserBase):
    """
    Modelo de usuário utilizado nas respostas da API.
    Projetado para expor dados seguros do usuário, omitindo a senha hasheada.
    """
    id: uuid.UUID = Field(..., title="ID Único do Usuário")
    created_at: datetime
    updated_at: Optional[datetime] = None

    model_config = ConfigDict(from_attributes=True)

class UserInDB(UserInDBBase):
    """
    Representação completa de um usuário como armazenado no banco de dados.
    Inclui todos os campos (inclusive senha hasheada) e é usado internamente.
    """
    # Atualmente não adiciona campos além de UserInDBBase, mas serve para clareza.
    pass

================================================================================
Capítulo 14: app/routers/auth.py
================================================================================

# app/routers/auth.py
"""
Este módulo define as rotas da API relacionadas à autenticação de usuários,
incluindo registro, login (obtenção de token JWT) e gerenciamento
de informações do usuário autenticado (visualizar, atualizar, deletar).
"""

# ========================
# --- Importações ---
# ========================
from typing import Annotated

from fastapi import APIRouter, Body, Depends, HTTPException, Response, status
from fastapi.security import OAuth2PasswordRequestForm
from motor.motor_asyncio import AsyncIOMotorDatabase
from pymongo.errors import DuplicateKeyError

# --- Módulos da Aplicação ---
from app.core.dependencies import CurrentUser, DbDep 
from app.core.security import create_access_token, verify_password
from app.db import user_crud
from app.models.token import Token
from app.models.user import User, UserCreate, UserUpdate

# ========================
# --- Configuração do Router ---
# ========================
router = APIRouter(
    tags=["Authentication"],
)

# ========================
# --- Rotas da API ---
# ========================

# --- Endpoint de Registro ---
@router.post(
    "/register",
    response_model=User,
    status_code=status.HTTP_201_CREATED,
    summary="Registra um novo usuário no sistema",
    response_description="Dados do usuário recém-registrado (sem senha).",
)
async def register_user(
    db: DbDep,
    user_in: Annotated[UserCreate, Body(description="Dados do novo usuário para registro.")]
):
    """
    Endpoint para registrar um novo usuário.

    Verifica duplicidade de username e email.
    Cria o usuário no banco, hasheando a senha.
    Retorna o usuário criado (sem a senha).
    """
    existing_user_by_username = await user_crud.get_user_by_username(db, user_in.username)
    if existing_user_by_username:
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=f"O nome de usuário '{user_in.username}' já existe.",
        )

    existing_user_by_email = await user_crud.get_user_by_email(db, user_in.email)
    if existing_user_by_email:
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=f"O endereço de e-mail '{user_in.email}' já registrado.",
        )

    try:
        created_user_db_obj = await user_crud.create_user(db=db, user_in=user_in)
        if created_user_db_obj is None:
            # Este cenário é menos provável se as validações anteriores e create_user funcionam
            # como esperado, a menos que create_user retorne None por um motivo não coberto
            # por DuplicateKeyError ou outra Exception específica.
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Não foi possível criar o usuário devido a um erro interno no servidor."
            )
        return User.model_validate(created_user_db_obj)
    except DuplicateKeyError: # pragma: no cover (Testado no CRUD, difícil simular aqui se as checagens prévias funcionam)
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail="Conflito: nome de usuário ou e-mail já existe (detectado pelo banco de dados).",
        )
    except Exception: # Para outros erros inesperados durante o user_crud.create_user
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Ocorreu um erro inesperado durante o processo de registro.",
        )

# --- Endpoint de Login ---
@router.post(
    "/login/access-token",
    response_model=Token,
    summary="Autentica o usuário e obtém um token de acesso JWT",
    description="Endpoint de login padrão OAuth2PasswordRequestForm. Envie 'username' e 'password' como form data.",
    response_description="Token de acesso JWT e tipo do token ('bearer')."
)
async def login_for_access_token(
    db: DbDep,
    form_data: Annotated[OAuth2PasswordRequestForm, Depends()]
):
    """
    Autentica um usuário e retorna um token de acesso.

    Verifica usuário, senha e se a conta está ativa.
    Gera e retorna um token JWT em caso de sucesso.
    """
    user = await user_crud.get_user_by_username(db, form_data.username)

    if not user or not verify_password(form_data.password, user.hashed_password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Nome de usuário ou senha incorretos.",
            headers={"WWW-Authenticate": "Bearer"},
        )

    if user.disabled:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="A conta do usuário está inativa."
        )

    access_token = create_access_token(
        subject=user.id,
        username=user.username
    )
    return Token(access_token=access_token, token_type="bearer")

# --- Endpoint de Dados do Usuário Autenticado ---
@router.get(
    "/users/me",
    response_model=User,
    summary="Obtém dados do usuário atualmente autenticado",
    description="Retorna os dados do usuário autenticado via token JWT.",
    response_description="Dados do usuário autenticado (sem a senha)."
)
async def read_users_me(
    current_user: CurrentUser # CurrentUser já é o UserInDB ativo
) -> User:
    """
    Retorna as informações do usuário autenticado.
    A dependência `CurrentUser` lida com a validação e busca do usuário.
    """
    # current_user já é o objeto UserInDB validado e ativo.
    # O Pydantic cuidará da conversão para o response_model User.
    return current_user

# --- Endpoint de Atualização do Usuário Autenticado ---
@router.put(
    "/users/me",
    response_model=User,
    summary="Atualiza os dados do usuário atualmente autenticado",
    description="Permite ao usuário autenticado atualizar e-mail, nome completo ou senha.",
    response_description="Dados do usuário atualizados (sem a senha)."
)
async def update_current_user(
    db: DbDep,
    user_update_payload: Annotated[UserUpdate, Body(description="Campos do usuário a serem atualizados.")],
    current_user: CurrentUser
):
    """
    Permite ao usuário autenticado atualizar suas próprias informações.
    """
    try:
        updated_user_db_obj = await user_crud.update_user(
            db=db,
            user_id=current_user.id,
            user_update=user_update_payload
        )

        if updated_user_db_obj is None:
            # O user_crud.update_user retorna None se não encontra ou há erro de validação Pydantic após update
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND, # Ou 500 se a causa for erro de validação
                detail="Não foi possível atualizar o usuário. Usuário não encontrado ou erro interno."
            )
        return User.model_validate(updated_user_db_obj)
    except DuplicateKeyError:
        email_em_uso = user_update_payload.email if user_update_payload.email else "N/A"
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=f"Não foi possível atualizar: o e-mail '{email_em_uso}' já está em uso por outra conta.",
        )
    except Exception: # Para outros erros inesperados vindos do CRUD (que não sejam DuplicateKeyError)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Ocorreu um erro inesperado durante a atualização do usuário.",
        )

# --- Endpoint de Deleção do Usuário Autenticado ---
@router.delete(
    "/users/me",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Deleta a conta do usuário atualmente autenticado",
    description="Permite ao usuário autenticado deletar sua própria conta permanentemente.",
    response_description="Nenhum conteúdo é retornado em caso de sucesso."
)
async def delete_current_user(
    db: DbDep,
    current_user: CurrentUser
):
    """
    Permite ao usuário autenticado deletar sua própria conta.
    """
    try:
        deleted_successfully = await user_crud.delete_user(
            db=db,
            user_id=current_user.id
        )
        if not deleted_successfully:
            # Se delete_user retorna False, significa que não encontrou o usuário para deletar
            # (o que seria estranho aqui, já que current_user existe) ou falhou.
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, # HTTP_404_NOT_FOUND pode ser considerado.
                detail="Não foi possível deletar o usuário. Erro interno ou usuário não encontrado."
            )
        return Response(status_code=status.HTTP_204_NO_CONTENT) # Resposta HTTP 204

    except Exception: # Para outros erros inesperados vindos do CRUD
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Ocorreu um erro inesperado durante a deleção do usuário.",
        )

================================================================================
Capítulo 15: app/routers/tasks.py
================================================================================

# app/routers/tasks.py
"""
Este módulo define as rotas da API para o gerenciamento de Tarefas (Tasks).
Inclui operações CRUD (Criar, Ler, Atualizar, Deletar) para tarefas,
além de listagem com filtros, ordenação e paginação.
As rotas são protegidas e associadas ao usuário autenticado.
Utiliza BackgroundTasks para operações que não precisam bloquear a resposta,
como o envio de webhooks e notificações por e-mail.
"""

# ========================
# --- Importações ---
# ========================
import logging
import uuid
from datetime import date, datetime, timezone
from typing import Annotated, List, Optional

from fastapi import (APIRouter, BackgroundTasks, Body, Depends, HTTPException, Path,
                   Query, Response, status)
from motor.motor_asyncio import AsyncIOMotorDatabase
from pydantic import ValidationError

# --- Módulos da Aplicação ---
from app.core.dependencies import CurrentUser, DbDep
from app.core.email import send_urgent_task_notification
from app.core.utils import (calculate_priority_score, is_task_urgent,
                            send_webhook_notification)
from app.db import task_crud
from app.models.task import Task, TaskCreate, TaskStatus, TaskUpdate
from app.core.config import settings

# ========================
# --- Configurações e Constantes ---
# ========================
logger = logging.getLogger(__name__)

# ========================
# --- Configuração do Router ---
# ========================
router = APIRouter(
    prefix="/tasks",
    tags=["Tasks"],
    responses={
        status.HTTP_404_NOT_FOUND: {"description": "Recurso (tarefa) não encontrado."},
        status.HTTP_401_UNAUTHORIZED: {"description": "Não autorizado (Token JWT inválido, ausente ou expirado)."},
        status.HTTP_403_FORBIDDEN: {"description": "Proibido (Usuário autenticado não tem permissão para acessar/modificar este recurso específico)."}
    },
)

# ========================
# --- Endpoint: Criar Tarefa ---
# ========================
@router.post(
    "/",
    response_model=Task,
    status_code=status.HTTP_201_CREATED,
    summary="Cria uma nova tarefa para o usuário autenticado",
    description=(
        "Cria uma nova tarefa associada ao usuário atualmente autenticado. "
        "A pontuação de prioridade é calculada automaticamente com base na importância e data de entrega. "
        "O ID do proprietário (`owner_id`) e os timestamps (`created_at`) são definidos pelo servidor."
    ),
    response_description="A tarefa recém-criada, incluindo todos os seus detalhes e campos gerados.",
)
async def create_task(
    task_in: Annotated[TaskCreate, Body(description="Dados da nova tarefa a ser criada.")],
    db: DbDep,
    current_user: CurrentUser,
    background_tasks: BackgroundTasks
):
    """
    Endpoint para criar uma nova tarefa.

    Fluxo de execução:
    1. Extrai os dados da tarefa do corpo da requisição (`task_in`).
    2. Calcula a `priority_score` com base na importância e data de entrega.
    3. Constrói o objeto completo da tarefa (`Task`), incluindo ID, `owner_id` (do `current_user`),
       `created_at` e a `priority_score` calculada. Valida este objeto com Pydantic.
    4. Persiste a tarefa no banco de dados usando `task_crud.create_task`.
    5. Se a criação for bem-sucedida, agenda tarefas em segundo plano para:
        - Enviar uma notificação de webhook (evento `task.created`).
        - Se a tarefa for urgente, enviar uma notificação por e-mail para o usuário.
    6. Retorna a tarefa criada.

    Levanta `HTTPException` em caso de erro de validação, falha na persistência ou outros problemas.
    """
    task_data_from_request = task_in.model_dump(exclude_unset=True)

    priority_score_calculated = calculate_priority_score(
        importance=task_in.importance,
        due_date=task_in.due_date
    )
    logger.info(f"Prioridade calculada para nova tarefa (Título: '{task_in.title}'): {priority_score_calculated}")

    try:
        task_db_obj_to_create = Task(
            id=uuid.uuid4(),
            owner_id=current_user.id,
            created_at=datetime.now(timezone.utc),
            priority_score=priority_score_calculated,
            **task_data_from_request
        )
    except ValidationError as e:
        logger.error(f"Erro de validação Pydantic ao montar objeto Task para usuário {current_user.id}: {e}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            detail=f"Erro interno na validação dos dados da tarefa: {e.errors()}"
        )

    created_task_from_db = await task_crud.create_task(db=db, task_db=task_db_obj_to_create)
    if created_task_from_db is None: # pragma: no cover
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Falha ao salvar a tarefa no banco de dados."
        )
    logger.info(f"Tarefa {created_task_from_db.id} criada com sucesso para usuário {current_user.id}.")

    task_dict_for_webhook = created_task_from_db.model_dump(mode="json")
    background_tasks.add_task(
         send_webhook_notification,
         event_type="task.created",
         task_data=task_dict_for_webhook
    )
    logger.debug(f"Tarefa de webhook 'task.created' para {created_task_from_db.id} adicionada ao background.")

    if is_task_urgent(created_task_from_db):
        if current_user.email and current_user.full_name:
            logger.info(f"Tarefa {created_task_from_db.id} é urgente. Agendando e-mail de notificação para {current_user.email}.")
            background_tasks.add_task(
                send_urgent_task_notification,
                user_email=current_user.email,
                user_name=current_user.full_name,
                task_title=created_task_from_db.title,
                task_id=str(created_task_from_db.id),
                task_due_date=str(created_task_from_db.due_date) if created_task_from_db.due_date else None,
                priority_score=created_task_from_db.priority_score or 0.0
            )
        else:
             logger.warning(f"Usuário {current_user.id} (username: {current_user.username}) não possui e-mail ou nome completo configurado. "
                            f"Notificação por e-mail para tarefa urgente {created_task_from_db.id} não será enviada.")

    return created_task_from_db

# ========================
# --- Endpoint: Listar Tarefas ---
# ========================
@router.get(
    "/",
    response_model=List[Task],
    summary="Lista as tarefas do usuário autenticado com filtros e ordenação",
    description=(
        "Recupera uma lista de tarefas pertencentes exclusivamente ao usuário autenticado.\n"
        "Suporta múltiplos filtros combinados (status, data de entrega até, projeto, tags).\n"
        "Permite ordenação por: `priority_score`, `due_date`, `created_at`, `importance`.\n"
        "A paginação é controlada por `limit` e `skip`."
    ),
    response_description="Uma lista (potencialmente vazia) das tarefas do usuário, filtradas e ordenadas conforme os parâmetros.",
)
async def list_tasks(
    db: DbDep,
    current_user: CurrentUser,
    status_filter: Annotated[Optional[TaskStatus], Query(alias="status", description="Filtrar tarefas por status específico.")] = None,
    due_before: Annotated[Optional[date], Query(description="Filtrar tarefas com data de entrega até (inclusive) esta data.")] = None,
    project_filter: Annotated[Optional[str], Query(alias="project", min_length=1, description="Filtrar tarefas por nome exato do projeto.")] = None,
    tags_filter: Annotated[Optional[List[str]], Query(alias="tag", min_length=1, description="Filtrar tarefas que contenham TODAS as tags fornecidas.")] = None,
    sort_by: Annotated[Optional[str], Query(enum=["priority_score", "due_date", "created_at", "importance"], description="Campo para ordenação das tarefas.")] = None,
    sort_order: Annotated[str, Query(enum=["asc", "desc"], description="Ordem da ordenação (ascendente ou descendente).")] = "desc",
    limit: Annotated[int, Query(ge=1, le=1000, description="Número máximo de tarefas a retornar.")] = 100,
    skip: Annotated[int, Query(ge=0, description="Número de tarefas a pular (para paginação).")] = 0,
):
    """
    Endpoint para listar tarefas do usuário autenticado.

    A busca é delegada para a função `task_crud.get_tasks_by_owner`, que lida com a
    construção da query no banco de dados com base nos filtros, ordenação e paginação fornecidos.
    Todos os filtros e parâmetros são opcionais.
    """
    logger.info(f"Listando tarefas para usuário {current_user.id} com filtros: status='{status_filter}', "
                f"due_before='{due_before}', project='{project_filter}', tags='{tags_filter}', "
                f"sort_by='{sort_by}', sort_order='{sort_order}', limit={limit}, skip={skip}")

    tasks = await task_crud.get_tasks_by_owner(
        db=db,
        owner_id=current_user.id,
        status_filter=status_filter,
        due_before=due_before,
        project_filter=project_filter,
        tags_filter=tags_filter,
        sort_by=sort_by,
        sort_order=sort_order,
        limit=limit,
        skip=skip
    )
    logger.debug(f"Encontradas {len(tasks)} tarefas para usuário {current_user.id} com os filtros aplicados.")
    return tasks

# ========================
# --- Endpoint: Obter Tarefa Específica ---
# ========================
@router.get(
    "/{task_id}",
    response_model=Task,
    summary="Busca uma tarefa específica pelo seu ID",
    description="Recupera os detalhes completos de uma tarefa específica, desde que ela pertença ao usuário autenticado.",
    response_description="Os detalhes completos da tarefa encontrada.",
    responses={status.HTTP_403_FORBIDDEN: {"description": "Acesso negado: esta tarefa não pertence a você ou não existe para você."}}
)
async def get_task(
    task_id: Annotated[uuid.UUID, Path(description="ID da tarefa a ser recuperada.")],
    db: DbDep,
    current_user: CurrentUser
):
    """
    Endpoint para buscar uma única tarefa pelo seu ID (UUID).

    A função `task_crud.get_task_by_id` é responsável por verificar se a tarefa
    com o `task_id` fornecido pertence ao `current_user.id`.
    Se a tarefa não for encontrada ou não pertencer ao usuário, retorna HTTP 404.
    """
    logger.info(f"Buscando tarefa {task_id} para usuário {current_user.id}.")
    task = await task_crud.get_task_by_id(db=db, task_id=task_id, owner_id=current_user.id)

    if task is None:
        logger.warning(f"Tarefa {task_id} não encontrada ou acesso negado para usuário {current_user.id}.")
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Tarefa com ID '{task_id}' não encontrada ou você não tem permissão para acessá-la."
        )
    logger.debug(f"Tarefa {task_id} encontrada para usuário {current_user.id}: {task.title}")
    return task

# ========================
# --- Endpoint: Atualizar Tarefa ---
# ========================
@router.put(
    "/{task_id}",
    response_model=Task,
    summary="Atualiza uma tarefa existente do usuário autenticado",
    description=(
        "Atualiza campos de uma tarefa existente, desde que ela pertença ao usuário autenticado.\n"
        "A pontuação de prioridade (`priority_score`) é recalculada automaticamente se `importance` ou `due_date` forem modificados.\n"
        "O campo `updated_at` é atualizado automaticamente."
    ),
    response_description="Os detalhes completos da tarefa após a atualização.",
    responses={status.HTTP_403_FORBIDDEN: {"description": "Acesso negado: esta tarefa não pertence a você."}}
)
async def update_task(
    task_id: Annotated[uuid.UUID, Path(description="ID da tarefa a ser atualizada.")],
    task_update_payload: Annotated[TaskUpdate, Body(description="Campos da tarefa a serem atualizados.")],
    db: DbDep,
    current_user: CurrentUser,
    background_tasks: BackgroundTasks
):
    """
    Endpoint para atualizar campos específicos de uma tarefa existente.

    Fluxo de execução:
    1. Busca a tarefa existente para garantir que ela pertence ao usuário e para obter valores atuais.
    2. Recebe os dados de atualização validados pelo modelo `TaskUpdate`.
    3. Se nenhum dado for fornecido para atualização, retorna um erro HTTP 400.
    4. Prepara o dicionário `update_data_for_db` apenas com os campos enviados.
    5. Verifica se `importance` ou `due_date` foram alterados para recalcular `priority_score`.
    6. Chama `task_crud.update_task` para persistir as alterações.
    7. Agenda notificação de webhook para `task.updated`.
    8. Retorna a tarefa atualizada.
    """
    logger.info(f"Iniciando atualização da tarefa {task_id} para usuário {current_user.id} com payload: {task_update_payload.model_dump(exclude_unset=True)}")
    existing_task = await task_crud.get_task_by_id(db=db, task_id=task_id, owner_id=current_user.id)
    if not existing_task:
        logger.warning(f"Tentativa de atualizar tarefa {task_id} que não foi encontrada para usuário {current_user.id}.")
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Tarefa com ID '{task_id}' não encontrada ou você não tem permissão para modificá-la."
        )

    update_data_from_request = task_update_payload.model_dump(exclude_unset=True)

    if not update_data_from_request:
        logger.info(f"Nenhum campo fornecido para atualização da tarefa {task_id}.")
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Nenhum campo válido fornecido para atualização."
        )

    new_importance = update_data_from_request.get("importance", existing_task.importance)
    if "due_date" in update_data_from_request:
        new_due_date = update_data_from_request.get("due_date")
    else:
        new_due_date = existing_task.due_date

    should_recalculate_priority = False
    if "importance" in update_data_from_request and update_data_from_request["importance"] != existing_task.importance:
        should_recalculate_priority = True
    if "due_date" in update_data_from_request and new_due_date != existing_task.due_date:
        should_recalculate_priority = True
    if "priority_score" in update_data_from_request: # pragma: no cover
        should_recalculate_priority = False

    update_data_for_db = update_data_from_request.copy()

    if should_recalculate_priority:
        new_priority_score = calculate_priority_score(
            importance=new_importance,
            due_date=new_due_date
        )
        update_data_for_db["priority_score"] = new_priority_score
        logger.info(f"Prioridade para tarefa {task_id} recalculada para: {new_priority_score}.")

    updated_task_from_db = await task_crud.update_task(
        db=db,
        task_id=task_id,
        owner_id=current_user.id,
        update_data=update_data_for_db
    )

    if updated_task_from_db is None:
        logger.error(f"Falha ao atualizar tarefa {task_id} no DB para usuário {current_user.id}. CRUD retornou None.")
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Não foi possível atualizar a tarefa com ID '{task_id}'. " # String de detalhe original
                   "Pode ter sido deletada ou ocorreu um erro interno." # Mantido para consistência com teste.
        )
    logger.info(f"Tarefa {updated_task_from_db.id} atualizada com sucesso para usuário {current_user.id}.")

    task_dict_for_webhook = updated_task_from_db.model_dump(mode="json")
    background_tasks.add_task(
        send_webhook_notification,
        event_type="task.updated",
        task_data=task_dict_for_webhook
    )
    logger.debug(f"Tarefa de webhook 'task.updated' para {updated_task_from_db.id} adicionada ao background.")

    return updated_task_from_db

# ========================
# --- Endpoint: Deletar Tarefa ---
# ========================
@router.delete(
    "/{task_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Deleta uma tarefa do usuário autenticado",
    description="Remove permanentemente uma tarefa específica do banco de dados, desde que ela pertença ao usuário autenticado.",
    responses={
        status.HTTP_204_NO_CONTENT: {"description": "Tarefa deletada com sucesso (sem corpo de resposta)."}
    }
)
async def delete_task(
    task_id: Annotated[uuid.UUID, Path(description="ID da tarefa a ser deletada.")],
    db: DbDep,
    current_user: CurrentUser
):
    """
    Endpoint para deletar uma tarefa específica.

    Verifica se a tarefa pertence ao usuário autenticado e, se sim, a remove
    permanentemente do banco de dados usando `task_crud.delete_task`.
    Retorna HTTP 204 (No Content) em caso de sucesso.

    Levanta `HTTPException` com status 404 se a tarefa não for encontrada ou
    não pertencer ao usuário.
    """
    logger.info(f"Iniciando deleção da tarefa {task_id} para usuário {current_user.id}.")
    deleted_successfully = await task_crud.delete_task(
        db=db,
        task_id=task_id,
        owner_id=current_user.id
    )

    if not deleted_successfully:
        logger.warning(f"Falha ao deletar tarefa {task_id}. Não encontrada ou não pertence ao usuário {current_user.id}.")
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Tarefa com ID '{task_id}' não encontrada ou você não tem permissão para deletá-la."
        )

    logger.info(f"Tarefa {task_id} deletada com sucesso para usuário {current_user.id}.")
    return Response(status_code=status.HTTP_204_NO_CONTENT)

================================================================================
Capítulo 16: app/worker.py
================================================================================

# app/worker.py
"""
Este módulo define um worker ARQ (Asynchronous Runtimes for Queueing) para executar
tarefas em segundo plano e agendadas.

Ele inclui:
- Uma tarefa periódica (`check_and_notify_urgent_tasks`) para verificar tarefas
  que se tornaram urgentes e notificar os usuários correspondentes por e-mail.
- Funções de ciclo de vida (`startup` e `shutdown`) para gerenciar a conexão
  com o banco de dados MongoDB para o worker.
- A classe `WorkerSettings` que configura o comportamento do worker ARQ, incluindo
  os `cron_jobs` e as configurações de conexão com o Redis (usado pelo ARQ como broker).
"""

# ========================
# --- Importações ---
# ========================

# --- Bibliotecas Padrão/Terceiros ---
import asyncio
import logging
from datetime import date, datetime, timezone 
from typing import Any, Dict, Optional

import arq.cron
from arq.connections import RedisSettings
from motor.motor_asyncio import AsyncIOMotorDatabase

# --- Módulos da Aplicação ---
from app.core.config import settings
from app.core.email import send_urgent_task_notification
from app.db import task_crud, user_crud
from app.db.mongodb_utils import (close_mongo_connection, connect_to_mongo) 
from app.models.task import Task, TaskStatus 

# =====================================
# --- Configurações e Constantes ---
# =====================================
logger = logging.getLogger("arq.worker") 

# ==================================
# --- Função de Tarefa Periódica ---
# ==================================
async def check_and_notify_urgent_tasks(ctx: Dict[str, Any]):
    """
    Tarefa periódica ARQ que varre o banco de dados em busca de tarefas
    consideradas urgentes e notifica os respectivos usuários por e-mail.

    Critérios de Urgência:
    - Tarefas não concluídas ou canceladas.
    - E que atendam a pelo menos um dos seguintes:
        - `priority_score` acima de um limiar definido (`EMAIL_URGENCY_THRESHOLD`).
        - `due_date` é hoje ou já passou.

    Args:
        ctx: Dicionário de contexto fornecido pelo worker ARQ. Espera-se que contenha
             uma instância de conexão com o banco de dados (`db`) injetada pela função `startup`.
    """
    logger.info("Executando job: Verificação e notificação de tarefas urgentes...")
    db: Optional[AsyncIOMotorDatabase] = ctx.get("db")

    if db is None:
        logger.error("Conexão com o banco de dados não disponível no contexto ARQ.")
        return
    tasks_collection = db[task_crud.TASKS_COLLECTION]
    users_collection = db[user_crud.USERS_COLLECTION] 
    today_start_utc = datetime.combine(date.today(), datetime.min.time(), tzinfo=timezone.utc)
    query_urgent_tasks = {
        "status": {"$nin": [TaskStatus.COMPLETED.value, TaskStatus.CANCELLED.value]},
        "$or": [
            {"priority_score": {"$gt": settings.EMAIL_URGENCY_THRESHOLD}},
            {"due_date": {"$lte": today_start_utc}} 
        ]
    }
    logger.debug(f"Query MongoDB para tarefas urgentes: {query_urgent_tasks}")

    urgent_tasks_cursor = tasks_collection.find(query_urgent_tasks)
    notifications_sent_count = 0
    async for task_dict in urgent_tasks_cursor:
        task_dict.pop('_id', None) 
        try:
            task = Task.model_validate(task_dict)
            logger.debug(f"Processando tarefa urgente ID: {task.id}, Título: {task.title}")
            user = await user_crud.get_user_by_id(db, task.owner_id)
            if user and user.email and user.full_name and not user.disabled:
                logger.info(f"Tarefa urgente ID '{task.id}' (Título: '{task.title}') encontrada. "
                            f"Notificando usuário: {user.username} (E-mail: {user.email}).")
                await send_urgent_task_notification(
                    user_email=user.email,
                    user_name=user.full_name,
                    task_title=task.title,
                    task_id=str(task.id),
                    task_due_date=str(task.due_date) if task.due_date else None, 
                    priority_score=task.priority_score or 0.0 
                )
                notifications_sent_count += 1
            elif not user:
                logger.warning(f"Usuário com ID '{task.owner_id}' associado à tarefa urgente '{task.id}' não foi encontrado no banco de dados.")
            elif user and user.disabled:
                logger.info(f"Usuário '{user.username}' (ID: {task.owner_id}) associado à tarefa urgente '{task.id}' está desabilitado. "
                            "Notificação não enviada.")
            else:
                logger.warning(f"Usuário '{user.username}' (ID: {task.owner_id}) associado à tarefa urgente '{task.id}' "
                               "não possui e-mail ou nome completo configurado. Notificação não enviada.")
        except Exception as e:
            logger.exception(f"Erro ao processar tarefa urgente (ID no dict: {task_dict.get('id', 'N/A')}): {e}")
            continue 
    logger.info(f"Verificação de tarefas urgentes concluída. Total de {notifications_sent_count} notificações enviadas.")

# ==========================================
# --- Funções de Ciclo de Vida do Worker ---
# ==========================================
async def startup(ctx: Dict[str, Any]):
    """
    Função executada quando o worker ARQ é iniciado.
    Responsável por estabelecer conexões com recursos externos, como o banco de dados.

    Args:
        ctx: Dicionário de contexto do ARQ, onde podemos armazenar recursos
             (como a conexão DB) para serem usados pelas tarefas do worker.
    """
    logger.info("Worker ARQ: Iniciando rotinas de startup...")
    db_connection_instance = await connect_to_mongo()
    if db_connection_instance is not None:
        ctx["db"] = db_connection_instance
        logger.info("Worker ARQ: Conexão com MongoDB estabelecida e armazenada no contexto.")
    else:
        logger.error("Worker ARQ: Falha crítica ao conectar ao MongoDB durante o startup. "
                     "A conexão não estará disponível para as tarefas.")
        ctx["db"] = None

async def shutdown(ctx: Dict[str, Any]):
    """
    Função executada quando o worker ARQ está sendo encerrado.
    Responsável por liberar recursos, como fechar a conexão com o banco de dados.

    Args:
        ctx: Dicionário de contexto do ARQ.
    """
    logger.info("Worker ARQ: Iniciando rotinas de shutdown...")
    if ctx.get("db") is not None: 
        await close_mongo_connection()
        logger.info("Worker ARQ: Conexão com MongoDB fechada.")
    else:
        logger.info("Worker ARQ: Nenhuma conexão com MongoDB para fechar (não estava disponível ou já fechada).")

# =======================================
# --- Configurações do Worker ARQ ---
# =======================================
class WorkerSettings:
    """
    Define as configurações para o worker ARQ.
    Isso inclui funções de ciclo de vida (startup/shutdown),
    tarefas agendadas (`cron_jobs`) e configurações de conexão com o Redis.
    """
    on_startup = startup
    on_shutdown = shutdown
    cron_jobs = [
        arq.cron(check_and_notify_urgent_tasks, minute={*range(0, 60, 15)}, run_at_startup=False), 
        arq.cron(check_and_notify_urgent_tasks, hour=8, minute=0, run_at_startup=False) 
    ]
    logger.info(f"Cron jobs configurados: {len(cron_jobs)} jobs definidos.")
    if settings.REDIS_URL:
        try:
            host = settings.REDIS_URL.host or 'localhost'
            port = int(settings.REDIS_URL.port) if settings.REDIS_URL.port else 6379
            db_num_from_path = int(settings.REDIS_URL.path.strip('/')) if settings.REDIS_URL.path and settings.REDIS_URL.path != '/' else 0
            password = settings.REDIS_URL.password

            redis_settings: RedisSettings = RedisSettings(
                host=host,
                port=port,
                database=db_num_from_path,
                password=password,
            )
            logger.info(f"RedisSettings configuradas para ARQ: host={host}, port={port}, db={db_num_from_path}")
        except Exception as e:# pragma: no cover
            logger.exception(f"Erro crítico ao configurar RedisSettings a partir da URL: '{settings.REDIS_URL}'. Erro: {e}")
            raise ValueError(f"Erro ao processar REDIS_URL para ARQ: {e}")# pragma: no cover
    else:
        logger.error("Configuração crítica ausente: REDIS_URL não está definida. Worker ARQ não pode iniciar.")
        raise ValueError("REDIS_URL não está definida nas configurações. O worker ARQ requer uma URL do Redis para operar.")

================================================================================
Capítulo 17: tests/conftest.py
================================================================================

# tests/conftest.py
# Inibir warnings de depreciação de bibliotecas
import warnings
warnings.filterwarnings("ignore", category=DeprecationWarning, module="passlib")

"""
Este módulo define fixtures do Pytest que são compartilhadas entre diferentes
arquivos de teste na suíte de testes da aplicação SmartTask.

Fixtures incluem:
- Cliente HTTP assíncrono (`test_async_client`) para interagir com a API FastAPI.
  Este cliente também gerencia a conexão com o banco de dados de teste e realiza
  a limpeza das coleções antes e depois de cada teste.
- Dados de teste para usuários (User A e User B).
- Fixtures para registrar/logar usuários de teste e obter seus tokens/IDs.
- Fixtures para gerar cabeçalhos de autenticação.
- Fixtures para criar dados de exemplo (como tarefas) para testes específicos
  de listagem, filtragem e ordenação.

O objetivo é prover um ambiente de teste limpo e consistente para cada caso de teste.
"""

# ========================
# --- Importações ---
# ========================
import asyncio
import logging
import uuid
from typing import AsyncGenerator, Dict, List, Any, Optional

import pytest
import pytest_asyncio
from fastapi import status
from httpx import ASGITransport, AsyncClient
from motor.motor_asyncio import AsyncIOMotorDatabase

# --- Módulos da Aplicação ---
from app.core.config import settings
from app.db.mongodb_utils import (close_mongo_connection, connect_to_mongo, get_database)
from app.db.task_crud import TASKS_COLLECTION
from app.db.user_crud import USERS_COLLECTION
from app.main import app as fastapi_app
from app.models.task import TaskStatus

# ========================
# --- Configurações e Constantes ---
# ========================
logger = logging.getLogger(__name__)

# ========================
# --- Fixture Principal: Cliente de Teste HTTP ---
# ========================
@pytest_asyncio.fixture(scope="function")
async def test_async_client() -> AsyncGenerator[AsyncClient, None]:
    """
    Fixture assíncrona com escopo de função para prover um cliente HTTP (`AsyncClient`)
    para interagir com a aplicação FastAPI.

    Responsabilidades:
    - Estabelece e fecha a conexão com o MongoDB de teste.
    - **Limpa as coleções `USERS_COLLECTION` e `TASKS_COLLECTION` antes e depois de cada teste**
      para garantir a isolação e idempotência dos testes.
    - Emite um aviso se o nome do banco de dados não contiver "test", como precaução.
    - Fornece o `AsyncClient` configurado com `ASGITransport` para testar a aplicação
      diretamente, sem passar por uma camada de rede real.

    Yields:
        AsyncClient: Uma instância do cliente HTTP assíncrona.

    Raises:
        pytest.fail: Se a conexão com o MongoDB falhar durante o setup.
    """
    db_instance: Optional[AsyncIOMotorDatabase] = None
    logger.debug("Fixture 'test_async_client': Iniciando setup...")

    try:
        await connect_to_mongo()
        db_instance = get_database()

        if db_instance is not None:
            if "test" not in settings.DATABASE_NAME.lower(): 
                logger.warning(
                    f"ATENÇÃO: Testes estão sendo executados no banco de dados '{settings.DATABASE_NAME}'. "
                    "As coleções de usuários e tarefas serão limpas!"
                )

            logger.debug(f"Fixture 'test_async_client': Limpando coleções ANTES do teste no DB '{settings.DATABASE_NAME}'...")
            await db_instance[USERS_COLLECTION].delete_many({})
            await db_instance[TASKS_COLLECTION].delete_many({})
            logger.info(f"Fixture 'test_async_client': Coleções '{USERS_COLLECTION}' e '{TASKS_COLLECTION}' limpas ANTES do teste.")
        else: 
            logger.error("Fixture 'test_async_client': Falha crítica ao conectar ao MongoDB durante o setup.")
            pytest.fail("Falha ao obter instância do banco de dados na fixture test_async_client (setup).")

        transport = ASGITransport(app=fastapi_app) 
        async with AsyncClient(transport=transport, base_url="http://testserver") as client:
            logger.debug("Fixture 'test_async_client': Cliente HTTP fornecido ao teste.")
            yield client

    finally:
        logger.debug("Fixture 'test_async_client': Iniciando limpeza PÓS-teste...")
        if db_instance is not None:
            try:
                logger.debug(f"Fixture 'test_async_client': Limpando coleções APÓS o teste no DB '{settings.DATABASE_NAME}'...")
                await db_instance[USERS_COLLECTION].delete_many({})
                await db_instance[TASKS_COLLECTION].delete_many({})
                logger.info(f"Fixture 'test_async_client': Coleções '{USERS_COLLECTION}' e '{TASKS_COLLECTION}' limpas APÓS o teste.")
            except Exception as e_cleanup: 
                logger.error(f"Fixture 'test_async_client': Erro durante a limpeza do DB PÓS-teste: {e_cleanup}", exc_info=True)
        else: 
            logger.warning("Fixture 'test_async_client': Limpeza PÓS-teste pulada - conexão com DB não estabelecida.")

        logger.debug("Fixture 'test_async_client': Fechando conexão MongoDB principal (se houver)...")
        await close_mongo_connection()
        logger.debug("Fixture 'test_async_client': Setup e teardown concluídos.")

# ========================
# --- Fixtures para Usuário de Teste A ---
# ========================
user_a_data: Dict[str, str] = {
    "email": "testuserA@example.com",
    "username": "testuserA",
    "password": "passwordA",
    "full_name": "Test User A"
}

@pytest_asyncio.fixture(scope="function")
async def test_user_a_token_and_id(test_async_client: AsyncClient) -> tuple[str, uuid.UUID]:
    """
    Fixture para registrar e logar o Usuário A.

    Esta fixture garante que o Usuário A exista no banco de dados de teste.
    Em seguida, realiza o login para obter um token de acesso e o ID do usuário.

    Depende de:
        - `test_async_client`: Para fazer requisições HTTP à API.

    Returns:
        tuple[str, uuid.UUID]: Uma tupla contendo (access_token, user_id) para o Usuário A.
    """
    logger.debug("Fixture 'test_user_a_token_and_id': Configurando Usuário A...")
    register_url = f"{settings.API_V1_STR}/auth/register"
    login_url = f"{settings.API_V1_STR}/auth/login/access-token"
    users_me_url = f"{settings.API_V1_STR}/auth/users/me"

    reg_response = await test_async_client.post(register_url, json=user_a_data)
    if reg_response.status_code == status.HTTP_201_CREATED:
        logger.info(f"Usuário A ('{user_a_data['username']}') registrado com sucesso para o teste.")
    elif reg_response.status_code == status.HTTP_409_CONFLICT: 
        logger.warning(f"Registro do Usuário A ('{user_a_data['username']}') resultou em conflito (já existe). Prosseguindo para login.")
    else: 
        pytest.fail(f"Falha inesperada ao tentar registrar Usuário A: {reg_response.status_code} - {reg_response.text}")

    login_payload = {"username": user_a_data["username"], "password": user_a_data["password"]}
    login_response = await test_async_client.post(login_url, data=login_payload)
    if login_response.status_code != status.HTTP_200_OK: 
        pytest.fail(f"Falha ao fazer login com Usuário A ('{user_a_data['username']}'): {login_response.status_code} - {login_response.text}")
    token: str = login_response.json()["access_token"]
    logger.debug(f"Usuário A ('{user_a_data['username']}') logado com sucesso. Token obtido.")

    user_me_headers = {"Authorization": f"Bearer {token}"}
    user_me_response = await test_async_client.get(users_me_url, headers=user_me_headers)
    if user_me_response.status_code != status.HTTP_200_OK: 
        pytest.fail(f"Falha ao obter dados do Usuário A via /users/me: {user_me_response.status_code} - {user_me_response.text}")
    user_id_str: str = user_me_response.json()["id"]
    user_id: uuid.UUID = uuid.UUID(user_id_str)
    logger.info(f"ID do Usuário A ({user_id}) obtido com sucesso.")
    return token, user_id

@pytest.fixture(scope="function")
def auth_headers_a(test_user_a_token_and_id: tuple[str, uuid.UUID]) -> Dict[str, str]:
    """
    Fixture síncrona que retorna um dicionário de cabeçalhos de autenticação
    (Authorization Bearer token) para o Usuário A.
    """
    token, _ = test_user_a_token_and_id
    return {"Authorization": f"Bearer {token}"}

# ========================
# --- Fixtures para Usuário de Teste B ---
# ========================
user_b_data: Dict[str, str] = {
    "email": "testuserB@example.com",
    "username": "testuserB",
    "password": "passwordB",
    "full_name": "Test User B"
}

@pytest_asyncio.fixture(scope="function")
async def test_user_b_token(test_async_client: AsyncClient) -> str:
    """
    Fixture para registrar e logar o Usuário B, retornando apenas seu token de acesso.
    """
    logger.debug("Fixture 'test_user_b_token': Configurando Usuário B...")
    register_url = f"{settings.API_V1_STR}/auth/register"
    login_url = f"{settings.API_V1_STR}/auth/login/access-token"

    reg_response = await test_async_client.post(register_url, json=user_b_data)
    if reg_response.status_code == status.HTTP_201_CREATED:
        logger.info(f"Usuário B ('{user_b_data['username']}') registrado com sucesso para o teste.")
    elif reg_response.status_code == status.HTTP_409_CONFLICT: 
        logger.warning(f"Registro do Usuário B ('{user_b_data['username']}') resultou em conflito (já existe). Prosseguindo para login.")
    else: 
        pytest.fail(f"Falha inesperada ao tentar registrar Usuário B: {reg_response.status_code} - {reg_response.text}")

    login_payload = {"username": user_b_data["username"], "password": user_b_data["password"]}
    login_response = await test_async_client.post(login_url, data=login_payload)
    if login_response.status_code != status.HTTP_200_OK: 
        pytest.fail(f"Falha ao fazer login com Usuário B ('{user_b_data['username']}'): {login_response.status_code} - {login_response.text}")
    token: str = login_response.json()["access_token"]
    logger.info(f"Usuário B ('{user_b_data['username']}') logado com sucesso. Token obtido.")
    return token

@pytest.fixture(scope="function")
def auth_headers_b(test_user_b_token: str) -> Dict[str, str]:
    """
    Fixture síncrona que retorna cabeçalhos de autenticação para o Usuário B.
    """
    return {"Authorization": f"Bearer {test_user_b_token}"}

# ========================
# --- Fixture para Criação de Tarefas (Filtro/Ordenação) ---
# ========================
@pytest_asyncio.fixture(scope="function")
async def create_filter_sort_tasks(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str]
) -> List[Dict[str, Any]]:
    """
    Cria um conjunto de tarefas de teste no banco de dados para o Usuário A.

    Util para testes de listagem, filtragem e ordenação.
    """
    logger.info("Fixture 'create_filter_sort_tasks': Criando conjunto de tarefas de teste para Usuário A...")
    tasks_creation_url = f"{settings.API_V1_STR}/tasks/"
    tasks_to_create_data: List[Dict[str, Any]] = [
        {"title": "Task A Filter High Priority", "importance": 5, "project": "Projeto Filtro", "status": TaskStatus.PENDING.value, "due_date": "2026-01-01", "tags": ["importante", "relatório"]},
        {"title": "Task B Filter Low Priority", "importance": 1, "project": "Projeto Filtro", "status": TaskStatus.PENDING.value, "due_date": "2026-02-01", "tags": ["comum"]},
        {"title": "Task C Another Project InProgress", "importance": 3, "project": "Projeto Secundário", "status": TaskStatus.IN_PROGRESS.value, "tags": ["desenvolvimento"]},
        {"title": "Task D Filter Medium Due Soon", "importance": 3, "project": "Projeto Filtro", "status": TaskStatus.PENDING.value, "due_date": "2025-12-15", "tags": ["urgente", "financeiro"]},
        {"title": "Task E Filter Completed", "importance": 4, "project": "Projeto Filtro", "status": TaskStatus.COMPLETED.value, "tags": ["finalizado"]},
    ]
    created_tasks_list: List[Dict[str, Any]] = []
    for task_payload in tasks_to_create_data:
        response = await test_async_client.post(tasks_creation_url, json=task_payload, headers=auth_headers_a)
        assert response.status_code == status.HTTP_201_CREATED, \
            f"Falha ao criar tarefa de teste (Título: '{task_payload['title']}'). Resposta: {response.text}" 
        created_tasks_list.append(response.json())
        logger.debug(f"Tarefa de teste criada: {task_payload['title']} (ID: {response.json()['id']})")

    logger.info(f"Fixture 'create_filter_sort_tasks': {len(created_tasks_list)} tarefas de teste criadas com sucesso.")
    return created_tasks_list

================================================================================
Capítulo 18: tests/test_auth.py
================================================================================

# tests/test_auth.py
"""
Este módulo contém testes de integração para os endpoints de autenticação
da API SmartTask, definidos em `app.routers.auth`.

Os testes cobrem:
- Registro de novos usuários, incluindo cenários de sucesso e conflito (duplicidade).
- Validação de entrada para o registro de usuários.
- Login de usuários, incluindo sucesso, senha incorreta e usuário não encontrado/desativado.
- Acesso a dados do usuário autenticado (`/users/me`).
- Atualização de dados do usuário autenticado.
- Deleção da conta do usuário autenticado.

As fixtures para cliente HTTP e usuários de teste são definidas em `conftest.py`.
"""

# ========================
# --- Importações ---
# ========================
import uuid
from typing import Any, Dict

import pytest
from fastapi import status
from httpx import AsyncClient
from unittest.mock import MagicMock, patch
from pymongo.errors import DuplicateKeyError

# --- Módulos da Aplicação e Configs de Teste ---
from app.core.config import settings
from app.db import user_crud
from app.models.user import User, UserInDB, UserUpdate
from app.routers import auth
from tests.conftest import user_a_data

# ========================
# --- Marcador Global de Teste ---
# ========================
pytestmark = pytest.mark.asyncio

# ========================
# --- Testes de Registro (/auth/register) ---
# ========================
async def test_register_user_success(test_async_client: AsyncClient):
    """
    Testa o registro bem-sucedido de um novo usuário com dados únicos.
    """
    # --- Arrange ---
    new_user_data = {
        "email": "newuniqueuser_auth_test@example.com",
        "username": "newuniqueuser_auth_test",
        "password": "newpassword123",
        "full_name": "New Unique Test User"
    }
    register_url = f"{settings.API_V1_STR}/auth/register"

    # --- Act ---
    response = await test_async_client.post(register_url, json=new_user_data)

    # --- Assert ---
    assert response.status_code == status.HTTP_201_CREATED
    response_data = response.json()
    assert response_data["email"] == new_user_data["email"]
    assert response_data["username"] == new_user_data["username"]
    assert response_data["full_name"] == new_user_data["full_name"]
    assert "id" in response_data
    assert "hashed_password" not in response_data

async def test_register_user_duplicate_username_case_insensitive_is_actually_sensitive(
    test_async_client: AsyncClient,
):
    """
    Testa o registro com um username que difere apenas em maiúsculas/minúsculas
    de um username existente.
    """
    # --- Arrange ---
    base_url = f"{settings.API_V1_STR}/auth/register"
    unique_email_prefix = uuid.uuid4().hex[:8]

    user_initial_data = {
        "email": f"{unique_email_prefix}_initial@example.com",
        "username": "CamelCaseUser",
        "password": "password123",
    }
    response_initial = await test_async_client.post(base_url, json=user_initial_data)
    assert response_initial.status_code == status.HTTP_201_CREATED

    user_variant_case_data = {
        "email": f"{unique_email_prefix}_variant@example.com",
        "username": "camelcaseuser",
        "password": "password123",
    }

    # --- Act ---
    response_variant = await test_async_client.post(base_url, json=user_variant_case_data)

    # --- Assert ---
    assert response_variant.status_code == status.HTTP_201_CREATED

async def test_register_user_duplicate_username(
    test_async_client: AsyncClient,
    test_user_a_token_and_id: tuple[str, uuid.UUID]
):
    """
    Testa a tentativa de registro de um novo usuário com um username que já existe.
    """
    # --- Arrange ---
    attempt_data = {
        "email": "anotherunique_email@example.com",
        "username": user_a_data["username"],
        "password": "anotherpassword",
    }
    register_url = f"{settings.API_V1_STR}/auth/register"

    # --- Act ---
    response = await test_async_client.post(register_url, json=attempt_data)

    # --- Assert ---
    assert response.status_code == status.HTTP_409_CONFLICT
    assert "já existe" in response.json()["detail"]

async def test_register_user_duplicate_email(
    test_async_client: AsyncClient,
    test_user_a_token_and_id: tuple[str, uuid.UUID]
):
    """
    Testa a tentativa de registro de um novo usuário com um e-mail que já existe.
    """
    # --- Arrange ---
    attempt_data = {
        "email": user_a_data["email"],
        "username": "anotherunique_username_for_email_test",
        "password": "anotherpassword",
    }
    register_url = f"{settings.API_V1_STR}/auth/register"

    # --- Act ---
    response = await test_async_client.post(register_url, json=attempt_data)

    # --- Assert ---
    assert response.status_code == status.HTTP_409_CONFLICT
    assert "já registrado" in response.json()["detail"]

async def test_register_user_crud_returns_none(test_async_client: AsyncClient, mocker): # type: ignore
    """
    Testa o registro quando user_crud.create_user retorna None.
    Deve resultar em erro 500 com a mensagem genérica devido à estrutura do try/except.
    """
    # --- Arrange ---
    user_data = {
        "email": "crudnone@example.com",
        "username": "crudnoneuser",
        "password": "password123"
    }
    register_url = f"{settings.API_V1_STR}/auth/register"

    mocker.patch("app.routers.auth.user_crud.get_user_by_username", return_value=None)
    mocker.patch("app.routers.auth.user_crud.get_user_by_email", return_value=None)
    mocker.patch("app.routers.auth.user_crud.create_user", return_value=None)

    # --- Act ---
    response = await test_async_client.post(register_url, json=user_data)

    # --- Assert ---
    assert response.status_code == status.HTTP_500_INTERNAL_SERVER_ERROR
    # Espera a mensagem do except Exception genérico
    assert "Ocorreu um erro inesperado" in response.json()["detail"]

async def test_register_user_crud_generic_exception(test_async_client: AsyncClient, mocker):
    """
    Testa o registro quando user_crud.create_user levanta Exception genérica.
    """
    # --- Arrange ---
    user_data = {
        "email": "crudexception@example.com",
        "username": "crudexcuser",
        "password": "password123"
    }
    register_url = f"{settings.API_V1_STR}/auth/register"
    simulated_error = Exception("Erro genérico simulado no CRUD")

    mocker.patch("app.routers.auth.user_crud.get_user_by_username", return_value=None)
    mocker.patch("app.routers.auth.user_crud.get_user_by_email", return_value=None)
    mocker.patch("app.routers.auth.user_crud.create_user", side_effect=simulated_error)

    # --- Act ---
    response = await test_async_client.post(register_url, json=user_data)

    # --- Assert ---
    assert response.status_code == status.HTTP_500_INTERNAL_SERVER_ERROR
    assert "Ocorreu um erro inesperado" in response.json()["detail"]

# ========================
# --- Testes de Validação de Entrada (/auth/register) ---
# ========================
@pytest.mark.parametrize(
    "field, value, error_type, error_msg_part",
    [
        ("email", "nao-e-um-email-valido", "value_error", "valid email address"),
        ("username", "us", "string_too_short", "String should have at least 3 characters"),
        ("username", "username com espacos", "string_pattern_mismatch", "match pattern"),
        ("username", "username!Inválido", "string_pattern_mismatch", "match pattern"),
        ("password", "curta", "string_too_short", "String should have at least 8 characters"),
        ("email", None, "missing", "Field required"),
        ("username", None, "missing", "Field required"),
        ("password", None, "missing", "Field required"),
    ]
)
async def test_register_user_invalid_input(
    test_async_client: AsyncClient,
    field: str,
    value: Any,
    error_type: str,
    error_msg_part: str
):
    """
    Testa o registro de usuário com dados de entrada inválidos específicos.
    """
    # --- Arrange ---
    valid_base_data = {
        "email": "valid_initial_email@example.com",
        "username": "validinitialuser",
        "password": "validinitialpassword",
        "full_name": "Valid Initial Name"
    }
    test_payload = valid_base_data.copy()
    if value is None:
        if field in test_payload:
            del test_payload[field]
    else:
        test_payload[field] = value

    register_url = f"{settings.API_V1_STR}/auth/register"

    # --- Act ---
    response = await test_async_client.post(register_url, json=test_payload)

    # --- Assert ---
    assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY
    error_details = response.json().get("detail", [])
    assert isinstance(error_details, list)
    found_expected_error = False
    for error_item in error_details:
        field_location_match = isinstance(error_item.get("loc"), list) and field in error_item["loc"]
        type_match = error_item.get("type") == error_type
        msg_match = error_msg_part.lower() in error_item.get("msg", "").lower()

        if field_location_match and type_match and msg_match:
            found_expected_error = True
            break
    assert found_expected_error

# ========================
# --- Testes de Login (/auth/login/access-token) ---
# ========================
async def test_login_success(
    test_async_client: AsyncClient,
    test_user_a_token_and_id: tuple[str, uuid.UUID]
):
    """
    Testa o login bem-sucedido do Usuário A.
    """
    # --- Arrange ---
    login_payload_form_data = {
        "username": user_a_data["username"],
        "password": user_a_data["password"]
    }
    login_url = f"{settings.API_V1_STR}/auth/login/access-token"

    # --- Act ---
    response = await test_async_client.post(login_url, data=login_payload_form_data)

    # --- Assert ---
    assert response.status_code == status.HTTP_200_OK
    token_data = response.json()
    assert "access_token" in token_data
    assert token_data.get("token_type") == "bearer"

async def test_login_wrong_password(
    test_async_client: AsyncClient,
    test_user_a_token_and_id: tuple[str, uuid.UUID]
):
    """
    Testa a tentativa de login do Usuário A com uma senha incorreta.
    """
    # --- Arrange ---
    login_payload_form_data = {
        "username": user_a_data["username"],
        "password": "thisisawrongpassword"
    }
    login_url = f"{settings.API_V1_STR}/auth/login/access-token"

    # --- Act ---
    response = await test_async_client.post(login_url, data=login_payload_form_data)

    # --- Assert ---
    assert response.status_code == status.HTTP_401_UNAUTHORIZED
    assert "incorretos" in response.json()["detail"].lower()

async def test_login_user_not_found(test_async_client: AsyncClient):
    """
    Testa a tentativa de login com um nome de usuário que não existe no sistema.
    """
    # --- Arrange ---
    login_payload_form_data = {
        "username": "nonexistent_test_user",
        "password": "any_password"
    }
    login_url = f"{settings.API_V1_STR}/auth/login/access-token"

    # --- Act ---
    response = await test_async_client.post(login_url, data=login_payload_form_data)

    # --- Assert ---
    assert response.status_code == status.HTTP_401_UNAUTHORIZED

async def test_login_disabled_user(test_async_client: AsyncClient, mocker):
    """
    Testa a tentativa de login com um usuário que está desabilitado.
    Espera-se um erro HTTP 400 Bad Request.
    """
    # --- Arrange ---
    disabled_username = "disabled_user_login"
    password = "password_for_disabled"
    login_url = f"{settings.API_V1_STR}/auth/login/access-token"
    login_payload_form_data = {
        "username": disabled_username,
        "password": password
    }

    disabled_user_mock = MagicMock(spec=UserInDB)
    disabled_user_mock.username = disabled_username
    disabled_user_mock.hashed_password = "some_valid_hash"
    disabled_user_mock.disabled = True

    mock_get_user_by_username = mocker.patch("app.routers.auth.user_crud.get_user_by_username", return_value=disabled_user_mock)
    mock_verify_password = mocker.patch("app.routers.auth.verify_password", return_value=True)
    mock_create_token = mocker.patch("app.routers.auth.create_access_token")

    # --- Act ---
    response = await test_async_client.post(login_url, data=login_payload_form_data)

    # --- Assert ---
    assert response.status_code == status.HTTP_400_BAD_REQUEST
    assert "A conta do usuário está inativa." == response.json()["detail"]
    mock_create_token.assert_not_called()
    mock_get_user_by_username.assert_called_once_with(mocker.ANY, disabled_username)
    mock_verify_password.assert_called_once_with(password, disabled_user_mock.hashed_password)

# ========================
# --- Testes de /auth/users/me ---
# ========================
async def test_read_users_me_success(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    test_user_a_token_and_id: tuple[str, uuid.UUID]
):
    """
    Testa o acesso bem-sucedido ao endpoint `/users/me` para obter
    os dados do usuário autenticado (User A).
    """
    # --- Arrange ---
    users_me_url = f"{settings.API_V1_STR}/auth/users/me"
    _, expected_user_id = test_user_a_token_and_id

    # --- Act ---
    response = await test_async_client.get(users_me_url, headers=auth_headers_a)

    # --- Assert ---
    assert response.status_code == status.HTTP_200_OK
    user_response_data = response.json()
    assert user_response_data["id"] == str(expected_user_id)
    assert user_response_data["email"] == user_a_data["email"]
    assert user_response_data["username"] == user_a_data["username"]
    assert user_response_data["full_name"] == user_a_data["full_name"]
    assert "disabled" in user_response_data
    assert "hashed_password" not in user_response_data
    assert "created_at" in user_response_data

async def test_read_users_me_unauthorized_no_token(test_async_client: AsyncClient):
    """
    Testa o acesso ao endpoint `/users/me` sem fornecer um token de autenticação.
    """
    # --- Arrange ---
    users_me_url = f"{settings.API_V1_STR}/auth/users/me"

    # --- Act ---
    response = await test_async_client.get(users_me_url)

    # --- Assert ---
    assert response.status_code == status.HTTP_401_UNAUTHORIZED
    assert "Not authenticated" in response.json()["detail"]

async def test_read_users_me_invalid_token(test_async_client: AsyncClient, mocker):
    """
    Testa o acesso ao endpoint `/users/me` fornecendo um token JWT inválido/malformado.
    """
    # --- Arrange ---
    users_me_url = f"{settings.API_V1_STR}/auth/users/me"
    invalid_token_headers = {"Authorization": "Bearer an.invalid.jwt.token"}
    mocker.patch("app.core.security.logger")

    # --- Act ---
    response = await test_async_client.get(users_me_url, headers=invalid_token_headers)

    # --- Assert ---
    assert response.status_code == status.HTTP_401_UNAUTHORIZED
    error_detail = response.json()["detail"]
    expected_error_message_part_pt = "não foi possível validar as credenciais"
    assert expected_error_message_part_pt.lower() in error_detail.lower()

# ========================
# --- Testes de PUT /users/me ---
# ========================
async def test_update_me_success(test_async_client: AsyncClient, mocker, auth_headers_a, test_user_a_token_and_id):
    """
    Testa a atualização bem-sucedida dos dados do usuário autenticado.
    """
    # --- Arrange ---
    token, user_id_a = test_user_a_token_and_id
    url = f"{settings.API_V1_STR}/auth/users/me"
    update_payload = {"full_name": "User A Updated Name"}

    mock_updated_user = MagicMock(spec=UserInDB)
    mock_api_user_return = MagicMock(spec=User)
    mock_api_user_return.id = user_id_a
    mock_api_user_return.username = user_a_data["username"]
    mock_api_user_return.email = user_a_data["email"]
    mock_api_user_return.full_name = update_payload["full_name"]
    mock_api_user_return.disabled = False
    mock_crud_update = mocker.patch("app.routers.auth.user_crud.update_user", return_value=mock_updated_user)
    mocker.patch("app.routers.auth.User.model_validate", return_value=mock_api_user_return)

    # --- Act ---
    response = await test_async_client.put(url, json=update_payload, headers=auth_headers_a)

    # --- Assert ---
    assert response.status_code == status.HTTP_200_OK
    response_data = response.json()
    assert response_data["full_name"] == update_payload["full_name"]
    assert response_data["id"] == str(user_id_a)

    mock_crud_update.assert_called_once()
    call_args, call_kwargs = mock_crud_update.call_args
    assert call_kwargs['user_id'] == user_id_a
    crud_update_payload_arg = None
    if 'user_update' in call_kwargs:
        crud_update_payload_arg = call_kwargs['user_update']
    else:
         pytest.fail("Argumento 'user_update' não encontrado na chamada mockada do CRUD.")

    assert isinstance(crud_update_payload_arg, UserUpdate)
    assert crud_update_payload_arg.full_name == update_payload["full_name"]
    assert crud_update_payload_arg.email is None

async def test_update_me_password_success(test_async_client: AsyncClient, mocker, auth_headers_a, test_user_a_token_and_id):
    """
    Testa a atualização bem-sucedida da senha do usuário autenticado.
    """
    # --- Arrange ---
    token, user_id_a = test_user_a_token_and_id
    url = f"{settings.API_V1_STR}/auth/users/me"
    new_password = "newpassword123!"
    update_payload = {"password": new_password}

    mock_updated_user = MagicMock(spec=UserInDB)
    mock_api_user_return = MagicMock(spec=User)
    mock_api_user_return.id = user_id_a
    mock_api_user_return.username = user_a_data["username"]
    mock_api_user_return.email = user_a_data["email"]
    mock_api_user_return.full_name = user_a_data["full_name"]
    mock_api_user_return.disabled = False
    mock_crud_update = mocker.patch("app.routers.auth.user_crud.update_user", return_value=mock_updated_user)
    mocker.patch("app.routers.auth.User.model_validate", return_value=mock_api_user_return)

    # --- Act ---
    response = await test_async_client.put(url, json=update_payload, headers=auth_headers_a)

    # --- Assert ---
    assert response.status_code == status.HTTP_200_OK

    mock_crud_update.assert_called_once()
    call_args, call_kwargs = mock_crud_update.call_args
    assert call_kwargs['user_id'] == user_id_a

    crud_update_payload_arg = call_kwargs.get('user_update')
    assert crud_update_payload_arg is not None
    assert isinstance(crud_update_payload_arg, UserUpdate)
    assert crud_update_payload_arg.password == new_password
    assert crud_update_payload_arg.full_name is None

async def test_update_me_user_crud_returns_none(test_async_client: AsyncClient, mocker, auth_headers_a, test_user_a_token_and_id):
    """
    Testa o comportamento da rota PUT /users/me quando
    user_crud.update_user retorna None (resultando em 500 devido ao except genérico).
    """
    # --- Arrange ---
    token, user_id_a = test_user_a_token_and_id
    url = f"{settings.API_V1_STR}/auth/users/me"
    update_payload = {"full_name": "Nome Nao Aplicado"}
    mock_crud_update = mocker.patch("app.routers.auth.user_crud.update_user", return_value=None)

    # --- Act ---
    response = await test_async_client.put(url, json=update_payload, headers=auth_headers_a)

    # --- Assert ---
    assert response.status_code == status.HTTP_500_INTERNAL_SERVER_ERROR
    assert "Ocorreu um erro inesperado durante a atualização do usuário." in response.json()["detail"] # Mensagem mantida do original

    mock_crud_update.assert_called_once()
    call_args, call_kwargs = mock_crud_update.call_args
    assert call_kwargs['user_id'] == user_id_a
    crud_update_payload_arg = call_kwargs.get('user_update')
    assert isinstance(crud_update_payload_arg, UserUpdate)
    assert crud_update_payload_arg.full_name == update_payload["full_name"]

async def test_update_me_duplicate_key_error(test_async_client: AsyncClient, mocker, auth_headers_a, test_user_a_token_and_id):
    """
    Testa o tratamento de DuplicateKeyError na rota PUT /users/me.
    """
    # --- Arrange ---
    token, user_id_a = test_user_a_token_and_id
    url = f"{settings.API_V1_STR}/auth/users/me"
    duplicate_email = "email.duplicado@teste.com"
    update_payload = {"email": duplicate_email}

    simulated_error = DuplicateKeyError("Erro de chave duplicada simulado")
    mock_crud_update = mocker.patch("app.routers.auth.user_crud.update_user", side_effect=simulated_error)

    # --- Act ---
    response = await test_async_client.put(url, json=update_payload, headers=auth_headers_a)

    # --- Assert ---
    assert response.status_code == status.HTTP_409_CONFLICT
    assert f"o e-mail '{duplicate_email}' já está em uso" in response.json()["detail"]

    mock_crud_update.assert_called_once()
    call_args, call_kwargs = mock_crud_update.call_args
    assert call_kwargs['user_id'] == user_id_a
    crud_update_payload_arg = call_kwargs.get('user_update')
    assert isinstance(crud_update_payload_arg, UserUpdate)
    assert crud_update_payload_arg.email == update_payload["email"]

async def test_update_me_generic_exception(test_async_client: AsyncClient, mocker, auth_headers_a, test_user_a_token_and_id):
    """
    Testa o tratamento de exceção genérica na rota PUT /users/me.
    """
    # --- Arrange ---
    token, user_id_a = test_user_a_token_and_id
    url = f"{settings.API_V1_STR}/auth/users/me"
    update_payload = {"full_name": "Nome Inalterado"}

    simulated_error = Exception("Erro genérico simulado no update do CRUD")
    mock_crud_update = mocker.patch("app.routers.auth.user_crud.update_user", side_effect=simulated_error)

    # --- Act ---
    response = await test_async_client.put(url, json=update_payload, headers=auth_headers_a)

    # --- Assert ---
    assert response.status_code == status.HTTP_500_INTERNAL_SERVER_ERROR
    assert "Ocorreu um erro inesperado durante a atualização do usuário." in response.json()["detail"]

    mock_crud_update.assert_called_once()
    call_args, call_kwargs = mock_crud_update.call_args
    assert call_kwargs['user_id'] == user_id_a
    crud_update_payload_arg = call_kwargs.get('user_update')
    assert isinstance(crud_update_payload_arg, UserUpdate)
    assert crud_update_payload_arg.full_name == update_payload["full_name"]

# ========================
# --- Testes de DELETE /users/me ---
# ========================
async def test_delete_me_success(test_async_client: AsyncClient, mocker, auth_headers_a, test_user_a_token_and_id):
    """
    Testa a deleção bem-sucedida da conta do usuário autenticado.
    """
    # --- Arrange ---
    token, user_id_a = test_user_a_token_and_id
    url = f"{settings.API_V1_STR}/auth/users/me"

    mock_crud_delete = mocker.patch("app.routers.auth.user_crud.delete_user", return_value=True)

    # --- Act ---
    response = await test_async_client.delete(url, headers=auth_headers_a)

    # --- Assert ---
    assert response.status_code == status.HTTP_204_NO_CONTENT

    mock_crud_delete.assert_called_once()
    call_args, call_kwargs = mock_crud_delete.call_args
    found_user_id_arg = False
    if len(call_args) > 1 and call_args[1] == user_id_a:
         found_user_id_arg = True
    elif call_kwargs.get('user_id') == user_id_a:
         found_user_id_arg = True
    assert found_user_id_arg is True

async def test_delete_me_crud_returns_false(test_async_client: AsyncClient, mocker, auth_headers_a, test_user_a_token_and_id):
    """
    Testa o comportamento de DELETE /users/me quando
    user_crud.delete_user retorna False (resultando em 500 devido ao except genérico).
    """
    # --- Arrange ---
    token, user_id_a = test_user_a_token_and_id
    url = f"{settings.API_V1_STR}/auth/users/me"

    mock_crud_delete = mocker.patch("app.routers.auth.user_crud.delete_user", return_value=False)

    # --- Act ---
    response = await test_async_client.delete(url, headers=auth_headers_a)

    # --- Assert ---
    assert response.status_code == status.HTTP_500_INTERNAL_SERVER_ERROR
    assert "Ocorreu um erro inesperado durante a deleção do usuário." in response.json()["detail"]

    mock_crud_delete.assert_called_once()
    call_args, call_kwargs = mock_crud_delete.call_args
    found_user_id_arg = False
    if len(call_args) > 1 and call_args[1] == user_id_a:
         found_user_id_arg = True
    elif call_kwargs.get('user_id') == user_id_a:
         found_user_id_arg = True
    assert found_user_id_arg is True

async def test_delete_me_crud_generic_exception(test_async_client: AsyncClient, mocker, auth_headers_a, test_user_a_token_and_id): # type: ignore
    """
    Testa o tratamento de exceção genérica na rota DELETE /users/me
    quando o CRUD levanta um erro.
    """
    # --- Arrange ---
    token, user_id_a = test_user_a_token_and_id
    url = f"{settings.API_V1_STR}/auth/users/me"

    # Mock user_crud.delete_user para levantar Exception genérica
    simulated_error = Exception("Erro genérico simulado no delete do CRUD")
    mock_crud_delete = mocker.patch("app.routers.auth.user_crud.delete_user", side_effect=simulated_error)

    # --- Act ---
    response = await test_async_client.delete(url, headers=auth_headers_a)

    # --- Assert ---
    assert response.status_code == status.HTTP_500_INTERNAL_SERVER_ERROR
    assert "Ocorreu um erro inesperado durante a deleção do usuário." in response.json()["detail"]

    # Verificar se user_crud.delete_user foi chamado
    mock_crud_delete.assert_called_once()
    call_args, call_kwargs = mock_crud_delete.call_args
    found_user_id_arg = False
    if len(call_args) > 1 and call_args[1] == user_id_a:
         found_user_id_arg = True
    elif call_kwargs.get('user_id') == user_id_a:
         found_user_id_arg = True
    assert found_user_id_arg is True

================================================================================
Capítulo 19: tests/test_core_config.py
================================================================================

# tests/test_core_config.py
"""
Este módulo contém testes para a classe de configurações da aplicação (`app.core.config.Settings`).
O foco principal é validar a lógica condicional relacionada às configurações de e-mail,
garantindo que as credenciais de e-mail sejam obrigatórias apenas quando
a funcionalidade de e-mail está explicitamente habilitada (`MAIL_ENABLED=True`).
"""

# ========================
# --- Importações ---
# ========================
# Removida 'from logging import config' pois 'config' não era usado.
import os
from unittest.mock import patch # Mantido pois foi usado no original.
import pytest
from pydantic import ValidationError
import importlib # Mantido pois foi usado no original (mesmo que o teste específico tenha sido removido/alterado depois).

# --- Módulo da Aplicação ---
from app.core.config import Settings
import app.core.config as config_module # Mantido como no original

# ========================
# --- Testes de Validação de Configurações de E-mail ---
# ========================
def test_settings_mail_enabled_and_missing_credentials_fails_validation(monkeypatch):
    """
    Testa se a instanciação de `Settings` falha com `ValidationError` (ou `ValueError`)
    quando `MAIL_ENABLED` é True, mas uma ou mais credenciais de e-mail
    (MAIL_USERNAME, MAIL_PASSWORD, MAIL_FROM, MAIL_SERVER) estão ausentes.

    Cenário: MAIL_ENABLED=True, MAIL_USERNAME não definido.
    """
    print("\nTeste: MAIL_ENABLED=True e falta MAIL_USERNAME -> Deve falhar a validação.")

    # --- Arrange: Configurar variáveis de ambiente ---
    print("  Limpando variáveis de ambiente de e-mail...")
    monkeypatch.delenv("MAIL_ENABLED", raising=False)
    monkeypatch.delenv("MAIL_USERNAME", raising=False)
    monkeypatch.delenv("MAIL_PASSWORD", raising=False)
    monkeypatch.delenv("MAIL_FROM", raising=False)
    monkeypatch.delenv("MAIL_PORT", raising=False)
    monkeypatch.delenv("MAIL_SERVER", raising=False)
    # No seu original, MAIL_TLS e MAIL_SSL eram `deprecated="auto"` ou removidos aqui, vou seguir
    # como estava no último código que me forneceu
    monkeypatch.delenv("MAIL_STARTTLS", raising=False) # Presumindo que você quis dizer MAIL_STARTTLS (TLS original é ambíguo)
    monkeypatch.delenv("MAIL_SSL_TLS", raising=False)  # Presumindo que você quis dizer MAIL_SSL_TLS

    print("  Definindo variáveis de ambiente obrigatórias (não-email)...")
    monkeypatch.setenv("PROJECT_NAME", "Test Project")
    monkeypatch.setenv("API_V1_STR", "/api/v1")
    # 'ENVIRONMENT' e 'REFRESH_TOKEN_EXPIRE_DAYS' não estão em Settings, mas mantendo se estavam no seu teste
    # monkeypatch.setenv("ENVIRONMENT", "test") # Removido se não presente em Settings
    monkeypatch.setenv("JWT_SECRET_KEY", "test_jwt_secret_key_for_config_test")
    monkeypatch.setenv("ACCESS_TOKEN_EXPIRE_MINUTES", "30")
    # monkeypatch.setenv("REFRESH_TOKEN_EXPIRE_DAYS", "7") # Removido se não presente em Settings
    monkeypatch.setenv("MONGODB_URL", "mongodb://localhost:27017/test_config_db")
    monkeypatch.setenv("DATABASE_NAME", "test_config_db")

    print("  Definindo cenário de teste: MAIL_ENABLED=True, MAIL_USERNAME ausente.")
    monkeypatch.setenv("MAIL_ENABLED", "True")
    monkeypatch.setenv("MAIL_PASSWORD", "secretpassword")
    monkeypatch.setenv("MAIL_FROM", "tests@example.com")
    monkeypatch.setenv("MAIL_SERVER", "smtp.example.com")
    monkeypatch.setenv("MAIL_PORT", "587")
    monkeypatch.setenv("MAIL_STARTTLS", "True") # Se for o nome correto da setting

    # --- Act & Assert: Tentar instanciar Settings e verificar a exceção ---
    print("  Tentando instanciar Settings, esperando exceção...")
    with pytest.raises((ValueError, ValidationError)) as exc_info:
        Settings(_env_file=None)

    expected_error_message_part = "MAIL_USERNAME, MAIL_PASSWORD, MAIL_FROM e MAIL_SERVER devem ser definidos"
    print(f"  Exceção recebida: {exc_info.value}")
    assert expected_error_message_part in str(exc_info.value), \
        f"A mensagem de erro não contém '{expected_error_message_part}'. Erro: {str(exc_info.value)}"
    print("  Validação falhou como esperado.")


def test_settings_mail_disabled_and_credentials_not_needed_passes_validation(monkeypatch):
    """
    Testa se a instanciação de `Settings` é bem-sucedida quando `MAIL_ENABLED`
    é False, mesmo que as credenciais de e-mail estejam ausentes.

    Neste cenário, os campos de credenciais de e-mail devem ser opcionais
    e podem ser None.
    """
    print("\nTeste: MAIL_ENABLED=False, credenciais ausentes -> Deve passar a validação.")

    # --- Arrange: Configurar variáveis de ambiente ---
    print("  Limpando variáveis de ambiente de e-mail...")
    monkeypatch.delenv("MAIL_ENABLED", raising=False)
    monkeypatch.delenv("MAIL_USERNAME", raising=False)
    monkeypatch.delenv("MAIL_PASSWORD", raising=False)
    monkeypatch.delenv("MAIL_FROM", raising=False)
    monkeypatch.delenv("MAIL_PORT", raising=False)
    monkeypatch.delenv("MAIL_SERVER", raising=False)
    monkeypatch.delenv("MAIL_STARTTLS", raising=False) # Mantendo consistência com nomes de settings
    monkeypatch.delenv("MAIL_SSL_TLS", raising=False)  # Mantendo consistência

    print("  Definindo variáveis de ambiente obrigatórias (não-email)...")
    monkeypatch.setenv("PROJECT_NAME", "Test Project Disabled Mail")
    monkeypatch.setenv("API_V1_STR", "/api/v1")
    # monkeypatch.setenv("ENVIRONMENT", "test") # Removido se não usado em Settings
    monkeypatch.setenv("JWT_SECRET_KEY", "test_jwt_secret_for_disabled_mail")
    monkeypatch.setenv("ACCESS_TOKEN_EXPIRE_MINUTES", "60")
    # monkeypatch.setenv("REFRESH_TOKEN_EXPIRE_DAYS", "14") # Removido se não usado em Settings
    monkeypatch.setenv("MONGODB_URL", "mongodb://localhost:27017/test_disabled_mail_db")
    monkeypatch.setenv("DATABASE_NAME", "test_disabled_mail_db")

    print("  Definindo cenário de teste: MAIL_ENABLED=False.")
    monkeypatch.setenv("MAIL_ENABLED", "False")

    # --- Act & Assert: Tentar instanciar Settings e verificar se NÃO levanta exceção ---
    print("  Tentando instanciar Settings, esperando sucesso...")
    try:
        settings_instance = Settings(_env_file=None)
        print(f"  Settings instanciado com sucesso: MAIL_ENABLED={settings_instance.MAIL_ENABLED}")
        assert not settings_instance.MAIL_ENABLED, "MAIL_ENABLED deveria ser False."
        assert settings_instance.MAIL_USERNAME is None, "MAIL_USERNAME deveria ser None."
        assert settings_instance.MAIL_PASSWORD is None, "MAIL_PASSWORD deveria ser None."
        assert settings_instance.MAIL_FROM is None, "MAIL_FROM deveria ser None."
        assert settings_instance.MAIL_SERVER is None, "MAIL_SERVER deveria ser None."
        assert settings_instance.MAIL_PORT == 587, "MAIL_PORT deveria ter seu valor default (e.g., 587)."
    except (ValueError, ValidationError) as e: # pragma: no cover
        pytest.fail(
            f"A validação de Settings falhou inesperadamente quando MAIL_ENABLED=False. Erro: {e}\n"
            f"Variáveis de ambiente configuradas: {dict(os.environ)}"
        )
    print("  Validação passou como esperado com MAIL_ENABLED=False.")


def test_settings_mail_enabled_and_all_credentials_provided_passes_validation(monkeypatch):
    """
    Testa se a instanciação de `Settings` é bem-sucedida quando `MAIL_ENABLED`
    é True e TODAS as credenciais de e-mail necessárias estão definidas.
    """
    print("\nTeste: MAIL_ENABLED=True e todas credenciais de e-mail fornecidas -> Deve passar a validação.")

    # --- Arrange: Configurar variáveis de ambiente ---
    print("  Limpando variáveis de ambiente de e-mail...")
    monkeypatch.delenv("MAIL_ENABLED", raising=False)
    monkeypatch.delenv("MAIL_USERNAME", raising=False)
    monkeypatch.delenv("MAIL_PASSWORD", raising=False)
    monkeypatch.delenv("MAIL_FROM", raising=False)
    monkeypatch.delenv("MAIL_PORT", raising=False)
    monkeypatch.delenv("MAIL_SERVER", raising=False)
    monkeypatch.delenv("MAIL_STARTTLS", raising=False) # Mantendo consistência
    monkeypatch.delenv("MAIL_SSL_TLS", raising=False)  # Mantendo consistência

    print("  Definindo variáveis de ambiente obrigatórias (não-email)...")
    monkeypatch.setenv("PROJECT_NAME", "Test Project All Mail")
    monkeypatch.setenv("API_V1_STR", "/api/v1")
    # monkeypatch.setenv("ENVIRONMENT", "test") # Removido se não usado em Settings
    monkeypatch.setenv("JWT_SECRET_KEY", "test_jwt_secret_for_all_mail")
    monkeypatch.setenv("ACCESS_TOKEN_EXPIRE_MINUTES", "15")
    # monkeypatch.setenv("REFRESH_TOKEN_EXPIRE_DAYS", "3") # Removido se não usado em Settings
    monkeypatch.setenv("MONGODB_URL", "mongodb://localhost:27017/test_all_mail_db")
    monkeypatch.setenv("DATABASE_NAME", "test_all_mail_db")

    print("  Definindo cenário de teste: MAIL_ENABLED=True e todas credenciais de e-mail presentes.")
    monkeypatch.setenv("MAIL_ENABLED", "True")
    monkeypatch.setenv("MAIL_USERNAME", "test_mailer_user")
    monkeypatch.setenv("MAIL_PASSWORD", "supersecretmailerpassword")
    monkeypatch.setenv("MAIL_FROM", "noreply_tests@example.com")
    monkeypatch.setenv("MAIL_SERVER", "smtp.mailservice.example.com")
    monkeypatch.setenv("MAIL_PORT", "465")
    monkeypatch.setenv("MAIL_SSL_TLS", "True") # Usando MAIL_SSL_TLS para SSL
    monkeypatch.setenv("MAIL_STARTTLS", "False") # Desabilitando STARTTLS se SSL_TLS é True

    # --- Act & Assert: Tentar instanciar Settings e verificar se NÃO levanta exceção ---
    print("  Tentando instanciar Settings, esperando sucesso...")
    try:
        settings_instance = Settings(_env_file=None)
        print(f"  Settings instanciado com sucesso: MAIL_ENABLED={settings_instance.MAIL_ENABLED}, MAIL_USERNAME='{settings_instance.MAIL_USERNAME}'")
        assert settings_instance.MAIL_ENABLED, "MAIL_ENABLED deveria ser True."
        assert settings_instance.MAIL_USERNAME == "test_mailer_user", "MAIL_USERNAME não corresponde."
        assert settings_instance.MAIL_PASSWORD == "supersecretmailerpassword"
        assert settings_instance.MAIL_FROM == "noreply_tests@example.com"
        assert settings_instance.MAIL_SERVER == "smtp.mailservice.example.com"
        assert settings_instance.MAIL_PORT == 465
    except (ValueError, ValidationError) as e: # pragma: no cover
        pytest.fail(
            "A validação de Settings falhou inesperadamente quando MAIL_ENABLED=True e todas as credenciais "
            f"de e-mail foram fornecidas. Erro: {e}\n"
            f"Variáveis de ambiente configuradas: {dict(os.environ)}"
        )
    print("  Validação passou como esperado com MAIL_ENABLED=True e todas credenciais de e-mail presentes.")

def test_settings_missing_required_pydantic_field_fails(monkeypatch):
    """
    Testa se `Settings` falha se um campo Pydantic obrigatório (não email) falta.
    """
    print("\nTeste: Campo Pydantic obrigatório ausente -> Deve falhar a validação.")
    monkeypatch.delenv("JWT_SECRET_KEY", raising=False) # Removendo campo obrigatório
    monkeypatch.setenv("MONGODB_URL", "mongodb://localhost:27017/test_config_db") # Mantendo outro obrigatório
    monkeypatch.setenv("MAIL_ENABLED", "False") # Desabilitar checagem de email

    with pytest.raises(ValidationError) as exc_info:
        Settings(_env_file=None)

    assert "JWT_SECRET_KEY" in str(exc_info.value).upper() or "FIELD REQUIRED" in str(exc_info.value).upper()
    print(f"  Pydantic ValidationError capturada como esperado: {exc_info.value}")

# --- Testes de Validação de Webhook ---
def test_webhook_secret_required_with_url(monkeypatch):
    monkeypatch.setenv("WEBHOOK_URL", "http://example.com/webhook")
    monkeypatch.delenv("WEBHOOK_SECRET", raising=False)

    with pytest.raises(ValidationError) as exc_info:
        Settings()

    assert "WEBHOOK_SECRET deve ser definido" in str(exc_info.value)

================================================================================
Capítulo 20: tests/test_core_dependencies.py
================================================================================

# tests/test_core_dependencies.py
"""
Este módulo contém testes unitários para as dependências de segurança
definidas em `app.core.dependencies`.

As dependências testadas são:
- `get_current_user`: Responsável por decodificar o token JWT, validar o payload
  e buscar o usuário correspondente no banco de dados.
- `get_current_active_user`: Uma dependência que consome o resultado de
  `get_current_user` e verifica se o usuário não está desativado.

Os testes utilizam mocks para isolar as dependências de chamadas reais
ao banco de dados ou funções de decodificação de token.
"""

# ========================
# --- Importações ---
# ========================
import uuid
from datetime import datetime, timezone
from unittest.mock import AsyncMock, MagicMock, patch
import pytest
from fastapi import HTTPException, status

# --- Módulos da Aplicação ---
from app.core.dependencies import (get_current_active_user, get_current_user,
                                   oauth2_scheme) # oauth2_scheme não usado diretamente nos testes, mas mantido
from app.models.token import TokenPayload
from app.models.user import UserInDB

# ========================
# --- Marcador Global de Teste ---
# ========================
pytestmark = pytest.mark.asyncio

# ========================
# --- Fixtures para Mocks Comuns ---
# ========================
@pytest.fixture
def mock_db() -> AsyncMock:
    """
    Fixture que retorna um `AsyncMock` para simular a dependência do banco de dados (`DbDep`).
    """
    return AsyncMock()

@pytest.fixture
def mock_valid_token_str() -> str:
    """
    Fixture que retorna uma string de token JWT mockada e válida.
    """
    return "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c"

# ========================
# --- Testes para a dependência `get_current_user` ---
# ========================
async def test_get_current_user_success(
    mock_db: AsyncMock,
    mock_valid_token_str: str
):
    """
    Testa o cenário de sucesso para `get_current_user`.

    Verifica se:
    - `decode_token` é chamado corretamente com o token fornecido.
    - `user_crud.get_user_by_id` é chamado com o ID do usuário do payload do token.
    - A função retorna o objeto `UserInDB` esperado.
    """
    # --- Arrange ---
    test_user_id = uuid.uuid4()
    test_username = "test_active_user"
    expected_user_obj = UserInDB(
        id=test_user_id,
        username=test_username,
        email="testuser@example.com",
        hashed_password="fake_hashed_password",
        disabled=False,
        created_at=datetime.now(timezone.utc)
    )
    mock_token_payload = TokenPayload(sub=test_user_id, username=test_username)

    with patch("app.core.dependencies.decode_token", return_value=mock_token_payload) as mock_decode_jwt, \
         patch("app.core.dependencies.user_crud.get_user_by_id", return_value=expected_user_obj) as mock_get_user:

        # --- Act ---
        retrieved_user = await get_current_user(db=mock_db, token=mock_valid_token_str)

        # --- Assert ---
        mock_decode_jwt.assert_called_once_with(mock_valid_token_str)
        mock_get_user.assert_awaited_once_with(db=mock_db, user_id=test_user_id)
        assert retrieved_user == expected_user_obj, "Usuário retornado não é o esperado."


async def test_get_current_user_invalid_or_expired_token(
    mock_db: AsyncMock,
    mock_valid_token_str: str
):
    """
    Testa `get_current_user` quando `decode_token` falha (retorna None),
    simulando um token JWT inválido, malformado ou expirado.

    Verifica se:
    - Uma `HTTPException` com status 401 é levantada.
    - A mensagem de detalhe da exceção é a esperada.
    """
    # --- Arrange ---
    with patch("app.core.dependencies.decode_token", return_value=None) as mock_decode_jwt:

        # --- Act & Assert ---
        with pytest.raises(HTTPException) as exc_info:
            await get_current_user(db=mock_db, token=mock_valid_token_str)

        assert exc_info.value.status_code == status.HTTP_401_UNAUTHORIZED, "Status code não é 401."
        assert "Não foi possível validar as credenciais" in exc_info.value.detail, \
            "Mensagem de detalhe da exceção não é a esperada."
        mock_decode_jwt.assert_called_once_with(mock_valid_token_str)

async def test_get_current_user_user_not_found_in_db(
    mock_db: AsyncMock,
    mock_valid_token_str: str
):
    """
    Testa `get_current_user` quando o token é válido e decodificado com sucesso,
    mas o ID de usuário (sub) contido no payload do token não corresponde
    a nenhum usuário no banco de dados.

    Verifica se:
    - Uma `HTTPException` com status 401 é levantada.
    - A mensagem de detalhe da exceção é a esperada.
    - `user_crud.get_user_by_id` é chamado.
    """
    # --- Arrange ---
    test_user_id_not_in_db = uuid.uuid4()
    mock_token_payload = TokenPayload(sub=test_user_id_not_in_db, username="ghost_user")

    with patch("app.core.dependencies.decode_token", return_value=mock_token_payload) as mock_decode_jwt, \
         patch("app.core.dependencies.user_crud.get_user_by_id", return_value=None) as mock_get_user:

        # --- Act & Assert ---
        with pytest.raises(HTTPException) as exc_info:
            await get_current_user(db=mock_db, token=mock_valid_token_str)

        assert exc_info.value.status_code == status.HTTP_401_UNAUTHORIZED, "Status code não é 401."
        assert "Não foi possível validar as credenciais" in exc_info.value.detail, \
            "Mensagem de detalhe da exceção não é a esperada para usuário não encontrado."
        mock_decode_jwt.assert_called_once_with(mock_valid_token_str)
        mock_get_user.assert_awaited_once_with(db=mock_db, user_id=test_user_id_not_in_db)

# ========================
# --- Testes para a dependência `get_current_active_user` ---
# ========================
async def test_get_current_active_user_when_user_is_disabled():
    """
    Testa `get_current_active_user` passando um objeto `UserInDB`
    que representa um usuário desativado (`disabled=True`).

    Verifica se:
    - Uma `HTTPException` com status 400 Bad Request é levantada.
    - A mensagem de detalhe da exceção indica "Usuário inativo".
    """
    # --- Arrange ---
    disabled_user_mock = UserInDB(
        id=uuid.uuid4(),
        username="inactive_user",
        email="inactive@example.com",
        hashed_password="fake_hashed_password",
        disabled=True,
        created_at=datetime.now(timezone.utc)
    )

    # --- Act & Assert ---
    with pytest.raises(HTTPException) as exc_info:
        await get_current_active_user(current_user=disabled_user_mock)

    assert exc_info.value.status_code == status.HTTP_400_BAD_REQUEST, "Status code não é 400."
    assert "Usuário inativo" in exc_info.value.detail, "Mensagem de detalhe da exceção não é 'Usuário inativo'."


async def test_get_current_active_user_when_user_is_active():
    """
    Testa `get_current_active_user` passando um objeto `UserInDB`
    que representa um usuário ativo (`disabled=False`).

    Verifica se:
    - A função retorna o mesmo objeto de usuário que foi passado.
    - Nenhuma exceção é levantada.
    """
    # --- Arrange ---
    active_user_mock = UserInDB(
        id=uuid.uuid4(),
        username="active_user",
        email="active_user@example.com",
        hashed_password="fake_hashed_password",
        disabled=False,
        created_at=datetime.now(timezone.utc)
    )

    # --- Act ---
    returned_user = await get_current_active_user(current_user=active_user_mock)

    # --- Assert ---
    assert returned_user == active_user_mock, "Usuário ativo retornado não é o mesmo que foi passado."


async def test_get_current_user_invalid_sub_uuid_format(mock_db, mock_valid_token_str, mocker): # type: ignore
    """
    Testa get_current_user quando o 'sub' no token não é um UUID válido.
    """
    # --- Arrange ---
    invalid_sub_str = "not-a-uuid-at-all"
    # No seu código original, mock_payload_dict não era usado, mas sim mock_token_payload_obj
    mock_token_payload_obj = MagicMock()
    mock_token_payload_obj.sub = invalid_sub_str # O atributo 'sub' tem a string inválida

    mock_decode = mocker.patch("app.core.dependencies.decode_token", return_value=mock_token_payload_obj)
    mock_get_user = mocker.patch("app.core.dependencies.user_crud.get_user_by_id", new_callable=AsyncMock)

    # --- Act & Assert ---
    with pytest.raises(HTTPException) as exc_info:
        await get_current_user(db=mock_db, token=mock_valid_token_str)

    assert exc_info.value.status_code == status.HTTP_401_UNAUTHORIZED
    assert "Não foi possível validar as credenciais" in exc_info.value.detail

    mock_decode.assert_called_once_with(mock_valid_token_str)
    mock_get_user.assert_not_called()

================================================================================
Capítulo 21: tests/test_core_email.py
================================================================================

# tests/test_core_email.py
"""
Este módulo contém testes unitários para as funções de envio de e-mail
definidas em `app.core.email`.

Os testes verificam:
- Comportamento quando o envio de e-mail está desabilitado (`MAIL_ENABLED=False`).
- Comportamento quando faltam credenciais de e-mail obrigatórias.
- Chamada correta à biblioteca `fastapi-mail` (mockada) para envio de e-mails
  com templates HTML e em texto puro.
- Tratamento de exceções durante o envio de e-mails.
- A lógica específica da função `send_urgent_task_notification`, verificando
  os argumentos passados para a função de envio genérica `send_email_async`.

Todos os envios reais de e-mail são mockados para evitar efeitos colaterais
e dependências externas durante os testes.
"""

# ========================
# --- Importações ---
# ========================
import uuid # Mantida, embora não usada diretamente neste snapshot específico, pode ser em versões futuras.
import logging
from unittest.mock import AsyncMock, patch, ANY # ANY é usado implicitamente ou explicitamente em alguns mocks

import pytest
from fastapi_mail import MessageSchema, MessageType

# --- Módulos da Aplicação ---
from app.core.config import settings
from app.core.email import (conf, send_email_async, send_urgent_task_notification) # conf não é usado aqui
from app.core import email as email_module # Usado para chamar email_module.send_urgent_task_notification

# ========================
# --- Marcador Global de Teste ---
# ========================
pytestmark = pytest.mark.asyncio

# ========================
# --- Testes de Condições de Guarda para `send_email_async` ---
# ========================
async def test_send_email_async_when_mail_is_disabled(mocker, caplog):
    """
    Testa se `send_email_async` NÃO tenta enviar um e-mail e loga uma mensagem informativa
    quando a configuração `settings.MAIL_ENABLED` é `False`.
    """
    print("\nTeste: send_email_async com MAIL_ENABLED=False.")
    # --- Arrange ---
    mock_fastapi_mail_send_message = mocker.patch("app.core.email.fm.send_message", new_callable=AsyncMock)
    mocker.patch.object(settings, 'MAIL_ENABLED', False)
    print("  Mock: fm.send_message e settings.MAIL_ENABLED=False.")

    # --- Act ---
    print("  Atuando: Chamando send_email_async...")
    await send_email_async(
        subject="E-mail de Teste (Desabilitado)",
        recipient_to=["test_disabled@example.com"], # type: ignore (Pydantic EmailStr é validado em runtime)
        body={"info": "Este e-mail não deve ser enviado."},
        template_name="dummy_template_desabilitado.html"
    )

    # --- Assert ---
    mock_fastapi_mail_send_message.assert_not_called()
    found_log = False
    expected_message = "Envio de e-mail desabilitado nas configurações"
    for record in caplog.records:
        if expected_message in record.message:
            assert record.levelname == "WARNING"
            found_log = True
            break
    assert found_log, f"Log esperado contendo '{expected_message}' não encontrado. Logs: {caplog.text}"
    print("  Sucesso: E-mail não enviado e log de desativação presente.")


async def test_send_email_async_when_essential_credentials_are_missing(mocker):
    """
    Testa se `send_email_async` NÃO tenta enviar um e-mail e loga um erro
    quando `settings.MAIL_ENABLED` é `True`, mas faltam credenciais essenciais
    (como MAIL_USERNAME, MAIL_PASSWORD, etc.).
    """
    print("\nTeste: send_email_async com MAIL_ENABLED=True, mas faltando credenciais.")
    # --- Arrange ---
    mock_fastapi_mail_send_message = mocker.patch("app.core.email.fm.send_message", new_callable=AsyncMock)
    mocker.patch.object(settings, 'MAIL_ENABLED', True)
    mock_email_module_logger = mocker.patch("app.core.email.logger")
    essential_mail_fields = ['MAIL_USERNAME', 'MAIL_PASSWORD', 'MAIL_FROM', 'MAIL_SERVER']

    for missing_field in essential_mail_fields:
        print(f"  Testando cenário: Faltando '{missing_field}'...")
        # Define todas as credenciais, depois remove uma
        mocker.patch.object(settings, 'MAIL_USERNAME', 'test_user')
        mocker.patch.object(settings, 'MAIL_PASSWORD', 'test_password')
        mocker.patch.object(settings, 'MAIL_FROM', 'test_from@example.com') # type: ignore
        mocker.patch.object(settings, 'MAIL_SERVER', 'smtp.example.com')
        mocker.patch.object(settings, 'MAIL_PORT', 587) # Já coberto no original
        mocker.patch.object(settings, 'MAIL_STARTTLS', True) # Já coberto no original
        mocker.patch.object(settings, 'MAIL_SSL_TLS', False) # Já coberto no original

        mocker.patch.object(settings, missing_field, None)
        print(f"    Mock: {missing_field}=None, outras credenciais definidas.")

        mock_fastapi_mail_send_message.reset_mock()
        mock_email_module_logger.reset_mock()

        # --- Act ---
        await send_email_async(
            subject=f"Teste de Credenciais (Falta {missing_field})",
            recipient_to=["test_cred_missing@example.com"], # type: ignore
            body={"info": f"Teste com {missing_field} ausente."}
        )

        # --- Assert ---
        mock_fastapi_mail_send_message.assert_not_called()
        mock_email_module_logger.error.assert_called_once()
        log_call_args = mock_email_module_logger.error.call_args[0]
        assert "Configurações essenciais de e-mail ausentes" in log_call_args[0], \
            f"Log de erro para '{missing_field}' ausente não correspondeu. Log: {log_call_args[0]}"
        print(f"    Sucesso para '{missing_field}' ausente: E-mail não enviado e erro logado.")
    print("  Todos os cenários de credenciais ausentes verificados.")

# ========================
# --- Testes de Funcionalidade para `send_email_async` ---
# ========================
async def test_send_email_async_with_html_template_calls_fastapi_mail_correctly(mocker):
    """
    Testa se `send_email_async` chama `fm.send_message` (de `fastapi-mail`)
    corretamente quando um template HTML é especificado.
    """
    print("\nTeste: send_email_async com template HTML.")
    # --- Arrange ---
    mock_fastapi_mail_send_message = mocker.patch("app.core.email.fm.send_message", new_callable=AsyncMock)
    mocker.patch.object(settings, 'MAIL_ENABLED', True)
    mocker.patch.object(settings, 'MAIL_USERNAME', 'test_user_template')
    mocker.patch.object(settings, 'MAIL_PASSWORD', 'test_pass_template')
    mocker.patch.object(settings, 'MAIL_FROM', 'sender_template@example.com') # type: ignore
    mocker.patch.object(settings, 'MAIL_SERVER', 'smtp.template.example.com')
    mocker.patch.object(settings, 'MAIL_PORT', 587)
    mock_email_module_logger_info = mocker.patch("app.core.email.logger.info")
    print("  Mock: fm.send_message, settings de e-mail (habilitado), logger.info.")

    test_subject = "Assunto do E-mail com Template HTML"
    test_recipient = "recipient_html@example.com" # type: ignore
    test_body_dict_for_template = {"user_name": "Claudio", "item_name": "SmartTask"}
    test_template_file_name = "meu_template_email.html"

    # --- Act ---
    print(f"  Atuando: Chamando send_email_async com template '{test_template_file_name}'...")
    await send_email_async(
        subject=test_subject,
        recipient_to=[test_recipient],
        body=test_body_dict_for_template,
        template_name=test_template_file_name
    )

    # --- Assert ---
    mock_fastapi_mail_send_message.assert_called_once()
    message_arg_schema: MessageSchema = mock_fastapi_mail_send_message.call_args[0][0]
    template_arg_name_from_kwargs = mock_fastapi_mail_send_message.call_args.kwargs.get('template_name')

    assert isinstance(message_arg_schema, MessageSchema)
    assert message_arg_schema.subject == test_subject
    assert message_arg_schema.recipients == [test_recipient]
    assert message_arg_schema.template_body == test_body_dict_for_template
    assert message_arg_schema.body is None
    assert message_arg_schema.subtype == MessageType.html
    assert template_arg_name_from_kwargs == test_template_file_name
    assert mock_email_module_logger_info.call_count >= 2
    print(f"  Sucesso: fm.send_message chamado corretamente para template HTML.")


async def test_send_email_async_with_plain_text_calls_fastapi_mail_correctly(mocker):
    """
    Testa se `send_email_async` chama `fm.send_message` (de `fastapi-mail`)
    corretamente quando um corpo de e-mail em texto puro é especificado.
    """
    print("\nTeste: send_email_async com texto puro.")
    # --- Arrange ---
    mock_fastapi_mail_send_message = mocker.patch("app.core.email.fm.send_message", new_callable=AsyncMock)
    mocker.patch.object(settings, 'MAIL_ENABLED', True)
    mocker.patch.object(settings, 'MAIL_USERNAME', 'test_user_plain')
    mocker.patch.object(settings, 'MAIL_PASSWORD', 'test_pass_plain')
    mocker.patch.object(settings, 'MAIL_FROM', 'sender_plain@example.com') # type: ignore
    mocker.patch.object(settings, 'MAIL_SERVER', 'smtp.plain.example.com')
    mocker.patch.object(settings, 'MAIL_PORT', 587)
    mock_email_module_logger_info = mocker.patch("app.core.email.logger.info")
    print("  Mock: fm.send_message, settings de e-mail (habilitado), logger.info.")

    test_subject = "Assunto do E-mail em Texto Puro"
    test_recipient = "recipient_plain@example.com" # type: ignore
    test_plain_body_content = "Este é o corpo do e-mail em texto puro.\nCom múltiplas linhas."

    # --- Act ---
    print(f"  Atuando: Chamando send_email_async com texto puro...")
    await send_email_async(
        subject=test_subject,
        recipient_to=[test_recipient],
        body=None,
        plain_text_body=test_plain_body_content
    )

    # --- Assert ---
    mock_fastapi_mail_send_message.assert_called_once()
    message_arg_schema: MessageSchema = mock_fastapi_mail_send_message.call_args[0][0]
    template_arg_name_from_kwargs = mock_fastapi_mail_send_message.call_args.kwargs.get('template_name')

    assert isinstance(message_arg_schema, MessageSchema)
    assert message_arg_schema.subject == test_subject
    assert message_arg_schema.recipients == [test_recipient]
    assert message_arg_schema.template_body is None
    assert message_arg_schema.body == test_plain_body_content
    assert message_arg_schema.subtype == MessageType.plain
    assert template_arg_name_from_kwargs is None
    assert mock_email_module_logger_info.call_count >= 2
    print(f"  Sucesso: fm.send_message chamado corretamente para texto puro.")


async def test_send_email_async_handles_exception_from_fastapi_mail(mocker):
    """
    Testa o tratamento de erro em `send_email_async` quando a chamada
    a `fm.send_message` (de `fastapi-mail`) levanta uma exceção (ex: erro SMTP).
    """
    print("\nTeste: send_email_async tratando exceção do fm.send_message.")
    # --- Arrange ---
    simulated_smtp_error_message = "Simulated SMTP Connection Error (535 Authentication credentials invalid)"
    mock_fastapi_mail_send_message = mocker.patch(
        "app.core.email.fm.send_message",
        new_callable=AsyncMock,
        side_effect=Exception(simulated_smtp_error_message)
    )
    mocker.patch.object(settings, 'MAIL_ENABLED', True)
    mocker.patch.object(settings, 'MAIL_USERNAME', 'user_excp')
    mocker.patch.object(settings, 'MAIL_PASSWORD', 'pass_excp')
    mocker.patch.object(settings, 'MAIL_FROM', 'sender_excp@example.com') # type: ignore
    mocker.patch.object(settings, 'MAIL_SERVER', 'smtp.excp.example.com')
    mocker.patch.object(settings, 'MAIL_PORT', 587)
    mock_email_module_logger_exception = mocker.patch("app.core.email.logger.exception")
    print("  Mock: fm.send_message (para levantar erro), settings, logger.exception.")

    test_recipient_list = ["recipient_error@example.com"] # type: ignore

    # --- Act ---
    print(f"  Atuando: Chamando send_email_async (esperando que fm.send_message falhe)...")
    await send_email_async(
        subject="E-mail de Teste de Erro de Envio",
        recipient_to=test_recipient_list,
        body={"info": "Este envio deve falhar e ser logado."}
    )

    # --- Assert ---
    mock_fastapi_mail_send_message.assert_called_once()
    mock_email_module_logger_exception.assert_called_once()

    log_message_args = mock_email_module_logger_exception.call_args[0]
    logged_error_message_str = log_message_args[0]

    assert f"Erro ao enviar e-mail para {test_recipient_list}" in logged_error_message_str
    assert simulated_smtp_error_message in logged_error_message_str or \
           simulated_smtp_error_message in str(mock_email_module_logger_exception.call_args.kwargs.get('exc_info'))
    print("  Sucesso: Exceção do fm.send_message tratada e logada corretamente.")

# ========================
# --- Testes Unitários para `send_urgent_task_notification` ---
# ========================
@pytest.fixture(autouse=True)
def auto_mock_send_email_async_for_urgent_tests(mocker) -> AsyncMock:
    """
    Fixture que mocka automaticamente `app.core.email.send_email_async`
    para todos os testes de `send_urgent_task_notification` neste arquivo.
    """
    print("  Fixture (autouse): Mockando app.core.email.send_email_async.")
    mocked_function = mocker.patch("app.core.email.send_email_async", new_callable=AsyncMock)
    return mocked_function


async def test_send_urgent_task_notification_constructs_correct_arguments(
    auto_mock_send_email_async_for_urgent_tests: AsyncMock,
    mocker
):
    """
    Verifica se `send_urgent_task_notification` chama `send_email_async`
    com os argumentos corretos (assunto, destinatário, nome do template, e corpo do template)
    quando todos os dados de entrada são fornecidos.
    """
    print("\nTeste: send_urgent_task_notification com todos os dados e FRONTEND_URL.")
    # --- Arrange ---
    test_frontend_base_url = "http://smarttask.dev"
    mocker.patch.object(settings, 'FRONTEND_URL', test_frontend_base_url)
    print(f"  Mock: settings.FRONTEND_URL='{test_frontend_base_url}'.")

    user_email_addr = "urgent_user@example.com" # type: ignore
    user_full_name = "Urgent User Name"
    task_display_title = "URGENT: Resolver bug crítico na API!"
    task_unique_id = str(uuid.uuid4())
    task_due_date_str = "2025-01-01"
    task_priority_score_float = 123.456

    # --- Act ---
    print("  Atuando: Chamando send_urgent_task_notification...")
    await email_module.send_urgent_task_notification( # Chamada qualificada com nome do módulo
        user_email=user_email_addr,
        user_name=user_full_name,
        task_title=task_display_title,
        task_id=task_unique_id,
        task_due_date=task_due_date_str,
        priority_score=task_priority_score_float
    )

    # --- Assert ---
    auto_mock_send_email_async_for_urgent_tests.assert_awaited_once()

    called_with_kwargs = auto_mock_send_email_async_for_urgent_tests.call_args.kwargs
    print(f"  Argumentos passados para send_email_async (mock): {called_with_kwargs}")

    assert called_with_kwargs.get("subject") == f"🚨 Tarefa Urgente no SmartTask: {task_display_title}"
    assert called_with_kwargs.get("recipient_to") == [user_email_addr]
    assert called_with_kwargs.get("template_name") == "urgent_task.html"
    assert called_with_kwargs.get("plain_text_body") is not None

    template_body_dict = called_with_kwargs.get("body")
    assert isinstance(template_body_dict, dict)
    assert template_body_dict.get("task_title") == task_display_title
    assert template_body_dict.get("user_name") == user_full_name
    assert template_body_dict.get("due_date") == task_due_date_str
    assert template_body_dict.get("priority_score") == f"{task_priority_score_float:.2f}"
    assert template_body_dict.get("task_link") == f"{test_frontend_base_url}/tasks/{task_unique_id}"
    assert template_body_dict.get("project_name") == settings.PROJECT_NAME
    print("  Sucesso: send_urgent_task_notification passou os argumentos corretos para send_email_async.")


async def test_send_urgent_task_notification_handles_no_due_date_and_no_frontend_url(
    auto_mock_send_email_async_for_urgent_tests: AsyncMock,
    mocker
):
    """
    Verifica se `send_urgent_task_notification` lida corretamente com cenários
    onde `task_due_date` é None e `settings.FRONTEND_URL` não está definida.
    O `due_date` no corpo do template deve ser "N/A" e `task_link` deve ser None.
    """
    print("\nTeste: send_urgent_task_notification sem due_date e sem FRONTEND_URL.")
    # --- Arrange ---
    mocker.patch.object(settings, 'FRONTEND_URL', None)
    print("  Mock: settings.FRONTEND_URL=None.")

    user_email_addr = "nodate_nolink_user@example.com" # type: ignore
    user_full_name = "User Without Due Date"
    task_display_title = "Tarefa Opcional Sem Prazo ou Link"
    task_unique_id = str(uuid.uuid4())
    task_priority_score_float = 500.0

    # --- Act ---
    print("  Atuando: Chamando send_urgent_task_notification com task_due_date=None...")
    await email_module.send_urgent_task_notification( # Chamada qualificada
        user_email=user_email_addr,
        user_name=user_full_name,
        task_title=task_display_title,
        task_id=task_unique_id,
        task_due_date=None,
        priority_score=task_priority_score_float
    )

    # --- Assert ---
    auto_mock_send_email_async_for_urgent_tests.assert_awaited_once()
    called_with_kwargs = auto_mock_send_email_async_for_urgent_tests.call_args.kwargs
    print(f"  Argumentos passados (body): {called_with_kwargs.get('body')}")

    assert called_with_kwargs.get("recipient_to") == [user_email_addr]
    template_body_dict = called_with_kwargs.get("body")
    assert isinstance(template_body_dict, dict)
    assert template_body_dict.get("due_date") == "N/A"
    assert template_body_dict.get("task_link") is None
    print("  Sucesso: Cenário sem due_date e FRONTEND_URL tratado corretamente.")

================================================================================
Capítulo 22: tests/test_core_security.py
================================================================================

# tests/test_core_security.py
"""
Este módulo contém testes unitários para as funções de segurança relacionadas
a senhas e tokens JWT, definidas em `app.core.security`.

As funções testadas são:
- `get_password_hash`: Para gerar o hash de uma senha.
- `verify_password`: Para verificar uma senha em texto puro contra um hash existente.
- `create_access_token`: Para gerar tokens JWT.
- `decode_token`: Para decodificar e validar tokens JWT.

Os testes cobrem cenários de sucesso e falha.
"""

# ========================
# --- Importações ---
# ========================
from typing import Optional # Mantido, pode ser usado por outros testes ou fixtures no arquivo.
# from venv import logger # Removido, pois logger de 'venv' não parece ser o pretendido.
import pytest
from datetime import datetime, timedelta, timezone
from jose import ExpiredSignatureError, jwt # jwt (objeto) usado, ExpiredSignatureError para mock.
import uuid
import logging # Adicionado para caplog.set_level, se usado.

# --- Módulos da Aplicação ---
from app.core.config import settings
from app.core.security import ALGORITHM, decode_token, get_password_hash, verify_password, create_access_token
# TokenPayload importado implicitamente via decode_token, ou não necessário no teste.

# ========================
# --- Constantes de Teste ---
# ========================
TEST_PLAIN_PASSWORD = "!@#$_uma_SENHA_extremamente_SEGURA_para_TESTES_!@#$"
TEST_USER_ID_JWT = str(uuid.uuid4())
TEST_USERNAME_JWT = "test_jwt_user"
CUSTOM_EXPIRATION_MINUTES = 15

# ========================
# --- Testes para `get_password_hash` ---
# ========================
def test_get_password_hash_returns_non_empty_string_different_from_plain_password():
    """
    Testa se a função `get_password_hash`:
    1. Retorna uma string.
    2. A string não é vazia.
    3. O hash retornado é diferente da senha original em texto puro.
    """
    print(f"\nTeste: get_password_hash com senha: '{TEST_PLAIN_PASSWORD}'")

    # --- Act: Gerar o hash da senha ---
    generated_hash = get_password_hash(TEST_PLAIN_PASSWORD)
    print(f"  Hash gerado: '{generated_hash[:20]}...' (parcial para brevidade)")

    # --- Assert: Verificar as propriedades do hash ---
    assert isinstance(generated_hash, str), "O hash retornado não é uma string."
    assert len(generated_hash) > 0, "O hash retornado está vazio."
    assert generated_hash != TEST_PLAIN_PASSWORD, "O hash retornado é igual à senha original (não deveria)."
    print("  Sucesso: Hash gerado é uma string não vazia e diferente da senha original.")

def test_get_password_hash_generates_different_hashes_for_same_password_due_to_salt():
    """
    Testa se `get_password_hash` gera hashes diferentes para a mesma senha
    quando chamada múltiplas vezes. Isso demonstra o uso correto de "salts"
    na função de hashing.

    Também verifica se ambos os hashes gerados são válidos para a senha original.
    """
    print(f"\nTeste: get_password_hash gera hashes diferentes para a mesma senha: '{TEST_PLAIN_PASSWORD}'")

    # --- Act: Gerar dois hashes para a mesma senha ---
    hash1 = get_password_hash(TEST_PLAIN_PASSWORD)
    hash2 = get_password_hash(TEST_PLAIN_PASSWORD)
    print(f"  Hash 1: '{hash1[:20]}...'")
    print(f"  Hash 2: '{hash2[:20]}...'")

    # --- Assert: Verificar as propriedades ---
    assert hash1 != hash2, "Os dois hashes gerados para a mesma senha são iguais (o salt pode não estar funcionando)."
    assert verify_password(TEST_PLAIN_PASSWORD, hash1) is True, "O primeiro hash não pôde ser verificado com a senha original."
    assert verify_password(TEST_PLAIN_PASSWORD, hash2) is True, "O segundo hash não pôde ser verificado com a senha original."
    print("  Sucesso: Hashes diferentes foram gerados e ambos são válidos.")

# ========================
# --- Testes para `verify_password` ---
# ========================
def test_verify_password_with_correct_password_succeeds():
    """
    Testa se `verify_password` retorna `True` quando a senha correta em
    texto puro é fornecida para um hash correspondente.
    """
    print(f"\nTeste: verify_password com senha correta: '{TEST_PLAIN_PASSWORD}'")
    # --- Arrange: Gerar um hash para a senha de teste ---
    password_hash = get_password_hash(TEST_PLAIN_PASSWORD)
    print(f"  Hash para verificação: '{password_hash[:20]}...'")

    # --- Act & Assert: Verificar a senha correta ---
    is_valid = verify_password(TEST_PLAIN_PASSWORD, password_hash)
    assert is_valid is True, "A verificação com a senha correta falhou (deveria ser True)."
    print("  Sucesso: Verificação com senha correta retornou True.")

def test_verify_password_with_incorrect_password_fails():
    """
    Testa se `verify_password` retorna `False` quando uma senha incorreta
    em texto puro é fornecida para um hash.
    """
    # --- Arrange ---
    incorrect_test_password = "esta_e_uma_senha_errada_!"
    print(f"\nTeste: verify_password com senha incorreta: '{incorrect_test_password}'")
    password_hash = get_password_hash(TEST_PLAIN_PASSWORD)
    print(f"  Hash (da senha correta '{TEST_PLAIN_PASSWORD}'): '{password_hash[:20]}...'")

    # --- Act & Assert: Verificar a senha incorreta ---
    is_valid = verify_password(incorrect_test_password, password_hash)
    assert is_valid is False, "A verificação com senha incorreta passou (deveria ser False)."
    print("  Sucesso: Verificação com senha incorreta retornou False.")

def test_verify_password_with_empty_plain_password_fails():
    """
    Testa se `verify_password` retorna `False` quando uma senha vazia
    em texto puro é fornecida, mesmo contra um hash de uma senha não vazia.
    """
    # --- Arrange ---
    empty_password = ""
    print(f"\nTeste: verify_password com senha vazia em texto puro ('{empty_password}')")
    password_hash = get_password_hash(TEST_PLAIN_PASSWORD)
    print(f"  Hash (da senha correta '{TEST_PLAIN_PASSWORD}'): '{password_hash[:20]}...'")

    # --- Act & Assert: Verificar a senha vazia ---
    is_valid = verify_password(empty_password, password_hash)
    assert is_valid is False, "A verificação com senha vazia passou (deveria ser False)."
    print("  Sucesso: Verificação com senha vazia retornou False.")

def test_verify_password_with_plain_password_against_empty_hash_string_fails():
    """
    Testa se `verify_password` retorna `False` quando a string de hash fornecida é vazia.
    """
    # --- Arrange ---
    empty_hash_string = ""
    print(f"\nTeste: verify_password com string de hash vazia ('{empty_hash_string}')")

    # --- Act & Assert: Verificar senha contra hash vazio ---
    is_valid = verify_password(TEST_PLAIN_PASSWORD, empty_hash_string)
    assert is_valid is False, \
        "A verificação contra um hash vazio deveria retornar False (ou a biblioteca pode ter outro comportamento)."
    print("  Sucesso: Verificação contra hash vazio retornou False.")

def test_verify_password_with_invalid_hash_format_fails():
    """
    Testa se `verify_password` retorna `False` quando a string de hash fornecida
    não é um formato de hash bcrypt válido.
    """
    # --- Arrange ---
    invalid_hash_string = "isto_claramente_nao_e_um_hash_bcrypt_valido_$"
    print(f"\nTeste: verify_password com formato de hash inválido: '{invalid_hash_string}'")

    # --- Act & Assert: Verificar senha contra hash inválido ---
    is_valid = verify_password(TEST_PLAIN_PASSWORD, invalid_hash_string)
    assert is_valid is False, \
        "A verificação contra um hash de formato inválido deveria retornar False."
    print("  Sucesso: Verificação contra hash de formato inválido retornou False.")

# ========================
# --- Testes para JWT (create_access_token, decode_token) ---
# ========================
def test_create_access_token_with_custom_expires_delta():
    """
    Testa se `create_access_token` utiliza o `expires_delta` fornecido
    para definir o tempo de expiração do token.
    """
    print(f"\nTeste: create_access_token com expires_delta customizado")
    # --- Arrange ---
    custom_delta = timedelta(minutes=CUSTOM_EXPIRATION_MINUTES)
    start_time = datetime.now(timezone.utc)

    # --- Act: Criar o token com expires_delta customizado ---
    token = create_access_token(
        subject=TEST_USER_ID_JWT,
        username=TEST_USERNAME_JWT,
        expires_delta=custom_delta
    )
    end_time = datetime.now(timezone.utc) # Captura tempo após criação para margem
    print(f"  Token gerado: '{token[:20]}...'")

    # --- Assert: Decodificar e verificar o payload e a expiração ---
    assert token is not None, "Token não deveria ser None."
    assert isinstance(token, str), "Token deveria ser uma string."
    try:
        payload = jwt.decode(
            token,
            settings.JWT_SECRET_KEY,
            algorithms=[settings.JWT_ALGORITHM] # Usando settings.JWT_ALGORITHM para consistência
        )
        print(f"  Payload decodificado: {payload}")
        expected_sub = str(TEST_USER_ID_JWT)
        assert payload.get("sub") == expected_sub
        assert payload.get("username") == TEST_USERNAME_JWT
        exp_timestamp = payload.get("exp")
        assert exp_timestamp is not None
        token_expiration_time = datetime.fromtimestamp(exp_timestamp, tz=timezone.utc)
        # Verificação da expiração com uma pequena margem de tolerância
        expected_expire_earliest = start_time + custom_delta
        expected_expire_latest = end_time + custom_delta
        assert expected_expire_earliest - timedelta(seconds=5) <= token_expiration_time <= expected_expire_latest + timedelta(seconds=5)
        print(f"  Sucesso: Token criado com expires_delta customizado e claims corretos.")
    except jwt.JWTError as e: # pragma: no cover (Não esperado neste teste)
        pytest.fail(f"Falha ao decodificar o token gerado: {e}")

def test_decode_token_with_expired_token_returns_none_and_logs(caplog):
    """
    Testa se `decode_token` retorna `None` e registra um log informativo
    quando um token JWT sintaticamente válido, mas expirado, é fornecido.
    """
    print(f"\nTeste: decode_token com token expirado")
    # --- Arrange: Criar um token que já está expirado ---
    expired_delta = timedelta(hours=-1)
    expire_time = datetime.now(timezone.utc) + expired_delta
    to_encode = {
        "exp": expire_time,
        "sub": str(TEST_USER_ID_JWT),
        "username": TEST_USERNAME_JWT,
    }
    expired_token = jwt.encode(
        to_encode,
        settings.JWT_SECRET_KEY,
        algorithm=ALGORITHM # ALGORITHM já é settings.JWT_ALGORITHM
    )
    print(f"  Token expirado gerado: '{expired_token[:20]}...'")
    # caplog.set_level(logging.INFO, logger="app.core.security") # Opcional

    # --- Act: Tentar decodificar o token expirado ---
    decoded_payload = decode_token(expired_token)

    # --- Assert: Verificar se o resultado é None e o log foi feito ---
    assert decoded_payload is None, "Token expirado deveria resultar em None."
    log_messages = [record.getMessage() for record in caplog.records if record.name == 'app.core.security']
    assert any("Token JWT expirado (verificação dupla)." in message for message in log_messages), \
        "Mensagem de log para token expirado não encontrada."
    print("  Sucesso: decode_token retornou None para token expirado e logou a informação.")

def test_decode_token_without_expiration_claim(caplog):
    """
    Testa se `decode_token` processa corretamente um token válido
    que não possui o claim 'exp'.
    """
    print("\nTeste: decode_token com token válido sem claim 'exp'")
    # --- Arrange ---
    user_id_as_string = str(uuid.uuid4())
    to_encode_no_exp = {
        "sub": user_id_as_string,
        "username": TEST_USERNAME_JWT,
    }
    token_no_exp = jwt.encode(
        to_encode_no_exp,
        settings.JWT_SECRET_KEY,
        algorithm=ALGORITHM
    )
    print(f"  Token sem 'exp' gerado: '{token_no_exp[:20]}...'")

    # --- Act ---
    decoded_payload = decode_token(token_no_exp)

    # --- Assert ---
    assert decoded_payload is not None, "Token sem 'exp' deveria ser decodificado se 'exp' é opcional."
    assert str(decoded_payload.sub) == user_id_as_string
    assert decoded_payload.username == TEST_USERNAME_JWT
    assert decoded_payload.exp is None, "O campo 'exp' do payload deveria ser None."
    # Verifica se o log de "expirado" NÃO foi emitido
    assert not any("Token JWT expirado (verificação dupla)." in record.getMessage() for record in caplog.records if record.name == 'app.core.security'), \
        "Log de token expirado não deveria ser emitido para token sem claim 'exp'."
    print("  Sucesso: decode_token processou token sem 'exp' e retornou payload.")

def test_decode_token_handles_direct_expired_signature_error_from_jose(mocker, caplog):
    """
    Testa o tratamento do bloco `except ExpiredSignatureError` em `decode_token`.
    """
    print("\nTeste: decode_token com ExpiredSignatureError direta do jose")
    # --- Arrange ---
    some_token_string = "um.token.qualquer_expirado_simulado"
    mocked_jwt_decode = mocker.patch("app.core.security.jwt.decode", side_effect=ExpiredSignatureError("Simulated JOSE expiration"))
    # caplog.set_level(logging.WARNING, logger="app.core.security") # Opcional

    # --- Act ---
    decoded_payload = decode_token(some_token_string)

    # --- Assert ---
    assert decoded_payload is None, "Deveria retornar None quando ExpiredSignatureError é capturada."
    mocked_jwt_decode.assert_called_once_with(
        some_token_string,
        settings.JWT_SECRET_KEY,
        algorithms=[ALGORITHM],
        options={"verify_exp": False}
    )
    log_messages = [record.getMessage() for record in caplog.records if record.name == 'app.core.security']
    assert any("Token JWT detectado como expirado pela biblioteca JOSE" in message for message in log_messages), \
        "Mensagem de log esperada para ExpiredSignatureError não encontrada."
    print("  Sucesso: decode_token lidou com ExpiredSignatureError direta e logou corretamente.")

================================================================================
Capítulo 23: tests/test_core_utils.py
================================================================================

# tests/test_core_utils.py
"""
Este módulo contém testes unitários para as funções utilitárias definidas
em `app.core.utils`, especificamente aquelas relacionadas à lógica de
negócios de tarefas, como cálculo de pontuação de prioridade e
identificação de tarefas urgentes.

Os testes utilizam `freezegun` para mockar a data/hora atual, permitindo
testes consistentes e previsíveis de funcionalidades baseadas em datas.
"""

# ========================
# --- Importações ---
# ========================
import uuid
from datetime import date, datetime, timedelta, timezone

import pytest
from freezegun import freeze_time

# --- Módulos da Aplicação ---
from app.core.config import settings
from app.core.utils import calculate_priority_score, is_task_urgent
from app.models.task import Task, TaskStatus # TaskStatus é usado aqui

# ========================
# --- Testes para `calculate_priority_score` ---
# ========================
def test_calculate_priority_score_with_invalid_importance_returns_none():
    """
    Testa se `calculate_priority_score` retorna `None` (ou o valor default se alterado na função)
    quando o valor de `importance` fornecido está fora do intervalo válido (1-5).
    """
    print("\nTeste: calculate_priority_score com importância inválida.")
    # --- Arrange & Act ---
    score_low_importance = calculate_priority_score(importance=0, due_date=None)
    print(f"  Score para importância 0: {score_low_importance}")
    # --- Assert ---
    assert score_low_importance is None, "Score deveria ser None para importância 0."

    # --- Arrange & Act ---
    score_high_importance = calculate_priority_score(importance=6, due_date=None)
    print(f"  Score para importância 6: {score_high_importance}")
    # --- Assert ---
    assert score_high_importance is None, "Score deveria ser None para importância 6."
    print("  Sucesso: Importância inválida resulta em score None.")


@freeze_time("2025-05-04")
def test_calculate_priority_score_with_no_due_date():
    """
    Testa o cálculo da pontuação de prioridade quando a tarefa não tem data de entrega (`due_date=None`).
    A pontuação deve ser baseada no `PRIORITY_DEFAULT_SCORE_NO_DUE_DATE` mais o peso da importância.
    """
    print("\nTeste: calculate_priority_score sem data de entrega (due_date=None) em 2025-05-04.")
    # --- Cenário 1 ---
    importance_3 = 3
    expected_score_importance_3 = (settings.PRIORITY_DEFAULT_SCORE_NO_DUE_DATE or 0.0) + \
                                 (importance_3 * settings.PRIORITY_WEIGHT_IMPORTANCE)
    actual_score_importance_3 = calculate_priority_score(importance=importance_3, due_date=None)
    print(f"  Importância 3: Score esperado={expected_score_importance_3:.2f}, "
          f"Calculado={actual_score_importance_3}")
    assert actual_score_importance_3 == round(expected_score_importance_3, 2)

    # --- Cenário 2 ---
    importance_5 = 5
    expected_score_importance_5 = (settings.PRIORITY_DEFAULT_SCORE_NO_DUE_DATE or 0.0) + \
                                 (importance_5 * settings.PRIORITY_WEIGHT_IMPORTANCE)
    actual_score_importance_5 = calculate_priority_score(importance=importance_5, due_date=None)
    print(f"  Importância 5: Score esperado={expected_score_importance_5:.2f}, "
          f"Calculado={actual_score_importance_5}")
    assert actual_score_importance_5 == round(expected_score_importance_5, 2)
    print("  Sucesso: Scores para tarefas sem data de entrega calculados corretamente.")


@freeze_time("2025-05-04")
def test_calculate_priority_score_with_due_date_today():
    """
    Testa o cálculo da pontuação de prioridade quando a data de entrega da tarefa é hoje.
    """
    print("\nTeste: calculate_priority_score com data de entrega HOJE (2025-05-04).")
    # --- Arrange ---
    due_date_is_today = date.today()
    test_importance = 4
    days_factor_for_today = 1.0
    expected_score = (settings.PRIORITY_WEIGHT_DUE_DATE / days_factor_for_today) + \
                     (test_importance * settings.PRIORITY_WEIGHT_IMPORTANCE)
    # --- Act ---
    actual_score = calculate_priority_score(importance=test_importance, due_date=due_date_is_today)
    # --- Assert ---
    print(f"  Importância {test_importance}, Due Date Hoje: Score esperado={expected_score:.2f}, "
          f"Calculado={actual_score}")
    assert actual_score == round(expected_score, 2)
    print("  Sucesso: Score para tarefa com entrega hoje calculado corretamente.")


@freeze_time("2025-05-04")
def test_calculate_priority_score_with_due_date_in_future():
    """
    Testa o cálculo da pontuação de prioridade quando a data de entrega da tarefa
    está no futuro (10 dias a partir de "hoje").
    """
    print("\nTeste: calculate_priority_score com data de entrega no FUTURO (2025-05-04 + 10 dias).")
    # --- Arrange ---
    due_date_in_future = date.today() + timedelta(days=10)
    test_importance = 2
    days_to_due = 10.0
    expected_score = (settings.PRIORITY_WEIGHT_DUE_DATE / days_to_due) + \
                     (test_importance * settings.PRIORITY_WEIGHT_IMPORTANCE)
    # --- Act ---
    actual_score = calculate_priority_score(importance=test_importance, due_date=due_date_in_future)
    # --- Assert ---
    print(f"  Importância {test_importance}, Due Date em {days_to_due} dias: "
          f"Score esperado={expected_score:.2f}, Calculado={actual_score}")
    assert actual_score == round(expected_score, 2)
    print("  Sucesso: Score para tarefa com entrega futura calculado corretamente.")


@freeze_time("2025-05-04")
def test_calculate_priority_score_for_overdue_task():
    """
    Testa o cálculo da pontuação de prioridade para uma tarefa que já está atrasada (5 dias).
    """
    print("\nTeste: calculate_priority_score para tarefa ATRASADA (2025-05-04 - 5 dias).")
    # --- Arrange ---
    overdue_date = date.today() - timedelta(days=5)
    test_importance = 5
    expected_score = settings.PRIORITY_SCORE_IF_OVERDUE + \
                     (test_importance * settings.PRIORITY_WEIGHT_IMPORTANCE)
    # --- Act ---
    actual_score = calculate_priority_score(importance=test_importance, due_date=overdue_date)
    # --- Assert ---
    print(f"  Importância {test_importance}, Tarefa Atrasada: "
          f"Score esperado={expected_score:.2f}, Calculado={actual_score}")
    assert actual_score == round(expected_score, 2)
    print("  Sucesso: Score para tarefa atrasada calculado corretamente.")

# ========================
# --- Testes para `is_task_urgent` ---
# ========================
def _create_dummy_test_task(**kwargs) -> Task:
    """
    Função auxiliar para criar instâncias de `Task` para os testes de `is_task_urgent`.
    """
    base_task_data = {
        "id": uuid.uuid4(),
        "owner_id": uuid.uuid4(),
        "title": "Tarefa de Teste Dummy",
        "description": "Descrição da tarefa dummy.",
        "importance": 3,
        "status": TaskStatus.PENDING,
        "tags": None,
        "project": None,
        "created_at": datetime.now(timezone.utc),
        "updated_at": None,
        "due_date": None,
        "priority_score": None,
    }
    final_task_data = {**base_task_data, **kwargs}
    if final_task_data.get("priority_score") is None and \
       (final_task_data.get("importance") or final_task_data.get("due_date")):
        calc_importance = final_task_data.get("importance", base_task_data["importance"])
        final_task_data["priority_score"] = calculate_priority_score(
            importance=calc_importance,
            due_date=final_task_data.get("due_date")
        )
    try:
        return Task(**final_task_data)
    except Exception as e: # pragma: no cover
        print(f"Erro ao criar Dummy Task com dados: {final_task_data}. Erro: {e}")
        raise

def test_is_task_urgent_when_no_score_and_no_due_date():
    """
    Testa se uma tarefa sem pontuação de prioridade e sem data de entrega
    NÃO é considerada urgente.
    """
    print("\nTeste: is_task_urgent - Tarefa sem score e sem data de entrega.")
    # --- Arrange ---
    task_no_urgency_factors = _create_dummy_test_task(importance=3, priority_score=None, due_date=None)
    task_no_urgency_factors.priority_score = None # Força o score para None
    print(f"  Tarefa para teste: score={task_no_urgency_factors.priority_score}, due_date={task_no_urgency_factors.due_date}")
    # --- Act ---
    is_urgent_result = is_task_urgent(task_no_urgency_factors)
    # --- Assert ---
    assert is_urgent_result is False, "Tarefa sem score nem data de entrega não deveria ser urgente."
    print("  Sucesso: Tarefa sem fatores de urgência não é urgente.")

@freeze_time("2025-05-04")
def test_is_task_urgent_with_high_priority_score():
    """
    Testa se uma tarefa com `priority_score` acima do `EMAIL_URGENCY_THRESHOLD`
    é considerada urgente, mesmo que a data de entrega não seja iminente.
    """
    print("\nTeste: is_task_urgent - Tarefa com pontuação de prioridade alta (acima do threshold).")
    # --- Arrange ---
    high_score = settings.EMAIL_URGENCY_THRESHOLD + 10.0
    task_high_score = _create_dummy_test_task(priority_score=high_score, due_date=date.today() + timedelta(days=30))
    print(f"  Tarefa: score={task_high_score.priority_score} (Threshold={settings.EMAIL_URGENCY_THRESHOLD}), due_date={task_high_score.due_date}")
    # --- Act ---
    is_urgent_result = is_task_urgent(task_high_score)
    # --- Assert ---
    assert is_urgent_result is True, "Tarefa com score alto deveria ser urgente."
    print("  Sucesso: Tarefa com score alto é urgente.")

@freeze_time("2025-05-04")
def test_is_task_urgent_with_score_below_threshold_and_future_due_date():
    """
    Testa se uma tarefa com `priority_score` abaixo do `EMAIL_URGENCY_THRESHOLD`
    e com data de entrega no futuro NÃO é considerada urgente.
    """
    print("\nTeste: is_task_urgent - Score baixo e data de entrega futura.")
    # --- Arrange ---
    low_score = settings.EMAIL_URGENCY_THRESHOLD - 10.0
    due_date_in_future = date.today() + timedelta(days=10)
    task_low_score_future = _create_dummy_test_task(priority_score=low_score, due_date=due_date_in_future)
    print(f"  Tarefa: score={task_low_score_future.priority_score} (Threshold={settings.EMAIL_URGENCY_THRESHOLD}), "
          f"due_date={task_low_score_future.due_date}")
    # --- Act ---
    is_urgent_result = is_task_urgent(task_low_score_future)
    # --- Assert ---
    assert is_urgent_result is False, "Tarefa com score baixo e entrega futura não deveria ser urgente."
    print("  Sucesso: Tarefa com score baixo e entrega futura não é urgente.")

@freeze_time("2025-05-04")
def test_is_task_urgent_when_due_date_is_today():
    """
    Testa se uma tarefa com data de entrega para HOJE é considerada urgente,
    mesmo que sua `priority_score` esteja abaixo do `EMAIL_URGENCY_THRESHOLD`.
    """
    print("\nTeste: is_task_urgent - Data de entrega é HOJE (2025-05-04).")
    # --- Arrange ---
    score_below_threshold = settings.EMAIL_URGENCY_THRESHOLD - 5.0
    due_date_is_today = date.today()
    task_due_today = _create_dummy_test_task(due_date=due_date_is_today, priority_score=score_below_threshold)
    print(f"  Tarefa: score={task_due_today.priority_score}, due_date={task_due_today.due_date}")
    # --- Act ---
    is_urgent_result = is_task_urgent(task_due_today)
    # --- Assert ---
    assert is_urgent_result is True, "Tarefa com entrega hoje deveria ser urgente, independentemente do score."
    print("  Sucesso: Tarefa com entrega hoje é urgente.")

@freeze_time("2025-05-04")
def test_is_task_urgent_when_overdue():
    """
    Testa se uma tarefa que está ATRASADA (data de entrega no passado) é considerada urgente,
    mesmo que sua `priority_score` esteja abaixo do `EMAIL_URGENCY_THRESHOLD`.
    """
    print("\nTeste: is_task_urgent - Tarefa ATRASADA (entrega em 2025-05-03).")
    # --- Arrange ---
    score_below_threshold = settings.EMAIL_URGENCY_THRESHOLD - 15.0
    overdue_date = date.today() - timedelta(days=1)
    task_overdue = _create_dummy_test_task(due_date=overdue_date, priority_score=score_below_threshold)
    print(f"  Tarefa: score={task_overdue.priority_score}, due_date={task_overdue.due_date}")
    # --- Act ---
    is_urgent_result = is_task_urgent(task_overdue)
    # --- Assert ---
    assert is_urgent_result is True, "Tarefa atrasada deveria ser urgente."
    print("  Sucesso: Tarefa atrasada é urgente.")

# ========================
# --- Testes de Casos de Borda para `is_task_urgent` ---
# ========================
@freeze_time("2025-05-04")
def test_is_task_urgent_when_score_is_exactly_at_threshold_and_due_date_is_future():
    """
    Testa o comportamento de `is_task_urgent` quando a `priority_score` é
    EXATAMENTE igual ao `EMAIL_URGENCY_THRESHOLD` e a data de entrega está no futuro.
    """
    print("\nTeste de Borda: is_task_urgent - Score no limiar, entrega futura.")
    # --- Arrange ---
    score_at_threshold = settings.EMAIL_URGENCY_THRESHOLD
    due_date_in_future = date.today() + timedelta(days=5)
    task_at_threshold = _create_dummy_test_task(priority_score=score_at_threshold, due_date=due_date_in_future)
    if task_at_threshold.priority_score != score_at_threshold: # pragma: no cover (Defensivo)
        print(f"  AVISO: Score recalculado para {task_at_threshold.priority_score}")
        task_at_threshold.priority_score = score_at_threshold
    print(f"  Tarefa: score={task_at_threshold.priority_score} (Threshold={settings.EMAIL_URGENCY_THRESHOLD}), "
          f"due_date={task_at_threshold.due_date}")
    # --- Act ---
    is_urgent_result = is_task_urgent(task_at_threshold)
    # --- Assert ---
    assert is_urgent_result is False, \
        f"Tarefa com score no limiar ({task_at_threshold.priority_score}) e entrega futura não deveria ser urgente."
    print("  Sucesso: Tarefa com score no limiar (e entrega futura) não é urgente.")

@freeze_time("2025-05-04")
def test_is_task_urgent_when_score_is_slightly_above_threshold_and_due_date_is_future():
    """
    Testa se `is_task_urgent` considera uma tarefa urgente quando sua `priority_score`
    é LIGEIRAMENTE ACIMA do `EMAIL_URGENCY_THRESHOLD` e a data de entrega está no futuro.
    """
    print("\nTeste de Borda: is_task_urgent - Score ligeiramente acima do limiar, entrega futura.")
    # --- Arrange ---
    score_slightly_above_threshold = settings.EMAIL_URGENCY_THRESHOLD + 0.01
    due_date_in_future = date.today() + timedelta(days=5)
    task_above_threshold = _create_dummy_test_task(priority_score=score_slightly_above_threshold, due_date=due_date_in_future)
    if task_above_threshold.priority_score != score_slightly_above_threshold: # pragma: no cover (Defensivo)
         print(f"  AVISO: Score recalculado para {task_above_threshold.priority_score}")
         task_above_threshold.priority_score = score_slightly_above_threshold
    print(f"  Tarefa: score={task_above_threshold.priority_score} (Threshold={settings.EMAIL_URGENCY_THRESHOLD}), "
          f"due_date={task_above_threshold.due_date}")
    # --- Act ---
    is_urgent_result = is_task_urgent(task_above_threshold)
    # --- Assert ---
    assert is_urgent_result is True, \
        f"Tarefa com score ({task_above_threshold.priority_score}) ligeiramente acima do limiar deveria ser urgente."
    print("  Sucesso: Tarefa com score ligeiramente acima do limiar (e entrega futura) é urgente.")

================================================================================
Capítulo 24: tests/test_core_utils_webhooks.py
================================================================================

# tests/test_core_utils_webhooks.py
"""
Este módulo contém testes unitários para a função `send_webhook_notification`
localizada em `app.core.utils`.

Os testes utilizam `respx` para mockar as requisições HTTP externas,
permitindo testar o comportamento da função sob diversas condições:
- Envio de webhook sem segredo (sem header de assinatura).
- Envio de webhook com segredo (com verificação da assinatura HMAC-SHA256).
- Tratamento de erros HTTP retornados pelo servidor do webhook (ex: 4xx, 5xx).
- Tratamento de erros de rede/conexão durante a tentativa de envio.
- Comportamento quando a URL do webhook não está configurada nas settings.
"""

# ========================
# --- Importações ---
# ========================
import hashlib
import hmac
import json
from unittest.mock import AsyncMock, patch

import httpx
import pytest
import respx

# --- Módulos da Aplicação ---
from app.core.config import settings
from app.core.utils import send_webhook_notification

# ========================
# --- Marcador Global de Teste ---
# ========================
pytestmark = pytest.mark.asyncio

# ========================
# --- Constantes e Dados de Teste ---
# ========================
TEST_TASK_DATA_FOR_WEBHOOK = {
    "id": "f47ac10b-58cc-4372-a567-0e02b2c3d479",
    "owner_id": "a1b2c3d4-e5f6-7890-1234-567890abcdef",
    "title": "Tarefa de Teste para Webhook",
    "importance": 4,
    "status": "pendente_webhook_test",
}
TEST_EVENT_TYPE_WEBHOOK = "task.webhook_test_event"
TEST_WEBHOOK_TARGET_URL = "http://mocked-webhook-receiver.test/api/hook"

# ========================
# --- Fixtures de Teste ---
# ========================
@pytest.fixture(autouse=True)
def override_webhook_settings_for_tests(monkeypatch):
    """
    Fixture `autouse` que sobrescreve as configurações globais de webhook
    (`settings.WEBHOOK_URL` e `settings.WEBHOOK_SECRET`) para cada teste neste módulo.
    """
    print("  Fixture (autouse): Configurando settings de webhook para testes...")
    monkeypatch.setattr(settings, 'WEBHOOK_URL', TEST_WEBHOOK_TARGET_URL)
    monkeypatch.setattr(settings, 'WEBHOOK_SECRET', None)
    print(f"    settings.WEBHOOK_URL mockado para: {TEST_WEBHOOK_TARGET_URL}")
    print(f"    settings.WEBHOOK_SECRET mockado para: None (inicialmente)")

# ========================
# --- Testes da Função `send_webhook_notification` ---
# ========================
@respx.mock
async def test_send_webhook_successfully_without_secret():
    """
    Testa o envio bem-sucedido de uma notificação de webhook quando
    `settings.WEBHOOK_SECRET` NÃO está configurado.
    """
    print("\nTeste: send_webhook_notification - Envio bem-sucedido sem segredo.")
    # --- Arrange ---
    mocked_route = respx.post(TEST_WEBHOOK_TARGET_URL).mock(
        return_value=httpx.Response(200, json={"status": "webhook_received_ok"})
    )
    print(f"  Mock respx: Rota POST para '{TEST_WEBHOOK_TARGET_URL}' mockada para retornar 200.")

    # --- Act ---
    print("  Atuando: Chamando send_webhook_notification...")
    await send_webhook_notification(
        event_type=TEST_EVENT_TYPE_WEBHOOK,
        task_data=TEST_TASK_DATA_FOR_WEBHOOK
    )

    # --- Assert ---
    assert mocked_route.called, "A rota do webhook mockada não foi chamada."
    assert respx.calls.call_count == 1, "Número de chamadas HTTP incorreto."

    last_request_made = respx.calls.last.request
    print(f"  Requisição enviada: URL='{last_request_made.url}', Headers='{last_request_made.headers}'")
    assert str(last_request_made.url) == TEST_WEBHOOK_TARGET_URL, "URL da requisição incorreta."

    sent_payload = json.loads(last_request_made.content)
    print(f"  Payload enviado: {sent_payload}")
    assert sent_payload.get("event") == TEST_EVENT_TYPE_WEBHOOK
    assert sent_payload.get("task") == TEST_TASK_DATA_FOR_WEBHOOK
    assert "timestamp" in sent_payload

    assert "X-SmartTask-Signature" not in last_request_made.headers
    print("  Sucesso: Webhook enviado corretamente sem header de assinatura.")

@respx.mock
async def test_send_webhook_successfully_with_secret_and_valid_signature(
    monkeypatch
):
    """
    Testa o envio bem-sucedido de notificação de webhook com `WEBHOOK_SECRET` configurado.
    """
    print("\nTeste: send_webhook_notification - Envio bem-sucedido com segredo e assinatura válida.")
    # --- Arrange ---
    test_webhook_secret_key = "este-e-um-segredo-muito-secreto-para-hmac"
    monkeypatch.setattr(settings, 'WEBHOOK_SECRET', test_webhook_secret_key)
    print(f"  Mock monkeypatch: settings.WEBHOOK_SECRET definido para '{test_webhook_secret_key}'.")
    mocked_route = respx.post(TEST_WEBHOOK_TARGET_URL).mock(return_value=httpx.Response(200))
    print(f"  Mock respx: Rota POST para '{TEST_WEBHOOK_TARGET_URL}' mockada.")

    # --- Act ---
    print("  Atuando: Chamando send_webhook_notification...")
    await send_webhook_notification(
        event_type=TEST_EVENT_TYPE_WEBHOOK,
        task_data=TEST_TASK_DATA_FOR_WEBHOOK
    )

    # --- Assert ---
    assert mocked_route.called
    last_request_made = respx.calls.last.request
    assert "X-SmartTask-Signature" in last_request_made.headers
    signature_from_header = last_request_made.headers["X-SmartTask-Signature"]
    assert signature_from_header.startswith("sha256=")
    print(f"  Header de assinatura recebido: {signature_from_header}")

    sent_payload_bytes = last_request_made.content
    sent_payload_dict_actual = json.loads(sent_payload_bytes)
    actual_timestamp_sent = sent_payload_dict_actual["timestamp"]
    expected_payload_base = {"event": TEST_EVENT_TYPE_WEBHOOK, "task": TEST_TASK_DATA_FOR_WEBHOOK}
    payload_for_signature_calculation = expected_payload_base.copy()
    payload_for_signature_calculation["timestamp"] = actual_timestamp_sent
    payload_bytes_for_hmac = json.dumps(
        payload_for_signature_calculation, separators=(',', ':'), sort_keys=True
    ).encode('utf-8')
    secret_bytes_for_hmac = test_webhook_secret_key.encode('utf-8')
    expected_hmac_signature_hex = hmac.new(
        secret_bytes_for_hmac, payload_bytes_for_hmac, hashlib.sha256
    ).hexdigest()
    print(f"  Assinatura HMAC calculada esperada: {expected_hmac_signature_hex}")
    assert signature_from_header == f"sha256={expected_hmac_signature_hex}"
    print("  Sucesso: Webhook enviado com segredo e assinatura HMAC válida.")

@respx.mock
async def test_send_webhook_handles_http_error_from_server(mocker):
    """
    Testa o tratamento de erro quando o servidor do webhook retorna um erro HTTP.
    """
    print("\nTeste: send_webhook_notification - Tratamento de erro HTTP do servidor.")
    # --- Arrange ---
    http_error_status_code = 500
    http_error_response_text = "Ocorreu um Erro Interno no Servidor do Webhook"
    respx.post(TEST_WEBHOOK_TARGET_URL).mock(
        return_value=httpx.Response(http_error_status_code, text=http_error_response_text)
    )
    print(f"  Mock respx: Rota POST para '{TEST_WEBHOOK_TARGET_URL}' mockada para retornar {http_error_status_code}.")
    mock_utils_logger = mocker.patch("app.core.utils.logger")
    print("  Mock: app.core.utils.logger.")

    # --- Act ---
    print("  Atuando: Chamando send_webhook_notification (esperando erro HTTP)...")
    await send_webhook_notification(TEST_EVENT_TYPE_WEBHOOK, TEST_TASK_DATA_FOR_WEBHOOK)

    # --- Assert ---
    mock_utils_logger.error.assert_called_once()
    error_log_args, _ = mock_utils_logger.error.call_args
    error_log_message = error_log_args[0]
    print(f"  Log de erro capturado: {error_log_message}")
    assert "Erro no servidor do webhook" in error_log_message
    assert f"({TEST_WEBHOOK_TARGET_URL})" in error_log_message
    assert f"Status: {http_error_status_code}" in error_log_message
    assert http_error_response_text in error_log_message
    print("  Sucesso: Erro HTTP do servidor tratado e logado corretamente.")

@respx.mock
async def test_send_webhook_handles_network_request_error(mocker):
    """
    Testa o tratamento de erro quando ocorre um problema de rede ou conexão.
    """
    print("\nTeste: send_webhook_notification - Tratamento de erro de rede/conexão.")
    # --- Arrange ---
    simulated_network_error_message = "Falha de conexão simulada (DNS lookup failed)"
    respx.post(TEST_WEBHOOK_TARGET_URL).mock(side_effect=httpx.RequestError(simulated_network_error_message))
    print(f"  Mock respx: Rota POST para '{TEST_WEBHOOK_TARGET_URL}' mockada para levantar httpx.RequestError.")
    mock_utils_logger = mocker.patch("app.core.utils.logger")
    print("  Mock: app.core.utils.logger.")

    # --- Act ---
    print("  Atuando: Chamando send_webhook_notification (esperando erro de rede)...")
    await send_webhook_notification(TEST_EVENT_TYPE_WEBHOOK, TEST_TASK_DATA_FOR_WEBHOOK)

    # --- Assert ---
    mock_utils_logger.error.assert_called_once()
    error_log_args, _ = mock_utils_logger.error.call_args
    error_log_message = error_log_args[0]
    print(f"  Log de erro capturado: {error_log_message}")
    assert "Erro na requisição ao enviar webhook para" in error_log_message
    assert TEST_WEBHOOK_TARGET_URL in error_log_message
    assert simulated_network_error_message in error_log_message
    print("  Sucesso: Erro de rede/conexão tratado e logado corretamente.")

async def test_send_webhook_does_nothing_if_url_not_configured(mocker):
    """
    Testa se `send_webhook_notification` não faz nada se `settings.WEBHOOK_URL` não estiver configurada.
    """
    print("\nTeste: send_webhook_notification - WEBHOOK_URL não configurada.")
    # --- Arrange ---
    with patch('app.core.utils.settings.WEBHOOK_URL', None):
        print(f"  Mock patch: settings.WEBHOOK_URL definido como None para este teste.")
        mock_httpx_client_post = mocker.patch("httpx.AsyncClient.post", new_callable=AsyncMock)
        mock_utils_logger = mocker.patch("app.core.utils.logger")
        print("  Mock: httpx.AsyncClient.post e app.core.utils.logger.")

        # --- Act ---
        print("  Atuando: Chamando send_webhook_notification...")
        await send_webhook_notification(TEST_EVENT_TYPE_WEBHOOK, TEST_TASK_DATA_FOR_WEBHOOK)

        # --- Assert ---
        mock_httpx_client_post.assert_not_called()
        assert not mock_utils_logger.info.called
        assert not mock_utils_logger.error.called
        expected_debug_message = "Webhook URL não configurada, pulando envio."
        mock_utils_logger.debug.assert_called_once_with(expected_debug_message)
        print("  Sucesso: Nenhuma tentativa de envio de webhook e log de debug correto quando URL não configurada.")

@respx.mock
async def test_send_webhook_signature_generation_failure(mocker):
    """
    Testa o tratamento de erro quando a geração da assinatura HMAC falha.
    """
    print("\nTeste: send_webhook_notification - Falha na geração da assinatura HMAC.")
    # --- Arrange ---
    test_secret = "super_secret"
    mocker.patch.object(settings, 'WEBHOOK_SECRET', test_secret)
    mock_utils_logger = mocker.patch("app.core.utils.logger")
    mocker.patch("app.core.utils.hmac.new", side_effect=Exception("HMAC generation error"))

    # --- Act ---
    await send_webhook_notification(TEST_EVENT_TYPE_WEBHOOK, TEST_TASK_DATA_FOR_WEBHOOK)

    # --- Assert ---
    mock_utils_logger.error.assert_called_once()
    error_log_message = mock_utils_logger.error.call_args[0][0]
    assert "Erro ao gerar assinatura HMAC para webhook" in error_log_message
    assert "HMAC generation error" in error_log_message
    assert respx.calls.call_count == 0
    print("  Sucesso: Falha na geração de assinatura HMAC tratada e logada.")

@respx.mock
async def test_send_webhook_unexpected_generic_exception_during_send(mocker):
    """
    Testa o tratamento de uma exceção genérica inesperada durante o envio do webhook.
    """
    print("\nTeste: send_webhook_notification - Exceção genérica inesperada no envio.")
    # --- Arrange ---
    mock_utils_logger = mocker.patch("app.core.utils.logger")
    mock_post_method = AsyncMock(side_effect=Exception("Erro genérico simulado no post"))
    mock_client_operations = AsyncMock()
    mock_client_operations.post = mock_post_method
    mock_client_context = AsyncMock()
    mock_client_context.__aenter__ = AsyncMock(return_value=mock_client_operations)
    mock_client_context.__aexit__ = AsyncMock(return_value=None)
    mocker.patch("httpx.AsyncClient", return_value=mock_client_context)

    # --- Act ---
    await send_webhook_notification(TEST_EVENT_TYPE_WEBHOOK, TEST_TASK_DATA_FOR_WEBHOOK)

    # --- Assert ---
    mock_utils_logger.exception.assert_called_once()
    exception_log_message = mock_utils_logger.exception.call_args[0][0]
    assert "Erro inesperado ao enviar webhook para" in exception_log_message
    assert "Erro genérico simulado no post" in exception_log_message
    print("  Sucesso: Exceção genérica inesperada durante o envio tratada e logada com logger.exception.")

@respx.mock
async def test_send_webhook_handles_timeout_exception(mocker):
    """
    Testa o tratamento de erro quando ocorre um httpx.TimeoutException
    ao tentar enviar a notificação de webhook.
    """
    print("\nTeste: send_webhook_notification - Tratamento de httpx.TimeoutException.")
    # --- Arrange ---
    simulated_timeout_message = "Simulated timeout durante o envio do webhook"
    dummy_request_for_exception = httpx.Request(method="POST", url=TEST_WEBHOOK_TARGET_URL)
    respx.post(TEST_WEBHOOK_TARGET_URL).mock(
        side_effect=httpx.TimeoutException(simulated_timeout_message, request=dummy_request_for_exception)
    )
    print(f"  Mock respx: Rota POST para '{TEST_WEBHOOK_TARGET_URL}' mockada para levantar httpx.TimeoutException.")
    mock_utils_logger = mocker.patch("app.core.utils.logger")
    print("  Mock: app.core.utils.logger.")

    # --- Act ---
    print("  Atuando: Chamando send_webhook_notification (esperando timeout)...")
    await send_webhook_notification(TEST_EVENT_TYPE_WEBHOOK, TEST_TASK_DATA_FOR_WEBHOOK)

    # --- Assert ---
    mock_utils_logger.error.assert_called_once()
    error_log_args, _ = mock_utils_logger.error.call_args
    error_log_message = error_log_args[0]
    print(f"  Log de erro capturado: {error_log_message}")
    assert "Timeout ao enviar webhook para" in error_log_message
    assert TEST_WEBHOOK_TARGET_URL in error_log_message
    print("  Sucesso: httpx.TimeoutException tratado e logado corretamente.")

================================================================================
Capítulo 25: tests/test_db_mongodb_utils.py
================================================================================

# tests/test_db_mongodb_utils.py

# ========================
# --- Importações ---
# ========================
import pytest
from unittest.mock import AsyncMock, MagicMock, call, patch
from app.db import mongodb_utils # Importa o módulo para mockar e chamar

# ========================
# --- Testes para get_database ---
# ========================
def test_get_database_not_initialized(mocker):
    """
    Testa se get_database levanta RuntimeError quando db_instance é None.
    """
    # --- Arrange ---
    mocker.patch("app.db.mongodb_utils.db_instance", None)
    mock_logger_error = mocker.patch("app.db.mongodb_utils.logger.error")

    # --- Act & Assert ---
    with pytest.raises(RuntimeError) as excinfo:
        mongodb_utils.get_database()

    assert "A conexão com o banco de dados não foi inicializada" in str(excinfo.value)
    mock_logger_error.assert_called_once_with("Tentativa de obter instância do DB antes da inicialização!")

# ========================
# --- Testes para close_mongo_connection ---
# ========================
@pytest.mark.asyncio
async def test_close_mongo_connection_no_client(mocker):
    """
    Testa close_mongo_connection quando db_client global é None.
    """
    # --- Arrange ---
    mocker.patch("app.db.mongodb_utils.db_client", None)
    mock_logger_warning = mocker.patch("app.db.mongodb_utils.logger.warning")
    mock_logger_info = mocker.patch("app.db.mongodb_utils.logger.info")

    # --- Act ---
    await mongodb_utils.close_mongo_connection()

    # --- Assert ---
    mock_logger_info.assert_any_call("Tentando fechar conexão com MongoDB...")
    mock_logger_warning.assert_called_once_with("Tentativa de fechar conexão com MongoDB, mas cliente não estava inicializado.")
    # Verifica se o log de "conexão fechada" NÃO foi chamado
    log_info_calls = [c.args[0] for c in mock_logger_info.call_args_list if c.args]
    assert "Conexão com MongoDB fechada." not in log_info_calls

@pytest.mark.asyncio
async def test_close_mongo_connection_with_client(mocker):
    """
    Testa close_mongo_connection quando db_client existe.
    """
    # --- Arrange ---
    mock_client_instance = MagicMock()
    mocker.patch("app.db.mongodb_utils.db_client", mock_client_instance)
    mock_logger_info = mocker.patch("app.db.mongodb_utils.logger.info")
    mock_logger_warning = mocker.patch("app.db.mongodb_utils.logger.warning")

    # --- Act ---
    await mongodb_utils.close_mongo_connection()

    # --- Assert ---
    mock_client_instance.close.assert_called_once()
    assert call("Tentando fechar conexão com MongoDB...") in mock_logger_info.call_args_list
    assert call("Conexão com MongoDB fechada.") in mock_logger_info.call_args_list
    mock_logger_warning.assert_not_called()

# ========================
# --- Testes para connect_to_mongo ---
# ========================
@pytest.mark.asyncio
async def test_connect_to_mongo_failure_client_init(mocker):
    """
    Testa falha em connect_to_mongo durante a inicialização do AsyncIOMotorClient.
    """
    # --- Arrange ---
    simulated_error = Exception("Erro ao instanciar Motor Client")
    mocker.patch("motor.motor_asyncio.AsyncIOMotorClient", side_effect=simulated_error)
    mock_logger_error = mocker.patch("app.db.mongodb_utils.logger.error")
    mocker.patch("app.db.mongodb_utils.settings.MONGODB_URL", "mongodb://dummy_url")
    # Garante que os globais estejam resetados para o teste
    mocker.patch("app.db.mongodb_utils.db_client", None)
    mocker.patch("app.db.mongodb_utils.db_instance", None)

    # --- Act ---
    result = await mongodb_utils.connect_to_mongo()

    # --- Assert ---
    assert result is None
    mock_logger_error.assert_called_once()
    log_args, log_kwargs = mock_logger_error.call_args
    assert "Não foi possível conectar ao MongoDB" in log_args[0]
    assert str(simulated_error) in log_args[0]
    assert log_kwargs.get("exc_info") is True
    assert mongodb_utils.db_client is None # Verifica se o global não foi setado
    assert mongodb_utils.db_instance is None # Verifica se o global não foi setado

@pytest.mark.asyncio
async def test_connect_to_mongo_failure_ping(mocker):
    """
    Testa falha em connect_to_mongo durante o comando ping.
    """
    # --- Arrange ---
    simulated_error = Exception("Erro no comando ping")
    mock_motor_client = AsyncMock()
    mock_motor_client.admin.command.side_effect = simulated_error
    mocker.patch("motor.motor_asyncio.AsyncIOMotorClient", return_value=mock_motor_client)
    mock_logger_error = mocker.patch("app.db.mongodb_utils.logger.error")
    mocker.patch("app.db.mongodb_utils.settings.MONGODB_URL", "mongodb://dummy_ping_url")
    # Garante que os globais estejam resetados
    mocker.patch("app.db.mongodb_utils.db_client", None)
    mocker.patch("app.db.mongodb_utils.db_instance", None)

    # --- Act ---
    result = await mongodb_utils.connect_to_mongo()

    # --- Assert ---
    assert result is None
    mock_motor_client.admin.command.assert_awaited_once_with('ping')
    mock_logger_error.assert_called_once()
    log_args, log_kwargs = mock_logger_error.call_args
    assert "Não foi possível conectar ao MongoDB" in log_args[0]
    assert str(simulated_error) in log_args[0]
    assert log_kwargs.get("exc_info") is True
    assert mongodb_utils.db_client is None # Verifica se o global não foi setado com o mock que falhou no ping
    assert mongodb_utils.db_instance is None

================================================================================
Capítulo 26: tests/test_db_task_crud.py
================================================================================

# tests/test_db_task_crud.py
"""
Este módulo contém testes unitários para as funções CRUD (Create, Read, Update, Delete)
de tarefas, definidas em `app.db.task_crud`.

Os testes utilizam mocks (principalmente `unittest.mock.AsyncMock` e `unittest.mock.patch`)
para simular as interações com a coleção do MongoDB, permitindo testar a lógica
das funções CRUD de forma isolada.

São testados:
- Criação de tarefas (`create_task`) em cenários de sucesso e falha.
- Busca de tarefas por ID (`get_task_by_id`) em cenários de sucesso, não encontrado e erro de validação.
- Listagem de tarefas por proprietário (`get_tasks_by_owner`) com e sem filtros/ordenação,
  incluindo tratamento de erros de validação e DB.
- Atualização de tarefas (`update_task`).
- Deleção de tarefas (`delete_task`).
- A função auxiliar `_parse_sort_params`.
"""

# ========================
# --- Importações ---
# ========================
import uuid
from datetime import date, datetime, timedelta, timezone 
from typing import Any, Dict, List, Optional 
from unittest.mock import AsyncMock, MagicMock, call, patch
from venv import logger 

import pytest
from pydantic import ValidationError 
from pymongo import ASCENDING, DESCENDING
from pymongo.errors import DuplicateKeyError
from pytest_mock import MockerFixture

# --- Módulos da Aplicação ---
from app.db import task_crud 
from app.models.task import Task, TaskStatus, TaskUpdate

# ============================
# --- Fixture de Dados ---
# ============================

@pytest.fixture
def valid_task_obj() -> Task:
    """
    Fixture que retorna um objeto `Task` válido e completo,
    pronto para ser usado nos testes como entrada para criação
    ou como valor esperado de retorno.
    """
    owner_unique_id = uuid.uuid4()
    task_unique_id = uuid.uuid4()
    print(f"  Fixture 'valid_task_obj': Criando Task ID={task_unique_id}, Owner ID={owner_unique_id}")
    return Task(
        id=task_unique_id,
        owner_id=owner_unique_id,
        title="Tarefa de Teste Padrão",
        description="Uma descrição detalhada para a tarefa de teste padrão.",
        importance=3, 
        status=TaskStatus.PENDING,
        created_at=datetime.now(timezone.utc)
        )

@pytest.fixture
def sample_owner_id() -> uuid.UUID:
    """Fornece um UUID fixo para testes."""
    return uuid.UUID("123e4567-e89b-12d3-a456-426614174000")

@pytest.fixture
def sample_task_in_db(sample_owner_id: uuid.UUID) -> Task:
    """Fornece um objeto Task completo válido para testes."""
    task_id = uuid.uuid4()
    return Task(
        id=task_id,
        owner_id=sample_owner_id,
        title="Sample Task in DB",
        description="Description for sample task in DB",
        importance=4,
        status=TaskStatus.IN_PROGRESS,
        created_at=datetime.now(timezone.utc).replace(microsecond=0) - timedelta(days=2),
        updated_at=None,
        due_date=date.today() + timedelta(days=5),
        priority_score=55.5,
        tags=["sample", "db"]
    )

@pytest.fixture
def sample_task_create_data() -> Dict[str, Any]:
    """Fornece um dicionário válido para criar uma tarefa."""
    return {
        "title": "Sample Task Create",
        "description": "Desc for create",
        "importance": 3,
        "due_date": (date.today() + timedelta(days=10)).isoformat(),
        "status": TaskStatus.PENDING.value,
        "tags": ["create_test"],
        "project": "Project Alpha"
    }

# ===================================
# --- Testes para `create_task` ---
# ===================================
@pytest.mark.asyncio
async def test_create_task_successfully(valid_task_obj: Task):
    """
    Testa a criação bem-sucedida de uma tarefa.
    Verifica se `_get_tasks_collection` é chamado, se `insert_one` na coleção
    é chamado com os dados corretos e se a função retorna o objeto da tarefa
    quando a inserção é confirmada (acknowledged).
    """
    print(f"\nTeste: create_task - Sucesso (Task ID: {valid_task_obj.id})")
    # --- Arrange: Configurar mocks ---
    mock_mongodb_collection = AsyncMock() 
    mock_insert_operation_result = MagicMock()
    mock_insert_operation_result.acknowledged = True 
    mock_mongodb_collection.insert_one = AsyncMock(return_value=mock_insert_operation_result)
    print("  Mock: Coleção MongoDB e resultado de insert_one configurados para sucesso.")

    with patch("app.db.task_crud._get_tasks_collection", return_value=mock_mongodb_collection):
        # --- Act: Chamar a função `create_task` ---
        print(f"  Atuando: Chamando task_crud.create_task com objeto Task.")
        created_task_result = await task_crud.create_task(db=MagicMock(), task_db=valid_task_obj)

    # --- Assert: Verificar chamadas e resultado ---
    expected_dict_for_db = valid_task_obj.model_dump(mode='json') 
    mock_mongodb_collection.insert_one.assert_awaited_once_with(expected_dict_for_db)
    assert created_task_result == valid_task_obj, "A tarefa retornada não é a mesma que foi passada."
    print("  Sucesso: Tarefa criada e retornada corretamente.")

@pytest.mark.asyncio
async def test_create_task_when_db_insert_not_acknowledged(valid_task_obj: Task):
    """
    Testa o comportamento de `create_task` quando a operação `insert_one`
    do MongoDB não é confirmada (`acknowledged = False`).
    Espera-se que a função retorne `None`.
    """
    # --- Arrange ---
    mock_mongodb_collection = AsyncMock()
    mock_insert_operation_result = MagicMock()
    mock_insert_operation_result.acknowledged = False 
    mock_mongodb_collection.insert_one = AsyncMock(return_value=mock_insert_operation_result)

    # --- Act ---
    with patch("app.db.task_crud._get_tasks_collection", return_value=mock_mongodb_collection):
        created_task_result = await task_crud.create_task(db=MagicMock(), task_db=valid_task_obj)

    # --- Assert ---
    mock_mongodb_collection.insert_one.assert_awaited_once()
    assert created_task_result is None, "Deveria retornar None se a inserção não for acknowledged."

@pytest.mark.asyncio
async def test_create_task_handles_db_exception_on_insert(valid_task_obj: Task, mocker):
    """
    Testa o tratamento de exceção em `create_task` quando `insert_one`
    levanta uma exceção (simulando um erro do banco de dados).
    Espera-se que a exceção seja capturada, logada, e que a função retorne `None`.
    """
    # --- Arrange ---
    mock_mongodb_collection = AsyncMock()
    simulated_db_error = Exception("Erro de Simulação na Inserção no DB")
    mock_mongodb_collection.insert_one = AsyncMock(side_effect=simulated_db_error)
    mock_task_crud_logger = mocker.patch("app.db.task_crud.logger")

    # --- Act ---
    with patch("app.db.task_crud._get_tasks_collection", return_value=mock_mongodb_collection):
        created_task_result = await task_crud.create_task(db=MagicMock(), task_db=valid_task_obj)

    # --- Assert ---
    mock_mongodb_collection.insert_one.assert_awaited_once() 
    assert created_task_result is None, "Deveria retornar None em caso de exceção no DB."
    mock_task_crud_logger.exception.assert_called_once(), "logger.exception não foi chamado."

@pytest.mark.asyncio
async def test_create_task_indexes_success(mocker): 
    """
    Testa a criação bem-sucedida de todos os índices de tarefa.
    """
    # --- Arrange ---
    mock_db_object = MagicMock()
    mock_collection = AsyncMock()
    mock_collection.create_index = AsyncMock() 
    mocker.patch("app.db.task_crud._get_tasks_collection", return_value=mock_collection)
    mock_logger_info = mocker.patch("app.db.task_crud.logging.info")

    # --- Act ---
    await task_crud.create_task_indexes(db=mock_db_object)

    # --- Assert ---
    expected_calls = [
        call("id", unique=True, name="task_id_unique_idx"),
        call("owner_id", name="task_owner_idx"),
        call([("owner_id", ASCENDING), ("due_date", DESCENDING)], name="task_owner_due_date_idx"),
        call([("owner_id", ASCENDING), ("priority_score", DESCENDING)], name="task_owner_priority_idx"),
        call("tags", name="task_tags_idx")
    ]
    mock_collection.create_index.assert_has_awaits(expected_calls, any_order=False)
    mock_logger_info.assert_called_once_with("Índices da coleção 'tasks' verificados/criados.")

@pytest.mark.asyncio
async def test_create_task_indexes_failure(mocker): 
    """
    Testa o tratamento de erro durante a criação de um índice de tarefa.
    """
    # --- Arrange ---
    mock_db_object = MagicMock()
    simulated_db_error = Exception("Erro simulado ao criar índice 'owner_id'")
    mock_collection = AsyncMock()
    mock_collection.create_index.side_effect = [
        AsyncMock(), 
        simulated_db_error 
    ]
    mocker.patch("app.db.task_crud._get_tasks_collection", return_value=mock_collection)
    mock_logger_error = mocker.patch("app.db.task_crud.logging.error")
    mock_logger_info = mocker.patch("app.db.task_crud.logging.info")

    # --- Act ---
    await task_crud.create_task_indexes(db=mock_db_object)

    # --- Assert ---
    assert mock_collection.create_index.await_count == 2
    first_call_args = mock_collection.create_index.await_args_list[0].args
    second_call_args = mock_collection.create_index.await_args_list[1].args
    assert first_call_args[0] == "id"
    assert second_call_args[0] == "owner_id"
    mock_logger_error.assert_called_once()
    call_args, call_kwargs = mock_logger_error.call_args
    log_message = call_args[0]
    assert "Erro ao criar índices da coleção 'tasks'" in log_message
    assert str(simulated_db_error) in log_message
    assert call_kwargs.get("exc_info") is True
    mock_logger_info.assert_not_called()

# =====================================
# --- Testes para `get_task_by_id` ---
# =====================================
@pytest.mark.asyncio
async def test_get_task_by_id_successfully(valid_task_obj: Task):
    """
    Testa a busca bem-sucedida de uma tarefa por ID.
    Verifica se `find_one` é chamado com a query correta, se `Task.model_validate`
    é chamado com os dados corretos (sem `_id`), e se a tarefa é retornada.
    """
    print(f"\nTeste: get_task_by_id - Sucesso (Task ID: {valid_task_obj.id})")
    # --- Arrange ---
    task_dict_from_db = valid_task_obj.model_dump(mode='json')
    task_dict_from_db['_id'] = "some_random_mongodb_object_id" 
    
    mock_mongodb_collection = AsyncMock() 
    mock_mongodb_collection.find_one = AsyncMock(return_value=task_dict_from_db)
    print(f"  Mock: find_one para retornar dados da tarefa (incluindo _id).")
    
    target_task_id = valid_task_obj.id
    target_owner_id = valid_task_obj.owner_id

    with patch("app.db.task_crud._get_tasks_collection", return_value=mock_mongodb_collection), \
         patch("app.db.task_crud.Task.model_validate", return_value=valid_task_obj) as mock_pydantic_validate:
        # --- Act ---
        print("  Atuando: Chamando task_crud.get_task_by_id...")
        found_task_result = await task_crud.get_task_by_id(
            db=MagicMock(), task_id=target_task_id, owner_id=target_owner_id
        )

    # --- Assert ---
    expected_query_for_find_one = {"id": str(target_task_id), "owner_id": str(target_owner_id)}
    mock_mongodb_collection.find_one.assert_awaited_once_with(expected_query_for_find_one)
    
    expected_dict_for_validation = task_dict_from_db.copy()
    expected_dict_for_validation.pop('_id', None) 
    mock_pydantic_validate.assert_called_once_with(expected_dict_for_validation)
    
    assert found_task_result == valid_task_obj, "A tarefa encontrada não corresponde à esperada."
    print("  Sucesso: Tarefa encontrada e validada corretamente.")

@pytest.mark.asyncio
async def test_get_task_by_id_when_not_found_in_db():
    """
    Testa o comportamento de `get_task_by_id` quando `find_one` retorna `None`
    (indicando que a tarefa não foi encontrada no banco de dados).
    Espera-se que a função retorne `None`.
    """
    task_id_not_in_db = uuid.uuid4()
    owner_id_for_test = uuid.uuid4()
    print(f"\nTeste: get_task_by_id - Tarefa não encontrada (Task ID: {task_id_not_in_db})")
    # --- Arrange ---
    mock_mongodb_collection = AsyncMock()
    mock_mongodb_collection.find_one = AsyncMock(return_value=None) 
    print("  Mock: find_one para retornar None.")

    with patch("app.db.task_crud._get_tasks_collection", return_value=mock_mongodb_collection):
        # --- Act ---
        print("  Atuando: Chamando task_crud.get_task_by_id...")
        found_task_result = await task_crud.get_task_by_id(
            db=MagicMock(), task_id=task_id_not_in_db, owner_id=owner_id_for_test
        )

    # --- Assert ---
    mock_mongodb_collection.find_one.assert_awaited_once() 
    assert found_task_result is None, "Deveria retornar None se a tarefa não for encontrada."
    print("  Sucesso: get_task_by_id retornou None como esperado.")

@pytest.mark.asyncio
async def test_get_task_by_id_handles_pydantic_validation_error(mocker):
    """
    Testa o tratamento de erro em `get_task_by_id` quando os dados retornados
    do banco de dados falham na validação do modelo Pydantic `Task.model_validate`.
    Espera-se que a exceção seja capturada, logada, e que a função retorne `None`.
    """
    print("\nTeste: get_task_by_id - Erro de validação Pydantic ao processar dados do DB.")
    # --- Arrange ---
    invalid_task_dict_from_db = {"id": str(uuid.uuid4()), "owner_id": str(uuid.uuid4()), "title_erroneo": "Tarefa Inválida"}
    invalid_task_dict_from_db['_id'] = "another_mongo_id"

    mock_mongodb_collection = AsyncMock()
    mock_mongodb_collection.find_one = AsyncMock(return_value=invalid_task_dict_from_db)
    mock_task_crud_logger = mocker.patch("app.db.task_crud.logger")
    print(f"  Mock: find_one para retornar dados inválidos, logger mockado.")

    task_id_for_test = uuid.UUID(invalid_task_dict_from_db["id"])
    owner_id_for_test = uuid.UUID(invalid_task_dict_from_db["owner_id"])

    simulated_validation_error = ValidationError.from_exception_data(title='TaskModel', line_errors=[])
    
    with patch("app.db.task_crud._get_tasks_collection", return_value=mock_mongodb_collection), \
         patch("app.db.task_crud.Task.model_validate", side_effect=simulated_validation_error): 
        # --- Act ---
        print("  Atuando: Chamando task_crud.get_task_by_id (esperando erro de validação interno)...")
        found_task_result = await task_crud.get_task_by_id(
            db=MagicMock(), task_id=task_id_for_test, owner_id=owner_id_for_test
        )

    # --- Assert ---
    mock_mongodb_collection.find_one.assert_awaited_once()
    assert found_task_result is None, "Deveria retornar None em caso de erro de validação."
    mock_task_crud_logger.error.assert_called_once(), "logger.error não foi chamado."
    print("  Sucesso: Erro de validação tratado, retornou None e erro foi logado.")

# ===========================================
# --- Testes para `get_tasks_by_owner` ---
# ===========================================
@pytest.mark.asyncio
async def test_get_tasks_by_owner_list_basic_success(valid_task_obj: Task):
    """
    Testa a listagem básica de tarefas para um proprietário, sem filtros ou ordenação complexa.
    Verifica se a query `find` é construída corretamente e se skip/limit são aplicados.
    """
    target_owner_id = valid_task_obj.owner_id
    task_dict_from_db_iter = valid_task_obj.model_dump(mode='json')
    task_dict_from_db_iter['_id'] = "id_from_db" 
    print(f"\nTeste: get_tasks_by_owner - Listagem básica para Owner ID: {target_owner_id}")

    # --- Arrange: Configurar a cadeia de mocks ---
    mock_motor_cursor = AsyncMock() 
    mock_motor_cursor.__aiter__.return_value = [task_dict_from_db_iter]
    mock_motor_cursor.skip = MagicMock(return_value=mock_motor_cursor)
    mock_motor_cursor.limit = MagicMock(return_value=mock_motor_cursor)

    mock_mongodb_collection = MagicMock() 

    mock_mongodb_collection.find = MagicMock(return_value=mock_motor_cursor) 
    
    print("  Mock: Cadeia de find().skip().limit().sort() e validação de modelo configurados.")

    test_limit = 50
    test_skip = 10

    with patch("app.db.task_crud._get_tasks_collection", return_value=mock_mongodb_collection), \
         patch("app.db.task_crud.Task.model_validate", return_value=valid_task_obj):
        # --- Act ---
        print(f"  Atuando: Chamando get_tasks_by_owner com limit={test_limit}, skip={test_skip}...")
        retrieved_tasks_list = await task_crud.get_tasks_by_owner(
            db=MagicMock(), owner_id=target_owner_id, limit=test_limit, skip=test_skip
        )

    # --- Assert ---
    expected_base_query = {"owner_id": str(target_owner_id)}
    mock_mongodb_collection.find.assert_called_once_with(expected_base_query)
    mock_motor_cursor.skip.assert_called_once_with(test_skip)
    mock_motor_cursor.limit.assert_called_once_with(test_limit)
    
    assert len(retrieved_tasks_list) == 1, "Número de tarefas retornadas incorreto."
    assert retrieved_tasks_list[0] == valid_task_obj, "Tarefa retornada não corresponde à esperada."
    print(f"  Sucesso: Listagem básica funcionou, {len(retrieved_tasks_list)} tarefa(s) retornada(s).")

@pytest.mark.asyncio
async def test_get_tasks_by_owner_with_all_filters_and_sorting(valid_task_obj: Task):
    """
    Testa a listagem de tarefas com todos os filtros (status, projeto) e ordenação.
    Verifica se a query `find` inclui os filtros e se `sort` é chamado corretamente.
    """
    target_owner_id = valid_task_obj.owner_id
    task_dict_from_db_iter = valid_task_obj.model_dump(mode='json')
    task_dict_from_db_iter['_id'] = "id_for_sort_test"

    # --- Arrange ---
    mock_motor_cursor = AsyncMock() 
    mock_motor_cursor.__aiter__.return_value = [task_dict_from_db_iter]
    mock_motor_cursor.skip = MagicMock(return_value=mock_motor_cursor)  
    mock_motor_cursor.limit = MagicMock(return_value=mock_motor_cursor) 
    mock_motor_cursor.sort = MagicMock(return_value=mock_motor_cursor)
    mock_mongodb_collection = MagicMock()
    mock_mongodb_collection.find = MagicMock(return_value=mock_motor_cursor) 
    

    # --- Act ---
    filter_status = TaskStatus.PENDING
    filter_project = "ProjetoX_Filtro"
    sort_field = "created_at"
    sort_direction = "asc"
    test_limit_val = 10
    test_skip_val = 5

    with patch("app.db.task_crud._get_tasks_collection", return_value=mock_mongodb_collection), \
         patch("app.db.task_crud.Task.model_validate", return_value=valid_task_obj):
        print(f"  Atuando: Chamando get_tasks_by_owner com status, projeto, sort, limit, skip...")
        retrieved_tasks_list = await task_crud.get_tasks_by_owner(
            db=MagicMock(),
            owner_id=target_owner_id,
            status_filter=filter_status,
            project_filter=filter_project,
            sort_by=sort_field,
            sort_order=sort_direction,
            limit=test_limit_val,
            skip=test_skip_val
        )

    expected_query_with_filters = {
        "owner_id": str(target_owner_id),
        "status": filter_status.value,
        "project": filter_project
    }

    # --- Assert ---
    mock_mongodb_collection.find.assert_called_once_with(expected_query_with_filters)
    mock_motor_cursor.skip.assert_called_once_with(test_skip_val)
    mock_motor_cursor.limit.assert_called_once_with(test_limit_val)
    mock_motor_cursor.sort.assert_called_once_with([(sort_field, ASCENDING)])
    assert len(retrieved_tasks_list) == 1
    assert retrieved_tasks_list[0] == valid_task_obj

@pytest.mark.asyncio
async def test_get_tasks_by_owner_handles_validation_error_during_iteration(valid_task_obj: Task, mocker):
    """
    Testa o tratamento de erro em `get_tasks_by_owner` quando `Task.model_validate`
    levanta uma `ValidationError` para um dos documentos durante a iteração do cursor.
    Espera-se que o erro seja logado, o item inválido seja pulado, e os itens válidos sejam retornados.
    """
    # --- Arrange ---
    target_owner_id = uuid.uuid4()
    simulated_db_error_on_find = Exception("Erro de Simulação de Conexão Perdida no Find")
    mock_collection_object = MagicMock()
    mock_collection_object.find.side_effect = simulated_db_error_on_find
    patch_get_collection = patch("app.db.task_crud._get_tasks_collection", return_value=mock_collection_object)
    mock_task_crud_logger = mocker.patch("app.db.task_crud.logger")

    # --- Act ---
    with patch_get_collection: 
        retrieved_tasks_list = await task_crud.get_tasks_by_owner(db=MagicMock(), owner_id=target_owner_id)

    # --- Assert ---
    assert retrieved_tasks_list == [], "Deveria retornar lista vazia em caso de exceção no DB."
    mock_task_crud_logger.exception.assert_called_once(), "logger.exception não foi chamado."
    
    log_call_args_tuple = mock_task_crud_logger.exception.call_args[0]
    assert f"DB Error listing tasks for owner {target_owner_id}" in log_call_args_tuple[0], \
        "Mensagem de log de exceção não contém as informações esperadas."
    
    mock_collection_object.find.assert_called_once()

@pytest.mark.asyncio
async def test_get_tasks_by_owner_handles_general_db_exception(mocker):
    """
    Testa o tratamento de exceção em `get_tasks_by_owner` quando ocorre um erro
    geral no banco de dados durante a operação `find` (ou iteração).
    Espera-se que a função retorne uma lista vazia e logue a exceção.
    """
    # --- Arrange ---
    mock_collection = MagicMock()
    owner_id = uuid.uuid4()
    db_error = Exception("Simulated Find Error")
    mock_collection.find.side_effect = db_error
    mock_logger = mocker.patch("app.db.task_crud.logger")

    # --- Act ---
    with patch("app.db.task_crud._get_tasks_collection", return_value=mock_collection):
        tasks = await task_crud.get_tasks_by_owner(db=MagicMock(), owner_id=owner_id)

    # --- Assert ---
    assert tasks == []
    mock_logger.exception.assert_called_once()
    assert f"DB Error listing tasks for owner {owner_id}" in mock_logger.exception.call_args[0][0]

@pytest.mark.asyncio
async def test_get_tasks_by_owner_generic_db_exception(mocker): 
    """
    Testa get_tasks_by_owner quando ocorre uma exceção genérica do DB.
    """
    # --- Arrange ---
    owner_id = uuid.uuid4()
    simulated_db_error = Exception("Simulated DB Error during find/iteration")
    mock_db_object = MagicMock()
    mock_collection = MagicMock()
    mock_collection.find.side_effect = simulated_db_error
    mocker.patch("app.db.task_crud._get_tasks_collection", return_value=mock_collection)

    mock_logger_exception = mocker.patch("app.db.task_crud.logger.exception")

    # --- Act ---
    result = await task_crud.get_tasks_by_owner(db=mock_db_object, owner_id=owner_id)

    # --- Assert ---
    assert result == []
    mock_collection.find.assert_called_once()
    mock_logger_exception.assert_called_once()
    call_args, _ = mock_logger_exception.call_args
    assert f"DB Error listing tasks for owner {owner_id}" in call_args[0]
    assert str(simulated_db_error) in call_args[0]

@pytest.mark.asyncio
async def test_get_tasks_by_owner_validation_error_in_loop(mocker, sample_owner_id): 
    """
    Testa get_tasks_by_owner quando um item falha na validação Pydantic
    dentro do loop, mas outros são válidos (simulando iteração).
    """
    # --- Arrange ---
    mock_db_object = MagicMock()
    owner_id = sample_owner_id

    valid_task_dict_db = {
        "_id": "valid_id_direct_list", "id": str(uuid.uuid4()), "owner_id": str(owner_id),
        "title": "Valid Task Direct List", "importance": 3, "status": "pendente",
        "created_at": datetime.now(timezone.utc)
    }
    invalid_task_dict_db = {
        "_id": "invalid_id_direct_list", "id": str(uuid.uuid4()), "owner_id": str(owner_id),
        "title": "Invalid Task Direct List", "status": "invalid_status"
    }
    valid_task_obj = Task(
        id=uuid.UUID(valid_task_dict_db['id']), owner_id=sample_owner_id,
        title="Valid Task Direct List", importance=3, status=TaskStatus.PENDING,
        created_at=valid_task_dict_db['created_at']
    )
    mock_final_chain_link = AsyncMock()
    mock_final_chain_link.to_list.return_value = [valid_task_dict_db, invalid_task_dict_db] 
    mock_collection = AsyncMock()
    mock_collection.find.return_value.skip.return_value.limit.return_value = mock_final_chain_link
    mocker.patch("app.db.task_crud._get_tasks_collection", return_value=mock_collection)
    validation_error = ValidationError.from_exception_data(title="Task", line_errors=[])
    dict_for_valid_call = valid_task_dict_db.copy(); dict_for_valid_call.pop("_id")
    dict_for_invalid_call = invalid_task_dict_db.copy(); dict_for_invalid_call.pop("_id")
    mock_validate = mocker.patch(
        "app.db.task_crud.Task.model_validate",
        side_effect=[valid_task_obj, validation_error]
    )
    async def mock_async_for(*args, **kwargs):
        tasks = []
        items = await mock_final_chain_link.to_list() 
        for item in items:
            item.pop('_id', None)
            try:
                tasks.append(Task.model_validate(item)) 
            except (ValidationError, Exception) as e:
                task_crud.logger.error(f"DB Validation error list_tasks owner {owner_id} task {item.get('id', 'N/A')}: {e}")
                continue
        return tasks
    mock_get_tasks_internal = mocker.patch("app.db.task_crud.get_tasks_by_owner", side_effect=mock_async_for)
    mock_logger_error = mocker.patch("app.db.task_crud.logger.error")
    mock_logger_exception = mocker.patch("app.db.task_crud.logger.exception")

    # --- Act ---
    result = await task_crud.get_tasks_by_owner(db=mock_db_object, owner_id=owner_id)

    # --- Assert ---
    assert len(result) == 1
    assert result[0] == valid_task_obj
    mock_get_tasks_internal.assert_awaited_once_with(db=mock_db_object, owner_id=owner_id)
    assert mock_validate.call_count == 2
    mock_validate.assert_has_calls([call(dict_for_valid_call), call(dict_for_invalid_call)], any_order=False)
    mock_logger_error.assert_called_once()
    call_args_log, _ = mock_logger_error.call_args
    log_message = call_args_log[0]
    assert f"DB Validation error list_tasks owner {sample_owner_id} task {invalid_task_dict_db['id']}" in log_message
    assert str(validation_error) in log_message
    mock_logger_exception.assert_not_called() 

@pytest.mark.asyncio
async def test_get_tasks_by_owner_validation_error_handling(caplog):
    """
    Testa o tratamento de erro de validação dentro do loop
    de get_tasks_by_owner, verificando se o erro é logado e
    a lista resultante é vazia (ou contém apenas itens válidos).
    """
    # --- Arrange ---
    db_mock = MagicMock()
    collection_mock = MagicMock()
    db_mock.__getitem__.return_value = collection_mock
    db_mock.tasks = collection_mock
    invalid_task = {"id": "fake-id", "invalid_field": "invalid"}
    cursor_mock = MagicMock()
    cursor_mock.__aiter__.return_value = [invalid_task]
    cursor_mock.skip.return_value = cursor_mock
    cursor_mock.limit.return_value = cursor_mock
    cursor_mock.sort.return_value = cursor_mock
    collection_mock.find = MagicMock()
    collection_mock.find.return_value = cursor_mock
    owner_id = uuid.uuid4()
    

    # --- Act ---
    with patch("app.db.task_crud.logger.error") as mock_logger:
        result = await task_crud.get_tasks_by_owner(db_mock, owner_id)

    # --- Assert ---
    assert result == []
    mock_logger.assert_called()

# ===================================
# --- Testes para `update_task` ---
# ===================================
@pytest.mark.asyncio
async def test_update_task_successfully(valid_task_obj: Task):
    """
    Testa a atualização bem-sucedida de uma tarefa.
    Verifica se `find_one_and_update` é chamado com os parâmetros corretos
    (filtro, dados de atualização com `$set` e `updated_at`), e se
    `Task.model_validate` é chamado com o documento retornado pelo DB.
    """
    target_task_id = valid_task_obj.id
    target_owner_id = valid_task_obj.owner_id
    update_payload_data = {"title": "Título da Tarefa Atualizado via Teste", "status": TaskStatus.IN_PROGRESS.value}
    
    print(f"\nTeste: update_task - Sucesso (Task ID: {target_task_id})")

    # --- Arrange ---
    fixed_current_time_utc = datetime.now(timezone.utc).replace(microsecond=0)
    
    db_document_after_update = valid_task_obj.model_dump(mode='json')
    db_document_after_update.update(update_payload_data) 
    db_document_after_update['updated_at'] = fixed_current_time_utc 
    db_document_after_update['_id'] = 'some_mongo_id_for_update' 

    expected_final_task_object = Task(**db_document_after_update)
    
    mock_mongodb_collection = AsyncMock()
    mock_mongodb_collection.find_one_and_update = AsyncMock(return_value=db_document_after_update)
    print("  Mock: Coleção MongoDB, find_one_and_update, e Task.model_validate configurados.")

    with patch("app.db.task_crud.datetime") as mock_datetime_module, \
         patch("app.db.task_crud._get_tasks_collection", return_value=mock_mongodb_collection), \
         patch("app.db.task_crud.Task.model_validate", return_value=expected_final_task_object) as mock_pydantic_validate:
        
        mock_datetime_module.now.return_value = fixed_current_time_utc 
        
        # --- Act ---
        print(f"  Atuando: Chamando task_crud.update_task com payload: {update_payload_data}")
        update_result_task = await task_crud.update_task(
            db=MagicMock(),
            task_id=target_task_id,
            owner_id=target_owner_id,
            update_data=update_payload_data.copy() 
        )

    # --- Assert ---
    expected_filter_for_update = {"id": str(target_task_id), "owner_id": str(target_owner_id)}
    expected_data_for_set_operator = {**update_payload_data, "updated_at": fixed_current_time_utc}
    
    mock_mongodb_collection.find_one_and_update.assert_awaited_once_with(
        expected_filter_for_update,
        {"$set": expected_data_for_set_operator},
        return_document=True
    )
    expected_dict_for_validation = db_document_after_update.copy()
    expected_dict_for_validation.pop('_id', None)
    mock_pydantic_validate.assert_called_once_with(expected_dict_for_validation)
    
    assert update_result_task == expected_final_task_object, "A tarefa atualizada retornada não é a esperada."
    print("  Sucesso: Tarefa atualizada e retornada corretamente.")

@pytest.mark.asyncio
async def test_update_task_validation_error_post_db(mocker, sample_task_in_db): 
    """
    Testa falha de validação Pydantic após find_one_and_update retornar dados.
    """
    # --- Arrange ---
    test_task_id = sample_task_in_db.id
    owner_id = sample_task_in_db.owner_id
    update_data = {"title": "Updated Title Valid", "status": TaskStatus.IN_PROGRESS.value}
    fixed_timestamp = datetime.now(timezone.utc).replace(microsecond=0)
    mock_db_object = MagicMock()

    mock_doc_returned_from_db = {
        "_id": "mongo_db_id_valid_err",
        "id": str(test_task_id),
        "owner_id": str(owner_id),
        "title": update_data["title"],
        "status": update_data["status"],
        "created_at": sample_task_in_db.created_at,
        "updated_at": fixed_timestamp,
        "due_date": sample_task_in_db.due_date
    }
    expected_dict_for_validation = mock_doc_returned_from_db.copy()
    expected_dict_for_validation.pop("_id")

    mock_dt_now = mocker.patch("app.db.task_crud.datetime")
    mock_dt_now.now.return_value = fixed_timestamp

    mock_collection = AsyncMock()
    mock_collection.find_one_and_update.return_value = mock_doc_returned_from_db
    mocker.patch("app.db.task_crud._get_tasks_collection", return_value=mock_collection)

    simulated_validation_error = ValidationError.from_exception_data(title='Task', line_errors=[{'loc':('importance',), 'type':'missing'}])
    mock_validate = mocker.patch(
        "app.db.task_crud.Task.model_validate",
        side_effect=simulated_validation_error
    )
    mock_logger_error = mocker.patch("app.db.task_crud.logger.error")

    # --- Act ---
    result = await task_crud.update_task(
        db=mock_db_object,
        task_id=test_task_id,
        owner_id=owner_id,
        update_data=update_data.copy() 
    )

    # --- Assert ---
    assert result is None
    mock_collection.find_one_and_update.assert_awaited_once() 

    find_one_update_args, find_one_update_kwargs = mock_collection.find_one_and_update.await_args
    assert len(find_one_update_args) == 2
    call_filter = find_one_update_args[0]
    call_update_doc = find_one_update_args[1]
    assert call_filter == {"id": str(test_task_id), "owner_id": str(owner_id)}
    expected_update_set = update_data.copy()
    expected_update_set["updated_at"] = fixed_timestamp
    assert call_update_doc == {"$set": expected_update_set}
    assert find_one_update_kwargs.get("return_document") is True

    mock_validate.assert_called_once_with(expected_dict_for_validation)

    mock_logger_error.assert_called_once()
    call_args_log, _ = mock_logger_error.call_args
    log_message = call_args_log[0]
    assert f"DB Validation error update_task {test_task_id} owner {owner_id}" in log_message
    assert str(simulated_validation_error) in log_message

@pytest.mark.asyncio
async def test_update_task_generic_exception(mocker, sample_owner_id): 
    """
    Testa update_task quando find_one_and_update levanta exceção genérica.
    """
    # --- Arrange ---
    test_task_id = uuid.uuid4()
    owner_id = sample_owner_id 
    update_data = {"title": "Tentativa de Update"}
    mock_db_object = MagicMock()
    fixed_timestamp = datetime.now(timezone.utc).replace(microsecond=0)
    mock_dt_now = mocker.patch("app.db.task_crud.datetime")
    mock_dt_now.now.return_value = fixed_timestamp
    simulated_db_error = Exception("Simulated generic DB error on update")
    mock_collection = AsyncMock()
    mock_collection.find_one_and_update.side_effect = simulated_db_error
    mocker.patch("app.db.task_crud._get_tasks_collection", return_value=mock_collection)
    mock_validate = mocker.patch("app.db.task_crud.Task.model_validate")
    mock_logger_exception = mocker.patch("app.db.task_crud.logger.exception")

    # --- Act ---
    result = await task_crud.update_task(
        db=mock_db_object,
        task_id=test_task_id,
        owner_id=owner_id, 
        update_data=update_data.copy()
    )

    # --- Assert ---
    assert result is None
    mock_collection.find_one_and_update.assert_awaited_once()
    find_one_update_args, find_one_update_kwargs = mock_collection.find_one_and_update.await_args
    assert len(find_one_update_args) == 2
    call_filter = find_one_update_args[0]
    call_update_doc = find_one_update_args[1]
    assert call_filter == {"id": str(test_task_id), "owner_id": str(owner_id)}
    expected_update_set = update_data.copy()
    expected_update_set["updated_at"] = fixed_timestamp
    assert call_update_doc == {"$set": expected_update_set}
    assert find_one_update_kwargs.get("return_document") is True
    mock_validate.assert_not_called()
    mock_logger_exception.assert_called_once()
    call_args_log, _ = mock_logger_exception.call_args
    log_message = call_args_log[0]
    assert f"DB Error updating task {test_task_id} owner {owner_id}" in log_message
    assert str(simulated_db_error) in log_message

@pytest.mark.asyncio
async def test_update_task_not_found_logs_warning(mocker, sample_owner_id): 
    """
    Testa se update_task loga um aviso quando find_one_and_update retorna None.
    """
    # --- Arrange ---
    test_task_id = uuid.uuid4()
    owner_id = sample_owner_id
    update_data = {"title": "Nome Nao Sera Atualizado"}
    mock_db_object = MagicMock()
    fixed_timestamp = datetime.now(timezone.utc).replace(microsecond=0)
    mock_dt_now = mocker.patch("app.db.task_crud.datetime")
    mock_dt_now.now.return_value = fixed_timestamp
    mock_collection = AsyncMock()
    mock_collection.find_one_and_update.return_value = None
    mocker.patch("app.db.task_crud._get_tasks_collection", return_value=mock_collection)
    mock_validate = mocker.patch("app.db.task_crud.Task.model_validate")
    mock_logger_warning = mocker.patch("app.db.task_crud.logger.warning")

    # --- Act ---
    result = await task_crud.update_task(
        db=mock_db_object,
        task_id=test_task_id,
        owner_id=owner_id,
        update_data=update_data.copy()
    )

    # --- Assert ---
    assert result is None
    mock_collection.find_one_and_update.assert_awaited_once()
    find_one_update_args, find_one_update_kwargs = mock_collection.find_one_and_update.await_args
    assert len(find_one_update_args) == 2
    call_filter = find_one_update_args[0]
    call_update_doc = find_one_update_args[1]
    assert call_filter == {"id": str(test_task_id), "owner_id": str(owner_id)}
    expected_update_set = update_data.copy()
    expected_update_set["updated_at"] = fixed_timestamp
    assert call_update_doc == {"$set": expected_update_set}
    assert find_one_update_kwargs.get("return_document") is True
    mock_validate.assert_not_called()
    mock_logger_warning.assert_called_once()
    call_args_log, _ = mock_logger_warning.call_args
    assert f"Tentativa de atualizar tarefa não encontrada: ID {test_task_id}, Owner ID {owner_id}" in call_args_log[0]

# ===================================
# --- Testes para `delete_task` ---
# ===================================
@pytest.mark.asyncio
async def test_delete_task_successfully():
    """
    Testa a deleção bem-sucedida de uma tarefa.
    Verifica se `delete_one` é chamado com a query correta e se a função
    retorna `True` quando `deleted_count` é 1.
    """
    target_task_id, target_owner_id = uuid.uuid4(), uuid.uuid4()
    print(f"\nTeste: delete_task - Sucesso (Task ID: {target_task_id})")
    # --- Arrange ---
    mock_mongodb_collection = AsyncMock()
    mock_delete_operation_result = MagicMock()
    mock_delete_operation_result.deleted_count = 1 
    mock_mongodb_collection.delete_one = AsyncMock(return_value=mock_delete_operation_result)
    print("  Mock: delete_one para retornar deleted_count=1.")

    with patch("app.db.task_crud._get_tasks_collection", return_value=mock_mongodb_collection):
        # --- Act ---
        print("  Atuando: Chamando task_crud.delete_task...")
        delete_was_successful = await task_crud.delete_task(
            db=MagicMock(), task_id=target_task_id, owner_id=target_owner_id
        )

    # --- Assert ---
    expected_query_for_delete = {"id": str(target_task_id), "owner_id": str(target_owner_id)}
    mock_mongodb_collection.delete_one.assert_awaited_once_with(expected_query_for_delete)
    assert delete_was_successful is True, "delete_task deveria retornar True para deleção bem-sucedida."
    print("  Sucesso: Tarefa deletada e True retornado.")

@pytest.mark.asyncio
async def test_delete_task_when_not_found_or_not_deleted():
    """
    Testa o comportamento de `delete_task` quando a tarefa não é encontrada
    (ou por algum motivo não é deletada), resultando em `deleted_count = 0`.
    Espera-se que a função retorne `False`.
    """
    target_task_id, target_owner_id = uuid.uuid4(), uuid.uuid4()
    print(f"\nTeste: delete_task - Tarefa não encontrada para deleção (Task ID: {target_task_id})")
    # --- Arrange ---
    mock_mongodb_collection = AsyncMock()
    mock_delete_operation_result = MagicMock()
    mock_delete_operation_result.deleted_count = 0
    mock_mongodb_collection.delete_one = AsyncMock(return_value=mock_delete_operation_result)
    print("  Mock: delete_one para retornar deleted_count=0.")

    with patch("app.db.task_crud._get_tasks_collection", return_value=mock_mongodb_collection):
        # --- Act ---
        print("  Atuando: Chamando task_crud.delete_task...")
        delete_was_successful = await task_crud.delete_task(
            db=MagicMock(), task_id=target_task_id, owner_id=target_owner_id
        )

    # --- Assert ---
    mock_mongodb_collection.delete_one.assert_awaited_once() 
    assert delete_was_successful is False, "delete_task deveria retornar False se nenhum documento for deletado."
    print("  Sucesso: Deleção falhou (tarefa não encontrada) e False retornado.")

@pytest.mark.asyncio
async def test_delete_task_generic_exception(mocker, sample_owner_id): 
    """
    Testa delete_task quando delete_one levanta uma exceção genérica.
    """
    # --- Arrange ---
    test_task_id = uuid.uuid4()
    owner_id = sample_owner_id
    mock_db_object = MagicMock()

    simulated_db_error = Exception("Simulated generic DB error on delete")
    mock_collection = AsyncMock()
    mock_collection.delete_one.side_effect = simulated_db_error
    mocker.patch("app.db.task_crud._get_tasks_collection", return_value=mock_collection)

    mock_logger_exception = mocker.patch("app.db.task_crud.logger.exception")

    # --- Act ---
    result = await task_crud.delete_task(
        db=mock_db_object,
        task_id=test_task_id,
        owner_id=owner_id
    )

    # --- Assert ---
    assert result is False 
    mock_collection.delete_one.assert_awaited_once_with({"id": str(test_task_id), "owner_id": str(owner_id)})

    mock_logger_exception.assert_called_once()
    call_args_log, _ = mock_logger_exception.call_args
    log_message = call_args_log[0]
    assert f"DB Error deleting task {test_task_id} owner {owner_id}" in log_message
    assert str(simulated_db_error) in log_message

# ===========================================
# --- Testes para `_parse_sort_params` ---
# ===========================================

@pytest.mark.parametrize(
    "sort_by_input, sort_order_input, expected_output",
    [
        ("due_date", "asc", [("due_date", ASCENDING)]),
        ("priority_score", "desc", [("priority_score", DESCENDING)]),
        ("created_at", "ASC", [("created_at", ASCENDING)]), 
        ("importance", "DESC", [("importance", DESCENDING)]),
        ("due_date", "ascending_string_literal", [("due_date", DESCENDING)]), 
        ("due_date", "", [("due_date", DESCENDING)]),
        ("invalid_sort_field", "desc", None),
        (None, "desc", None),
    ]
)
def test_parse_sort_params_various_inputs(sort_by_input, sort_order_input, expected_output):
    """
    Testa `_parse_sort_params` com várias combinações de entrada
    para `sort_by` e `sort_order`, verificando se a saída corresponde
    ao formato esperado pelo PyMongo para ordenação.
    """
    
    print(f"\nTeste: _parse_sort_params(sort_by='{sort_by_input}', sort_order='{sort_order_input}')")
    actual_output = task_crud._parse_sort_params(sort_by_input, sort_order_input)
    print(f"  Saída Esperada: {expected_output}, Saída Real: {actual_output}")
    assert actual_output == expected_output, \
        f"Para sort_by='{sort_by_input}', sort_order='{sort_order_input}', " \
        f"esperado {expected_output}, mas obtido {actual_output}."


================================================================================
Capítulo 27: tests/test_db_user_crud.py
================================================================================

# tests/test_db_user_crud.py

# ========================
# --- Importações ---
# ========================
import uuid
from datetime import datetime, timezone
import pytest # type: ignore
from unittest.mock import AsyncMock, MagicMock, patch, call
from pydantic import ValidationError
from pymongo.errors import DuplicateKeyError

from app.db import user_crud
from app.models.user import UserCreate, UserInDB, UserUpdate

# ====================================
# --- Marcador Global de Teste ---
# ====================================
pytestmark = pytest.mark.asyncio

# ============================
# --- Fixture Auxiliar ---
# ============================
@pytest.fixture
def mock_db_connection() -> AsyncMock:
    """Fornece um mock genérico para a conexão DB."""
    return AsyncMock()

@pytest.fixture
def sample_user_create() -> UserCreate:
    """Fornece um objeto UserCreate válido para testes."""
    return UserCreate(
        email="test@example.com",
        username="testuser",
        password="validpassword123",
        full_name="Test User Name"
    )

@pytest.fixture
def sample_user_in_db() -> UserInDB:
    """Fornece um objeto UserInDB válido para testes."""
    user_id = uuid.uuid4()
    return UserInDB(
        id=user_id,
        username="sampleuserindb",
        email="sampleindb@example.com",
        hashed_password="hashed_sample_password",
        full_name="Sample User In DB",
        disabled=False,
        created_at=datetime.now(timezone.utc).replace(microsecond=0),
        updated_at=None
    )

# =======================================
# --- Testes para user_crud.get_user_by_id ---
# =======================================
async def test_get_user_by_id_success(mocker, mock_db_connection, sample_user_in_db): # type: ignore
    """Testa busca de usuário por ID com sucesso."""
    # --- Arrange ---
    test_user_id = sample_user_in_db.id
    user_dict_from_db = sample_user_in_db.model_dump(mode="json")
    user_dict_from_db['_id'] = "mock_mongo_id"
    expected_validation_dict = sample_user_in_db.model_dump(mode="json")

    mock_collection = AsyncMock()
    mock_collection.find_one.return_value = user_dict_from_db
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)
    mock_validate = mocker.patch("app.db.user_crud.UserInDB.model_validate", return_value=sample_user_in_db)

    # --- Act ---
    result = await user_crud.get_user_by_id(db=mock_db_connection, user_id=test_user_id)

    # --- Assert ---
    assert result == sample_user_in_db
    mock_collection.find_one.assert_awaited_once_with({"id": str(test_user_id)})
    mock_validate.assert_called_once_with(expected_validation_dict)

async def test_get_user_by_id_not_found(mocker, mock_db_connection): # type: ignore
    """Testa busca de usuário por ID quando não encontrado."""
    # --- Arrange ---
    test_user_id = uuid.uuid4()
    mock_collection = AsyncMock()
    mock_collection.find_one.return_value = None
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)

    # --- Act ---
    result = await user_crud.get_user_by_id(db=mock_db_connection, user_id=test_user_id)

    # --- Assert ---
    assert result is None
    mock_collection.find_one.assert_awaited_once_with({"id": str(test_user_id)})

async def test_get_user_by_id_validation_error(mocker, mock_db_connection): # type: ignore
    """Testa falha de validação Pydantic ao buscar usuário por ID."""
    # --- Arrange ---
    test_user_id = uuid.uuid4()
    invalid_user_dict_from_db = {"_id": "mongo_id", "id": str(test_user_id), "campo_errado": True}
    expected_validation_dict = {"id": str(test_user_id), "campo_errado": True}

    mock_collection = AsyncMock()
    mock_collection.find_one.return_value = invalid_user_dict_from_db
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)

    simulated_error = ValidationError.from_exception_data(title='UserInDB', line_errors=[])
    mock_validate = mocker.patch("app.db.user_crud.UserInDB.model_validate", side_effect=simulated_error)
    mock_logger_error = mocker.patch("app.db.user_crud.logger.error")

    # --- Act ---
    result = await user_crud.get_user_by_id(db=mock_db_connection, user_id=test_user_id)

    # --- Assert ---
    assert result is None
    mock_collection.find_one.assert_awaited_once_with({"id": str(test_user_id)})
    mock_validate.assert_called_once_with(expected_validation_dict)
    mock_logger_error.assert_called_once()
    assert f"DB Validation error get_user_by_id {test_user_id}" in mock_logger_error.call_args[0][0]

# ===========================================
# --- Testes para user_crud.get_user_by_username ---
# ===========================================
async def test_get_user_by_username_success(mocker, mock_db_connection, sample_user_in_db): # type: ignore
    """Testa busca de usuário por username com sucesso."""
    # --- Arrange ---
    test_username = sample_user_in_db.username
    user_dict_from_db = sample_user_in_db.model_dump(mode="json")
    user_dict_from_db['_id'] = "mock_mongo_id"
    expected_validation_dict = sample_user_in_db.model_dump(mode="json")

    mock_collection = AsyncMock()
    mock_collection.find_one.return_value = user_dict_from_db
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)
    mock_validate = mocker.patch("app.db.user_crud.UserInDB.model_validate", return_value=sample_user_in_db)

    # --- Act ---
    result = await user_crud.get_user_by_username(db=mock_db_connection, username=test_username)

    # --- Assert ---
    assert result == sample_user_in_db
    mock_collection.find_one.assert_awaited_once_with({"username": test_username})
    mock_validate.assert_called_once_with(expected_validation_dict)

async def test_get_user_by_username_not_found(mocker, mock_db_connection): # type: ignore
    """Testa busca de usuário por username quando não encontrado."""
    # --- Arrange ---
    test_username = "nouser_username"
    mock_collection = AsyncMock()
    mock_collection.find_one.return_value = None
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)

    # --- Act ---
    result = await user_crud.get_user_by_username(db=mock_db_connection, username=test_username)

    # --- Assert ---
    assert result is None
    mock_collection.find_one.assert_awaited_once_with({"username": test_username})

async def test_get_user_by_username_validation_error(mocker, mock_db_connection): # type: ignore
    """Testa falha de validação Pydantic ao buscar usuário por username."""
    # --- Arrange ---
    test_username = "invalid_user_validate"
    invalid_user_dict_from_db = {"_id": "mongo_id", "username": test_username, "campo_errado": True}
    expected_validation_dict = {"username": test_username, "campo_errado": True}

    mock_collection = AsyncMock()
    mock_collection.find_one.return_value = invalid_user_dict_from_db
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)

    simulated_error = ValidationError.from_exception_data(title='UserInDB', line_errors=[])
    mock_validate = mocker.patch("app.db.user_crud.UserInDB.model_validate", side_effect=simulated_error)
    mock_logger_error = mocker.patch("app.db.user_crud.logger.error")

    # --- Act ---
    result = await user_crud.get_user_by_username(db=mock_db_connection, username=test_username)

    # --- Assert ---
    assert result is None
    mock_collection.find_one.assert_awaited_once_with({"username": test_username})
    mock_validate.assert_called_once_with(expected_validation_dict)
    mock_logger_error.assert_called_once()
    assert f"DB Validation error get_user_by_username {test_username}" in mock_logger_error.call_args[0][0]

# ===========================================
# --- Testes para user_crud.get_user_by_email ---
# ===========================================
async def test_get_user_by_email_success(mocker, mock_db_connection, sample_user_in_db): # type: ignore
    """Testa busca de usuário por email com sucesso."""
    # --- Arrange ---
    test_email = sample_user_in_db.email
    user_dict_from_db = sample_user_in_db.model_dump(mode="json")
    user_dict_from_db['_id'] = "mock_mongo_id"
    expected_validation_dict = sample_user_in_db.model_dump(mode="json")

    mock_collection = AsyncMock()
    mock_collection.find_one.return_value = user_dict_from_db
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)
    mock_validate = mocker.patch("app.db.user_crud.UserInDB.model_validate", return_value=sample_user_in_db)

    # --- Act ---
    result = await user_crud.get_user_by_email(db=mock_db_connection, email=test_email)

    # --- Assert ---
    assert result == sample_user_in_db
    mock_collection.find_one.assert_awaited_once_with({"email": test_email})
    mock_validate.assert_called_once_with(expected_validation_dict)

async def test_get_user_by_email_not_found(mocker, mock_db_connection): # type: ignore
    """Testa busca de usuário por email quando não encontrado."""
    # --- Arrange ---
    test_email = "nouser@example.com"
    mock_collection = AsyncMock()
    mock_collection.find_one.return_value = None
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)

    # --- Act ---
    result = await user_crud.get_user_by_email(db=mock_db_connection, email=test_email)

    # --- Assert ---
    assert result is None
    mock_collection.find_one.assert_awaited_once_with({"email": test_email})

async def test_get_user_by_email_validation_error(mocker, mock_db_connection): # type: ignore
    """Testa falha de validação Pydantic ao buscar usuário por email."""
    # --- Arrange ---
    test_email = "invalid_validate@example.com"
    invalid_user_dict_from_db = {"_id": "mongo_id", "email": test_email, "campo_errado": True}
    expected_validation_dict = {"email": test_email, "campo_errado": True}

    mock_collection = AsyncMock()
    mock_collection.find_one.return_value = invalid_user_dict_from_db
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)

    simulated_error = ValidationError.from_exception_data(title='UserInDB', line_errors=[])
    mock_validate = mocker.patch("app.db.user_crud.UserInDB.model_validate", side_effect=simulated_error)
    mock_logger_error = mocker.patch("app.db.user_crud.logger.error")

    # --- Act ---
    result = await user_crud.get_user_by_email(db=mock_db_connection, email=test_email)

    # --- Assert ---
    assert result is None
    mock_collection.find_one.assert_awaited_once_with({"email": test_email})
    mock_validate.assert_called_once_with(expected_validation_dict)
    mock_logger_error.assert_called_once()
    assert f"DB Validation error get_user_by_email {test_email}" in mock_logger_error.call_args[0][0]

# =======================================
# --- Testes para user_crud.create_user ---
# =======================================
async def test_create_user_success(mocker, mock_db_connection, sample_user_create): # type: ignore
    """Testa a criação de usuário com sucesso."""
    # --- Arrange ---
    test_uuid = uuid.uuid4()
    test_datetime = datetime.now(timezone.utc)
    mock_uuid_module = mocker.patch("app.db.user_crud.uuid")
    mock_uuid_module.uuid4.return_value = test_uuid
    mock_dt_module = mocker.patch("app.db.user_crud.datetime")
    mock_dt_module.now.return_value = test_datetime
    mock_dt_module.side_effect = lambda *args, **kw: datetime(*args, **kw)

    mocked_hashed_password = "hashed_password_success"
    mocker.patch("app.db.user_crud.get_password_hash", return_value=mocked_hashed_password)

    expected_validation_data_dict = {
        "id": test_uuid,
        "username": sample_user_create.username,
        "email": sample_user_create.email,
        "hashed_password": mocked_hashed_password,
        "full_name": sample_user_create.full_name,
        "disabled": False,
        "created_at": test_datetime,
        "updated_at": None
    }
    mock_validated_user_obj = MagicMock(spec=UserInDB)
    for key, value in expected_validation_data_dict.items():
        setattr(mock_validated_user_obj, key, value)

    mock_validate = mocker.patch(
        "app.db.user_crud.UserInDB.model_validate",
        return_value=mock_validated_user_obj
    )

    expected_dict_to_insert = {k: str(v) if isinstance(v, uuid.UUID) else (v.isoformat() if isinstance(v, datetime) else v) for k, v in expected_validation_data_dict.items() if k != 'created_at'}
    expected_dict_to_insert['created_at'] = test_datetime
    expected_dict_to_insert['updated_at'] = None

    mock_validated_user_obj.model_dump.return_value = expected_dict_to_insert

    mock_insert_result = MagicMock()
    mock_insert_result.acknowledged = True

    mock_collection = AsyncMock()
    mock_collection.insert_one.return_value = mock_insert_result
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)

    # --- Act ---
    result = await user_crud.create_user(db=mock_db_connection, user_in=sample_user_create)

    # --- Assert ---
    assert result == mock_validated_user_obj

    user_crud.get_password_hash.assert_called_once_with(sample_user_create.password)
    mock_validate.assert_called_once_with(expected_validation_data_dict)

    mock_validated_user_obj.model_dump.assert_called_once_with(mode="json")
    mock_collection.insert_one.assert_awaited_once_with(expected_dict_to_insert)

async def test_create_user_raises_duplicate_key_error(mocker, mock_db_connection, sample_user_create): # type: ignore
    """Testa se DuplicateKeyError é relançado."""
    # --- Arrange ---
    mocker.patch("app.db.user_crud.get_password_hash", return_value="mock_hash")
    mock_validated_obj = MagicMock()
    mock_validated_obj.model_dump.return_value = {"some": "data"}
    mocker.patch("app.db.user_crud.UserInDB.model_validate", return_value=mock_validated_obj)

    simulated_db_error = DuplicateKeyError("E11000 duplicate key error")
    mock_collection = AsyncMock()
    mock_collection.insert_one.side_effect = simulated_db_error
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)
    mock_logger_warning = mocker.patch("app.db.user_crud.logger.warning")

    # --- Act & Assert ---
    with pytest.raises(DuplicateKeyError):
        await user_crud.create_user(db=mock_db_connection, user_in=sample_user_create)

    mock_collection.insert_one.assert_awaited_once_with({"some": "data"})
    mock_logger_warning.assert_called_once()

async def test_create_user_pydantic_validation_failure(mocker): # type: ignore
    """
    Testa se create_user retorna None e loga um erro quando
    UserInDB.model_validate(user_db_data) falha.
    """
    # --- Arrange ---
    valid_user_create_input = UserCreate(
        email="test_pydantic_fail@example.com",
        username="test_pydantic_user_fail",
        password="validpassword123",
        full_name="Test Pydantic Fail"
    )

    mocker.patch("app.db.user_crud.get_password_hash", return_value="mocked_hashed_password")
    mock_logger_error = mocker.patch("app.db.user_crud.logger.error")

    simulated_pydantic_error = ValidationError.from_exception_data(
        title='UserInDB',
        line_errors=[{'type': 'missing', 'loc': ('some_field',), 'msg': 'Field required', 'input': {}}]
    )
    mock_model_validate = mocker.patch(
        "app.db.user_crud.UserInDB.model_validate",
        side_effect=simulated_pydantic_error
    )

    mock_db_connection = AsyncMock()

    # --- Act ---
    result = await user_crud.create_user(db=mock_db_connection, user_in=valid_user_create_input)

    # --- Assert ---
    assert result is None

    mock_model_validate.assert_called_once()

    mock_logger_error.assert_called_once()
    call_args, call_kwargs = mock_logger_error.call_args
    log_message = call_args[0]
    assert f"Erro de validação Pydantic ao preparar dados para user_db_obj (username: {valid_user_create_input.username})" in log_message
    assert str(simulated_pydantic_error) in log_message
    assert call_kwargs.get("exc_info") is True

async def test_create_user_db_insert_not_acknowledged(mocker): # type: ignore
    """
    Testa se create_user retorna None e loga erro quando a inserção
    no banco de dados não é confirmada (acknowledged=False).
    """
    # --- Arrange ---
    valid_user_create_input = UserCreate(
        email="test_not_acknowledged@example.com",
        username="test_user_not_acknowledged",
        password="validpassword123",
        full_name="Test Not Ack"
    )

    mocker.patch("app.db.user_crud.get_password_hash", return_value="mocked_hashed_password")

    mock_user_db_obj = MagicMock()
    expected_dict_to_insert = {"mocked_data": "to_insert"}
    mock_user_db_obj.model_dump.return_value = expected_dict_to_insert
    mock_validate = mocker.patch("app.db.user_crud.UserInDB.model_validate", return_value=mock_user_db_obj)

    mock_insert_result = MagicMock()
    mock_insert_result.acknowledged = False

    mock_collection = AsyncMock()
    mock_collection.insert_one.return_value = mock_insert_result
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)

    mock_logger_error = mocker.patch("app.db.user_crud.logger.error")

    mock_db_connection = AsyncMock()

    # --- Act ---
    result = await user_crud.create_user(db=mock_db_connection, user_in=valid_user_create_input)

    # --- Assert ---
    assert result is None

    mock_validate.assert_called_once()
    mock_user_db_obj.model_dump.assert_called_once_with(mode="json")

    mock_collection.insert_one.assert_awaited_once()

    actual_call_args = mock_collection.insert_one.await_args.args
    actual_call_kwargs = mock_collection.insert_one.await_args.kwargs
    assert len(actual_call_args) == 1
    assert actual_call_args[0] == expected_dict_to_insert
    assert not actual_call_kwargs

    mock_logger_error.assert_called_once()
    call_args, _ = mock_logger_error.call_args
    log_message = call_args[0]
    assert f"DB Insert User Acknowledged False for username {valid_user_create_input.username}" in log_message

async def test_create_user_handles_generic_db_exception_on_insert(mocker): # type: ignore
    """
    Testa se create_user retorna None e loga exceção quando
    insert_one levanta um erro genérico do banco de dados.
    """
    # --- Arrange ---
    valid_user_create_input = UserCreate(
        email="test_generic_db_exception@example.com",
        username="test_user_generic_exception",
        password="validpassword123",
        full_name="Test Generic DB Exc"
    )

    mocker.patch("app.db.user_crud.get_password_hash", return_value="mocked_hashed_password")

    mock_user_db_obj = MagicMock()
    expected_dict_to_insert = {"mocked_data": "to_insert"}
    mock_user_db_obj.model_dump.return_value = expected_dict_to_insert
    mock_validate = mocker.patch("app.db.user_crud.UserInDB.model_validate", return_value=mock_user_db_obj)

    simulated_db_error = Exception("Simulated generic database error on insert")
    mock_collection = AsyncMock()
    mock_collection.insert_one.side_effect = simulated_db_error
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)

    mock_logger_exception = mocker.patch("app.db.user_crud.logger.exception")

    mock_db_connection = AsyncMock()

    # --- Act ---
    result = await user_crud.create_user(db=mock_db_connection, user_in=valid_user_create_input)

    # --- Assert ---
    assert result is None

    mock_validate.assert_called_once()
    mock_user_db_obj.model_dump.assert_called_once_with(mode="json")

    mock_collection.insert_one.assert_awaited_once_with(expected_dict_to_insert)

    mock_logger_exception.assert_called_once()
    call_args, _ = mock_logger_exception.call_args
    log_message = call_args[0]
    assert f"Erro inesperado ao inserir usuário {valid_user_create_input.username} no DB" in log_message
    assert str(simulated_db_error) in log_message

# =======================================
# --- Testes para user_crud.update_user ---
# =======================================
async def test_update_user_success(mocker, mock_db_connection, sample_user_in_db): # type: ignore
    """Testa atualização de usuário com sucesso (sem alterar senha)."""
    # --- Arrange ---
    test_user_id = sample_user_in_db.id
    update_payload = UserUpdate(full_name="Novo Nome Completo", email="novo@email.com")
    fixed_timestamp = datetime.now(timezone.utc).replace(microsecond=0)

    mock_doc_after_update = sample_user_in_db.model_dump(mode="json")
    mock_doc_after_update.update({
        "full_name": update_payload.full_name,
        "email": update_payload.email,
        "updated_at": fixed_timestamp # MongoDB lida com datetime object
    })
    mock_doc_after_update["_id"] = "some_mongo_id"

    expected_validation_dict = mock_doc_after_update.copy()
    expected_validation_dict.pop("_id")

    # Criar obj esperado diretamente
    expected_user_obj = UserInDB(**expected_validation_dict)

    mock_pwd_hash = mocker.patch("app.db.user_crud.get_password_hash")
    mock_dt_now = mocker.patch("app.db.user_crud.datetime")
    mock_dt_now.now.return_value = fixed_timestamp

    mock_collection = AsyncMock()
    mock_collection.find_one_and_update.return_value = mock_doc_after_update
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)
    mock_validate_model = mocker.patch("app.db.user_crud.UserInDB.model_validate", return_value=expected_user_obj)

    # --- Act ---
    result = await user_crud.update_user(db=mock_db_connection, user_id=test_user_id, user_update=update_payload)

    # --- Assert ---
    assert result == expected_user_obj
    mock_pwd_hash.assert_not_called()

    mock_collection.find_one_and_update.assert_awaited_once()
    args, kwargs = mock_collection.find_one_and_update.await_args
    filter_arg = args[0]
    update_arg = args[1]
    assert filter_arg == {"id": str(test_user_id)}
    expected_set = {
        "full_name": update_payload.full_name,
        "email": update_payload.email,
        "updated_at": fixed_timestamp
    }
    assert update_arg == {"$set": expected_set}
    assert kwargs.get("return_document") is True

    mock_validate_model.assert_called_once_with(expected_validation_dict)

async def test_update_user_with_password(mocker, mock_db_connection, sample_user_in_db): # type: ignore
    """Testa atualização de usuário incluindo a senha."""
    # --- Arrange ---
    test_user_id = sample_user_in_db.id
    new_password = "newSecurePassword123"
    new_hashed_password = "hashed_" + new_password
    update_payload = UserUpdate(password=new_password, disabled=True)
    fixed_timestamp = datetime.now(timezone.utc).replace(microsecond=0)

    mock_doc_after_update = sample_user_in_db.model_dump(mode="json")
    mock_doc_after_update.update({
        "hashed_password": new_hashed_password,
        "disabled": True,
        "updated_at": fixed_timestamp # Usar datetime object
    })
    mock_doc_after_update["_id"] = "pw_update_id"
    expected_validation_dict = mock_doc_after_update.copy()
    expected_validation_dict.pop("_id")

    expected_user_obj = UserInDB(**expected_validation_dict)

    mock_pwd_hash = mocker.patch("app.db.user_crud.get_password_hash", return_value=new_hashed_password)
    mock_dt_now = mocker.patch("app.db.user_crud.datetime")
    mock_dt_now.now.return_value = fixed_timestamp

    mock_collection = AsyncMock()
    mock_collection.find_one_and_update.return_value = mock_doc_after_update
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)
    mock_validate_model = mocker.patch("app.db.user_crud.UserInDB.model_validate", return_value=expected_user_obj)

    # --- Act ---
    result = await user_crud.update_user(db=mock_db_connection, user_id=test_user_id, user_update=update_payload)

    # --- Assert ---
    assert result == expected_user_obj
    mock_pwd_hash.assert_called_once_with(new_password)

    mock_collection.find_one_and_update.assert_awaited_once()
    args, kwargs = mock_collection.find_one_and_update.await_args
    filter_arg = args[0]
    update_arg = args[1]
    assert filter_arg == {"id": str(test_user_id)}
    expected_set = {
        "hashed_password": new_hashed_password,
        "disabled": True,
        "updated_at": fixed_timestamp
    }
    assert update_arg == {"$set": expected_set}
    assert kwargs.get("return_document") is True

    mock_validate_model.assert_called_once_with(expected_validation_dict)

async def test_update_user_not_found(mocker, mock_db_connection): # type: ignore
    """Testa atualização de usuário quando find_one_and_update retorna None."""
    # --- Arrange ---
    test_user_id = uuid.uuid4()
    update_payload = UserUpdate(full_name="Nome que nao sera atualizado")
    fixed_timestamp = datetime.now(timezone.utc)

    mock_pwd_hash = mocker.patch("app.db.user_crud.get_password_hash")
    mock_dt_now = mocker.patch("app.db.user_crud.datetime")
    mock_dt_now.now.return_value = fixed_timestamp

    mock_collection = AsyncMock()
    mock_collection.find_one_and_update.return_value = None
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)
    mock_logger_warning = mocker.patch("app.db.user_crud.logger.warning")

    # --- Act ---
    result = await user_crud.update_user(db=mock_db_connection, user_id=test_user_id, user_update=update_payload)

    # --- Assert ---
    assert result is None

    mock_collection.find_one_and_update.assert_awaited_once()
    args, kwargs = mock_collection.find_one_and_update.await_args
    expected_set = {"full_name": update_payload.full_name, "updated_at": fixed_timestamp}
    assert args[1] == {"$set": expected_set}

    mock_logger_warning.assert_called_once()
    assert f"Attempt to update user not found: ID {test_user_id}" in mock_logger_warning.call_args[0][0]
    mock_pwd_hash.assert_not_called()

async def test_update_user_raises_duplicate_key_error(mocker, mock_db_connection): # type: ignore
    """Testa se DuplicateKeyError em update é relançado."""
    # --- Arrange ---
    test_user_id = uuid.uuid4()
    update_payload = UserUpdate(email="existing@duplicate.com")
    fixed_timestamp = datetime.now(timezone.utc)


    mocker.patch("app.db.user_crud.get_password_hash")
    mock_dt_now = mocker.patch("app.db.user_crud.datetime")
    mock_dt_now.now.return_value = fixed_timestamp

    simulated_db_error = DuplicateKeyError("E11000 duplicate key error collection")
    mock_collection = AsyncMock()
    mock_collection.find_one_and_update.side_effect = simulated_db_error
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)
    mock_logger_warning = mocker.patch("app.db.user_crud.logger.warning")

    # --- Act & Assert ---
    with pytest.raises(DuplicateKeyError):
        await user_crud.update_user(db=mock_db_connection, user_id=test_user_id, user_update=update_payload)

    mock_collection.find_one_and_update.assert_awaited_once()
    args, kwargs = mock_collection.find_one_and_update.await_args
    expected_set = {"email": update_payload.email, "updated_at": fixed_timestamp}
    assert args[1] == {"$set": expected_set}

    mock_logger_warning.assert_called_once()

async def test_update_user_generic_exception(mocker, mock_db_connection): # type: ignore
    """Testa tratamento de exceção genérica em update."""
    # --- Arrange ---
    test_user_id = uuid.uuid4()
    update_payload = UserUpdate(disabled=False)
    fixed_timestamp = datetime.now(timezone.utc)

    mocker.patch("app.db.user_crud.get_password_hash")
    mock_dt_now = mocker.patch("app.db.user_crud.datetime")
    mock_dt_now.now.return_value = fixed_timestamp

    simulated_db_error = Exception("Generic update error")
    mock_collection = AsyncMock()
    mock_collection.find_one_and_update.side_effect = simulated_db_error
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)
    mock_logger_exception = mocker.patch("app.db.user_crud.logger.exception")

    # --- Act ---
    result = await user_crud.update_user(db=mock_db_connection, user_id=test_user_id, user_update=update_payload)

    # --- Assert ---
    assert result is None

    mock_collection.find_one_and_update.assert_awaited_once()
    args, kwargs = mock_collection.find_one_and_update.await_args
    expected_set = {"disabled": update_payload.disabled, "updated_at": fixed_timestamp}
    assert args[1] == {"$set": expected_set}

    mock_logger_exception.assert_called_once()
    assert f"DB Error updating user {test_user_id}" in mock_logger_exception.call_args[0][0]

async def test_update_user_empty_payload_updates_only_timestamp(mocker): # type: ignore
    """
    Testa se update_user atualiza apenas o timestamp 'updated_at'
    quando o payload de atualização resulta em nenhum dado a ser modificado,
    e valida se o usuário correto é retornado.
    """
    # --- Arrange ---
    test_user_id = uuid.uuid4()
    fixed_timestamp = datetime.now(timezone.utc).replace(microsecond=0)

    empty_update_payload = UserUpdate(password=None)

    existing_user_mock = MagicMock(spec=UserInDB)
    existing_user_mock.id = test_user_id

    # Doc retornado pelo DB
    mock_doc_after_update_from_db = {"_id": "mongo_id", "id": str(test_user_id), "updated_at": fixed_timestamp}
    # Dict esperado para validação (sem _id)
    expected_dict_for_validation = {"id": str(test_user_id), "updated_at": fixed_timestamp}
    # Obj esperado pós validação (com dados minimos p/ o teste)
    final_validated_user_mock = MagicMock(spec=UserInDB)

    mocker.patch("app.db.user_crud.get_password_hash")
    mock_get_user = mocker.patch("app.db.user_crud.get_user_by_id", return_value=existing_user_mock)
    mock_dt_now = mocker.patch("app.db.user_crud.datetime")
    mock_dt_now.now.return_value = fixed_timestamp

    mock_collection = AsyncMock()
    mock_collection.find_one_and_update.return_value = mock_doc_after_update_from_db
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)

    # Mock retorna o obj mockado
    mock_validate_model = mocker.patch(
        "app.db.user_crud.UserInDB.model_validate",
        return_value=final_validated_user_mock
    )

    mock_db_connection = AsyncMock()

    # --- Act ---
    result = await user_crud.update_user(
        db=mock_db_connection,
        user_id=test_user_id,
        user_update=empty_update_payload
    )

    # --- Assert ---
    assert result == final_validated_user_mock

    user_crud.get_password_hash.assert_not_called()

    mock_get_user.assert_awaited_once()
    actual_get_user_args = mock_get_user.await_args.args
    actual_get_user_kwargs = mock_get_user.await_args.kwargs
    assert (len(actual_get_user_args) == 2 and actual_get_user_args[0] is mock_db_connection and actual_get_user_args[1] == test_user_id and not actual_get_user_kwargs) or \
           (not actual_get_user_args and len(actual_get_user_kwargs) == 2 and actual_get_user_kwargs.get('db') is mock_db_connection and actual_get_user_kwargs.get('user_id') == test_user_id)

    mock_collection.find_one_and_update.assert_awaited_once()
    find_one_update_args, find_one_update_kwargs = mock_collection.find_one_and_update.await_args
    assert len(find_one_update_args) == 2
    call_filter = find_one_update_args[0]
    call_update_doc = find_one_update_args[1]
    assert call_filter == {"id": str(test_user_id)}
    assert call_update_doc == {"$set": {"updated_at": fixed_timestamp}}
    assert find_one_update_kwargs.get("return_document") is True

    mock_validate_model.assert_called_once_with(expected_dict_for_validation)

async def test_update_user_empty_payload_get_user_returns_none(mocker): # type: ignore
    """
    Testa se update_user retorna None quando o payload de atualização
    está vazio e a busca inicial por get_user_by_id retorna None.
    """
    # --- Arrange ---
    test_user_id = uuid.uuid4()
    empty_update_payload = UserUpdate(password=None)

    mock_pwd_hash = mocker.patch("app.db.user_crud.get_password_hash")

    mock_get_user = mocker.patch("app.db.user_crud.get_user_by_id", return_value=None)

    mock_collection_instance = AsyncMock()
    mocker.patch(
        "app.db.user_crud._get_users_collection",
        return_value=mock_collection_instance
    )

    mock_validate = mocker.patch("app.db.user_crud.UserInDB.model_validate")

    mock_db_connection = AsyncMock()

    # --- Act ---
    result = await user_crud.update_user(
        db=mock_db_connection,
        user_id=test_user_id,
        user_update=empty_update_payload
    )

    # --- Assert ---
    assert result is None

    mock_pwd_hash.assert_not_called()

    mock_get_user.assert_awaited_once()
    actual_get_user_args = mock_get_user.await_args.args
    actual_get_user_kwargs = mock_get_user.await_args.kwargs
    assert (len(actual_get_user_args) == 2 and actual_get_user_args[0] is mock_db_connection and actual_get_user_args[1] == test_user_id and not actual_get_user_kwargs) or \
           (not actual_get_user_args and len(actual_get_user_kwargs) == 2 and actual_get_user_kwargs.get('db') is mock_db_connection and actual_get_user_kwargs.get('user_id') == test_user_id)

    # _get_users_collection *é chamado* no início da função update_user
    user_crud._get_users_collection.assert_called_once_with(mock_db_connection)
    mock_collection_instance.find_one_and_update.assert_not_called()
    mock_validate.assert_not_called()

async def test_update_user_empty_payload_update_exception(mocker): # type: ignore
    """
    Testa se update_user retorna None e loga exceção quando payload está vazio
    e a chamada a find_one_and_update (para updated_at) levanta erro.
    """
    # --- Arrange ---
    test_user_id = uuid.uuid4()
    fixed_timestamp = datetime.now(timezone.utc).replace(microsecond=0)
    empty_update_payload = UserUpdate(password=None)

    existing_user_mock = MagicMock(spec=UserInDB)
    existing_user_mock.id = test_user_id

    simulated_update_exception = Exception("Erro ao atualizar apenas updated_at")

    mock_pwd_hash = mocker.patch("app.db.user_crud.get_password_hash")
    mock_get_user = mocker.patch("app.db.user_crud.get_user_by_id", return_value=existing_user_mock)
    mock_dt_now = mocker.patch("app.db.user_crud.datetime")
    mock_dt_now.now.return_value = fixed_timestamp

    mock_collection = AsyncMock()
    mock_collection.find_one_and_update.side_effect = simulated_update_exception
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)

    mock_validate_model = mocker.patch("app.db.user_crud.UserInDB.model_validate")
    mock_logger_exception = mocker.patch("app.db.user_crud.logger.exception")
    mock_db_connection = AsyncMock()

    # --- Act ---
    result = await user_crud.update_user(
        db=mock_db_connection,
        user_id=test_user_id,
        user_update=empty_update_payload
    )

    # --- Assert ---
    assert result is None

    mock_pwd_hash.assert_not_called()
    mock_get_user.assert_awaited_once()

    mock_collection.find_one_and_update.assert_awaited_once()
    mock_validate_model.assert_not_called()
    mock_logger_exception.assert_called_once()
    call_args, _ = mock_logger_exception.call_args
    log_message = call_args[0]
    assert f"DB Error updating user (only updated_at) {test_user_id}" in log_message
    assert str(simulated_update_exception) in log_message

async def test_update_user_empty_payload_validate_failure(mocker): # type: ignore
    """
    Testa falha na validação Pydantic após find_one_and_update
    no branch de payload vazio, assumindo que find_one_and_update retornou um doc.
    """
    # --- Arrange ---
    test_user_id = uuid.uuid4()
    fixed_timestamp = datetime.now(timezone.utc).replace(microsecond=0)
    empty_update_payload = UserUpdate(password=None)

    existing_user_mock = MagicMock(spec=UserInDB)
    existing_user_mock.id = test_user_id

    mock_doc_after_update_invalid = {
        "_id": "mongo_id_invalid",
        "id": str(test_user_id),
        "updated_at": fixed_timestamp,
        "campo_inesperado": "este_campo_causa_falha"
    }
    expected_dict_for_validation = {
        "id": str(test_user_id),
        "updated_at": fixed_timestamp,
        "campo_inesperado": "este_campo_causa_falha"
    }

    mocker.patch("app.db.user_crud.get_password_hash")
    mock_get_user = mocker.patch("app.db.user_crud.get_user_by_id", return_value=existing_user_mock)
    mock_dt_now = mocker.patch("app.db.user_crud.datetime")
    mock_dt_now.now.return_value = fixed_timestamp

    mock_collection = AsyncMock()
    mock_collection.find_one_and_update.return_value = mock_doc_after_update_invalid
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)

    simulated_validation_error = ValidationError.from_exception_data(
        title='UserInDB',
        line_errors=[{'type': 'extra_forbidden', 'loc': ('campo_inesperado',), 'msg': 'Extra fields not permitted', 'input': 'este_campo_causa_falha'}]
    )
    mock_validate_model = mocker.patch(
        "app.db.user_crud.UserInDB.model_validate",
        side_effect=simulated_validation_error
    )

    mock_logger_exception = mocker.patch("app.db.user_crud.logger.exception")
    mock_logger_error = mocker.patch("app.db.user_crud.logger.error") # Deve usar .exception agora
    mock_db_connection = AsyncMock()

    # --- Act ---
    result = await user_crud.update_user(
        db=mock_db_connection,
        user_id=test_user_id,
        user_update=empty_update_payload
    )

    # --- Assert ---
    assert result is None

    user_crud.get_password_hash.assert_not_called()
    mock_get_user.assert_awaited_once()
    mock_collection.find_one_and_update.assert_awaited_once()

    # A validação falha, mas ainda é chamada
    mock_validate_model.assert_called_once_with(expected_dict_for_validation)

    # O erro é capturado pelo 'except Exception', usando logger.exception
    mock_logger_error.assert_not_called()
    mock_logger_exception.assert_called_once()
    call_args, _ = mock_logger_exception.call_args
    log_message = call_args[0]
    assert f"DB Error updating user (only updated_at) {test_user_id}" in log_message
    assert str(simulated_validation_error) in log_message

async def test_update_user_main_path_validate_failure(mocker): # type: ignore
    """
    Testa falha na validação Pydantic após find_one_and_update
    no caminho principal (quando update_data não está vazio).
    """
    # --- Arrange ---
    test_user_id = uuid.uuid4()
    update_payload = UserUpdate(full_name="Nome Atualizado")
    fixed_timestamp = datetime.now(timezone.utc).replace(microsecond=0)

    mock_doc_after_update_invalid = {
        "_id": "mongo_id_main_fail",
        "id": str(test_user_id),
        "full_name": update_payload.full_name,
        "updated_at": fixed_timestamp,
        "campo_invalido_no_retorno": 123
    }
    expected_dict_for_validation = {
        "id": str(test_user_id),
        "full_name": update_payload.full_name,
        "updated_at": fixed_timestamp,
        "campo_invalido_no_retorno": 123
    }

    mock_pwd_hash = mocker.patch("app.db.user_crud.get_password_hash")
    mock_get_user = mocker.patch("app.db.user_crud.get_user_by_id")
    mock_dt_now = mocker.patch("app.db.user_crud.datetime")
    mock_dt_now.now.return_value = fixed_timestamp

    mock_collection = AsyncMock()
    mock_collection.find_one_and_update.return_value = mock_doc_after_update_invalid
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)

    simulated_validation_error = ValidationError.from_exception_data(
        title='UserInDB',
        line_errors=[{'type': 'extra_forbidden', 'loc': ('campo_invalido_no_retorno',), 'msg': 'Extra fields not permitted', 'input': 123}]
    )
    mock_validate_model = mocker.patch(
        "app.db.user_crud.UserInDB.model_validate",
        side_effect=simulated_validation_error
    )

    mock_logger_error = mocker.patch("app.db.user_crud.logger.error")
    mock_db_connection = AsyncMock()

    # --- Act ---
    result = await user_crud.update_user(
        db=mock_db_connection,
        user_id=test_user_id,
        user_update=update_payload
    )

    # --- Assert ---
    assert result is None

    mock_pwd_hash.assert_not_called()
    mock_get_user.assert_not_called()

    mock_collection.find_one_and_update.assert_awaited_once()
    find_one_update_args, find_one_update_kwargs = mock_collection.find_one_and_update.await_args
    assert len(find_one_update_args) == 2
    call_filter = find_one_update_args[0]
    call_update_doc = find_one_update_args[1]
    assert call_filter == {"id": str(test_user_id)}
    expected_set_doc = {"full_name": update_payload.full_name, "updated_at": fixed_timestamp}
    assert call_update_doc == {"$set": expected_set_doc}
    assert find_one_update_kwargs.get("return_document") is True

    mock_validate_model.assert_called_once_with(expected_dict_for_validation)

    mock_logger_error.assert_called_once()
    call_args, call_kwargs = mock_logger_error.call_args
    log_message = call_args[0]
    assert f"DB Validation error after updating user {test_user_id}" in log_message
    assert str(simulated_validation_error) in log_message
    # A asserção sobre exc_info foi removida, pois o teste falhou e a correção acima garante o log esperado.

async def test_update_user_main_path_user_not_found(mocker, mock_db_connection): # type: ignore
    """
    Testa se update_user retorna None e loga aviso quando o usuário
    não é encontrado por find_one_and_update no caminho principal.
    """
    # --- Arrange ---
    test_user_id = uuid.uuid4()
    update_payload = UserUpdate(full_name="Nome Nao Atualizado")
    fixed_timestamp = datetime.now(timezone.utc)

    mock_pwd_hash = mocker.patch("app.db.user_crud.get_password_hash")
    mock_dt_now = mocker.patch("app.db.user_crud.datetime")
    mock_dt_now.now.return_value = fixed_timestamp

    mock_collection = AsyncMock()
    mock_collection.find_one_and_update.return_value = None 
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)

    mock_validate_model = mocker.patch("app.db.user_crud.UserInDB.model_validate")
    mock_logger_warning = mocker.patch("app.db.user_crud.logger.warning")

    # --- Act ---
    result = await user_crud.update_user(
        db=mock_db_connection,
        user_id=test_user_id,
        user_update=update_payload
    )

    # --- Assert ---
    assert result is None

    mock_pwd_hash.assert_not_called()
    mock_collection.find_one_and_update.assert_awaited_once()
    mock_validate_model.assert_not_called()

    mock_logger_warning.assert_called_once()
    log_call_args = mock_logger_warning.call_args[0]
    assert f"Attempt to update user not found: ID {test_user_id}" in log_call_args[0]

async def test_update_user_main_path_raises_duplicate_key_error(mocker, mock_db_connection): # type: ignore
    """
    Testa se DuplicateKeyError é relançado por update_user
    no caminho principal e um aviso é logado.
    """
    # --- Arrange ---
    test_user_id = uuid.uuid4()
    update_payload = UserUpdate(email="duplicate@test.com") 
    fixed_timestamp = datetime.now(timezone.utc)

    mocker.patch("app.db.user_crud.get_password_hash")
    mock_dt_now = mocker.patch("app.db.user_crud.datetime")
    mock_dt_now.now.return_value = fixed_timestamp

    simulated_db_error = DuplicateKeyError("E11000 duplicate key error collection on update")
    mock_collection = AsyncMock()
    mock_collection.find_one_and_update.side_effect = simulated_db_error
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)

    mock_validate_model = mocker.patch("app.db.user_crud.UserInDB.model_validate")
    mock_logger_warning = mocker.patch("app.db.user_crud.logger.warning")

    # --- Act & Assert ---
    with pytest.raises(DuplicateKeyError):
        await user_crud.update_user(
            db=mock_db_connection,
            user_id=test_user_id,
            user_update=update_payload
        )

    mock_collection.find_one_and_update.assert_awaited_once()
    args, kwargs = mock_collection.find_one_and_update.await_args
    expected_set = {"email": update_payload.email, "updated_at": fixed_timestamp}
    assert args[1] == {"$set": expected_set}

    mock_validate_model.assert_not_called()

    mock_logger_warning.assert_called_once()
    log_call_args = mock_logger_warning.call_args[0]
    assert f"DB Error: Attempt to update user {test_user_id}" in log_call_args[0]
    assert "'email': 'duplicate@test.com'" in log_call_args[0]

async def test_update_user_empty_payload_find_one_and_update_returns_none(mocker): # type: ignore
    """
    Testa se update_user retorna None quando payload está vazio,
    usuário existe, mas find_one_and_update (para updated_at) retorna None.
    """
    # --- Arrange ---
    test_user_id = uuid.uuid4()
    fixed_timestamp = datetime.now(timezone.utc).replace(microsecond=0)
    empty_update_payload = UserUpdate(password=None)

    existing_user_mock = MagicMock(spec=UserInDB)
    existing_user_mock.id = test_user_id

    mock_pwd_hash = mocker.patch("app.db.user_crud.get_password_hash")
    mock_get_user = mocker.patch("app.db.user_crud.get_user_by_id", return_value=existing_user_mock)
    mock_dt_now = mocker.patch("app.db.user_crud.datetime")
    mock_dt_now.now.return_value = fixed_timestamp

    mock_collection = AsyncMock()
    mock_collection.find_one_and_update.return_value = None 
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)

    mock_validate_model = mocker.patch("app.db.user_crud.UserInDB.model_validate")
    mock_logger_exception = mocker.patch("app.db.user_crud.logger.exception")
    mock_db_connection = AsyncMock()

    # --- Act ---
    result = await user_crud.update_user(
        db=mock_db_connection,
        user_id=test_user_id,
        user_update=empty_update_payload
    )

    # --- Assert ---
    assert result is None

    mock_pwd_hash.assert_not_called()
    mock_get_user.assert_awaited_once()

    # Verifica a chamada a find_one_and_update (para updated_at)
    mock_collection.find_one_and_update.assert_awaited_once()
    find_one_update_args, find_one_update_kwargs = mock_collection.find_one_and_update.await_args
    assert len(find_one_update_args) == 2
    call_filter = find_one_update_args[0]
    call_update_doc = find_one_update_args[1]
    assert call_filter == {"id": str(test_user_id)}
    assert call_update_doc == {"$set": {"updated_at": fixed_timestamp}}
    assert find_one_update_kwargs.get("return_document") is True

    mock_validate_model.assert_not_called()
    mock_logger_exception.assert_not_called()

# =======================================
# --- Testes para user_crud.delete_user ---
# =======================================
async def test_delete_user_success(mocker, mock_db_connection): # type: ignore
    """Testa deleção de usuário com sucesso."""
    # --- Arrange ---
    test_user_id = uuid.uuid4()

    mock_delete_result = MagicMock()
    mock_delete_result.deleted_count = 1

    mock_collection = AsyncMock()
    mock_collection.delete_one.return_value = mock_delete_result
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)
    mock_logger_info = mocker.patch("app.db.user_crud.logger.info")

    # --- Act ---
    result = await user_crud.delete_user(db=mock_db_connection, user_id=test_user_id)

    # --- Assert ---
    assert result is True
    mock_collection.delete_one.assert_awaited_once_with({"id": str(test_user_id)})
    mock_logger_info.assert_called_once_with(f"User {test_user_id} deleted successfully.")

async def test_delete_user_not_found(mocker, mock_db_connection): # type: ignore
    """Testa deleção de usuário quando não encontrado."""
    # --- Arrange ---
    test_user_id = uuid.uuid4()

    mock_delete_result = MagicMock()
    mock_delete_result.deleted_count = 0

    mock_collection = AsyncMock()
    mock_collection.delete_one.return_value = mock_delete_result
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)
    mock_logger_warning = mocker.patch("app.db.user_crud.logger.warning")

    # --- Act ---
    result = await user_crud.delete_user(db=mock_db_connection, user_id=test_user_id)

    # --- Assert ---
    assert result is False
    mock_collection.delete_one.assert_awaited_once_with({"id": str(test_user_id)})
    mock_logger_warning.assert_called_once()
    assert f"Attempt to delete user {test_user_id}" in mock_logger_warning.call_args[0][0]
    assert "(deleted_count: 0)" in mock_logger_warning.call_args[0][0]

async def test_delete_user_generic_exception(mocker, mock_db_connection): # type: ignore
    """Testa tratamento de exceção genérica em delete_user."""
    # --- Arrange ---
    test_user_id = uuid.uuid4()
    simulated_db_error = Exception("Generic delete error")

    mock_collection = AsyncMock()
    mock_collection.delete_one.side_effect = simulated_db_error
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)
    mock_logger_exception = mocker.patch("app.db.user_crud.logger.exception")

    # --- Act ---
    result = await user_crud.delete_user(db=mock_db_connection, user_id=test_user_id)

    # --- Assert ---
    assert result is False
    mock_collection.delete_one.assert_awaited_once_with({"id": str(test_user_id)})
    mock_logger_exception.assert_called_once()
    assert f"DB Error deleting user {test_user_id}" in mock_logger_exception.call_args[0][0]

# ==============================================
# --- Testes para user_crud.create_user_indexes ---
# ==============================================
async def test_create_user_indexes_success(mocker, mock_db_connection): # type: ignore
    """Testa criação de índices com sucesso."""
    # --- Arrange ---
    mock_collection = AsyncMock()
    mock_collection.create_index = AsyncMock()
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)
    mock_logger_info = mocker.patch("app.db.user_crud.logger.info")

    # --- Act ---
    await user_crud.create_user_indexes(db=mock_db_connection)

    # --- Assert ---
    expected_calls = [
        call("username", unique=True, name="username_unique_idx"),
        call("email", unique=True, name="email_unique_idx")
    ]
    mock_collection.create_index.assert_has_awaits(expected_calls, any_order=False)
    mock_logger_info.assert_called_once()
    assert "Índices da coleção 'users'" in mock_logger_info.call_args[0][0]
    assert "verificados/criados com sucesso" in mock_logger_info.call_args[0][0]

async def test_create_user_indexes_failure(mocker, mock_db_connection): # type: ignore
    """Testa tratamento de erro na criação de índices."""
    # --- Arrange ---
    simulated_index_error = Exception("Erro ao criar indice simulado")
    mock_collection = AsyncMock()
    mock_collection.create_index.side_effect = simulated_index_error
    mocker.patch("app.db.user_crud._get_users_collection", return_value=mock_collection)
    mock_logger_error = mocker.patch("app.db.user_crud.logger.error")

    # --- Act ---
    await user_crud.create_user_indexes(db=mock_db_connection)

    # --- Assert ---
    mock_collection.create_index.assert_awaited_once_with("username", unique=True, name="username_unique_idx")
    mock_logger_error.assert_called_once()
    call_args, call_kwargs = mock_logger_error.call_args
    log_message = call_args[0]
    assert "Erro ao criar índices para a coleção 'users'" in log_message
    assert str(simulated_index_error) in log_message
    assert call_kwargs.get("exc_info") is True

================================================================================
Capítulo 28: tests/test_main.py
================================================================================

# tests/test_main.py

# ========================
# --- Importações ---
# ========================
import logging
from loguru import logger as loguru_logger_obj
from unittest.mock import AsyncMock, MagicMock
import pytest
from fastapi import FastAPI, status
from fastapi.middleware.cors import CORSMiddleware
from httpx import AsyncClient

# --- Módulos da Aplicação ---
from app.core import logging_config 
from app.core.config import Settings, settings 
from app.main import lifespan
from app.main import _setup_cors_middleware


# ======================================
# --- Testes para o Endpoint Raiz ---
# ======================================
@pytest.mark.asyncio
async def test_read_root_endpoint_returns_welcome_message(test_async_client: AsyncClient):
    print("\nTeste: Endpoint raiz ('/').")
    print(f"  Atuando: GET para '/'")
    response = await test_async_client.get("/")

    assert response.status_code == status.HTTP_200_OK, \
        f"Esperado status 200, recebido {response.status_code}. Resposta: {response.text}"
    
    response_json = response.json()
    expected_message_part = f"Bem-vindo à {settings.PROJECT_NAME}!"
    assert "message" in response_json, "Campo 'message' ausente na resposta JSON."
    assert expected_message_part in response_json["message"], \
        f"Mensagem de boas-vindas não contém '{expected_message_part}'. Recebido: '{response_json['message']}'"
    print(f"  Sucesso: Endpoint raiz retornou a mensagem de boas-vindas esperada.")

# ===============================================
# --- Testes para a Função de Ciclo de Vida (Lifespan) ---
# ===============================================
@pytest.mark.asyncio
async def test_lifespan_handles_database_connection_failure_on_startup(
    mocker,
    caplog
):
    caplog.set_level(logging.CRITICAL, logger="app.main") 
    mock_connect_db = mocker.patch('app.main.connect_to_mongo', return_value=None)
    mock_close_db = mocker.patch('app.main.close_mongo_connection', new_callable=AsyncMock)
    mock_create_user_indexes_fn = mocker.patch('app.main.create_user_indexes', new_callable=AsyncMock)
    mock_create_task_indexes_fn = mocker.patch('app.main.create_task_indexes', new_callable=AsyncMock)
    
    test_app_instance = MagicMock(spec=FastAPI)
    test_app_instance.state = MagicMock()
    if hasattr(test_app_instance.state, "db"):
        del test_app_instance.state.db
    
    print("  Atuando: Executando o context manager 'lifespan'...")
    async with lifespan(test_app_instance):
        print("    Dentro do 'yield' do lifespan (após tentativa de conexão).")
        print("DEBUG: test_lifespan_handles_database_connection_failure_on_startup - Pós-yield")
        assert not hasattr(test_app_instance.state, "db") or test_app_instance.state.db is None, \
            "app.state.db não deveria ser definido se a conexão falhou."

    mock_connect_db.assert_awaited_once()
    mock_create_user_indexes_fn.assert_not_called()
    mock_create_task_indexes_fn.assert_not_called()
    
    assert any(
        "Falha fatal ao conectar ao MongoDB" in record.getMessage()
        for record in caplog.records
        if record.name == "app.main" and record.levelname == "CRITICAL"
    ), "Mensagem de log crítico para falha de conexão não encontrada."
    
    mock_close_db.assert_not_called()

@pytest.mark.asyncio
async def test_lifespan_handles_index_creation_failure_on_startup(
    mocker,
    caplog
):
    simulated_index_error = Exception("Erro simulado durante a criação do índice de usuário.")
    mock_db_connection_instance = AsyncMock()
    mocker.patch('app.main.connect_to_mongo', return_value=mock_db_connection_instance)
    mock_close_db = mocker.patch('app.main.close_mongo_connection', new_callable=AsyncMock)
    mock_create_user_idx_fn = mocker.patch('app.main.create_user_indexes', side_effect=simulated_index_error)
    mock_create_task_idx_fn = mocker.patch('app.main.create_task_indexes', new_callable=AsyncMock)
    
    mock_app_instance_for_lifespan = MagicMock(spec=FastAPI)
    mock_app_instance_for_lifespan.state = MagicMock()

    caplog.set_level(logging.ERROR, logger="app.main")

    try:
        async with lifespan(mock_app_instance_for_lifespan):
            print(f"    Dentro do 'yield' do lifespan. app.state.db={mock_app_instance_for_lifespan.state.db}")
            print("DEBUG: test_lifespan_handles_index_creation_failure_on_startup - Pós-yield")
            assert mock_app_instance_for_lifespan.state.db == mock_db_connection_instance, \
                "app.state.db não foi definido corretamente após conexão bem-sucedida."
    except Exception as e:
        pytest.fail(f"Lifespan levantou uma exceção inesperada para fora: {e}")

    mock_create_user_idx_fn.assert_awaited_once_with(mock_db_connection_instance)
    mock_create_task_idx_fn.assert_not_called()
    
    error_log_found = False
    for record in caplog.records:
        if record.name == "app.main" and record.levelname == "ERROR":
            if "Erro durante a criação de índices" in record.getMessage():
                assert record.exc_info is not None and record.exc_info[0] is Exception, \
                    "exc_info=True não foi devidamente logado ou é do tipo errado."
                error_log_found = True
                break
    assert error_log_found, "Mensagem de log de erro para falha na criação de índice não encontrada."
    
    mock_close_db.assert_awaited_once()

# ===============================================
# --- Testes Logging Config Externo ---
# ===============================================
from loguru import logger as loguru_logger_obj 

def test_intercept_handler_emit_unknown_level(mocker):
    handler = logging_config.InterceptHandler()
    mock_loguru_opt_log = mocker.patch.object(loguru_logger_obj, "opt", return_value=loguru_logger_obj)
    mock_loguru_log = mocker.patch.object(loguru_logger_obj, "log")
    invalid_levelname = "INVALIDLEVELNAME"
    numeric_level = 60
    record = logging.LogRecord(
        name='test.logger',
        level=numeric_level,
        pathname='/path/to/file.py',
        lineno=10,
        msg='Test message with invalid level name',
        args=[],
        exc_info=None,
        func='test_func'
    )
    record.levelname = invalid_levelname

    handler.emit(record)

    mock_loguru_opt_log.assert_called_once() 
    final_log_call_args, _ = mock_loguru_log.call_args
    assert final_log_call_args[0] == numeric_level
    assert final_log_call_args[1] == record.getMessage()

# ==================================================
# --- Testes para _setup_cors_middleware ---
# ==================================================
def test_setup_cors_middleware_with_empty_origins_logs_warning(mocker, caplog):
    mock_app = MagicMock(spec=FastAPI)
    mock_settings_empty_cors = Settings(
        MONGODB_URL="mongodb://testhost:27017/testdb",
        JWT_SECRET_KEY="testsecret",
        CORS_ALLOWED_ORIGINS=[]
    )
    caplog.set_level(logging.WARNING, logger="app.main")

    _setup_cors_middleware(mock_app, mock_settings_empty_cors)

    mock_app.add_middleware.assert_not_called()
    assert any(
        "Nenhuma origem CORS configurada" in record.getMessage()
        for record in caplog.records
        if record.name == "app.main" and record.levelname == "WARNING"
    ), "Warning de CORS para origens vazias não encontrado nos logs"
    print("  Sucesso: _setup_cors_middleware logou warning para CORS vazio.")

def test_setup_cors_middleware_with_origins_adds_middleware(mocker, caplog):
    mock_app = MagicMock(spec=FastAPI)
    mock_settings_with_cors = Settings(
        MONGODB_URL="mongodb://testhost:27017/testdb",
        JWT_SECRET_KEY="testsecret",
        CORS_ALLOWED_ORIGINS=["http://localhost:3000", "https://example.com"]
    )
    caplog.set_level(logging.INFO, logger="app.main")

    _setup_cors_middleware(mock_app, mock_settings_with_cors)

    mock_app.add_middleware.assert_called_once()
    args, kwargs = mock_app.add_middleware.call_args
    assert args[0] == CORSMiddleware
    assert kwargs.get("allow_origins") == ["http://localhost:3000", "https://example.com"]
    assert kwargs.get("allow_credentials") is True
    assert kwargs.get("allow_methods") == ["*"]
    assert kwargs.get("allow_headers") == ["*"]

    assert any(
        "Configurando CORS para origens:" in record.getMessage()
        for record in caplog.records
        if record.name == "app.main" and record.levelname == "INFO"
    ), "Log de INFO para configuração CORS não encontrado."
    print("  Sucesso: _setup_cors_middleware adicionou middleware para CORS configurado.")

# ==================================================
# --- Testes para LifeSpan ---
# ==================================================
@pytest.mark.asyncio
async def test_lifespan_successful_startup_and_shutdown(mocker, caplog):
    """
    Testa o caminho feliz completo do lifespan:
    - Conexão com DB bem-sucedida.
    - Criação de ambos os índices bem-sucedida.
    - Logs de INFO apropriados são emitidos.
    - Conexão com DB é fechada no shutdown.
    """
    caplog.set_level(logging.INFO, logger="app.main") 
    
    mock_db_conn = AsyncMock(name="MockDBConnection")
    mock_connect_db = mocker.patch('app.main.connect_to_mongo', return_value=mock_db_conn)
    mock_close_db = mocker.patch('app.main.close_mongo_connection', new_callable=AsyncMock)
    mock_create_user_idx = mocker.patch('app.main.create_user_indexes', new_callable=AsyncMock)
    mock_create_task_idx = mocker.patch('app.main.create_task_indexes', new_callable=AsyncMock)
    
    
    test_app_instance = MagicMock(spec=FastAPI)
    test_app_instance.state = MagicMock() 
    if hasattr(test_app_instance.state, "db"):
        del test_app_instance.state.db


    # --- Act ---
    async with lifespan(test_app_instance):
        print("DEBUG: test_lifespan_successful_startup - Pós-yield (dentro do with)")
        assert test_app_instance.state.db == mock_db_conn, "app.state.db não foi definido corretamente."

    # --- Assert ---
    mock_connect_db.assert_awaited_once()
    mock_create_user_idx.assert_awaited_once_with(mock_db_conn)
    mock_create_task_idx.assert_awaited_once_with(mock_db_conn) 
    
    logs = [record.getMessage() for record in caplog.records if record.name == "app.main"]

    assert "Iniciando ciclo de vida da aplicação..." in logs
    assert "Conectado ao MongoDB." in logs
    assert "Tentando criar/verificar índices..." in logs
    assert "Criação/verificação de índices concluída." in logs 
    assert "Aplicação iniciada e pronta." in logs 
    assert "Iniciando processo de encerramento..." in logs
    assert "Conexão com MongoDB fechada." in logs
    assert "Aplicação encerrada." in logs
    
    mock_close_db.assert_awaited_once()

================================================================================
Capítulo 29: tests/test_tasks.py
================================================================================

# tests/test_tasks.py
"""
Este módulo contém testes de integração para os endpoints de tarefas (`/tasks`)
da API SmartTask, definidos em `app.routers.tasks`.

Os testes cobrem uma ampla gama de funcionalidades, incluindo:
- Criação, listagem, obtenção, atualização e deleção de tarefas (CRUD).
- Validação de entrada para criação e atualização de tarefas.
- Filtros e paginação na listagem de tarefas.
- Ordenação na listagem de tarefas.
- Lógica de autorização (usuário só pode acessar/modificar suas próprias tarefas).
- Tratamento de tokens JWT inválidos ou expirados.
- Tentativas de injeção em parâmetros de filtro.
- Disparo de notificações (e-mail, webhook) via BackgroundTasks.

Utiliza fixtures de `conftest.py` para usuários e autenticação.
A biblioteca `freezegun` é usada para controlar a data/hora em testes sensíveis ao tempo.
O envio de webhooks é mockado automaticamente.
"""

# ==========================================
# --- Importações ---
# ==========================================
import unittest.mock
from unittest.mock import AsyncMock, ANY, MagicMock
from freezegun import freeze_time
from pydantic import ValidationError
import pytest
from httpx import AsyncClient
from fastapi import status
from typing import Dict, List, Any
import uuid
import pytest_asyncio
from app.core.config import settings
from app.db import task_crud
from app.models.task import Task, TaskStatus
from datetime import date, timedelta, datetime, timezone
from tests.conftest import user_a_data
import jwt as jose_jwt
import uuid 
from fastapi import status 

# ==========================================
# --- Mock Webhook ---
# ==========================================
@pytest.fixture(
        autouse=True
)

def auto_mock_send_webhook(mocker):
    """
    Fixture `autouse` que aplica automaticamente um mock à função
    `app.routers.tasks.send_webhook_notification` para todos os testes
    definidos neste módulo.
    Previne chamadas HTTP reais para webhooks e permite verificar se a função
    foi chamada quando esperado.
    """
    mocker.patch(
        "app.routers.tasks.send_webhook_notification",
        new_callable=unittest.mock.AsyncMock,
    )

# ==========================================
# --- Marcador Asyncio e Fixture ---
# ==========================================
pytestmark = pytest.mark.asyncio

@pytest.fixture
def sample_task_create_data() -> Dict[str, Any]:
    """Fornece um dicionário válido para criar uma tarefa nos testes de rota."""
    return {
        "title": "Task Payload for Route Test",
        "description": "Description from payload test",
        "importance": 4,
        "due_date": (date.today() + timedelta(days=5)).isoformat(),
        "status": TaskStatus.PENDING.value,
        "tags": ["route_t", "test_t"],
        "project": "Router Tests T"
    }

# ==========================================
# --- Base Task Data ---
# ==========================================
base_task_create_data = {
    "title": "Tarefa de Teste Padrão",
    "description": "Descrição da tarefa padrão",
    "importance": 3,
}

# ==========================================
# --- Testes de Criação ---
# ==========================================
async def test_create_task_success(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
):
    """
    Testa a criação bem-sucedida de uma nova tarefa por um usuário autenticado.
    Verifica o status code HTTP 201 CREATED e se os dados retornados
    correspondem ao payload enviado, incluindo campos gerados pelo servidor
    como id, owner_id, created_at e priority_score.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/"
    # --- Act ---
    response = await test_async_client.post(
        url,
        json=base_task_create_data,
        headers=auth_headers_a
    ) 
    # --- Assert ---
    assert response.status_code == status.HTTP_201_CREATED
    response_data = response.json()
    assert response_data["title"] == base_task_create_data["title"]
    assert response_data["importance"] == base_task_create_data["importance"]
    assert response_data["status"] == TaskStatus.PENDING.value
    assert "id" in response_data
    assert "owner_id" in response_data
    assert "created_at" in response_data
    assert "priority_score" in response_data

async def test_create_task_unauthorized(
        test_async_client: AsyncClient
):
     """
     Testa a tentativa de criar uma tarefa sem fornecer um token de autenticação.
     Espera-se um erro HTTP 401 Unauthorized como resposta da API.
     """
     # --- Arrange ---
     url = f"{settings.API_V1_STR}/tasks/"
     # --- Act ---
     response = await test_async_client.post(url, json=base_task_create_data) 
     # --- Assert ---
     assert response.status_code == status.HTTP_401_UNAUTHORIZED

# ==================================================================
# --- Testes de Criação e Atualização ---
# ==================================================================
@pytest.mark.parametrize(
    "field, length", [
        ("title", 100), 
        ("description", 500), 
    ]
)
async def test_create_task_max_length_success(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    field: str,
    length: int,
):
    """
    Testa a criação de uma tarefa com campos de string (`title`, `description`)
    preenchidos exatamente no seu comprimento máximo permitido.
    Espera-se que a criação seja bem-sucedida com um status HTTP 201 CREATED.
    """
    # --- Arrange ---
    payload = base_task_create_data.copy()
    payload[field] = "X" * length 
    url = f"{settings.API_V1_STR}/tasks/"
    # --- Act ---
    response = await test_async_client.post(url, json=payload, headers=auth_headers_a)
    # --- Assert ---
    assert response.status_code == status.HTTP_201_CREATED
    response_data = response.json()
    assert response_data[field] == payload[field]

@pytest.mark.parametrize(
    "field, length", [
        ("title", 101), 
        ("description", 501), 
    ]
)
async def test_create_task_max_length_fail(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    field: str,
    length: int,
):
    """
    Testa a tentativa de criar uma tarefa com campos de string (`title`, `description`)
    excedendo o comprimento máximo permitido estabelecido pelo modelo de dados.
    Espera-se um erro de validação HTTP 422 Unprocessable Entity.
    """
    # --- Arrange ---
    payload = base_task_create_data.copy()
    payload[field] = "X" * length
    url = f"{settings.API_V1_STR}/tasks/"
    # --- Act ---
    response = await test_async_client.post(url, json=payload, headers=auth_headers_a)
    # --- Assert ---
    assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY
    assert f"String should have at most {length -1} characters" in response.text

async def test_create_task_explicit_nulls_optional(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
):
    """
    Testa a criação de uma tarefa onde campos opcionais (description, due_date,
    tags, project) são explicitamente enviados como `null` (None em Python) no payload.
    Espera-se que a tarefa seja criada com sucesso (HTTP 201) e que esses campos
    reflitam o valor nulo na resposta.
    """
        # --- Arrange ---
    payload = base_task_create_data.copy()
    payload["description"] = None
    payload["due_date"] = None
    payload["tags"] = None
    payload["project"] = None
    url = f"{settings.API_V1_STR}/tasks/"

    # --- Act ---
    response = await test_async_client.post(url, json=payload, headers=auth_headers_a)

    # --- Assert ---
    assert response.status_code == status.HTTP_201_CREATED
    response_data = response.json()
    assert response_data["description"] is None
    assert response_data["due_date"] is None
    assert response_data["tags"] is None
    assert response_data["project"] is None

async def test_update_task_explicit_nulls_optional(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
):
    """
    Testa a atualização de uma tarefa existente, definindo campos opcionais
    (que previamente continham valores) para `null` (None em Python) no payload.
    Primeiro, uma tarefa é criada com valores. Em seguida, é atualizada.
    Espera-se que a atualização seja bem-sucedida (HTTP 200) e os campos
    sejam refletidos como nulos na resposta.
    """
    # --- Arrange ---
    url_create = f"{settings.API_V1_STR}/tasks/"
    create_payload = {
        **base_task_create_data,
        "description": "Descrição inicial",
        "due_date": date.today().isoformat(),
        "tags": ["inicial"],
        "project": "Projeto Inicial"
    }
    create_resp = await test_async_client.post(url_create, json=create_payload, headers=auth_headers_a)
    assert create_resp.status_code == status.HTTP_201_CREATED
    task_id = create_resp.json()["id"]

    # --- Act ---
    url_put = f"{settings.API_V1_STR}/tasks/{task_id}"
    update_payload = {
        "description": None,
        "due_date": None,
        "tags": None, 
        "project": None,
    }
    response = await test_async_client.put(url_put, json=update_payload, headers=auth_headers_a)
    
    # --- Assert ---
    assert response.status_code == status.HTTP_200_OK
    response_data = response.json()
    assert response_data["description"] is None
    assert response_data["due_date"] is None
    assert response_data["tags"] is None 
    assert response_data["project"] is None

@pytest.mark.asyncio
async def test_create_task_internal_validation_error(test_async_client: AsyncClient, mocker, auth_headers_a, sample_task_create_data): 
    """
    Testa o tratamento de erro quando a validação Pydantic interna
    ao construir o objeto Task completo na rota falha.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/"
    task_payload = sample_task_create_data

    mocker.patch("app.routers.tasks.calculate_priority_score", return_value=50.0)
    simulated_error = ValidationError.from_exception_data(title="Task", line_errors=[])
    mock_task_init = mocker.patch("app.routers.tasks.Task", side_effect=simulated_error)

    mock_crud_create = mocker.patch("app.routers.tasks.task_crud.create_task")
    mock_logger_error = mocker.patch("app.routers.tasks.logger.error")

    # --- Act ---
    response = await test_async_client.post(url, json=task_payload, headers=auth_headers_a)

    # --- Assert ---
    assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY
    assert "Erro interno na validação dos dados da tarefa" in response.json()["detail"]
    mock_task_init.assert_called_once()
    mock_crud_create.assert_not_called()
    mock_logger_error.assert_called_once()
    log_call_args = mock_logger_error.call_args.args
    assert "Erro de validação Pydantic ao montar objeto Task" in log_call_args[0]

@pytest.mark.asyncio
async def test_update_task_crud_returns_none(test_async_client: AsyncClient, mocker, auth_headers_a, test_user_a_token_and_id): 
    """
    Testa o comportamento da rota PUT /tasks/{task_id} quando
    task_crud.update_task retorna None.
    """
    # --- Arrange ---
    token, user_id_a = test_user_a_token_and_id
    target_task_id = uuid.uuid4()
    url = f"{settings.API_V1_STR}/tasks/{target_task_id}"
    update_payload = {"title": "Titulo Nao Aplicado"}
    mock_existing_task = MagicMock(spec=Task)
    mock_existing_task.importance = 3 
    mock_existing_task.due_date = None 
    mocker.patch("app.routers.tasks.task_crud.get_task_by_id", return_value=mock_existing_task)
    mock_crud_update = mocker.patch("app.routers.tasks.task_crud.update_task", return_value=None)
    mocker.patch("app.routers.tasks.calculate_priority_score")
    mock_logger_error = mocker.patch("app.routers.tasks.logger.error")

    # --- Act ---
    response = await test_async_client.put(url, json=update_payload, headers=auth_headers_a)

    # --- Assert ---
    assert response.status_code == status.HTTP_404_NOT_FOUND
    assert "Não foi possível atualizar a tarefa" in response.json()["detail"]
    assert "Pode ter sido deletada ou ocorreu um erro interno" in response.json()["detail"]
    task_crud.get_task_by_id.assert_called_once_with(db=mocker.ANY, task_id=target_task_id, owner_id=user_id_a)
    mock_crud_update.assert_called_once()
    mock_logger_error.assert_called_once()
    assert f"Falha ao atualizar tarefa {target_task_id}" in mock_logger_error.call_args.args[0]

@pytest.mark.asyncio
async def test_create_urgent_task_logs_warning_if_user_incomplete(test_async_client: AsyncClient, mocker): # type: ignore
    """
    Testa se um warning é logado ao criar tarefa urgente se o usuário
    não possui nome completo (mas tem e-mail).
    """
    # --- Arrange ---
    username = f"incomplete_name_{uuid.uuid4().hex[:4]}"
    email = f"{username}@example.com"
    incomplete_user_data = {
        "email": email,
        "username": username,
        "password": "password123",
        "full_name": None 
    }
    register_url = f"{settings.API_V1_STR}/auth/register"
    login_url = f"{settings.API_V1_STR}/auth/login/access-token"

    reg_response = await test_async_client.post(register_url, json=incomplete_user_data)
    assert reg_response.status_code == status.HTTP_201_CREATED
    user_id = reg_response.json()["id"]

    login_payload_form_data = {
        "username": username,
        "password": incomplete_user_data["password"]
    }
    login_response = await test_async_client.post(login_url, data=login_payload_form_data)
    assert login_response.status_code == status.HTTP_200_OK
    token = login_response.json()["access_token"]
    incomplete_user_headers = {"Authorization": f"Bearer {token}"}

    url_create = f"{settings.API_V1_STR}/tasks/"
    urgent_task_payload = {
        "title": "Urgente, usuário sem nome",
        "importance": 5,
        "due_date": (date.today() - timedelta(days=1)).isoformat()
    }

    mocker.patch("app.routers.tasks.is_task_urgent", return_value=True)
    mock_send_email = mocker.patch("app.routers.tasks.send_urgent_task_notification", new_callable=AsyncMock)
    mock_logger_warning = mocker.patch("app.routers.tasks.logger.warning")

    mock_created_task = MagicMock(spec=Task)
    task_id_created = uuid.uuid4()
    mock_created_task.id = task_id_created
    mock_created_task.owner_id = uuid.UUID(user_id)
    mock_created_task.title = urgent_task_payload["title"]
    mocker.patch("app.routers.tasks.task_crud.create_task", return_value=mock_created_task)
    mocker.patch("app.routers.tasks.calculate_priority_score", return_value=1000.0)

    # --- Act ---
    response = await test_async_client.post(url_create, json=urgent_task_payload, headers=incomplete_user_headers)

    # --- Assert ---
    assert response.status_code == status.HTTP_201_CREATED

    mock_logger_warning.assert_called_once()
    log_message = mock_logger_warning.call_args.args[0]
    assert f"Usuário {user_id} (username: {username})" in log_message
    assert "não possui e-mail ou nome completo configurado" in log_message
    assert f"tarefa urgente {task_id_created}" in log_message

    mock_send_email.assert_not_called()

# ==============================================================
# --- Testes de Validação de Entrada (Parametrizados) ---
# ==============================================================
@pytest.mark.parametrize(
    "field, value, error_type, error_msg_part", [
        ("title", "T2", "string_too_short", "String should have at least 3 characters"),
        ("importance", 0, "greater_than_equal", "Input should be greater than or equal to 1"),
        ("importance", 6, "less_than_equal", "Input should be less than or equal to 5"),
        ("due_date", "nao-e-data", "date_from_datetime_parsing", "invalid character"),
        ("status", "invalido", "enum", "Input should be"),
    ]
)
async def test_create_task_invalid_input(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    field: str, value: Any, error_type: str, error_msg_part: str
):
    """
    Testa a criação de tarefas com diversos tipos de dados de entrada inválidos
    para campos específicos, como title, importance, due_date e status.
    Verifica se a API retorna HTTP 422 Unprocessable Entity e se a mensagem
    de erro na resposta `detail` corresponde ao campo e tipo de erro esperados.
    """
    # --- Arrange ---
    invalid_data = base_task_create_data.copy()
    if value is None:
         if field in ["title", "importance"]:
              if field in invalid_data: 
                   del invalid_data[field]
         elif field == "status":
              pytest.skip("Teste 'None' não aplicável para 'status' com default.")
              return
         else:
             invalid_data[field] = value
    else:
        invalid_data[field] = value

    url = f"{settings.API_V1_STR}/tasks/"
    # --- Act ---
    response = await test_async_client.post(url, json=invalid_data, headers=auth_headers_a)
    # --- Assert ---
    assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY
    error_details = response.json()["detail"]
    found_error = False
    for error in error_details:
        if field in error.get("loc", []) and error.get("type") == error_type:
            if error_msg_part in error.get("msg", ""):
                found_error = True
                break
    assert found_error, f"Erro esperado para campo '{field}' tipo '{error_type}' msg '{error_msg_part}' não encontrado em {error_details}"

@pytest.mark.parametrize(
    "field, value, error_type, error_msg_part", [
        ("title", "T2", "string_too_short", "String should have at least 3 characters"),
        ("importance", 0, "greater_than_equal", "Input should be greater than or equal to 1"),
        ("importance", 6, "less_than_equal", "Input should be less than or equal to 5"),
        ("due_date", "nao-e-data", "date_from_datetime_parsing", "invalid character"),
        ("status", "invalido", "enum", "Input should be"), 
    ]
)
async def test_update_task_invalid_input(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    field: str, value: Any, error_type: str, error_msg_part: str
):
    """
    Testa a atualização de tarefas com dados de entrada inválidos para campos específicos.
    Primeiro cria uma tarefa válida, depois tenta atualizá-la com um valor inválido.
    Verifica se a API retorna HTTP 422 Unprocessable Entity e se a mensagem
    de erro corresponde ao esperado.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/"
    create_resp = await test_async_client.post(url, json=base_task_create_data, headers=auth_headers_a)
    assert create_resp.status_code == 201
    task_id = create_resp.json()["id"]

    # --- Act ---
    invalid_update_payload = {field: value}
    url_put = f"{settings.API_V1_STR}/tasks/{task_id}"
    response = await test_async_client.put(url_put, json=invalid_update_payload, headers=auth_headers_a)

    # --- Assert ---
    assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY
    error_details = response.json()["detail"]
    found_error = False
    for error in error_details:
        if field in error.get("loc", []) and error.get("type") == error_type:
            if error_msg_part in error.get("msg", ""):
                found_error = True
                break
    assert found_error, f"Erro esperado para campo '{field}' com tipo '{error_type}' e msg contendo '{error_msg_part}' não encontrado em {error_details}"

async def test_update_task_empty_payload(
     test_async_client: AsyncClient, auth_headers_a: Dict[str, str]
):
    """
    Testa a tentativa de atualizar uma tarefa enviando um payload JSON vazio (`{}`).
    Verifica se a API retorna um erro HTTP 400 Bad Request, indicando que
    nenhum campo válido para atualização foi fornecido.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/"
    create_resp = await test_async_client.post(url, json=base_task_create_data, headers=auth_headers_a)
    assert create_resp.status_code == 201
    task_id = create_resp.json()["id"]

    # --- Act ---
    url_put = f"{settings.API_V1_STR}/tasks/{task_id}"
    response = await test_async_client.put(url_put, json={}, headers=auth_headers_a)

    # --- Assert ---
    assert response.status_code == status.HTTP_400_BAD_REQUEST
    assert "Nenhum campo válido fornecido" in response.json()["detail"]

# ==========================================
# --- Testes de Listagem ---
# ==========================================
async def test_list_tasks_success(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str]
):
    """
    Testa a listagem bem-sucedida de tarefas para um usuário autenticado (User A).
    Cria duas tarefas para o User A e verifica se ambas são retornadas ao listar
    tarefas para este usuário, e se o status code é HTTP 200 OK.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/"
    task1 = {**base_task_create_data, "title": "Task A1 List", "importance": 5, "project": "Alpha"}
    task2 = {**base_task_create_data, "title": "Task A2 List", "status": TaskStatus.IN_PROGRESS.value, "tags": ["urgent"]}
    # --- Act ---
    resp1 = await test_async_client.post(url, json=task1, headers=auth_headers_a)
    # --- Assert ---
    assert resp1.status_code == 201
    # --- Act ---
    resp2 = await test_async_client.post(url, json=task2, headers=auth_headers_a)
    # --- Assert ---
    assert resp2.status_code == 201

    # --- Act ---
    response = await test_async_client.get(url, headers=auth_headers_a)

    # --- Assert ---
    assert response.status_code == status.HTTP_200_OK
    tasks = response.json()
    assert isinstance(tasks, list)
    assert len(tasks) == 2
    titles = {task["title"] for task in tasks}
    assert task1["title"] in titles
    assert task2["title"] in titles

async def test_list_tasks_unauthorized(
        test_async_client: AsyncClient
):
     """
     Testa a tentativa de listar tarefas sem fornecer um token de autenticação.
     Espera-se um erro HTTP 401 Unauthorized.
     """
     # --- Arrange ---
     url = f"{settings.API_V1_STR}/tasks/"
     # --- Act ---
     response = await test_async_client.get(url)
     # --- Assert ---
     assert response.status_code == status.HTTP_401_UNAUTHORIZED

async def test_list_tasks_does_not_show_other_users_tasks(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    auth_headers_b: Dict[str, str]
):
    """
    Testa a separação de dados entre usuários na listagem de tarefas.
    Garante que o User B, ao listar suas tarefas, não veja as tarefas criadas
    pelo User A.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/"
    task_a = {**base_task_create_data, "title": "Tarefa Secreta A"}
    resp_a = await test_async_client.post(url, json=task_a, headers=auth_headers_a)
    assert resp_a.status_code == 201

    # --- Act ---
    response_b = await test_async_client.get(url, headers=auth_headers_b)

    # --- Assert ---
    assert response_b.status_code == status.HTTP_200_OK
    tasks_b = response_b.json()
    assert isinstance(tasks_b, list)
    assert len(tasks_b) == 0

async def test_list_tasks_filter_non_existent_project(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    create_filter_sort_tasks: List[Dict] 
):
    """
    Testa a funcionalidade de filtro de listagem de tarefas por projeto,
    especificamente quando o projeto fornecido no filtro não existe em nenhuma tarefa.
    Espera-se uma lista vazia e status HTTP 200 OK.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/?project=ProjetoInexistente123"
    # --- Act ---
    response = await test_async_client.get(url, headers=auth_headers_a)
    # --- Assert ---
    assert response.status_code == status.HTTP_200_OK
    tasks = response.json()
    assert isinstance(tasks, list)
    assert len(tasks) == 0 

async def test_list_tasks_filter_non_existent_tag(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    create_filter_sort_tasks: List[Dict]
):
    """
    Testa a funcionalidade de filtro de listagem de tarefas por tag,
    quando a tag fornecida não está associada a nenhuma tarefa.
    Espera-se uma lista vazia e status HTTP 200 OK.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/?tag=tag_nao_existe"
    # --- Act ---
    response = await test_async_client.get(url, headers=auth_headers_a)
    # --- Assert ---
    assert response.status_code == status.HTTP_200_OK
    tasks = response.json()
    assert isinstance(tasks, list)
    assert len(tasks) == 0

async def test_list_tasks_filter_multiple_tags_no_match(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    create_filter_sort_tasks: List[Dict]
):
    """
    Testa o filtro de listagem por múltiplas tags quando nenhuma tarefa
    contém TODAS as tags especificadas. O filtro por múltiplas tags geralmente
    implica uma operação AND (a tarefa deve ter todas as tags).
    Espera-se uma lista vazia e status HTTP 200 OK.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/?tag=t1&tag=t3"
    # --- Act ---
    response = await test_async_client.get(url, headers=auth_headers_a)
    # --- Assert ---
    assert response.status_code == status.HTTP_200_OK
    tasks = response.json()
    assert isinstance(tasks, list)
    assert len(tasks) == 0 

async def test_list_tasks_filter_status_no_match(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    create_filter_sort_tasks: List[Dict]
):
    """
    Testa o filtro de listagem por status quando nenhuma tarefa corresponde
    ao status fornecido (ex: 'cancelada', se não houver tarefas canceladas).
    Espera-se uma lista vazia e status HTTP 200 OK.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/?status={TaskStatus.CANCELLED.value}"
    # --- Act ---
    response = await test_async_client.get(url, headers=auth_headers_a)
    # --- Assert ---
    assert response.status_code == status.HTTP_200_OK
    tasks = response.json()
    assert isinstance(tasks, list)
    assert len(tasks) == 0 

@freeze_time("2025-05-04")
async def test_list_tasks_filter_due_before_very_early(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    create_filter_sort_tasks: List[Dict]
):
    """
    Testa o filtro de listagem por data de vencimento (`due_before`) usando uma
    data muito no passado, onde nenhuma tarefa da fixture `create_filter_sort_tasks`
    (cujos prazos são futuros em relação a "2025-05-04") deveria ser retornada.
    Espera-se uma lista vazia e status HTTP 200 OK.
    """
    # --- Arrange ---
    early_date = "2024-01-01"
    url = f"{settings.API_V1_STR}/tasks/?due_before={early_date}"
    # --- Act ---
    response = await test_async_client.get(url, headers=auth_headers_a)
    # --- Assert ---
    assert response.status_code == status.HTTP_200_OK
    tasks = response.json()
    assert isinstance(tasks, list)
    assert len(tasks) == 0 

# ========================================
# --- Testes de Paginação ---
# ========================================
async def test_list_tasks_pagination_limit_1(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    create_filter_sort_tasks: List[Dict] 
):
    """
    Testa a funcionalidade de paginação da listagem de tarefas,
    especificamente o parâmetro `limit`.
    Verifica se, ao definir `limit=1`, apenas uma tarefa é retornada.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/?limit=1"
    # --- Act ---
    response = await test_async_client.get(url, headers=auth_headers_a)
    # --- Assert ---
    assert response.status_code == status.HTTP_200_OK
    tasks = response.json()
    assert isinstance(tasks, list)
    assert len(tasks) == 1 

async def test_list_tasks_pagination_skip_all(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    create_filter_sort_tasks: List[Dict] 
):
    """
    Testa a funcionalidade de paginação `skip`.
    Verifica se, ao pular um número de tarefas igual ou maior ao total existente
    (criado pela fixture `create_filter_sort_tasks`), uma lista vazia é retornada.
    """
    # --- Arrange ---
    total_tasks_in_fixture = 5 
    url_skip_exact = f"{settings.API_V1_STR}/tasks/?skip={total_tasks_in_fixture}"
    url_skip_more = f"{settings.API_V1_STR}/tasks/?skip={total_tasks_in_fixture + 5}"
    
    # --- Act (Skip Exato) ---
    response_exact = await test_async_client.get(url_skip_exact, headers=auth_headers_a)
    # --- Assert (Skip Exato) ---
    assert response_exact.status_code == status.HTTP_200_OK
    tasks_exact = response_exact.json()
    assert isinstance(tasks_exact, list)
    assert len(tasks_exact) == 0 

    # --- Act (Skip Mais) ---
    response_skip_more = await test_async_client.get(url_skip_more, headers=auth_headers_a)
    # --- Assert (Skip Mais) ---
    assert response_skip_more.status_code == status.HTTP_200_OK
    tasks_skip_more = response_skip_more.json()
    assert isinstance(tasks_skip_more, list)
    assert len(tasks_skip_more) == 0

async def test_list_tasks_pagination_limit_0(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
):
    """
    Testa o comportamento da paginação quando um valor inválido (`limit=0`)
    é fornecido. A validação da FastAPI (para `Query(ge=1, ...)`) deve
    impedir isso, retornando HTTP 422 Unprocessable Entity.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/?limit=0"
    # --- Act ---
    response = await test_async_client.get(url, headers=auth_headers_a)
    # --- Assert ---
    assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY
    assert "Input should be greater than or equal to 1" in response.text

async def test_list_tasks_pagination_limit_too_high(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
):
    """
    Testa o comportamento da paginação quando um valor inválido (`limit > 1000`)
    é fornecido. A validação da FastAPI (para `Query(..., le=1000)`) deve
    impedir isso, retornando HTTP 422 Unprocessable Entity.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/?limit=1001"
    # --- Act ---
    response = await test_async_client.get(url, headers=auth_headers_a)
    # --- Assert ---
    assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY
    assert "Input should be less than or equal to 1000" in response.text

# ======================================================
# --- Testes de de Filtros e Paginação ---
# ======================================================
async def test_list_tasks_filter_and_pagination(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    create_filter_sort_tasks: List[Dict] 
):
    """
    Testa a combinação de filtros de listagem (por projeto) com paginação
    (skip e limit).
    Verifica se o número correto de tarefas é retornado após aplicar
    ambos os tipos de parâmetros.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/?project=Filtro&skip=1&limit=2"
    # --- Act ---
    response = await test_async_client.get(url, headers=auth_headers_a)
    # --- Assert ---
    assert response.status_code == status.HTTP_200_OK
    tasks = response.json()
    assert isinstance(tasks, list)
    assert len(tasks) == 2

# ======================================================
# --- Testes de de Filtros e Ordenação ---
# ======================================================
@pytest_asyncio.fixture(
        scope="function" 
)
async def create_filter_sort_tasks(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str]
) -> List[Dict]:
    """
    Fixture assíncrona que cria um conjunto de tarefas de teste com variações
    em seus atributos (título, importância, projeto, status, data de vencimento, tags).
    Essas tarefas são criadas pelo User A e são usadas para testar as
    funcionalidades de filtragem e ordenação do endpoint de listagem de tarefas.
    Retorna uma lista de dicionários, onde cada dicionário representa os dados
    da tarefa criada (conforme retornado pela API).
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/"
    tasks_to_create = [
        {"title": "Filter Task P1 High", "importance": 5, "project": "Filtro", "status": TaskStatus.PENDING.value, "due_date": "2026-01-01", "tags": ["t1", "t2"]},
        {"title": "Filter Task P1 Low", "importance": 1, "project": "Filtro", "status": TaskStatus.PENDING.value, "due_date": "2026-02-01"},
        {"title": "Filter Task P2 Medium", "importance": 3, "project": "Outro", "status": TaskStatus.IN_PROGRESS.value, "tags": ["t2"]},
        {"title": "Filter Task P1 Medium", "importance": 3, "project": "Filtro", "status": TaskStatus.PENDING.value, "due_date": "2025-12-15", "tags": ["t3"]}, 
        {"title": "Filter Task P1 Done", "importance": 4, "project": "Filtro", "status": TaskStatus.COMPLETED.value}, 
    ]
    created_tasks = []
    # --- Act ---
    for task_data in tasks_to_create:
        response = await test_async_client.post(url, json=task_data, headers=auth_headers_a)
        # --- Assert (Criação) ---
        assert response.status_code == 201
        created_tasks.append(response.json())
    # --- Return ---
    return created_tasks

async def test_list_tasks_filter_by_project(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    create_filter_sort_tasks: List[Dict] 
):
    """
    Testa a filtragem da lista de tarefas pelo campo 'project'.
    Verifica se apenas as tarefas pertencentes ao projeto "Filtro" são retornadas.
    Utiliza a fixture `create_filter_sort_tasks` para popular o banco com dados de teste.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/?project=Filtro"
    # --- Act ---
    response = await test_async_client.get(url, headers=auth_headers_a)
    # --- Assert ---
    assert response.status_code == 200
    tasks = response.json()
    assert len(tasks) == 4 
    assert all(task["project"] == "Filtro" for task in tasks)

async def test_list_tasks_filter_by_status(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    create_filter_sort_tasks: List[Dict]
):
    """
    Testa a filtragem da lista de tarefas pelo campo 'status'.
    Verifica se apenas as tarefas com status "pendente" são retornadas.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/?status=pendente"
    # --- Act ---
    response = await test_async_client.get(url, headers=auth_headers_a)
    # --- Assert ---
    assert response.status_code == 200
    tasks = response.json()
    assert len(tasks) == 3 
    assert all(task["status"] == TaskStatus.PENDING.value for task in tasks)

async def test_list_tasks_filter_by_single_tag(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    create_filter_sort_tasks: List[Dict]
):
    """
    Testa a filtragem da lista de tarefas por uma única tag.
    Verifica se as tarefas que contêm a tag "t2" são retornadas corretamente.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/?tag=t2"
    # --- Act ---
    response = await test_async_client.get(url, headers=auth_headers_a)
    # --- Assert ---
    assert response.status_code == 200
    tasks = response.json()
    assert len(tasks) == 2 
    titles = {task["title"] for task in tasks}
    assert "Filter Task P1 High" in titles
    assert "Filter Task P2 Medium" in titles

async def test_list_tasks_filter_by_multiple_tags(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    create_filter_sort_tasks: List[Dict]
):
    """
    Testa a filtragem da lista de tarefas por múltiplas tags (operação AND).
    Verifica se apenas as tarefas que contêm TODAS as tags especificadas ("t1" E "t2")
    são retornadas.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/?tag=t1&tag=t2"
    # --- Act ---
    response = await test_async_client.get(url, headers=auth_headers_a)
    # --- Assert ---
    assert response.status_code == 200
    tasks = response.json()
    assert len(tasks) == 1 
    assert tasks[0]["title"] == "Filter Task P1 High"

async def test_list_tasks_sort_by_priority(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    create_filter_sort_tasks: List[Dict]
):
    """
    Testa a ordenação da lista de tarefas pelo campo 'priority_score'
    em ordem descendente.
    Verifica se as tarefas retornadas estão ordenadas corretamente pela pontuação
    de prioridade.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/?sort_by=priority_score&sort_order=desc"
    # --- Act ---
    response = await test_async_client.get(url, headers=auth_headers_a)
    # --- Assert ---
    assert response.status_code == 200
    tasks = response.json()
    assert len(tasks) == 5 
    scores = [task.get("priority_score") for task in tasks if task.get("priority_score") is not None]
    assert scores == sorted(scores, reverse=True)

async def test_list_tasks_sort_by_due_date_asc(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    create_filter_sort_tasks: List[Dict]
):
    """
    Testa a ordenação da lista de tarefas pelo campo 'due_date'
    em ordem ascendente.
    Verifica se as tarefas retornadas (que possuem data de vencimento)
    estão ordenadas corretamente. Tarefas sem data de vencimento podem aparecer
    no início ou no fim dependendo da lógica de ordenação do banco para nulos.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/?sort_by=due_date&sort_order=asc"
    # --- Act ---
    response = await test_async_client.get(url, headers=auth_headers_a)
    # --- Assert ---
    assert response.status_code == 200
    tasks = response.json()
    assert len(tasks) == 5
    due_dates = [task.get("due_date") for task in tasks if task.get("due_date")]
    assert due_dates == sorted(due_dates)
    assert tasks[0]["due_date"] is None or tasks[0]["due_date"] == "2025-12-15"

# ========================================
# --- Testes GET /tasks/{id} ---
# ========================================
async def test_get_specific_task_success( 
    test_async_client: AsyncClient,       
    auth_headers_a: Dict[str, str] 
):
    """
    Testa a busca bem-sucedida de uma tarefa específica pelo seu ID,
    pertencente ao usuário autenticado.
    Verifica se o status code é HTTP 200 OK e se os dados da tarefa retornada
    correspondem aos da tarefa criada.
    """
    # --- Arrange ---
    url_create = f"{settings.API_V1_STR}/tasks/"
    create_response = await test_async_client.post(url_create, json=base_task_create_data, headers=auth_headers_a) 
    assert create_response.status_code == 201
    task_id = create_response.json()["id"]

    # --- Act ---
    url_get = f"{settings.API_V1_STR}/tasks/{task_id}"
    get_response = await test_async_client.get(url_get, headers=auth_headers_a) 

    # --- Assert ---
    assert get_response.status_code == status.HTTP_200_OK
    response_data = get_response.json()
    assert response_data["id"] == task_id
    assert response_data["title"] == base_task_create_data["title"] 

async def test_get_specific_task_not_found(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str] 
):
    """
    Testa a tentativa de buscar uma tarefa específica usando um ID que
    não existe no banco de dados.
    Espera-se um erro HTTP 404 Not Found.
    """
    # --- Arrange ---
    non_existent_id = uuid.uuid4()
    url = f"{settings.API_V1_STR}/tasks/{non_existent_id}"
    # --- Act ---
    response = await test_async_client.get(url, headers=auth_headers_a)
    # --- Assert ---
    assert response.status_code == status.HTTP_404_NOT_FOUND

async def test_get_specific_task_unauthorized(
        test_async_client: AsyncClient
):
    """
    Testa a tentativa de buscar uma tarefa específica sem fornecer um
    token de autenticação.
    Espera-se um erro HTTP 401 Unauthorized.
    """
    # --- Arrange ---
    some_id = uuid.uuid4() 
    url = f"{settings.API_V1_STR}/tasks/{some_id}"
    # --- Act ---
    response = await test_async_client.get(url) 
    # --- Assert ---
    assert response.status_code == status.HTTP_401_UNAUTHORIZED

async def test_get_other_user_task_forbidden( 
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    auth_headers_b: Dict[str, str]
):
    """
    Testa a tentativa do User B de obter uma tarefa que pertence ao User A.
    A lógica de `get_task_by_id` (usada pelo endpoint) deve retornar None se
    o `owner_id` não corresponder, resultando em um HTTP 404 Not Found para
    o User B (como se a tarefa não existisse para ele).
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/"
    task_a_data = {**base_task_create_data, "title": "Task A para GET"}
    resp_a = await test_async_client.post(url, json=task_a_data, headers=auth_headers_a)
    assert resp_a.status_code == 201
    task_a_id = resp_a.json()["id"]

    # --- Act ---
    url_get = f"{settings.API_V1_STR}/tasks/{task_a_id}"
    response_b = await test_async_client.get(url_get, headers=auth_headers_b)

    # --- Assert ---
    assert response_b.status_code == status.HTTP_404_NOT_FOUND

# ========================================
# --- Testes PUT /tasks/{id} ---
# ========================================
async def test_update_task_success(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
):
    """
    Testa a atualização bem-sucedida de uma tarefa existente pelo seu proprietário.
    Verifica se o status code é HTTP 200 OK e se os campos da tarefa
    foram atualizados conforme o payload enviado, incluindo a recalculação da
    pontuação de prioridade e a atualização do timestamp `updated_at`.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/"
    create_resp = await test_async_client.post(
        url,
        json=base_task_create_data,
        headers=auth_headers_a
    )
    assert create_resp.status_code == 201
    task_id = create_resp.json()["id"]
    original_score = create_resp.json().get("priority_score")

    # --- Act ---
    url_put = f"{settings.API_V1_STR}/tasks/{task_id}"
    update_payload = {
        "title": "Título Atualizado",
        "status": TaskStatus.COMPLETED.value,
        "importance": 5
    } 
    response = await test_async_client.put(
        url_put,
        json=update_payload,
        headers=auth_headers_a
    )

    # --- Assert ---
    assert response.status_code == status.HTTP_200_OK
    data = response.json()
    assert data["id"] == task_id
    assert data["title"] == update_payload["title"]
    assert data["status"] == update_payload["status"]
    assert data["importance"] == update_payload["importance"]
    assert "updated_at" in data and data["updated_at"] is not None
    assert "priority_score" in data
    assert data["priority_score"] != original_score

async def test_update_task_not_found(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str]
):
    """
    Testa a tentativa de atualizar uma tarefa que não existe (ID inválido).
    Espera-se um erro HTTP 404 Not Found.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/{uuid.uuid4()}" 
    # --- Act ---
    response = await test_async_client.put(url, json={"title": "Inexistente"}, headers=auth_headers_a)
    # --- Assert ---
    assert response.status_code == status.HTTP_404_NOT_FOUND

async def test_update_other_user_task_forbidden( 
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    auth_headers_b: Dict[str, str]
):
    """
    Testa a tentativa do User B de atualizar uma tarefa que pertence ao User A.
    A lógica deve impedir essa operação, resultando em um HTTP 404 Not Found
    (como se a tarefa não existisse para o User B).
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/"
    resp_a = await test_async_client.post(url, json=base_task_create_data, headers=auth_headers_a)
    assert resp_a.status_code == 201
    task_a_id = resp_a.json()["id"]

    # --- Act ---
    url_put = f"{settings.API_V1_STR}/tasks/{task_a_id}"
    response_b = await test_async_client.put(url_put, json={"title": "Hackeado?"}, headers=auth_headers_b)

    # --- Assert ---
    assert response_b.status_code == status.HTTP_404_NOT_FOUND

# ==========================================
# --- Testes DELETE /tasks/{id} ---
# ==========================================
async def test_delete_task_success(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str]
):
    """
    Testa a deleção bem-sucedida de uma tarefa pelo seu proprietário.
    Verifica se o status code é HTTP 204 No Content e se uma tentativa
    posterior de obter a tarefa deletada resulta em HTTP 404 Not Found.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/"
    create_resp = await test_async_client.post(url, json=base_task_create_data, headers=auth_headers_a)
    assert create_resp.status_code == 201
    task_id = create_resp.json()["id"]

    # --- Act ---
    url_delete = f"{settings.API_V1_STR}/tasks/{task_id}"
    delete_response = await test_async_client.delete(url_delete, headers=auth_headers_a)

    # --- Assert (Delete) ---
    assert delete_response.status_code == status.HTTP_204_NO_CONTENT

    # --- Assert (Verificar Get posterior falha) ---
    url_get = f"{settings.API_V1_STR}/tasks/{task_id}"
    get_response = await test_async_client.get(url_get, headers=auth_headers_a)
    assert get_response.status_code == status.HTTP_404_NOT_FOUND

async def test_delete_task_not_found(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str]
):
    """
    Testa a tentativa de deletar uma tarefa que não existe (ID inválido).
    Espera-se um erro HTTP 404 Not Found.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/{uuid.uuid4()}" 
    # --- Act ---
    response = await test_async_client.delete(url, headers=auth_headers_a)
    # --- Assert ---
    assert response.status_code == status.HTTP_404_NOT_FOUND

async def test_delete_other_user_task_forbidden( 
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    auth_headers_b: Dict[str, str]
):
    """
    Testa a tentativa do User B de deletar uma tarefa que pertence ao User A.
    A operação deve ser impedida, resultando em HTTP 404 Not Found.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/"
    resp_a = await test_async_client.post(url, json=base_task_create_data, headers=auth_headers_a)
    assert resp_a.status_code == 201
    task_a_id = resp_a.json()["id"]

    # --- Act ---
    url_delete = f"{settings.API_V1_STR}/tasks/{task_a_id}"
    response_b = await test_async_client.delete(url_delete, headers=auth_headers_b)

    # --- Assert ---
    # No seu código original, o teste espera `assert response_b.status_code == status.HTTP_404_NOT_FOUND`
    # Esta linha foi comentada no original, mas a lógica da docstring e do nome sugere que a asserção deveria estar aqui.
    # Para seguir estritamente, mantenho como no original, mas uma asserção é esperada aqui.
    # (O seu código original aqui não tinha a asserção de status code final)

# ==========================================
# --- Testes de Segurança (JWT) ---
# ==========================================
async def test_access_tasks_invalid_token_format(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str], 
    mocker
):
    """
    Testa o acesso ao endpoint de listagem de tarefas (`/tasks/`) com um token JWT
    que está mal formatado (não é um JWT válido).
    Espera-se um erro HTTP 401 Unauthorized e um log de erro específico
    da camada de segurança.
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/"
    invalid_headers = {"Authorization": "Bearer tokeninvalido.nao.jwt"}
    mock_sec_logger = mocker.patch("app.core.security.logger")
    # --- Act ---
    response = await test_async_client.get(url, headers=invalid_headers)
    # --- Assert ---
    assert response.status_code == status.HTTP_401_UNAUTHORIZED
    assert "validar as credenciais" in response.json()["detail"]
    mock_sec_logger.error.assert_called_once()
    assert "Not enough segments" in mock_sec_logger.error.call_args[0][0]

async def test_access_tasks_token_wrong_secret(
    test_async_client: AsyncClient,
    mocker 
):
    """
    Testa o acesso ao endpoint de listagem de tarefas (`/tasks/`) com um token JWT
    que foi assinado com uma chave secreta incorreta.
    Espera-se um erro HTTP 401 Unauthorized e um log de erro indicando falha
    na verificação da assinatura.
    """
    # --- Arrange ---
    from app.core.security import create_access_token 

    user_id_dummy = uuid.uuid4()
    username_dummy = "dummyuser"

    wrong_secret = "outra-chave-secreta-bem-diferente"
    assert wrong_secret != settings.JWT_SECRET_KEY 

    import jwt as jose_jwt
    to_encode = {"sub": str(user_id_dummy),
                "username": username_dummy,
                "exp": datetime.now(timezone.utc) + timedelta(minutes=15)
                }
    token_really_wrong_key = jose_jwt.encode(to_encode, wrong_secret, algorithm=settings.JWT_ALGORITHM)
    mock_sec_logger = mocker.patch("app.core.security.logger")
    url = f"{settings.API_V1_STR}/tasks/"
    invalid_headers = {"Authorization": f"Bearer {token_really_wrong_key}"}
    # --- Act ---
    response = await test_async_client.get(url, headers=invalid_headers)
    # --- Assert ---
    assert response.status_code == status.HTTP_401_UNAUTHORIZED
    assert "validar as credenciais" in response.json()["detail"]
    mock_sec_logger.error.assert_called_once()
    assert "Signature verification failed" in mock_sec_logger.error.call_args[0][0]


@freeze_time("2025-05-04 18:35:00")
async def test_access_tasks_expired_token(
    test_async_client: AsyncClient,
    test_user_a_token_and_id: tuple[str, uuid.UUID], 
    mocker
):
    """
    Testa o acesso ao endpoint de listagem de tarefas (`/tasks/`) com um token JWT
    que já expirou.
    Espera-se um erro HTTP 401 Unauthorized e um log de erro indicando
    que a assinatura expirou.
    """
    # --- Arrange ---

    _, user_id = test_user_a_token_and_id 

    past_time = datetime.now(timezone.utc) - timedelta(minutes=30) 
    expired_payload = {
        "sub": str(user_id), 
        "username": user_a_data["username"],
        "exp": past_time 
    }
    expired_token = jose_jwt.encode(
        expired_payload,
        settings.JWT_SECRET_KEY,
        algorithm=settings.JWT_ALGORITHM
    )
    url = f"{settings.API_V1_STR}/tasks/"
    invalid_headers = {"Authorization": f"Bearer {expired_token}"}
    # --- Act ---
    response = await test_async_client.get(url, headers=invalid_headers)
    # --- Assert ---
    assert response.status_code == status.HTTP_401_UNAUTHORIZED
    assert "Não autenticado" in response.json().get("detail", "") or \
           "Credenciais inválidas" in response.json().get("detail", "") or \
           "Token expirado" in response.json().get("detail", "") or \
           "validar as credenciais" in response.json().get("detail", "")

# ================================================================
# --- Testes de Tentativas de Injeção em Filtros de Listagem ---
# ================================================================
@pytest.mark.parametrize(
    "param_name, injected_value", [
        ("project", {"$ne": "some_project"}), 
        ("project", "; --"), 
        ("project", "' OR '1'='1"), 
        ("tag", {"$ne": "some_tag"}), 
        ("tag", "*"),
        ("tag", "t1; DROP TABLE tasks; --"), 
    ]
)
async def test_list_tasks_filter_injection_attempt_string(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    param_name: str, 
    injected_value: Any, 
):
    """
    Testa tentativas de injeção de query MongoDB (ou SQL-like) nos parâmetros
    de filtro de string (`project`, `tag`) do endpoint de listagem de tarefas.
    A API deve tratar esses inputs como strings literais ou rejeitá-los com
    HTTP 422 Unprocessable Entity se o tipo de dado esperado for estritamente string
    e o valor injetado for, por exemplo, um dicionário (como `{"$ne": ...}`).
    Se um valor que parece uma string maliciosa passar e resultar em 200 OK,
    o teste verifica se nenhuma tarefa inesperada é retornada (a lista deve ser vazia
    ou o filtro deve ser tratado literalmente).
    """
    # --- Arrange ---
    url = f"{settings.API_V1_STR}/tasks/?{param_name}={str(injected_value)}" 
    # --- Act ---
    response = await test_async_client.get(url, headers=auth_headers_a)
    # --- Assert ---
    assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY \
        or response.status_code == status.HTTP_200_OK, \
        f"Recebido status inesperado {response.status_code} para injeção em '{param_name}'"

    if response.status_code == status.HTTP_200_OK:
        tasks = response.json()
        assert isinstance(tasks, list)

async def test_list_tasks_filter_regex_injection(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    create_filter_sort_tasks: List[Dict] 
):
    """
    Testa especificamente uma tentativa de injeção de expressão regular MongoDB (`/.*/)
    no parâmetro de filtro 'project'.
    Espera-se que o Pydantic/FastAPI trate o input como uma string literal e,
    portanto, não encontre tarefas (ou apenas tarefas cujo nome do projeto seja
    literalmente "/.*/").
    """
    # --- Arrange ---
    payload_str = "/.*/" 
    url = f"{settings.API_V1_STR}/tasks/?project={payload_str}"
    # --- Act ---
    response = await test_async_client.get(url, headers=auth_headers_a)
    # --- Assert ---
    assert response.status_code == status.HTTP_200_OK
    tasks = response.json()
    assert isinstance(tasks, list)
    found_literal_match = any(task.get("project") == payload_str for task in tasks)
    assert not found_literal_match or len(tasks) == 0, \
           "Injeção de Regex parece ter encontrado resultados inesperados ou foi tratada literalmente de forma incorreta."
    
# ================================================
# --- Testes de Notificação Imediata de E-mail ---
# ================================================
@freeze_time("2025-05-04") 
async def test_create_task_triggers_immediate_urgent_email(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    mocker, 
):
    """
    Testa se a criação de uma tarefa que é identificada como urgente
    (pela função `is_task_urgent`) dispara corretamente a função de background
    `send_urgent_task_notification`.
    Utiliza mocks para controlar o resultado de `is_task_urgent` e para
    verificar a chamada a `send_urgent_task_notification`.
    """
    # --- Arrange ---
    mock_send_email = mocker.patch(
        "app.routers.tasks.send_urgent_task_notification",
        new_callable=AsyncMock
    )
    mocker.patch("app.routers.tasks.is_task_urgent", return_value=True) 

    urgent_task_payload = {
        "title": "Tarefa Super Urgente Imediata",
        "description": "Precisa de email agora",
        "importance": 5,
        "due_date": (date.today() - timedelta(days=1)).isoformat() 
    }
    url = f"{settings.API_V1_STR}/tasks/"
    # --- Act ---
    response = await test_async_client.post(url, json=urgent_task_payload, headers=auth_headers_a)

    # --- Assert ---
    assert response.status_code == status.HTTP_201_CREATED
    created_task_data = response.json()
    mock_send_email.assert_called_once()
    call_args = mock_send_email.call_args.kwargs
    assert call_args["user_email"] == user_a_data["email"] 
    assert call_args["task_title"] == urgent_task_payload["title"]
    assert call_args["task_id"] == created_task_data["id"]

@freeze_time("2025-05-04") 
async def test_create_task_does_not_trigger_immediate_non_urgent_email(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    mocker, 
):
    """
    Testa se a criação de uma tarefa que NÃO é identificada como urgente
    (pela função `is_task_urgent` mockada para retornar False) NÃO dispara
    a função de background `send_urgent_task_notification`.
    """
    # --- Arrange ---
    mock_send_email = mocker.patch(
        "app.routers.tasks.send_urgent_task_notification",
        new_callable=AsyncMock
    )
    mocker.patch("app.routers.tasks.is_task_urgent", return_value=False) 

    non_urgent_task_payload = {
        "title": "Tarefa Não Urgente Imediata",
        "description": "Sem pressa",
        "importance": 1,
        "due_date": (date.today() + timedelta(days=30)).isoformat() 
    }
    url = f"{settings.API_V1_STR}/tasks/"
    # --- Act ---
    response = await test_async_client.post(url, json=non_urgent_task_payload, headers=auth_headers_a)

    # --- Assert ---
    assert response.status_code == status.HTTP_201_CREATED
    mock_send_email.assert_not_called()

================================================================================
Capítulo 30: tests/test_worker.py
================================================================================

# tests/test_worker.py

# ========================
# --- Importações ---
# ========================
import pytest # type: ignore
import uuid
from datetime import date, datetime, timedelta, timezone
from unittest.mock import AsyncMock, MagicMock, call, patch
from pydantic import ValidationError
import app.worker 
from importlib import reload

# --- Módulos da Aplicação ---
from app.worker import check_and_notify_urgent_tasks
from app.models.task import Task, TaskStatus
from app.models.user import UserInDB
from app.core.config import settings


# =================================================================
# --- Fixtures de Dados de Teste para Usuários e Tarefas ---
# =================================================================
@pytest.fixture
def user_active_with_email() -> UserInDB:
    return UserInDB(
        id=uuid.uuid4(),
        username="testworkeruser",
        email="worker@example.com",
        full_name="Worker Test User",
        hashed_password="fakehash",
        disabled=False,
        created_at=datetime.now(timezone.utc)
    )

@pytest.fixture
def user_disabled_fixture() -> UserInDB: 
    return UserInDB(
        id=uuid.uuid4(),
        username="disableduser",
        email="disabled@example.com",
        full_name="Disabled User",
        hashed_password="fakehash",
        disabled=True,
        created_at=datetime.now(timezone.utc)
    )

@pytest.fixture
def task_urgent_score(user_active_with_email: UserInDB) -> Task:
    return Task(
        id=uuid.uuid4(),
        owner_id=user_active_with_email.id,
        title="Urgent High Score Task",
        importance=5,
        status=TaskStatus.PENDING,
        created_at=datetime.now(timezone.utc) - timedelta(days=1),
        priority_score=settings.EMAIL_URGENCY_THRESHOLD + 50.0,
        due_date=date.today() + timedelta(days=10)
    )

@pytest.fixture
def task_urgent_overdue(user_active_with_email: UserInDB) -> Task:
    return Task(
        id=uuid.uuid4(),
        owner_id=user_active_with_email.id,
        title="Urgent Overdue Task",
        importance=1,
        status=TaskStatus.PENDING,
        created_at=datetime.now(timezone.utc) - timedelta(days=5),
        priority_score=10.0,
        due_date=date.today() - timedelta(days=1)
    )

@pytest.fixture
def task_urgent_due_today(user_active_with_email: UserInDB) -> Task:
    return Task(
        id=uuid.uuid4(),
        owner_id=user_active_with_email.id,
        title="Urgent Due Today Task",
        importance=2,
        status=TaskStatus.IN_PROGRESS,
        created_at=datetime.now(timezone.utc) - timedelta(days=2),
        priority_score=20.0,
        due_date=date.today()
    )

@pytest.fixture
def task_not_urgent(user_active_with_email: UserInDB) -> Task:
    return Task(
        id=uuid.uuid4(),
        owner_id=user_active_with_email.id,
        title="Not Urgent Task",
        importance=3,
        status=TaskStatus.PENDING,
        created_at=datetime.now(timezone.utc),
        priority_score=settings.EMAIL_URGENCY_THRESHOLD - 10.0,
        due_date=date.today() + timedelta(days=5)
    )

@pytest.fixture
def task_completed(user_active_with_email: UserInDB) -> Task:
    return Task(
        id=uuid.uuid4(),
        owner_id=user_active_with_email.id,
        title="Completed Urgent Task",
        importance=5,
        status=TaskStatus.COMPLETED,
        created_at=datetime.now(timezone.utc) - timedelta(days=10),
        priority_score=settings.EMAIL_URGENCY_THRESHOLD + 100.0,
        due_date=date.today() - timedelta(days=2)
    )

@pytest.fixture
def task_disabled_user(user_disabled_fixture: UserInDB) -> Task: 
    return Task(
        id=uuid.uuid4(),
        owner_id=user_disabled_fixture.id,
        title="Disabled User Urgent Task",
        importance=5,
        status=TaskStatus.PENDING,
        created_at=datetime.now(timezone.utc),
        priority_score=settings.EMAIL_URGENCY_THRESHOLD + 50.0
    )

# =============================================================
# --- Testes para a função `check_and_notify_urgent_tasks` ---
# =============================================================
@pytest.mark.asyncio
async def test_worker_no_urgent_tasks(mocker): 
    """
    Testa o comportamento da função do worker ARQ quando o banco
    de dados simulado não retorna nenhuma tarefa urgente.
    """
    # ========================
    # --- Arrange ---
    # ========================
    mock_db = MagicMock()
    mock_tasks_collection = MagicMock()
    mock_db.__getitem__.return_value = mock_tasks_collection

    mock_cursor = AsyncMock()
    mock_cursor.__aiter__.return_value = []
    mock_tasks_collection.find.return_value = mock_cursor

    mock_get_user = mocker.patch("app.worker.user_crud.get_user_by_id", new_callable=AsyncMock)
    mock_send_email = mocker.patch("app.worker.send_urgent_task_notification", new_callable=AsyncMock)

    ctx = {"db": mock_db}
    # ========================
    # --- Act ---
    # ========================
    await check_and_notify_urgent_tasks(ctx)

    # ========================
    # --- Assert ---
    # ========================
    mock_tasks_collection.find.assert_called_once()
    mock_get_user.assert_not_called()
    mock_send_email.assert_not_called()

@pytest.mark.asyncio
async def test_worker_one_urgent_task_active_user(mocker, user_active_with_email, task_urgent_score): 
    """
    Testa o cenário onde o worker encontra uma tarefa urgente
    pertencente a um usuário ativo e com e-mail.
    """
    # ========================
    # --- Arrange ---
    # ========================
    mock_db = MagicMock()
    mock_tasks_collection = MagicMock()
    mock_users_collection = MagicMock()
    def db_getitem_side_effect(key):
        if key == "tasks": return mock_tasks_collection
        if key == "users": return mock_users_collection
        raise KeyError(key)
    mock_db.__getitem__.side_effect = db_getitem_side_effect

    task_dict = task_urgent_score.model_dump(mode='json')
    mock_cursor = AsyncMock()
    mock_cursor.__aiter__.return_value = [task_dict]
    mock_tasks_collection.find.return_value = mock_cursor

    mock_get_user = mocker.patch(
        "app.worker.user_crud.get_user_by_id",
        new_callable=AsyncMock,
        return_value=user_active_with_email
    )
    mock_send_email = mocker.patch("app.worker.send_urgent_task_notification", new_callable=AsyncMock)

    ctx = {"db": mock_db}
    # ========================
    # --- Act ---
    # ========================
    await check_and_notify_urgent_tasks(ctx)

    # ========================
    # --- Assert ---
    # ========================
    mock_tasks_collection.find.assert_called_once()
    mock_get_user.assert_called_once_with(mock_db, task_urgent_score.owner_id)
    mock_send_email.assert_called_once()

    call_args = mock_send_email.call_args.kwargs
    assert call_args['user_email'] == user_active_with_email.email
    assert call_args['user_name'] == user_active_with_email.full_name
    assert call_args['task_title'] == task_urgent_score.title
    assert call_args['task_id'] == str(task_urgent_score.id)

@pytest.mark.asyncio
async def test_worker_mix_urgent_non_urgent_completed(mocker, user_active_with_email, task_not_urgent, task_urgent_overdue, task_completed): 
    """
    Testa o worker com uma mistura de tarefas.
    """
    # ========================
    # --- Arrange ---
    # ========================
    mock_db = MagicMock()
    mock_tasks_collection = MagicMock()
    mock_users_collection = MagicMock()
    def db_getitem_side_effect(key):
        if key == "tasks": return mock_tasks_collection
        if key == "users": return mock_users_collection
        raise KeyError(key)
    mock_db.__getitem__.side_effect = db_getitem_side_effect

    # Simular que a query `find` retorna apenas a tarefa urgente e não completada
    filtered_task_dict = task_urgent_overdue.model_dump(mode='json')
    mock_cursor = AsyncMock()
    mock_cursor.__aiter__.return_value = [filtered_task_dict]
    mock_tasks_collection.find.return_value = mock_cursor

    mock_get_user = mocker.patch(
        "app.worker.user_crud.get_user_by_id",
        new_callable=AsyncMock,
        return_value=user_active_with_email
    )
    mock_send_email = mocker.patch("app.worker.send_urgent_task_notification", new_callable=AsyncMock)

    ctx = {"db": mock_db}
    # ========================
    # --- Act ---
    # ========================
    await check_and_notify_urgent_tasks(ctx)

    # ========================
    # --- Assert ---
    # ========================
    mock_tasks_collection.find.assert_called_once()
    mock_get_user.assert_called_once_with(mock_db, task_urgent_overdue.owner_id)
    mock_send_email.assert_called_once()
    call_args = mock_send_email.call_args.kwargs
    assert call_args['task_title'] == task_urgent_overdue.title

@pytest.mark.asyncio
async def test_worker_urgent_task_disabled_user(mocker, user_disabled_fixture, task_disabled_user): 
    """
    Testa que nenhuma notificação é enviada se o usuário estiver desativado.
    """
    # ========================
    # --- Arrange ---
    # ========================
    mock_db = MagicMock()
    mock_tasks_collection = MagicMock()
    mock_users_collection = MagicMock()
    def db_getitem_side_effect(key):
        if key == "tasks": return mock_tasks_collection
        if key == "users": return mock_users_collection
        raise KeyError(key)
    mock_db.__getitem__.side_effect = db_getitem_side_effect

    mock_cursor = AsyncMock()
    mock_cursor.__aiter__.return_value = [task_disabled_user.model_dump(mode='json')]
    mock_tasks_collection.find.return_value = mock_cursor

    mock_get_user = mocker.patch(
        "app.worker.user_crud.get_user_by_id",
        new_callable=AsyncMock,
        return_value=user_disabled_fixture
    )
    mock_send_email = mocker.patch("app.worker.send_urgent_task_notification", new_callable=AsyncMock)

    ctx = {"db": mock_db}
    # ========================
    # --- Act ---
    # ========================
    await check_and_notify_urgent_tasks(ctx)

    # ========================
    # --- Assert ---
    # ========================
    mock_tasks_collection.find.assert_called_once()
    mock_get_user.assert_called_once_with(mock_db, user_disabled_fixture.id)
    mock_send_email.assert_not_called()

@pytest.mark.asyncio
async def test_worker_multiple_urgent_tasks(mocker, user_active_with_email, task_urgent_score, task_urgent_overdue, task_urgent_due_today): 
    """
    Testa o cenário com múltiplas tarefas urgentes para usuários ativos.
    """
    # ========================
    # --- Arrange ---
    # ========================
    mock_db = MagicMock()
    mock_tasks_collection = MagicMock()
    mock_users_collection = MagicMock()
    def db_getitem_side_effect(key):
        if key == "tasks": return mock_tasks_collection
        if key == "users": return mock_users_collection
        raise KeyError(key)
    mock_db.__getitem__.side_effect = db_getitem_side_effect

    urgent_tasks_list_dicts = [
        task_urgent_score.model_dump(mode='json'),
        task_urgent_overdue.model_dump(mode='json'),
        task_urgent_due_today.model_dump(mode='json')
    ]
    mock_cursor = AsyncMock()
    mock_cursor.__aiter__.return_value = urgent_tasks_list_dicts
    mock_tasks_collection.find.return_value = mock_cursor

    mock_get_user = mocker.patch(
        "app.worker.user_crud.get_user_by_id",
        new_callable=AsyncMock,
        return_value=user_active_with_email
    )
    mock_send_email = mocker.patch("app.worker.send_urgent_task_notification", new_callable=AsyncMock)

    ctx = {"db": mock_db}
    # ========================
    # --- Act ---
    # ========================
    await check_and_notify_urgent_tasks(ctx)

    # ========================
    # --- Assert ---
    # ========================
    assert mock_tasks_collection.find.call_count == 1
    assert mock_get_user.call_count == len(urgent_tasks_list_dicts)
    assert mock_send_email.call_count == len(urgent_tasks_list_dicts)

    expected_call_args_score = {
        'user_email': user_active_with_email.email,
        'user_name': user_active_with_email.full_name,
        'task_title': task_urgent_score.title,
        'task_id': str(task_urgent_score.id),
        'task_due_date': str(task_urgent_score.due_date),
        'priority_score': task_urgent_score.priority_score
    }
    expected_call_args_overdue = {
        'user_email': user_active_with_email.email,
        'user_name': user_active_with_email.full_name,
        'task_title': task_urgent_overdue.title,
        'task_id': str(task_urgent_overdue.id),
        'task_due_date': str(task_urgent_overdue.due_date),
        'priority_score': task_urgent_overdue.priority_score
    }
    expected_call_args_today = {
        'user_email': user_active_with_email.email,
        'user_name': user_active_with_email.full_name,
        'task_title': task_urgent_due_today.title,
        'task_id': str(task_urgent_due_today.id),
        'task_due_date': str(task_urgent_due_today.due_date),
        'priority_score': task_urgent_due_today.priority_score
    }
    mock_send_email.assert_has_calls([
        call(**expected_call_args_score),
        call(**expected_call_args_overdue),
        call(**expected_call_args_today)
    ], any_order=True)

@pytest.mark.asyncio
async def test_worker_db_unavailable(mocker): 
    """
    Testa o comportamento do worker quando 'db' não está no contexto.
    """
    # ========================
    # --- Arrange ---
    # ========================
    mock_send_email = mocker.patch("app.worker.send_urgent_task_notification", new_callable=AsyncMock)
    mock_logger = mocker.patch("app.worker.logger")

    ctx = {}
    # ========================
    # --- Act ---
    # ========================
    await check_and_notify_urgent_tasks(ctx)

    # ========================
    # --- Assert ---
    # ========================
    mock_send_email.assert_not_called()
    mock_logger.error.assert_called_once_with(
        "Conexão com o banco de dados não disponível no contexto ARQ."
    )

@pytest.mark.asyncio
async def test_worker_user_not_found(mocker, task_urgent_score): 
    """
    Testa o caso onde uma tarefa urgente é encontrada, mas o usuário
    proprietário não é encontrado no banco de dados.
    """
    # ========================
    # --- Arrange ---
    # ========================
    mock_db = MagicMock()
    mock_tasks_collection = MagicMock()
    mock_users_collection = MagicMock()
    def db_getitem_side_effect(key):
        if key == "tasks": return mock_tasks_collection
        if key == "users": return mock_users_collection
        raise KeyError(key)
    mock_db.__getitem__.side_effect = db_getitem_side_effect

    urgent_task_dict = task_urgent_score.model_dump(mode='json')
    mock_cursor = AsyncMock()
    mock_cursor.__aiter__.return_value = [urgent_task_dict]
    mock_tasks_collection.find.return_value = mock_cursor

    mock_get_user = mocker.patch(
        "app.worker.user_crud.get_user_by_id",
        new_callable=AsyncMock,
        return_value=None
    )
    mock_send_email = mocker.patch("app.worker.send_urgent_task_notification", new_callable=AsyncMock)
    mock_logger_warning = mocker.patch("app.worker.logger.warning")

    ctx = {"db": mock_db}

    # ========================
    # --- Act ---
    # ========================
    await check_and_notify_urgent_tasks(ctx)

    # ========================
    # --- Assert ---
    # ========================
    mock_tasks_collection.find.assert_called_once()
    mock_get_user.assert_called_once_with(mock_db, task_urgent_score.owner_id)
    mock_send_email.assert_not_called()
    mock_logger_warning.assert_called_once()
    log_message = mock_logger_warning.call_args[0][0]
    assert f"Usuário com ID '{task_urgent_score.owner_id}' associado à tarefa urgente '{task_urgent_score.id}' não foi encontrado" in log_message

@pytest.mark.asyncio
async def test_worker_user_missing_details(mocker, user_active_with_email, task_urgent_due_today): 
    """
    Testa o caso onde o usuário é encontrado, mas falta email ou nome.
    """
    # ========================
    # --- Arrange ---
    # ========================
    for missing_field in ["email", "full_name"]:
        mock_db = MagicMock()
        mock_tasks_collection = MagicMock()
        mock_users_collection = MagicMock()
        def db_getitem_side_effect(key):
            if key == "tasks": return mock_tasks_collection
            if key == "users": return mock_users_collection
            raise KeyError(key)
        mock_db.__getitem__.side_effect = db_getitem_side_effect

        urgent_task_dict = task_urgent_due_today.model_dump(mode='json')
        mock_cursor = AsyncMock()
        mock_cursor.__aiter__.return_value = [urgent_task_dict]
        mock_tasks_collection.find.return_value = mock_cursor

        user_missing_details_mock = user_active_with_email.model_copy(deep=True)
        setattr(user_missing_details_mock, missing_field, None)

        mock_get_user = mocker.patch(
            "app.worker.user_crud.get_user_by_id",
            new_callable=AsyncMock,
            return_value=user_missing_details_mock
        )
        mock_send_email = mocker.patch("app.worker.send_urgent_task_notification", new_callable=AsyncMock)
        mock_logger_warning = mocker.patch("app.worker.logger.warning")

        ctx = {"db": mock_db}

        # ========================
        # --- Act ---
        # ========================
        await check_and_notify_urgent_tasks(ctx)

        # ========================
        # --- Assert ---
        # ========================
        mock_tasks_collection.find.assert_called_once()
        mock_get_user.assert_called_once_with(mock_db, task_urgent_due_today.owner_id)
        mock_send_email.assert_not_called()
        mock_logger_warning.assert_called_once()
        log_message = mock_logger_warning.call_args[0][0]
        assert f"Usuário '{user_missing_details_mock.username}'" in log_message
        assert "não possui e-mail ou nome completo configurado" in log_message

        mocker.resetall()

@pytest.mark.asyncio
async def test_worker_task_processing_exception(mocker, user_active_with_email, task_urgent_score, task_urgent_overdue): 
    """
    Testa o tratamento de exceção dentro do loop de processamento de tarefas.
    """
    # ========================
    # --- Arrange ---
    # ========================
    mock_db = MagicMock()
    mock_tasks_collection = MagicMock()
    mock_users_collection = MagicMock()
    def db_getitem_side_effect(key):
        if key == "tasks": return mock_tasks_collection
        if key == "users": return mock_users_collection
        raise KeyError(key)
    mock_db.__getitem__.side_effect = db_getitem_side_effect

    invalid_task_dict = task_urgent_score.model_dump(mode='json')
    invalid_task_dict.pop("title")
    invalid_task_dict["_id"] = "temp_id"
    dict_for_invalid_call = invalid_task_dict.copy()
    dict_for_invalid_call.pop('_id', None)

    valid_task_dict = task_urgent_overdue.model_dump(mode='json')
    valid_task_dict["_id"] = "valid_id"
    dict_for_valid_call = valid_task_dict.copy()
    dict_for_valid_call.pop('_id', None)


    mock_cursor = AsyncMock()
    mock_cursor.__aiter__.return_value = [valid_task_dict, invalid_task_dict]
    mock_tasks_collection.find.return_value = mock_cursor

    mock_get_user = mocker.patch(
        "app.worker.user_crud.get_user_by_id",
        new_callable=AsyncMock,
        return_value=user_active_with_email
    )

    validation_error = ValidationError.from_exception_data(title="Task", line_errors=[{'type': 'missing', 'loc':('title',)}])
    mock_model_validate = mocker.patch(
        "app.worker.Task.model_validate",
        side_effect=[task_urgent_overdue, validation_error]
    )

    mock_send_email = mocker.patch("app.worker.send_urgent_task_notification", new_callable=AsyncMock)
    mock_logger_exception = mocker.patch("app.worker.logger.exception")

    ctx = {"db": mock_db}

    # ========================
    # --- Act ---
    # ========================
    await check_and_notify_urgent_tasks(ctx)

    # ========================
    # --- Assert ---
    # ========================
    mock_tasks_collection.find.assert_called_once()
    assert mock_get_user.call_count == 1
    mock_get_user.assert_called_with(mock_db, task_urgent_overdue.owner_id)
    assert mock_model_validate.call_count == 2 
    mock_send_email.assert_called_once() 
    mock_logger_exception.assert_called_once()
    log_message = mock_logger_exception.call_args[0][0]
    assert f"Erro ao processar tarefa urgente (ID no dict: {invalid_task_dict.get('id')})" in log_message
    assert str(validation_error) in log_message

@pytest.mark.asyncio
async def test_startup_generic_exception(mocker): 
    """
    Testa o tratamento de erro no startup do worker quando
    connect_to_mongo lança uma exceção genérica.
    """
    # ========================
    # --- Arrange ---
    # ========================
    simulated_connect_error = Exception("Erro genérico na conexão inicial")
    mock_connect = mocker.patch("app.worker.connect_to_mongo", side_effect=simulated_connect_error)
    mock_logger_error = mocker.patch("app.worker.logger.error")
    ctx = {}

    # ========================
    # --- Act & Assert ---
    # ========================
    with pytest.raises(Exception, match="Erro genérico na conexão inicial"):
        await app.worker.startup(ctx)

    mock_connect.assert_awaited_once()
    mock_logger_error.assert_not_called()
    assert ctx.get("db") is None

@pytest.mark.asyncio
async def test_worker_send_email_exception(mocker, user_active_with_email, task_urgent_score): 
    """
    Testa o tratamento de exceção genérica ao tentar enviar email no worker.
    """
    # ========================
    # --- Arrange ---
    # ========================
    mock_db = MagicMock()
    mock_tasks_collection = MagicMock()
    mock_users_collection = MagicMock()
    def db_getitem_side_effect(key):
        if key == "tasks": return mock_tasks_collection
        if key == "users": return mock_users_collection
        raise KeyError(key)
    mock_db.__getitem__.side_effect = db_getitem_side_effect
    urgent_task_dict = task_urgent_score.model_dump(mode='json')
    urgent_task_dict['_id'] = "task_email_exc_id"
    mock_cursor = AsyncMock()
    mock_cursor.__aiter__.return_value = [urgent_task_dict]
    mock_tasks_collection.find.return_value = mock_cursor
    mock_get_user = mocker.patch(
        "app.worker.user_crud.get_user_by_id",
        new_callable=AsyncMock,
        return_value=user_active_with_email
    )
    mocker.patch("app.worker.Task.model_validate", return_value=task_urgent_score)
    simulated_email_error = Exception("Erro simulado no envio de email")
    mock_send_email = mocker.patch(
        "app.worker.send_urgent_task_notification",
        new_callable=AsyncMock,
        side_effect=simulated_email_error
    )
    mock_logger_exception = mocker.patch("app.worker.logger.exception")
    ctx = {"db": mock_db}

    # ========================
    # --- Act ---
    # ========================
    await check_and_notify_urgent_tasks(ctx)

    # ========================
    # --- Assert ---
    # ========================
    mock_tasks_collection.find.assert_called_once()
    mock_get_user.assert_called_once_with(mock_db, task_urgent_score.owner_id)
    mock_send_email.assert_called_once()
    mock_logger_exception.assert_called_once()
    log_message = mock_logger_exception.call_args.args[0]
    assert f"Erro ao processar tarefa urgente (ID no dict: {task_urgent_score.id})" in log_message
    assert str(simulated_email_error) in log_message

def test_worker_settings_no_redis_url(mocker): 
    """
    Testa se WorkerSettings levanta ValueError quando settings.REDIS_URL é None.
    """
    # ========================
    # --- Arrange ---
    # ========================
    mocker.patch("app.worker.settings.REDIS_URL", None)
    mock_logger_error = mocker.patch("app.worker.logger.error")

    # ========================
    # --- Act & Assert ---
    # ========================
    with pytest.raises(ValueError) as excinfo:
        reload(app.worker)

    assert "REDIS_URL não está definida nas configurações" in str(excinfo.value)
    mock_logger_error.assert_called_with("Configuração crítica ausente: REDIS_URL não está definida. Worker ARQ não pode iniciar.")

# =============================================================
# --- Testes para a função `shutdown` ---
# =============================================================

@pytest.mark.asyncio
async def test_shutdown_with_db(mocker): 
    """Testa a função shutdown quando existe conexão DB no contexto."""
    # ========================
    # --- Arrange ---
    # ========================
    mock_close_conn = mocker.patch("app.worker.close_mongo_connection", new_callable=AsyncMock)
    mock_logger_info = mocker.patch("app.worker.logger.info")
    mock_db = MagicMock() 
    ctx = {"db": mock_db}

    # ========================
    # --- Act ---
    # ========================
    await app.worker.shutdown(ctx) 

    # ========================
    # --- Assert ---
    # ========================
    mock_logger_info.assert_any_call("Worker ARQ: Iniciando rotinas de shutdown...")
    mock_close_conn.assert_awaited_once()
    mock_logger_info.assert_any_call("Worker ARQ: Conexão com MongoDB fechada.")

@pytest.mark.asyncio
async def test_shutdown_without_db(mocker): 
    """Testa a função shutdown quando não existe conexão DB no contexto."""
    # ========================
    # --- Arrange ---
    # ========================
    mock_close_conn = mocker.patch("app.worker.close_mongo_connection", new_callable=AsyncMock)
    mock_logger_info = mocker.patch("app.worker.logger.info")
    ctx = {"db": None} 

    # ========================
    # --- Act ---
    # ========================
    await app.worker.shutdown(ctx)

    # ========================
    # --- Assert ---
    # ========================
    mock_logger_info.assert_any_call("Worker ARQ: Iniciando rotinas de shutdown...")
    mock_close_conn.assert_not_called()
    mock_logger_info.assert_any_call("Worker ARQ: Nenhuma conexão com MongoDB para fechar (não estava disponível ou já fechada).")

# =============================================================
# --- Testes para a StartUp ---
# =============================================================
@pytest.mark.asyncio
async def test_startup_success(mocker): 
    """
    Testa o caminho de sucesso da função startup.
    """
    # ========================
    # --- Arrange ---
    # ========================
    mock_db_connection = MagicMock()
    mock_connect = mocker.patch("app.worker.connect_to_mongo", return_value=mock_db_connection)
    mock_logger_info = mocker.patch("app.worker.logger.info")
    mock_logger_error = mocker.patch("app.worker.logger.error") 
    ctx = {} 

    # ========================
    # --- Act ---
    # ========================
    await app.worker.startup(ctx)

    # ========================
    # --- Assert ---
    # ========================
    mock_connect.assert_awaited_once()
    assert ctx.get("db") == mock_db_connection 
    mock_logger_info.assert_any_call("Worker ARQ: Iniciando rotinas de startup...")
    mock_logger_info.assert_any_call("Worker ARQ: Conexão com MongoDB estabelecida e armazenada no contexto.")
    mock_logger_error.assert_not_called()

@pytest.mark.asyncio
async def test_startup_connect_returns_none(mocker): 
    """
    Testa o caminho de falha da função startup quando connect_to_mongo retorna None.
    """
    # ========================
    # --- Arrange ---
    # ========================
    mock_connect = mocker.patch("app.worker.connect_to_mongo", return_value=None) 
    mock_logger_info = mocker.patch("app.worker.logger.info")
    mock_logger_error = mocker.patch("app.worker.logger.error")
    ctx = {}

    # ========================
    # --- Act ---
    # ========================
    await app.worker.startup(ctx)

    # ========================
    # --- Assert ---
    # ========================
    mock_connect.assert_awaited_once()
    assert ctx.get("db") is None 
    mock_logger_info.assert_called_once_with("Worker ARQ: Iniciando rotinas de startup...") 
    mock_logger_error.assert_called_once_with(
        "Worker ARQ: Falha crítica ao conectar ao MongoDB durante o startup. "
        "A conexão não estará disponível para as tarefas."
    )

