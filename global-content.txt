=========================
ÍNDICE DOS ARQUIVOS PYTHON
=========================

1. app/core/config.py                                 (127 linhas)
2. app/core/dependencies.py                           (84 linhas)
3. app/core/email.py                                  (107 linhas)
4. app/core/security.py                               (113 linhas)
5. app/core/utils.py                                  (154 linhas)
6. app/db/mongodb_utils.py                            (61 linhas)
7. app/db/task_crud.py                                (180 linhas)
8. app/db/user_crud.py                                (111 linhas)
9. app/main.py                                        (80 linhas)
10. app/models/task.py                                 (98 linhas)
11. app/models/token.py                                (15 linhas)
12. app/models/user.py                                 (56 linhas)
13. app/routers/auth.py                                (118 linhas)
14. app/routers/tasks.py                               (324 linhas)
15. app/worker.py                                      (133 linhas)
16. tests/conftest.py                                  (150 linhas)
17. tests/test_auth.py                                 (233 linhas)
18. tests/test_core_config.py                          (97 linhas)
19. tests/test_core_dependencies.py                    (109 linhas)
20. tests/test_core_email.py                           (235 linhas)
21. tests/test_core_security.py                        (43 linhas)
22. tests/test_core_utils.py                           (136 linhas)
23. tests/test_core_utils_webhooks.py                  (148 linhas)
24. tests/test_main.py                                 (90 linhas)
25. tests/test_tasks.py                                (1048 linhas)
26. tests/test_worker.py                               (343 linhas)

==================================================


--- Início de app/core/config.py (127 linhas) ---
# app/core/config.py
import os
from pydantic_settings import BaseSettings
from pydantic import EmailStr, Field, RedisDsn, model_validator, HttpUrl
from typing import Optional
from dotenv import load_dotenv
import logging

logger = logging.getLogger(__name__)

# --- Carrega variáveis do .env ---
dotenv_path = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), '.env')
loaded = load_dotenv(dotenv_path=dotenv_path)

class Settings(BaseSettings):
    """
    Configurações da aplicação lidas do ambiente.
    Docs Pydantic Settings: https://docs.pydantic.dev/latest/concepts/pydantic_settings/
    """
    PROJECT_NAME: str = Field("SmartTask API", description="Nome do Projeto")
    API_V1_STR: str = Field("/api/v1", description="Prefixo para a versão 1 da API")

    # --- Configurações MongoDB ---
    MONGODB_URL: str = Field(..., description="URL de conexão do MongoDB")
    DATABASE_NAME: str = Field("smarttask_db", description="Nome do banco de dados MongoDB")

     # --- Configurações JWT ---
    JWT_SECRET_KEY: str = Field(..., description="Chave secreta para assinar tokens JWT")
    JWT_ALGORITHM: str = Field("HS256", description="Algoritmo de assinatura JWT")
    ACCESS_TOKEN_EXPIRE_MINUTES: int = Field(60 * 24 * 7, description="Validade do token de acesso (minutos)") # Ex: 7 dias

    # --- Configurações de Prioridade ---
    PRIORITY_WEIGHT_DUE_DATE: float = Field(
        100.0, 
        description="Peso para o componente de prazo no cálculo de prioridade."
    )
    PRIORITY_WEIGHT_IMPORTANCE: float = Field(
        10.0, 
        description="Peso (multiplicador) para o componente de importância no cálculo de prioridade."
    )
    PRIORITY_DEFAULT_SCORE_NO_DUE_DATE: Optional[float] = Field(
        0.0, 
        description="Pontuação base de prazo para tarefas sem data de vencimento (pode ser None ou 0)."
    )
    PRIORITY_SCORE_IF_OVERDUE: float = Field(
        1000.0, 
        description="Pontuação (ou fator aditivo/multiplicativo) especial para tarefas atrasadas."
    )

    # --- Configuração Webhook ---
    WEBHOOK_URL: Optional[HttpUrl] = Field(
        None,
        description="URL opcional para enviar notificações de eventos de tarefas (webhooks)."
    )
    # Segredo para assinar requests de webhook (HMAC)
    WEBHOOK_SECRET: Optional[str] = Field(
        None,
        description="Segredo opcional usado para assinar payloads de webhook para verificação."
    )

    # --- Configurações de E-mail ---
    MAIL_ENABLED: bool = Field(
            default=True,
            description="Flag para habilitar/desabilitar envio de e-mails globalmente."
    )
    MAIL_USERNAME: Optional[str] = Field(None, description="Usuário do servidor SMTP.")
    MAIL_PASSWORD: Optional[str] = Field(None, description="Senha do servidor SMTP.")
    MAIL_FROM: Optional[EmailStr] = Field(
        None,
        description="Endereço de e-mail remetente."
    )
    MAIL_FROM_NAME: Optional[str] = Field(
        "SmartTask Notificações", 
        description="Nome do remetente exibido no e-mail."
    )
    MAIL_PORT: int = Field(
        587,
        description="Porta do servidor SMTP."
    )
    MAIL_SERVER: Optional[str] = Field(
        None,
        description="Endereço do servidor SMTP."
    )
    # Configurações para fastapi-mail
    MAIL_STARTTLS: bool = Field(True) 
    MAIL_SSL_TLS: bool = Field(False) 
    USE_CREDENTIALS: bool = Field(True)
    VALIDATE_CERTS: bool = Field(True) 

    # --- Configurações Adicionais (Templates, Limiar) ---
    EMAIL_TEMPLATES_DIR: str = Field("app/email-templates/build", description="Diretório de templates de e-mail compilados.") # Definiremos isso
    EMAIL_URGENCY_THRESHOLD: float = Field(
        100.0, 
        description="Limiar de priority_score para considerar uma tarefa urgente para notificação."
    )
    FRONTEND_URL: Optional[str] = Field(None, description="URL base do frontend para links no e-mail (se houver).") # Ex: http://localhost:3000

     # --- Configuração Redis ---
    REDIS_URL: Optional[RedisDsn] = Field(
        None, 
        description="URL de conexão do Redis para filas de tarefas (ARQ)."
    )

    # --- Configurações CORS ---

    # --- Configuração Pydantic (case-insensitive)---
    model_config = {
        "case_sensitive": False,
    }

# --- Validação ---
    @model_validator(mode='after')
    def check_mail_config(self) -> 'Settings':
        if self.MAIL_ENABLED and not all([self.MAIL_USERNAME, self.MAIL_PASSWORD, self.MAIL_FROM, self.MAIL_SERVER]):
            raise ValueError(
                "Se MAIL_ENABLED for True, MAIL_USERNAME, MAIL_PASSWORD, MAIL_FROM e MAIL_SERVER devem ser definidos."
            )
        return self

# --- Cria a instância ---
try:
    settings = Settings()
except ValueError as e:
     raise e 
# Validação extra da instância
if settings.WEBHOOK_URL and not isinstance(settings.WEBHOOK_URL, HttpUrl):
     logger.warning(f"WEBHOOK_URL '{settings.WEBHOOK_URL}' não parece ser uma URL válida.")
--- Fim de app/core/config.py ---

--- Início de app/core/dependencies.py (84 linhas) ---
# app/core/dependencies.py
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from motor.motor_asyncio import AsyncIOMotorDatabase
from typing import Annotated # Python 3.9+
import uuid

from app.db.mongodb_utils import get_database
from app.core.security import decode_token
from app.db import user_crud
from app.models.user import UserInDB, User # Import User para retorno

# Define o esquema OAuth2 para obter o token do header Authorization: Bearer <token>
# tokenUrl aponta para o nosso endpoint de login que gera o token
# O path relativo deve ser o correto APÓS o prefixo da API
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/v1/auth/login/access-token") # Ajuste se seu prefixo/rota for diferente

# Tipos anotados para dependências (mais legível)
DbDep = Annotated[AsyncIOMotorDatabase, Depends(get_database)]
TokenDep = Annotated[str, Depends(oauth2_scheme)]

async def get_current_user(
    db: DbDep,
    token: TokenDep # Obtém o token do header usando OAuth2PasswordBearer
) -> UserInDB: # Retorna o usuário completo do DB (incluindo senha hasheada)
               # Mude para 'User' se preferir retornar o modelo sem senha hasheada
    """
    Dependência para obter o usuário atual com base no token JWT:
    - Extrai e valida o token do header 'Authorization: Bearer <token>'.
    - Decodifica o token e obtém o ID do usuário ('sub').
    - Busca o usuário no banco de dados pelo ID.
    - Levanta exceção se o token for inválido, expirado ou o usuário não existir/estiver desativado.
    - Retorna o objeto do usuário encontrado.
    """
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Não foi possível validar as credenciais",
        headers={"WWW-Authenticate": "Bearer"},
    )

    # Decodifica o token JWT
    token_payload = decode_token(token)

    if token_payload is None or token_payload.sub is None:
         # Se decode_token retornou None, o token é inválido ou expirou
        raise credentials_exception

    # Tenta converter o 'sub' (subject/ID do usuário) para UUID
    try:
        user_id = uuid.UUID(str(token_payload.sub)) # Garante que sub seja tratado como string
    except ValueError:
         # O 'sub' no token não é um UUID válido
         raise credentials_exception

    # Busca o usuário no banco de dados usando o ID do token
    user = await user_crud.get_user_by_id(db=db, user_id=user_id)
    if user is None:
         # Usuário referenciado no token não existe mais no DB
         raise credentials_exception

    # Opcional: Poderia retornar o modelo User (sem hash de senha) aqui se preferir
    # return User.model_validate(user)
    return user # Retorna UserInDB (útil se precisarmos da info completa internamente)


async def get_current_active_user(
     # Esta dependência *reutiliza* a anterior
    current_user: Annotated[UserInDB, Depends(get_current_user)]
) -> UserInDB: # Mude para User se get_current_user retornar User
    """
    Dependência que garante que o usuário obtido de get_current_user
    não está desativado.
    """
    if current_user.disabled:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Usuário inativo")
    # Se passou, retorna o mesmo usuário validado
    # Poderia retornar User aqui também: User.model_validate(current_user)
    return current_user

# --- Tipos Anotados para Injeção ---
# Define tipos curtos para usar nos endpoints protegidos
CurrentUser = Annotated[UserInDB, Depends(get_current_active_user)]
# Use este se preferir retornar o modelo User sem a senha hasheada:
# CurrentUser = Annotated[User, Depends(get_current_active_user)] # Se get_current_active_user retornar User--- Fim de app/core/dependencies.py ---

--- Início de app/core/email.py (107 linhas) ---
# app/core/email.py
import logging
from pathlib import Path
from typing import List, Optional, Dict, Any
from fastapi_mail import FastMail, MessageSchema, ConnectionConfig, MessageType
from pydantic import EmailStr, BaseModel
from app.core.config import settings 

logger = logging.getLogger(__name__)

# --- Configuração da conexão ---
conf = ConnectionConfig(
    MAIL_USERNAME=settings.MAIL_USERNAME or "", 
    MAIL_PASSWORD=settings.MAIL_PASSWORD or "",
    MAIL_FROM=settings.MAIL_FROM or EmailStr("default@example.com"), 
    MAIL_PORT=settings.MAIL_PORT,
    MAIL_SERVER=settings.MAIL_SERVER or "",
    MAIL_FROM_NAME=settings.MAIL_FROM_NAME or "Default Sender",
    MAIL_STARTTLS=settings.MAIL_STARTTLS,
    MAIL_SSL_TLS=settings.MAIL_SSL_TLS,
    USE_CREDENTIALS=settings.USE_CREDENTIALS,
    VALIDATE_CERTS=settings.VALIDATE_CERTS,
    TEMPLATE_FOLDER=Path(settings.EMAIL_TEMPLATES_DIR) if settings.EMAIL_TEMPLATES_DIR else None, 
)

# Instância principal do FastMail
fm = FastMail(conf)

async def send_email_async(
    subject: str,
    recipient_to: List[EmailStr],
    body: Dict[str, Any], 
    template_name: Optional[str] = None, 
    plain_text_body: Optional[str] = None 
):
    """
    Envia um e-mail de forma assíncrona.

    Args:
        subject: Assunto do e-mail.
        recipient_to: Lista de destinatários.
        body: Dicionário com variáveis para preencher o template HTML.
        template_name: Nome do arquivo do template HTML (sem extensão, deve estar em EMAIL_TEMPLATES_DIR).
        plain_text_body: Conteúdo alternativo em texto puro.
    """
    if not settings.MAIL_ENABLED:
        logger.warning("Envio de e-mail desabilitado nas configurações (MAIL_ENABLED=false).")
        return

    if not all([settings.MAIL_USERNAME, settings.MAIL_PASSWORD, settings.MAIL_FROM, settings.MAIL_SERVER]):
        logger.error("Configurações essenciais de e-mail ausentes (USERNAME, PASSWORD, FROM, SERVER). Não foi possível enviar.")
        return

    message = MessageSchema(
        subject=subject,
        recipients=recipient_to,
        template_body=body if template_name else None, 
        body=plain_text_body if not template_name else None, 
        subtype=MessageType.html if template_name else MessageType.plain, 
    )

    try:
        logger.info(f"Tentando enviar e-mail para {recipient_to} com assunto '{subject}'...")
        await fm.send_message(message, template_name=template_name)
        logger.info(f"E-mail enviado com sucesso para {recipient_to}.")
    except Exception as e:
        logger.exception(f"Erro ao enviar e-mail para {recipient_to}: {e}")

# --- Funções utilitárias ---

async def send_urgent_task_notification(
    user_email: EmailStr,
    user_name: str,
    task_title: str,
    task_id: str,
    task_due_date: Optional[str],
    priority_score: float
):
    """Envia notificação de tarefa urgente."""

    subject = f"🚨 Tarefa Urgente no SmartTask: {task_title}"

    # Link para a tarefa
    task_link = f"{settings.FRONTEND_URL}/tasks/{task_id}" if settings.FRONTEND_URL else None

    # Corpo/Contexto para o template
    email_body_data = {
        "task_title": task_title,
        "user_name": user_name,
        "due_date": task_due_date or "N/A",
        "priority_score": f"{priority_score:.2f}", 
        "task_link": task_link,
        "project_name": settings.PROJECT_NAME
    }

    # Nome do template HTML (criaremos abaixo)
    template_name = "urgent_task.html"

    await send_email_async(
        subject=subject,
        recipient_to=[user_email],
        body=email_body_data,
        template_name=template_name,
        plain_text_body=f"Olá {user_name},\nA tarefa '{task_title}' no {settings.PROJECT_NAME} é considerada urgente.\n"
                       f"Prioridade: {priority_score:.2f}, Vencimento: {task_due_date or 'N/A'}.\n"
                       f"{'Acesse a tarefa aqui: ' + task_link if task_link else ''}"
    )--- Fim de app/core/email.py ---

--- Início de app/core/security.py (113 linhas) ---
# app/core/security.py
from datetime import datetime, timedelta, timezone
from typing import Any, Union, Optional
from passlib.context import CryptContext
from jose import jwt, JWTError
from pydantic import ValidationError # Para erros de validação de token

from app.core.config import settings # Importa configurações (SECRET_KEY, etc.)
from app.models.token import TokenPayload # Modelo para dados do payload

# --- Configuração do Hashing de Senha ---
# Define o contexto do passlib, especificando os esquemas de hash permitidos
# 'bcrypt' será o padrão para novas senhas. Outros são para senhas legadas (se houver)
# 'deprecated="auto"' significa que senhas com esquemas antigos serão automaticamente atualizadas para bcrypt no login
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

ALGORITHM = settings.JWT_ALGORITHM
ACCESS_TOKEN_EXPIRE_MINUTES = settings.ACCESS_TOKEN_EXPIRE_MINUTES

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """Verifica se a senha fornecida corresponde à senha hasheada."""
    try:
        return pwd_context.verify(plain_password, hashed_password)
    except ValueError: # Pode ocorrer se o hash não for reconhecido
         return False


def get_password_hash(password: str) -> str:
    """Gera o hash de uma senha usando bcrypt."""
    return pwd_context.hash(password)

# --- Funções JWT ---

def create_access_token(subject: Union[str, Any],username: str, expires_delta: Optional[timedelta] = None) -> str:
    """
    Cria um novo token de acesso JWT.

    Args:
        subject: O identificador único do sujeito do token (ex: user ID ou username).
        expires_delta: Tempo de vida do token. Se None, usa o padrão das configurações.

    Returns:
        O token JWT codificado como string.
    """
    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)

    # Garante que o subject (ID do usuário) seja uma string para o JWT
    # Embora Any seja aceito, geralmente é um ID (UUID, int, str)
    subject_str = str(subject)

    to_encode = {
        "exp": expire,
        "sub": subject_str, # User ID
        "username": username # Username
    }

    # Adicione outros dados ao payload se necessário (cuidado com o tamanho do token)
    # to_encode.update({"username": username_do_subject})

    encoded_jwt = jwt.encode(to_encode, settings.JWT_SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt


def decode_token(token: str) -> Optional[TokenPayload]:
    """
    Decodifica um token JWT e valida seu conteúdo.

    Args:
        token: O token JWT string.

    Returns:
        Um objeto TokenPayload com os dados do token se válido, None caso contrário.
    """
    try:
        # Decodifica o token
        payload = jwt.decode(
            token,
            settings.JWT_SECRET_KEY,
            algorithms=[ALGORITHM]
        )

        # Extrai os dados esperados (subject/user_id)
        # subject = payload.get("sub") # 'sub' é o id do usuário (UUID string)
        # username = payload.get("username") # Se incluímos o username no token

        # if subject is None: # or username is None:
        #     return None

        # Valida os dados do payload com o modelo Pydantic
        # Isso garante que os tipos e campos esperados estejam presentes
        token_data = TokenPayload.model_validate(payload)

        # Verifica se o token expirou (embora jwt.decode geralmente faça isso)
        if token_data.exp is not None:
             if datetime.now(timezone.utc) > datetime.fromtimestamp(token_data.exp, tz=timezone.utc):
                 # Poderia levantar uma exceção específica de expiração aqui
                 return None # Ou trate como inválido

        # Aqui poderíamos converter o 'sub' (string UUID) de volta para UUID se necessário
        # try:
        #     token_data.sub = uuid.UUID(token_data.sub)
        # except ValueError:
        #     return None # ID inválido no token

        return token_data

    except (JWTError, ValidationError, KeyError) as e:
        # Logar o erro `e` aqui seria útil para depuração
        print(f"Erro ao decodificar token: {e}") # Log de erro simples
        return None--- Fim de app/core/security.py ---

--- Início de app/core/utils.py (154 linhas) ---
# app/core/utils.py
from datetime import date, datetime, timezone
from typing import Any, Dict, Optional, TYPE_CHECKING
import math
from app.core.config import settings 
from app.models.task import Task
import httpx 
import json  
import logging 
import hmac   
import hashlib 

logger = logging.getLogger(__name__)

# --- Função de cálculo de prioridade ---
def calculate_priority_score(
    importance: int,
    due_date: Optional[date]
    ) -> Optional[float]:
    """
    Calcula a pontuação de prioridade de uma tarefa.

    Args:
        importance: Nível de importância da tarefa (ex: 1-5).
        due_date: Data de vencimento da tarefa (opcional).

    Returns:
        A pontuação de prioridade calculada, ou None se não aplicável.
        Retornaremos float para permitir scores não inteiros.
    """
    if not 1 <= importance <= 5:
         return None 

    # --- Importância
    importance_score = importance * settings.PRIORITY_WEIGHT_IMPORTANCE

    # --- Prazo
    due_date_score = 0.0 
    if due_date:
        today = date.today() 

        days_remaining = (due_date - today).days

        if days_remaining < 0: 
            due_date_score = settings.PRIORITY_SCORE_IF_OVERDUE

        elif days_remaining == 0: 
             due_date_score = settings.PRIORITY_WEIGHT_DUE_DATE / 1.0 

        elif days_remaining > 0:
            effective_days = max(1, days_remaining) 
            due_date_score = settings.PRIORITY_WEIGHT_DUE_DATE / effective_days
            importance_score = importance * settings.PRIORITY_WEIGHT_IMPORTANCE 

        else:
             due_date_score = 0.0

    elif settings.PRIORITY_DEFAULT_SCORE_NO_DUE_DATE is not None:
         due_date_score = settings.PRIORITY_DEFAULT_SCORE_NO_DUE_DATE

    # --- Combinar Scores
    total_score = round(due_date_score + importance_score, 2) 

    return total_score

# --- Função de tarefa urgente ---
def is_task_urgent(task: Task) -> bool:
    """Verifica se uma tarefa atende aos critérios de urgência para notificação."""
    # --- Critério 0: Tarefa deve ter um score ou prazo
    if task.priority_score is None and task.due_date is None:
         return False 

    # --- Critério 1: Score acima do limiar (e não None)
    if task.priority_score is not None and task.priority_score > settings.EMAIL_URGENCY_THRESHOLD:
        return True

    # --- Critério 2: Vence hoje ou está atrasada
    if task.due_date:
        today = date.today()
        days_remaining = (task.due_date - today).days
        if days_remaining <= 0:
            return True

    return False

# --- Função de Webhook ---
async def send_webhook_notification(
    event_type: str,
    task_data: Dict[str, Any] 
    ):
    """
    Envia uma notificação via webhook para a URL configurada (se houver).
    Executada em background.

    Args:
        event_type: Tipo do evento (ex: 'task.created', 'task.updated').
        task_data: Dados da tarefa como um dicionário Python.
    """
    if not settings.WEBHOOK_URL:
        logger.debug("Webhook URL não configurada, pulando envio.") 
        return 

    # Converter URL Pydantic para string
    webhook_url_str = str(settings.WEBHOOK_URL)

    payload = {
        "event": event_type,
        "task": task_data,
        "timestamp": datetime.now(timezone.utc).isoformat() 
    }

    headers = {
        "Content-Type": "application/json",
        "User-Agent": "SmartTask-Webhook-Client/1.0" 
    }

    # --- Segurança de Assinatura ---
    if settings.WEBHOOK_SECRET:
        try:
            payload_bytes = json.dumps(payload, separators=(',', ':'), sort_keys=True).encode('utf-8')
            secret_bytes = settings.WEBHOOK_SECRET.encode('utf-8')

            signature = hmac.new(secret_bytes, payload_bytes, hashlib.sha256).hexdigest()
            headers["X-SmartTask-Signature"] = f"sha256={signature}"
        except Exception as e:
             logger.error(f"Erro ao gerar assinatura HMAC para webhook: {e}")
             return 

    # --- Envio da Requisição HTTP ---
    try:
         async with httpx.AsyncClient() as client:
            logger.info(f"Enviando webhook evento '{event_type}' para {webhook_url_str}")
            response = await client.post(
                webhook_url_str,
                json=payload, 
                headers=headers,
                timeout=10.0 
            )

            response.raise_for_status()

            logger.info(f"Webhook enviado com sucesso para {webhook_url_str}. Status: {response.status_code}")

    except httpx.TimeoutException:
         logger.error(f"Timeout ao enviar webhook para {webhook_url_str}")
    except httpx.RequestError as exc:
         logger.error(f"Erro na requisição ao enviar webhook para {webhook_url_str}: {exc}")
    except httpx.HTTPStatusError as exc:
         logger.error(
             f"Erro no servidor do webhook ({webhook_url_str}). "
             f"Status: {exc.response.status_code}. Resposta: {exc.response.text[:200]}..." 
         )
    except Exception as e:
         logger.exception(f"Erro inesperado ao enviar webhook para {webhook_url_str}: {e}")--- Fim de app/core/utils.py ---

--- Início de app/db/mongodb_utils.py (61 linhas) ---
# app/db/mongodb_utils.py
from typing import Optional
import motor.motor_asyncio
from app.core.config import settings 
import logging
from motor.motor_asyncio import AsyncIOMotorDatabase

logger = logging.getLogger(__name__)

# Variáveis globais para o cliente e banco de dados
db_client: motor.motor_asyncio.AsyncIOMotorClient | None = None
db_instance: motor.motor_asyncio.AsyncIOMotorDatabase | None = None

async def connect_to_mongo() -> Optional[AsyncIOMotorDatabase]:
    """
    Conecta-se ao MongoDB na inicialização da aplicação.
    """
    global db_client, db_instance

    try:

        db_client = motor.motor_asyncio.AsyncIOMotorClient(
            settings.MONGODB_URL,
            serverSelectionTimeoutMS=5000 
        )
        await db_client.admin.command('ping')

        db_instance = db_client[settings.DATABASE_NAME]

        return db_instance
    
    except Exception as e:
        logger.error(f"Não foi possível conectar ao MongoDB: {e}")
        db_client = None
        db_instance = None
        return None

async def close_mongo_connection():
    """
    Fecha a conexão com o MongoDB no encerramento da aplicação.
    """
    global db_client
    if db_client:
        db_client.close()
    else:
        logger.warning("Tentativa de fechar conexão com MongoDB, mas cliente não estava inicializado.")

def get_database() -> motor.motor_asyncio.AsyncIOMotorDatabase:
    """
    Retorna a instância do banco de dados MongoDB.
    Pode ser usada como uma dependência FastAPI ou chamada diretamente.
    """
    if db_instance is None:
        logger.error("Tentativa de obter instância do DB antes da inicialização!")
        raise RuntimeError("A conexão com o banco de dados não foi inicializada.")
    return db_instance

# Você pode também querer uma função para obter coleções específicas:
# def get_task_collection() -> motor.motor_asyncio.AsyncIOMotorCollection:
#     db = get_database()
#     return db.get_collection("tasks") # Nome da coleção de tarefas--- Fim de app/db/mongodb_utils.py ---

--- Início de app/db/task_crud.py (180 linhas) ---
# app/db/task_crud.py
import logging
import uuid
from datetime import date, datetime, timezone
from typing import List, Optional, Dict, Any, Tuple

from motor.motor_asyncio import AsyncIOMotorDatabase, AsyncIOMotorCollection
from pymongo import ASCENDING, DESCENDING
from pydantic import ValidationError

from app.models.task import Task, TaskCreate, TaskUpdate, TaskStatus 

# Nome da coleção no MongoDB para tarefas
TASKS_COLLECTION = "tasks"

# --- Funções Auxiliares (internas ao CRUD) ---

def _get_tasks_collection(db: AsyncIOMotorDatabase) -> AsyncIOMotorCollection:
    """Retorna a coleção de tarefas."""
    return db[TASKS_COLLECTION]

def _parse_sort_params(sort_by: Optional[str], sort_order: str) -> Optional[List[Tuple[str, int]]]:
    """Converte parâmetros de sort em formato para pymongo."""
    if sort_by in ["priority_score", "due_date", "created_at", "importance"]:
        mongo_order = DESCENDING if sort_order.lower() == "desc" else ASCENDING
        return [(sort_by, mongo_order)]
    return None

# --- Funções CRUD para Tarefas ---

async def create_task(db: AsyncIOMotorDatabase, task_db: Task) -> Optional[Task]:
    """
    Cria uma nova tarefa no banco de dados.
    Recebe um objeto Task já validado e com campos calculados (id, owner_id, etc.).
    Retorna o objeto Task criado ou None em caso de erro.
    """
    collection = _get_tasks_collection(db)
    task_db_dict = task_db.model_dump(mode="json") 
    try:
        insert_result = await collection.insert_one(task_db_dict)
        if insert_result.acknowledged:
            return task_db 
        else:
            return None
    except Exception as e:
        print(f"DB Error creating task: {e}") 
        return None

async def get_task_by_id(db: AsyncIOMotorDatabase, task_id: uuid.UUID, owner_id: uuid.UUID) -> Optional[Task]:
    """Busca uma tarefa pelo seu ID e ID do proprietário."""
    collection = _get_tasks_collection(db)
    task_dict = await collection.find_one({"id": str(task_id), "owner_id": str(owner_id)})
    if task_dict:
        task_dict.pop('_id', None)
        try:
            return Task.model_validate(task_dict)
        except (ValidationError, Exception) as e:
            print(f"DB Validation error get_task_by_id {task_id}: {e}") 
            return None 
    return None

async def get_tasks_by_owner(
    db: AsyncIOMotorDatabase,
    owner_id: uuid.UUID,
    *, 
    status_filter: Optional[TaskStatus] = None,
    due_before: Optional[date] = None,
    project_filter: Optional[str] = None,
    tags_filter: Optional[List[str]] = None,
    sort_by: Optional[str] = None,
    sort_order: str = "desc",
    limit: int = 100,
    skip: int = 0
) -> List[Task]:
    """
    Busca tarefas de um proprietário com filtros, ordenação e paginação.
    Retorna uma lista de objetos Task.
    """
    collection = _get_tasks_collection(db)
    query: Dict[str, Any] = {"owner_id": str(owner_id)}

    # Adiciona filtros opcionais
    if status_filter:
        query["status"] = status_filter.value
    if due_before:
        due_before_dt = datetime.combine(due_before, datetime.min.time(), tzinfo=timezone.utc)
        query["due_date"] = {"$lte": due_before_dt}
    if project_filter:
        query["project"] = project_filter
    if tags_filter:
        query["tags"] = {"$all": tags_filter} 

    sort_list = _parse_sort_params(sort_by, sort_order)

    validated_tasks = []
    try:
        tasks_cursor = collection.find(query).skip(skip).limit(limit)
        if sort_list:
            tasks_cursor = tasks_cursor.sort(sort_list)

        async for task_dict in tasks_cursor:
            task_dict.pop('_id', None)
            try:
                validated_tasks.append(Task.model_validate(task_dict))
            except (ValidationError, Exception) as e:
                 print(f"DB Validation error list_tasks {task_dict.get('id')}: {e}") 
                 continue 
        return validated_tasks
    except Exception as e:
        print(f"DB Error listing tasks for owner {owner_id}: {e}") 
        return []


async def update_task(
    db: AsyncIOMotorDatabase,
    task_id: uuid.UUID,
    owner_id: uuid.UUID,
    update_data: Dict[str, Any] 
) -> Optional[Task]:
    """
    Atualiza uma tarefa existente.
    Recebe um dicionário com os campos $set do MongoDB.
    Retorna o objeto Task atualizado ou None se não encontrada/erro.
    """
    collection = _get_tasks_collection(db)
    update_data["updated_at"] = datetime.now(timezone.utc)

    try:
        updated_task_dict_raw = await collection.find_one_and_update(
            {"id": str(task_id), "owner_id": str(owner_id)},
            {"$set": update_data},
            return_document=True 
        )

        if updated_task_dict_raw:
            updated_task_dict_raw.pop('_id', None)
            try:
                return Task.model_validate(updated_task_dict_raw)
            except (ValidationError, Exception) as e:
                 print(f"DB Validation error update_task {task_id}: {e}") 
                 return None
        else:
            return None 
    except Exception as e:
        print(f"DB Error updating task {task_id}: {e}") 
        return None


async def delete_task(db: AsyncIOMotorDatabase, task_id: uuid.UUID, owner_id: uuid.UUID) -> bool:
    """
    Deleta uma tarefa pelo ID e ID do proprietário.
    Retorna True se a deleção foi bem-sucedida (1 documento deletado), False caso contrário.
    """
    collection = _get_tasks_collection(db)
    try:
        delete_result = await collection.delete_one({"id": str(task_id), "owner_id": str(owner_id)})
        return delete_result.deleted_count == 1
    except Exception as e:
        print(f"DB Error deleting task {task_id}: {e}") 
        return False
    
async def create_task_indexes(db: AsyncIOMotorDatabase):
    """Cria índices importantes para a coleção de tarefas se não existirem."""
    collection = _get_tasks_collection(db) 
    try:
        await collection.create_index("id", unique=True, name="task_id_unique_idx")
        await collection.create_index("owner_id", name="task_owner_idx")
        await collection.create_index(
            [("owner_id", ASCENDING), ("due_date", DESCENDING)], 
            name="task_owner_due_date_idx"
        )
        await collection.create_index(
            [("owner_id", ASCENDING), ("priority_score", DESCENDING)], 
            name="task_owner_priority_idx"
        )
        await collection.create_index("tags", name="task_tags_idx")

        logging.info("Índices da coleção 'tasks' verificados/criados.")
    except Exception as e:
        logging.error(f"Erro ao criar índices da coleção 'tasks': {e}")--- Fim de app/db/task_crud.py ---

--- Início de app/db/user_crud.py (111 linhas) ---
# app/db/user_crud.py
import logging
from motor.motor_asyncio import AsyncIOMotorDatabase, AsyncIOMotorCollection
from typing import Optional, List
import uuid
from datetime import datetime, timezone
from pymongo.errors import DuplicateKeyError

from app.models.user import UserCreate, UserInDB, UserUpdate
from app.core.security import get_password_hash

from motor.motor_asyncio import AsyncIOMotorDatabase

# Nome da coleção de usuários
USERS_COLLECTION = "users"

# --- Funções CRUD para Usuários ---

async def get_user_by_id(db: AsyncIOMotorDatabase, user_id: uuid.UUID) -> Optional[UserInDB]:
    """Busca um usuário pelo seu ID (UUID)."""
    user_dict = await db[USERS_COLLECTION].find_one({"id": str(user_id)})
    if user_dict:
        user_dict.pop('_id', None) # Remove _id do mongo
        try:
             return UserInDB.model_validate(user_dict)
        except Exception: # Tratamento básico de erro de validação
             return None
    return None

async def get_user_by_username(db: AsyncIOMotorDatabase, username: str) -> Optional[UserInDB]:
    """Busca um usuário pelo seu nome de usuário."""
    # Index no 'username' é recomendado para performance
    user_dict = await db[USERS_COLLECTION].find_one({"username": username})
    if user_dict:
         user_dict.pop('_id', None)
         try:
            return UserInDB.model_validate(user_dict)
         except Exception:
            return None
    return None

async def get_user_by_email(db: AsyncIOMotorDatabase, email: str) -> Optional[UserInDB]:
    """Busca um usuário pelo seu e-mail."""
     # Index no 'email' é recomendado para performance e unicidade
    user_dict = await db[USERS_COLLECTION].find_one({"email": email})
    if user_dict:
        user_dict.pop('_id', None)
        try:
            return UserInDB.model_validate(user_dict)
        except Exception:
            return None
    return None

async def create_user(db: AsyncIOMotorDatabase, user_in: UserCreate) -> Optional[UserInDB]:
    """Cria um novo usuário no banco de dados."""
    hashed_password = get_password_hash(user_in.password)

    user_db_data = {
        "id": uuid.uuid4(),
        "username": user_in.username,
        "email": user_in.email,
        "hashed_password": hashed_password,
        "full_name": user_in.full_name,
        "disabled": False, # Novo usuário começa ativo
        "created_at": datetime.now(timezone.utc),
        "updated_at": None
    }
    # Tenta validar antes de inserir (boa prática)
    try:
        user_db_obj = UserInDB.model_validate(user_db_data)
    except Exception as validation_error:
        # Logar validation_error seria importante
        print(f"Erro de validação Pydantic ao criar user_db_obj: {validation_error}")
        return None # Ou levantar uma exceção customizada

    # Converte para dicionário para inserir no Mongo
    user_db_dict = user_db_obj.model_dump(mode="json")

    try:
        insert_result = await db[USERS_COLLECTION].insert_one(user_db_dict)
        if not insert_result.acknowledged:
             # Logar erro
             return None
         # Retorna o objeto UserInDB validado (não o dict)
        return user_db_obj
    except DuplicateKeyError:
        # Este erro ocorreria se tivéssemos índices únicos no Mongo
        # Vamos tratar isso no endpoint que chama esta função
        raise # Re-lança a exceção para ser tratada na rota
    except Exception as e:
         # Logar erro 'e'
         print(f"Erro inesperado ao inserir usuário no DB: {e}")
         return None


# Adicionar funções de update e delete se necessário
# async def update_user(...)
# async def delete_user(...)

# --- Configuração de Índices MongoDB (Importante!) ---
# Esta função pode ser chamada uma vez na inicialização da aplicação
# ou você pode criar os índices manualmente no Atlas/Mongo Shell.
async def create_user_indexes(db: AsyncIOMotorDatabase):
    """Cria índices únicos para username e email se não existirem."""
    collection = db[USERS_COLLECTION]
    try:
        await collection.create_index("username", unique=True, name="username_unique_idx")
        await collection.create_index("email", unique=True, name="email_unique_idx")
        logging.info("Índices de usuário ('username', 'email') verificados/criados.")
    except Exception as e:
        logging.error(f"Erro ao criar índices de usuário: {e}")--- Fim de app/db/user_crud.py ---

--- Início de app/main.py (80 linhas) ---
# app/main.py

# Importações
import logging
from fastapi import FastAPI
from fastapi.concurrency import asynccontextmanager
from app.routers import tasks
from app.routers import auth
from app.db.mongodb_utils import connect_to_mongo, close_mongo_connection
from app.db.user_crud import create_user_indexes
from app.db.task_crud import create_task_indexes
from app.core.config import settings

# Configuração básica de logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Gerenciador de contexto de vida útil (eventos startup/shutdown)
# Docs: https://fastapi.tiangolo.com/advanced/events/#lifespan
@asynccontextmanager
async def lifespan(app: FastAPI):
    db_connection = await connect_to_mongo()
    if db_connection is None:
         logger.critical("Falha fatal ao conectar ao MongoDB na inicialização.")
         yield 
         return

    app.state.db = db_connection
    logger.info("Conectado ao MongoDB.")
    try:
        db_instance = app.state.db
        await create_user_indexes(db_instance)
        await create_task_indexes(db_instance) 
    except Exception as e:
        logger.error(f"Erro durante a criação de índices: {e}", exc_info=True)

    # Permite que a aplicação rode
    yield

    # Código de shutdown (executa ao parar a app)
    await close_mongo_connection()
    logger.info("Conexão com MongoDB fechada.")
    
# Instância FastAPI
app = FastAPI(
    title="SmartTask API",
    description="API RESTful para gerenciamento de tarefas com prioridade inteligente.",
    version="0.1.0",
    contact={
        "name": "Eng. Soft. Cláudio",
        "url": "https://www.linkedin.com/in/claudiodelimatosta/", 
        "email": "claudiodelimatosta@gmail.com", 
    },
    license_info={
        "name": "MIT License",
        "url": "https://opensource.org/licenses/MIT",
    },
    lifespan=lifespan
)

# Inclusões
app.include_router(auth.router, prefix=f"{settings.API_V1_STR}/auth")
app.include_router(tasks.router, prefix=settings.API_V1_STR)


# Endpoint Raiz
@app.get("/", tags=["Root"]) 
async def read_root():
    return {"message": f"Bem-vindo à {settings.PROJECT_NAME}!"}

# Adicione aqui mais endpoints e lógica da aplicação futuramente...

# (Para rodar localmente com Uvicorn, você usará o comando no terminal,
#  mas esta seção é útil se você fosse rodar o script diretamente)
if __name__ == "__main__":
    import uvicorn
    # Roda a aplicação usando o Uvicorn
    # host="0.0.0.0" permite acesso de fora do container/máquina local
    reload=True # reinicia o servidor automaticamente ao salvar alterações 
    uvicorn.run("main:app", host="0.0.0.0", port=8000, reload=True)--- Fim de app/main.py ---

--- Início de app/models/task.py (98 linhas) ---
# app/models/task.py

from pydantic import BaseModel, Field
from typing import Optional, List 
from datetime import date, datetime, timezone
import uuid 
from enum import Enum
from pydantic import ConfigDict

class TaskStatus(str, Enum):
    PENDING = "pendente"
    IN_PROGRESS = "em_progresso"
    COMPLETED = "concluída"
    CANCELLED = "cancelada"

# Modelo base para os campos comuns de uma tarefa
class TaskBase(BaseModel):
    title: str = Field(..., title="Título da Tarefa", min_length=3, max_length=100)
    description: Optional[str] = Field(None, title="Descrição Detalhada", max_length=500)
    importance: int = Field(..., ge=1, le=5, title="Importância (1-5)")
    due_date: Optional[date] = Field(None, title="Data de Vencimento")
    status: TaskStatus = Field(default=TaskStatus.PENDING, title="Status da Tarefa")
    tags: Optional[List[str]] = Field(None, title="Etiquetas/Tags")
    project: Optional[str] = Field(None, title="Projeto Associado")
    # owner_id: Optional[uuid.UUID] = Field(None, title="ID do Proprietário da Tarefa")
    model_config = {
        "json_schema_extra": {
            "examples": [
                {
                    "title": "Finalizar relatório mensal",
                    "description": "Compilar dados e escrever o relatório final.",
                    "importance": 4,
                    "due_date": "2024-08-15",
                    "status": "pendente",
                    "tags": ["relatorios", "financeiro"],
                    "project": "Relatórios Q3"
                    # owner_id não precisa estar no exemplo de criação base
                }
            ]
        }
    }

class TaskCreate(TaskBase):
    pass

class TaskUpdate(BaseModel):
    title: Optional[str] = Field(None, title="Título da Tarefa", min_length=3, max_length=100)
    description: Optional[str] = Field(None, title="Descrição Detalhada", max_length=500)
    importance: Optional[int] = Field(None, ge=1, le=5, title="Importância (1-5)")
    due_date: Optional[date] = Field(None, title="Data de Vencimento")
    status: Optional[TaskStatus] = Field(None, title="Status da Tarefa")
    tags: Optional[List[str]] = Field(None, title="Etiquetas/Tags")
    project: Optional[str] = Field(None, title="Projeto Associado")
    priority_score: Optional[float] = Field(None, title="Pontuação de Prioridade (para ajustes manuais, talvez?)")

    model_config = {
         "json_schema_extra": {
            "examples": [
                {
                    "title": "Revisar relatório mensal v2",
                    "status": TaskStatus.IN_PROGRESS,
                    "importance": 5
                }
            ]
        }
    }


class TaskInDBBase(TaskBase):
    id: uuid.UUID = Field(..., title="ID Único da Tarefa")
    owner_id: uuid.UUID = Field(..., title="ID do Proprietário da Tarefa")
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc), title="Data de Criação")
    updated_at: Optional[datetime] = Field(None, title="Data da Última Atualização")
    priority_score: Optional[float] = Field(None, title="Pontuação de Prioridade Calculada") 
    model_config = ConfigDict(from_attributes=True)

class Task(TaskInDBBase):
    model_config = ConfigDict(
         from_attributes=True, 
         json_schema_extra={ 
             "examples": [
                {
                    "id": "f47ac10b-58cc-4372-a567-0e02b2c3d479",
                    "owner_id": "a1b2c3d4-e5f6-7890-1234-567890abcdef", 
                    "title": "Finalizar relatório mensal",
                    "description": "Compilar dados e escrever o relatório final.",
                    "importance": 4,
                    "due_date": "2024-08-15",
                    "status": "pendente",
                    "tags": ["relatorios", "financeiro"],
                    "project": "Relatórios Q3",
                    "created_at": "2024-07-28T10:00:00Z",
                    "updated_at": None,
                    "priority_score": None 
                }
            ]
         }
     )--- Fim de app/models/task.py ---

--- Início de app/models/token.py (15 linhas) ---
# app/models/token.py
from pydantic import BaseModel, Field
from typing import Optional
import uuid

class Token(BaseModel):
    """Modelo para a resposta do token JWT."""
    access_token: str = Field(..., title="Token de Acesso JWT")
    token_type: str = Field(default="bearer", title="Tipo do Token")

class TokenPayload(BaseModel):
    """Modelo para os dados contidos no payload do JWT."""
    sub: uuid.UUID = Field(..., title="ID do Usuário (Subject)")
    username: str = Field(..., title="Nome de Usuário")
    exp: Optional[int] = Field(None, title="Timestamp de Expiração")
--- Fim de app/models/token.py ---

--- Início de app/models/user.py (56 linhas) ---
# app/models/user.py
from pydantic import BaseModel, Field, EmailStr, ConfigDict
from typing import Optional
import uuid
from datetime import datetime, timezone

class UserBase(BaseModel):
    """Campos base para um usuário."""
    email: EmailStr = Field(..., title="Endereço de E-mail", description="Deve ser um e-mail válido e único.")
    username: str = Field(..., title="Nome de Usuário", min_length=3, max_length=50, pattern="^[a-zA-Z0-9_]+$", description="Nome de usuário único (letras, números, underscore).")
    full_name: Optional[str] = Field(None, title="Nome Completo", max_length=100)
    disabled: bool = Field(default=False, title="Status Desativado", description="Indica se o usuário está desativado.")

class UserCreate(BaseModel):
    """Campos necessários para criar um novo usuário (recebido pela API)."""
    email: EmailStr = Field(..., title="Endereço de E-mail")
    username: str = Field(..., title="Nome de Usuário", min_length=3, max_length=50, pattern="^[a-zA-Z0-9_]+$")
    password: str = Field(..., title="Senha", min_length=8, description="Senha (será hasheada antes de salvar).")
    full_name: Optional[str] = Field(None, title="Nome Completo", max_length=100)

    model_config = {
        "json_schema_extra": {
            "examples": [
                {
                    "email": "userTest@example.com",
                    "username": "userTest",
                    "password": "averysecurepassword",
                    "full_name": "User Test"
                }
            ]
        }
    }

class UserUpdate(BaseModel):
    """Campos que podem ser atualizados para um usuário."""
    email: Optional[EmailStr] = Field(None, title="Endereço de E-mail")
    full_name: Optional[str] = Field(None, title="Nome Completo", max_length=100)
    disabled: Optional[bool] = Field(None, title="Status Desativado")

class UserInDBBase(UserBase):
    """Modelo de usuário como armazenado no banco, incluindo ID e senha hasheada."""
    id: uuid.UUID = Field(..., title="ID Único do Usuário")
    hashed_password: str = Field(..., title="Senha Hasheada")
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc), title="Data de Criação")
    updated_at: Optional[datetime] = Field(None, title="Data da Última Atualização")
    model_config = ConfigDict(from_attributes=True)

class User(UserBase):
    """Modelo de usuário para respostas da API (sem senha)."""
    id: uuid.UUID = Field(..., title="ID Único do Usuário")
    created_at: datetime
    updated_at: Optional[datetime] = None
    model_config = ConfigDict(from_attributes=True)

class UserInDB(UserInDBBase):
   pass--- Fim de app/models/user.py ---

--- Início de app/routers/auth.py (118 linhas) ---
# app/routers/auth.py
from fastapi import APIRouter, Depends, HTTPException, status, Body
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from motor.motor_asyncio import AsyncIOMotorDatabase
from pymongo.errors import DuplicateKeyError
from typing import Annotated
from app.db.mongodb_utils import get_database
from app.db import user_crud 
from app.models.user import User, UserCreate
from app.models.token import Token
from app.core.dependencies import CurrentUser 
from app.core.security import verify_password, create_access_token

router = APIRouter(
    tags=["Authentication"],
)

DbDep = Annotated[AsyncIOMotorDatabase, Depends(get_database)]

@router.post(
    "/register",
    response_model=User, 
    status_code=status.HTTP_201_CREATED,
    summary="Registra um novo usuário",
    response_description="O usuário recém-registrado.",
)
async def register_user(
    db: DbDep,
    user_in: Annotated[UserCreate, Body(description="Dados do novo usuário")]):
    """
    Registra um novo usuário no sistema:
    - Verifica se o username ou email já existem.
    - Hasheia a senha.
    - Salva o usuário no banco de dados.
    - Retorna os dados do usuário criado (sem a senha).
    """
    existing_user = await user_crud.get_user_by_username(db, user_in.username)
    if existing_user:
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=f"Usuário '{user_in.username}' já existe.",
        )
    existing_email = await user_crud.get_user_by_email(db, user_in.email)
    if existing_email:
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=f"E-mail '{user_in.email}' já registrado.",
        )

    try:
        created_user_db = await user_crud.create_user(db=db, user_in=user_in)
        if created_user_db is None:
            raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                                detail="Não foi possível criar o usuário.")
        return User.model_validate(created_user_db)
    except DuplicateKeyError:
         raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail="Usuário ou e-mail já registrado (conflito de índice único).",
         )
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                            detail="Ocorreu um erro inesperado durante o registro.")


@router.post(
    "/login/access-token",
    response_model=Token,
    summary="Obtém um token de acesso JWT",
    description="Autentica o usuário com username e senha (form data) e retorna um token JWT.",
)
async def login_for_access_token(
    db: DbDep,
    form_data: Annotated[OAuth2PasswordRequestForm, Depends()]
):
    """
    Endpoint de login padrão OAuth2:
    - Recebe `username` e `password` via form-data.
    - Busca o usuário pelo username.
    - Verifica se o usuário existe e se a senha está correta.
    - Verifica se o usuário não está desativado.
    - Cria e retorna um token de acesso JWT.
    """
    user = await user_crud.get_user_by_username(db, form_data.username)

    if not user or not verify_password(form_data.password, user.hashed_password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Usuário ou senha incorretos.",
            headers={"WWW-Authenticate": "Bearer"},
        )
    if user.disabled:
         raise HTTPException(
             status_code=status.HTTP_400_BAD_REQUEST,
             detail="Usuário inativo."
         )

    access_token = create_access_token(
        subject=user.id,
        username=user.username
        )

    return Token(access_token=access_token, token_type="bearer")

@router.get(
    "/users/me",
    response_model=User,
    summary="Obtém dados do usuário atual",
    description="Recupera os dados do usuário atualmente autenticado com base no token.",
    response_description="Dados do usuário autenticado.",
)
async def read_users_me(
    current_user: CurrentUser 
) -> User:
    """
    Retorna os dados do usuário associado ao token JWT válido fornecido.
    """
    return current_user--- Fim de app/routers/auth.py ---

--- Início de app/routers/tasks.py (324 linhas) ---
# app/routers/tasks.py

# --- Importações Essenciais ---
import logging
from typing import List, Optional, Annotated
import uuid
from datetime import date, datetime, timezone

# --- Imports do FastAPI ---
from fastapi import (
    APIRouter, HTTPException, Body, status, Depends, Response, Query,
    BackgroundTasks
)

# --- Imports do MongoDB/Motor ---
from motor.motor_asyncio import AsyncIOMotorDatabase
from pydantic import ValidationError 

# --- Imports da Nossa Aplicação ---
from app.core.email import send_urgent_task_notification
from app.models.task import Task, TaskCreate, TaskUpdate, TaskStatus
from app.db import task_crud
from app.db.mongodb_utils import get_database
from app.core.dependencies import CurrentUser
from app.models.user import UserInDB
from app.core.utils import calculate_priority_score, is_task_urgent, send_webhook_notification

# --- Instanciar Logger ---
logger = logging.getLogger(__name__)

# --- Configuração do Roteador ---
router = APIRouter(
    prefix="/tasks",
    tags=["Tasks"],
    responses={
        status.HTTP_404_NOT_FOUND: {"description": "Tarefa não encontrada"},
        status.HTTP_401_UNAUTHORIZED: {"description": "Não autorizado (Token inválido ou ausente)"},
        status.HTTP_403_FORBIDDEN: {"description": "Proibido (Usuário não tem permissão para este recurso)"}
    },
)

# --- Dependência de Banco de Dados (Simplificada) ---
DbDep = Annotated[AsyncIOMotorDatabase, Depends(get_database)]

# ==============================================================================
# --- ROTAS CRUD PROTEGIDAS PARA TAREFAS ---
# (Agora utilizando app.db.task_crud)
# ==============================================================================

@router.post(
    "/",
    response_model=Task,
    status_code=status.HTTP_201_CREATED,
    summary="Cria uma nova tarefa",
    description="Cria uma nova tarefa associada ao usuário autenticado. A prioridade e owner_id são definidos automaticamente.",
    response_description="A tarefa recém-criada com todos os seus detalhes.",
)
async def create_task(
    task_in: Annotated[TaskCreate, Body(description="Dados da nova tarefa a ser criada")],
    db: DbDep, 
    current_user: CurrentUser,
    background_tasks: BackgroundTasks
):
    """
    Endpoint para criar uma nova tarefa.

    - Recebe dados validados pelo modelo `TaskCreate`.
    - Calcula a `priority_score`.
    - Associa a tarefa ao `owner_id` do usuário logado.
    - Chama `task_crud.create_task` para salvar no MongoDB.
    - Envia notificações (webhook) em background se necessário.
    - Retorna a tarefa criada.
    """
    task_data = task_in.model_dump(exclude_unset=True)

    # --- Calcular Prioridade ---
    priority = calculate_priority_score(
        importance=task_in.importance,
        due_date=task_in.due_date
    )

    # --- Criar o objeto Tarefa completo ---
    try:
        task_db_obj = Task(
            id=uuid.uuid4(),
            owner_id=current_user.id,
            created_at=datetime.now(timezone.utc),
            priority_score=priority,
            **task_data
        )
    except ValidationError as e:
         logger.error(f"Erro de validação Pydantic ao montar Task para criação: {e}")
         raise HTTPException(
             status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
             detail=f"Erro interno na validação dos dados da tarefa: {e}"
         )

    # --- Inserir no Banco de Dados via CRUD ---
    created_task = await task_crud.create_task(db=db, task_db=task_db_obj)

    if created_task is None:
         logger.error(f"Falha ao criar tarefa no banco de dados para usuário {current_user.id}.")
         raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                            detail="Falha ao salvar a tarefa no banco de dados.")

    # --- Disparar Tarefas em Background ---
    task_dict_for_webhook = created_task.model_dump(mode="json")
    background_tasks.add_task(
         send_webhook_notification,
         event_type="task.created",
         task_data=task_dict_for_webhook
    )
    logger.info(f"Tarefa de webhook 'task.created' para {created_task.id} adicionada ao background.")

    if is_task_urgent(created_task):
        if current_user.email and current_user.full_name:
            logger.info(f"Tarefa {created_task.id} é urgente, agendando email imediato para {current_user.email}")
            background_tasks.add_task(
                send_urgent_task_notification,
                user_email=current_user.email,
                user_name=current_user.full_name,
                task_title=created_task.title,
                task_id=str(created_task.id),
                task_due_date=str(created_task.due_date) if created_task.due_date else None,
                priority_score=created_task.priority_score or 0.0
            )
        else:
             logger.warning(f"Usuário {current_user.id} sem e-mail/nome para notificação IMEDIATA da tarefa urgente {created_task.id}.")

    return created_task


@router.get(
    "/",
    response_model=List[Task],
    summary="Lista as tarefas do usuário autenticado",
    description="""Recupera uma lista de tarefas pertencentes ao usuário autenticado.
    Permite filtros por status, prazo (até uma data), projeto e tags (contendo todas).
    Permite ordenação por 'priority_score', 'due_date', 'created_at' ou 'importance'.""",
    response_description="Uma lista (possivelmente vazia) contendo as tarefas filtradas e ordenadas do usuário.",
)
async def list_tasks(
    db: DbDep, 
    current_user: CurrentUser,
    # --- Parâmetros de Filtro ---
    status_filter: Annotated[Optional[TaskStatus], Query(alias="status")] = None,
    due_before: Annotated[Optional[date], Query()] = None,
    project_filter: Annotated[Optional[str], Query(alias="project", min_length=1)] = None,
    tags_filter: Annotated[Optional[List[str]], Query(alias="tag", min_length=1)] = None,
    # --- Parâmetros de Ordenação ---
    sort_by: Annotated[Optional[str], Query(enum=["priority_score", "due_date", "created_at", "importance"])] = None,
    sort_order: Annotated[Optional[str], Query(enum=["asc", "desc"])] = "desc",
    # --- Parâmetros de Paginação ---
    limit: Annotated[int, Query(ge=1, le=1000)] = 100,
    skip: Annotated[int, Query(ge=0)] = 0,
):
    """
    Endpoint para listar tarefas do usuário autenticado com filtros, ordenação e paginação.
    Delega a busca para `task_crud.get_tasks_by_owner`.
    """
    # --- Chamar a função CRUD para buscar as tarefas ---
    tasks = await task_crud.get_tasks_by_owner(
        db=db,
        owner_id=current_user.id,
        status_filter=status_filter,
        due_before=due_before,
        project_filter=project_filter,
        tags_filter=tags_filter,
        sort_by=sort_by,
        sort_order=sort_order or "desc", 
        limit=limit,
        skip=skip
    )

    return tasks


@router.get(
    "/{task_id}",
    response_model=Task,
    summary="Busca uma tarefa específica por ID",
    description="Recupera os detalhes de uma tarefa específica, **se** ela pertencer ao usuário autenticado.",
    response_description="Os detalhes completos da tarefa encontrada.",
    responses={status.HTTP_403_FORBIDDEN: {"description": "Acesso negado a esta tarefa"}}
)
async def get_task(
    task_id: uuid.UUID,
    db: DbDep, 
    current_user: CurrentUser
):
    """
    Endpoint para buscar uma única tarefa pelo seu ID (UUID).
    Delega a busca para `task_crud.get_task_by_id`, que já inclui a verificação do owner.
    """
    # --- Buscar a tarefa via CRUD ---
    task = await task_crud.get_task_by_id(db=db, task_id=task_id, owner_id=current_user.id)

    if task is None:
        logger.warning(f"Tentativa de acesso à tarefa {task_id} falhou ou tarefa não encontrada para usuário {current_user.id}.")
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND,
                            detail=f"Tarefa com ID {task_id} não encontrada.")

    return task


@router.put(
    "/{task_id}",
    response_model=Task,
    summary="Atualiza uma tarefa existente",
    description="Atualiza os campos de uma tarefa existente, **se** ela pertencer ao usuário autenticado. A prioridade é recalculada se necessário.",
    response_description="Os detalhes completos da tarefa atualizada.",
    responses={status.HTTP_403_FORBIDDEN: {"description": "Acesso negado a esta tarefa"}}
)
async def update_task(
    task_id: uuid.UUID,
    task_update: Annotated[TaskUpdate, Body(description="Campos da tarefa a serem atualizados")],
    db: DbDep, 
    current_user: CurrentUser,
    background_tasks: BackgroundTasks
):
    """
    Endpoint para atualizar campos específicos de uma tarefa.

    - Busca a tarefa existente para obter os valores atuais (necessário para recalcular prioridade).
    - Recebe dados validados pelo modelo `TaskUpdate`.
    - Prepara dicionário `update_data` apenas com campos enviados.
    - Recalcula `priority_score` se `importance` ou `due_date` mudarem.
    - Adiciona `updated_at`.
    - Chama `task_crud.update_task` para salvar no MongoDB.
    - Envia webhook em background.
    - Retorna a tarefa completa e atualizada.
    """
    # --- Obter Tarefa Existente ---
    existing_task = await task_crud.get_task_by_id(db=db, task_id=task_id, owner_id=current_user.id)
    if not existing_task:
        logger.warning(f"Tentativa de atualizar tarefa {task_id} não encontrada para usuário {current_user.id}.")
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND,
                            detail=f"Tarefa {task_id} não encontrada ou não pertence a você.")

    # --- Preparar Dados para Atualização ---
    update_data_from_request = task_update.model_dump(exclude_unset=True)

    if not update_data_from_request:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST,
                            detail="Nenhum campo válido fornecido para atualização.")

    # --- Recalcular Prioridade (se necessário) ---
    should_recalculate_priority = False
    new_importance = update_data_from_request.get("importance", existing_task.importance)
    new_due_date = update_data_from_request.get("due_date", existing_task.due_date) \
                    if "due_date" in update_data_from_request else existing_task.due_date

    # Verifica se os campos relevantes foram alterados
    if "importance" in update_data_from_request and update_data_from_request["importance"] != existing_task.importance:
        should_recalculate_priority = True
    if "due_date" in update_data_from_request and new_due_date != existing_task.due_date:
        should_recalculate_priority = True

    # Dicionário final a ser passado para o $set no CRUD
    update_data_for_db = update_data_from_request.copy()

    if should_recalculate_priority:
         new_priority = calculate_priority_score(
            importance=new_importance,
            due_date=new_due_date
         )
         update_data_for_db["priority_score"] = new_priority
         logger.info(f"Recalculada prioridade para tarefa {task_id} para: {new_priority}")

    # --- Executar Atualização via CRUD ---
    updated_task = await task_crud.update_task(
        db=db,
        task_id=task_id,
        owner_id=current_user.id,
        update_data=update_data_for_db 
    )

    if updated_task is None:
         logger.error(f"Falha ao atualizar tarefa {task_id} no banco de dados para usuário {current_user.id}.")
         raise HTTPException(status_code=status.HTTP_404_NOT_FOUND,
                            detail=f"Não foi possível atualizar a tarefa {task_id} (pode ter sido deletada).")

    # --- Disparar Tarefas em Background ---
    task_dict_for_webhook = updated_task.model_dump(mode="json")
    background_tasks.add_task(
        send_webhook_notification,
        event_type="task.updated",
        task_data=task_dict_for_webhook
    )
    logger.info(f"Tarefa de webhook 'task.updated' para {updated_task.id} adicionada ao background.")

    return updated_task


@router.delete(
    "/{task_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Deleta uma tarefa",
    description="Remove permanentemente uma tarefa do banco de dados, **se** ela pertencer ao usuário autenticado.",
    responses={
        status.HTTP_404_NOT_FOUND: {"description": "Tarefa não encontrada ou não pertence a você"},
        status.HTTP_403_FORBIDDEN: {"description": "Acesso negado a esta tarefa"},
        status.HTTP_204_NO_CONTENT: {"description": "Tarefa deletada com sucesso (sem corpo de resposta)"},
    }
)
async def delete_task(
    task_id: uuid.UUID,
    db: DbDep, 
    current_user: CurrentUser
):
    """
    Endpoint para deletar uma tarefa.
    Delega a deleção para `task_crud.delete_task`.
    """
    # --- Tentar deletar via CRUD ---
    deleted = await task_crud.delete_task(db=db, task_id=task_id, owner_id=current_user.id)

    if not deleted:
         # Função CRUD retorna False se delete_one não deletou nada (count 0)
         logger.warning(f"Tentativa de deletar tarefa {task_id} não encontrada para usuário {current_user.id}.")
         raise HTTPException(status_code=status.HTTP_404_NOT_FOUND,
                            detail=f"Tarefa com ID {task_id} não encontrada ou não pertence a você.")

    return Response(status_code=status.HTTP_204_NO_CONTENT)--- Fim de app/routers/tasks.py ---

--- Início de app/worker.py (133 linhas) ---
# app/worker.py
import asyncio
import logging
from datetime import date, datetime
from typing import Dict, Any, Optional
from motor.motor_asyncio import AsyncIOMotorDatabase 
from arq import cron
from arq.connections import RedisSettings
from redis.asyncio import Redis
from app.core.config import settings
from app.db.mongodb_utils import connect_to_mongo, close_mongo_connection, get_database 
from app.db import user_crud, task_crud 
from app.core.email import send_urgent_task_notification
from app.core.utils import is_task_urgent
from app.models.task import Task, TaskStatus 

logger = logging.getLogger("arq.worker")

# === FUNÇÃO DA TAREFA PERIÓDICA ===
# Será chamada pelo scheduler do ARQ
async def check_and_notify_urgent_tasks(ctx: Dict[str, Any]):
    """
    Tarefa periódica que busca tarefas urgentes e notifica os usuários.
    'ctx' é um dicionário passado pelo worker ARQ, contém recursos como conexão DB.
    """
    logger.info("Executando verificação de tarefas urgentes...")
    db: Optional[AsyncIOMotorDatabase] = ctx.get("db")

    if db is None:
         logger.error("Conexão com o banco de dados não disponível no contexto ARQ.")
         return

    tasks_collection = db[task_crud.TASKS_COLLECTION] 
    users_collection = db[user_crud.USERS_COLLECTION] 

    # --- Critérios de Busca no MongoDB ---
    # 1. Tarefas não concluídas ou canceladas
    # 2. Com priority_score > threshold OU com due_date <= hoje
    today_start = datetime.combine(date.today(), datetime.min.time()) 

    query = {
        "status": {"$nin": [TaskStatus.COMPLETED.value, TaskStatus.CANCELLED.value]},
        "$or": [
            {"priority_score": {"$gt": settings.EMAIL_URGENCY_THRESHOLD}},
            {"due_date": {"$lte": today_start}} 
        ]
    }

    urgent_tasks_cursor = tasks_collection.find(query)
    count = 0

    async for task_dict in urgent_tasks_cursor:
        task_dict.pop('_id', None)
        try:
             task = Task.model_validate(task_dict) 

             user = await user_crud.get_user_by_id(db, task.owner_id)

             if user and user.email and user.full_name and not user.disabled:
                logger.info(f"Tarefa urgente encontrada ({task.id}), notificando usuário {user.email}...")

                await send_urgent_task_notification(
                     user_email=user.email,
                     user_name=user.full_name,
                     task_title=task.title,
                     task_id=str(task.id),
                     task_due_date=str(task.due_date) if task.due_date else None,
                     priority_score=task.priority_score or 0.0
                 )
                count += 1
             elif not user:
                logger.warning(f"Usuário {task.owner_id} da tarefa urgente {task.id} não encontrado.")
             elif user and user.disabled:
                 logger.info(f"Usuário {user.username} da tarefa urgente {task.id} está desabilitado. Notificação não enviada.")
             else: 
                 logger.warning(f"Usuário {user.username} da tarefa urgente {task.id} sem e-mail ou nome completo. Notificação não enviada.")

        except Exception as e:
            logger.exception(f"Erro ao processar tarefa urgente {task_dict.get('id')}: {e}")
            continue 

    logger.info(f"Verificação de tarefas urgentes concluída. {count} notificações enviadas.")


# === CONFIGURAÇÕES DO WORKER ARQ ===
async def startup(ctx: Dict[str, Any]):
    """Função executada quando o worker ARQ inicia."""
    logger.info("Iniciando worker ARQ...")
    db_instance = await connect_to_mongo()
    if db_instance is not None:
         ctx["db"] = db_instance 
         logger.info("Conexão MongoDB estabelecida para o worker ARQ.")
    else:
         logger.error("Falha ao conectar ao MongoDB no startup do worker ARQ.")
         ctx["db"] = None


async def shutdown(ctx: Dict[str, Any]):
    """Função executada quando o worker ARQ termina."""
    logger.info("Encerrando worker ARQ...")
    if ctx.get("db")is not None:
        await close_mongo_connection() 
        logger.info("Conexão MongoDB fechada pelo worker ARQ.")

# Classe de configurações do worker para ARQ
# ARQ procurará por esta classe quando executarmos o worker
class WorkerSettings:
    on_startup = startup
    on_shutdown = shutdown

    # --- Consulta à lista de tarefas agendadas ---
    cron_jobs = [
        cron(check_and_notify_urgent_tasks, minute={*range(0, 60, 1)}, run_at_startup=True),
        cron(check_and_notify_urgent_tasks, hour=8, minute=0),
    ]

    # --- Configurações do Redis ---
    if settings.REDIS_URL:
        try:
             redis_settings: RedisSettings = RedisSettings(
                 host=settings.REDIS_URL.host or 'localhost', 
                 port=int(settings.REDIS_URL.port) if settings.REDIS_URL.port else 6379,
                 database=int(settings.REDIS_URL.path[1:]) if settings.REDIS_URL.path and settings.REDIS_URL.path != '/' else 0, 
                 password=settings.REDIS_URL.password, 
                 # conn_timeout=10,
                 # conn_retries=5,
                 # conn_retry_delay=1,
            )
        except Exception as e:
             logger.exception(f"Erro ao configurar RedisSettings a partir da URL: {settings.REDIS_URL} - Erro: {e}")
             raise ValueError(f"Erro ao processar REDIS_URL: {e}")
    else:
         raise ValueError("REDIS_URL não está definida nas configurações, worker ARQ não pode iniciar.")--- Fim de app/worker.py ---

--- Início de tests/conftest.py (150 linhas) ---
# tests/conftest.py
import uuid
import pytest
import pytest_asyncio
from typing import AsyncGenerator, Generator, Dict, List 
import asyncio
import logging
from httpx import AsyncClient, ASGITransport
from fastapi import status #
from app.main import app as fastapi_app
from app.core.config import settings
from app.db.mongodb_utils import connect_to_mongo, close_mongo_connection, get_database
from motor.motor_asyncio import AsyncIOMotorDatabase
from app.db.user_crud import USERS_COLLECTION
from app.db.task_crud import TASKS_COLLECTION
from app.models.task import TaskStatus 

logger = logging.getLogger(__name__)

# --- Cliente de Teste (Escopo Function) ---
@pytest_asyncio.fixture(scope="function")

async def test_async_client() -> AsyncGenerator[AsyncClient, None]:
    db = None 
    try:
        # -- Conexão e Limpeza Antes do Teste --
        await connect_to_mongo()
        db = get_database() 

        # --- Verificar db antes de usar ---
        if db is not None:
             if "test" not in settings.DATABASE_NAME.lower():
                  logger.warning(f"Rodando testes no banco '{settings.DATABASE_NAME}'. Coleções serão limpas!")

             logger.debug("Limpando coleções ANTES do teste...")
             await db[USERS_COLLECTION].delete_many({})
             await db[TASKS_COLLECTION].delete_many({})
             logger.debug("Coleções limpas ANTES do teste.")
        else:
            pytest.fail("Falha ao conectar ao MongoDB na fixture test_async_client (setup).")


        # -- Cria e fornece o cliente --
        transport = ASGITransport(app=fastapi_app)
        async with AsyncClient(transport=transport, base_url="http://testserver") as client:
            yield client 

    finally:
        # --- Código de limpeza no finally ---
        logger.debug("Executando limpeza pós-teste...")
        if db is not None: # Usa a variável 'db' do escopo da fixture
             try:
                 await db[USERS_COLLECTION].delete_many({})
                 await db[TASKS_COLLECTION].delete_many({})
                 logger.debug("Coleções limpas APÓS o teste.")
             except Exception as e:
                 # Loga o erro específico da limpeza, mas não falha o teste principal
                 logger.error(f"Erro ao limpar DB após teste: {e}", exc_info=True)
        else:
            logger.warning("Limpeza pós-teste pulada: Conexão com DB não estava estabelecida.")

# --- Fixtures para Usuário A ---
user_a_data = {
    "email": "testuserA@example.com",
    "username": "testuserA",
    "password": "passwordA",
    "full_name": "Test User A"
}

@pytest_asyncio.fixture(scope="function")

async def test_user_a_token_and_id(test_async_client: AsyncClient) -> tuple[str, uuid.UUID]: 
    """Registra/loga User A e retorna (token, user_id)."""
    register_url = f"{settings.API_V1_STR}/auth/register"
    login_url = f"{settings.API_V1_STR}/auth/login/access-token"
    users_me_url = f"{settings.API_V1_STR}/auth/users/me" 

    # Registrar
    reg_response = await test_async_client.post(register_url, json=user_a_data)
    if reg_response.status_code not in [status.HTTP_201_CREATED, status.HTTP_409_CONFLICT]:
        pytest.fail(f"Falha inesperada ao registrar User A: {reg_response.text}")

    # Logar para obter o token
    login_payload = {"username": user_a_data["username"], "password": user_a_data["password"]}
    login_response = await test_async_client.post(login_url, data=login_payload)
    if login_response.status_code != status.HTTP_200_OK:
         pytest.fail(f"Falha ao fazer login com User A: {login_response.text}")
    token = login_response.json()["access_token"]

    # Obter o ID do usuário via /users/me
    user_me_headers = {"Authorization": f"Bearer {token}"}
    user_me_response = await test_async_client.get(users_me_url, headers=user_me_headers)
    if user_me_response.status_code != status.HTTP_200_OK:
        pytest.fail(f"Falha ao obter dados de User A via /users/me: {user_me_response.text}")
    user_id_str = user_me_response.json()["id"]
    user_id = uuid.UUID(user_id_str) # Converte para UUID

    return token, user_id

@pytest.fixture(scope="function")

def auth_headers_a(test_user_a_token_and_id: tuple[str, uuid.UUID]) -> Dict[str, str]:
     """Retorna headers de autenticação com o token de teste do User A."""
     token, _ = test_user_a_token_and_id 
     return {"Authorization": f"Bearer {token}"}

# --- Fixtures para Usuário B ---
user_b_data = {
    "email": "testuserB@example.com",
    "username": "testuserB",
    "password": "passwordB",
    "full_name": "Test User B"
}

@pytest_asyncio.fixture(scope="function")
async def test_user_b_token(test_async_client: AsyncClient) -> str:
    register_url = f"{settings.API_V1_STR}/auth/register"
    login_url = f"{settings.API_V1_STR}/auth/login/access-token"
    reg_response = await test_async_client.post(register_url, json=user_b_data)
    if reg_response.status_code not in [status.HTTP_201_CREATED, status.HTTP_409_CONFLICT]:
         pytest.fail(f"Falha inesperada ao registrar User B: {reg_response.text}")

    login_payload = {"username": user_b_data["username"], "password": user_b_data["password"]}
    response = await test_async_client.post(login_url, data=login_payload)
    if response.status_code != status.HTTP_200_OK:
         pytest.fail(f"Falha ao fazer login com User B: {response.text}")
    return response.json()["access_token"]

@pytest.fixture(scope="function")
def auth_headers_b(test_user_b_token: str) -> Dict[str, str]:
     return {"Authorization": f"Bearer {test_user_b_token}"}

# Fixture de dados para testes de filtro/sort
@pytest_asyncio.fixture(scope="function")
async def create_filter_sort_tasks(test_async_client: AsyncClient, auth_headers_a: Dict[str, str]) -> List[Dict]:
    url = f"{settings.API_V1_STR}/tasks/"
    tasks_to_create = [
        {"title": "Filter Task P1 High", "importance": 5, "project": "Filtro", "status": TaskStatus.PENDING.value, "due_date": "2026-01-01", "tags": ["t1", "t2"]},
        {"title": "Filter Task P1 Low", "importance": 1, "project": "Filtro", "status": TaskStatus.PENDING.value, "due_date": "2026-02-01"},
        {"title": "Filter Task P2 Medium", "importance": 3, "project": "Outro", "status": TaskStatus.IN_PROGRESS.value, "tags": ["t2"]},
        {"title": "Filter Task P1 Medium", "importance": 3, "project": "Filtro", "status": TaskStatus.PENDING.value, "due_date": "2025-12-15", "tags": ["t3"]},
        {"title": "Filter Task P1 Done", "importance": 4, "project": "Filtro", "status": TaskStatus.COMPLETED.value},
    ]
    created_tasks = []
    for task_data in tasks_to_create:
        response = await test_async_client.post(url, json=task_data, headers=auth_headers_a)
        # --- Usando status importado ---
        assert response.status_code == status.HTTP_201_CREATED, f"Falha ao criar tarefa de teste: {task_data['title']}"
        created_tasks.append(response.json())
    return created_tasks--- Fim de tests/conftest.py ---

--- Início de tests/test_auth.py (233 linhas) ---
# tests/test_auth.py
import uuid
import pytest
from httpx import AsyncClient
from fastapi import status
from typing import Any, Dict
from app.core.config import settings 
from tests.conftest import user_a_data
from app.models.user import User


pytestmark = pytest.mark.asyncio

# ==============================
# --- Testes de Registro ---
# ==============================
async def test_register_user_success(
        test_async_client: AsyncClient
):
    """Testa registro de usuário bem-sucedido."""
    # Usa dados únicos para este teste específico
    new_user_data = {
        "email": "newuniqueuser@example.com",
        "username": "newuniqueuser",
        "password": "newpassword123",
        "full_name": "New Test User"
    }
    url = f"{settings.API_V1_STR}/auth/register"

    response = await test_async_client.post(url, json=new_user_data)

    assert response.status_code == status.HTTP_201_CREATED
    response_data = response.json()
    assert response_data["email"] == new_user_data["email"]
    assert response_data["username"] == new_user_data["username"]
    assert response_data["full_name"] == new_user_data["full_name"]
    assert "id" in response_data
    assert "hashed_password" not in response_data 

async def test_register_user_duplicate_username_case_insensitive(
    test_async_client: AsyncClient,
):
    """
    Testa o registro com um username que difere apenas em maiúsculas/minúsculas
    de um username existente. Como o desejado é ser case-sensitive, espera-se sucesso (201).
    """
    # 1. Registrar usuário inicial
    user_initial_data = {
        "email": "case@example.com",
        "username": "CaseTestUser", 
        "password": "password123",
    }
    url = f"{settings.API_V1_STR}/auth/register"
    response_initial = await test_async_client.post(url, json=user_initial_data)
    assert response_initial.status_code == status.HTTP_201_CREATED, \
        f"Falha ao registrar usuário inicial para teste case-insensitive: {response_initial.text}"

    # 2. Tentar registrar com o mesmo username, mas minúsculo
    user_duplicate_case_data = {
        "email": "case_different@example.com", 
        "username": "casetestuser",
        "password": "password123",
    }
    response_duplicate = await test_async_client.post(url, json=user_duplicate_case_data)

    # Assert: Verifica se o registro foi permitido (201), confirmando case-sensitivity.
    assert response_duplicate.status_code == status.HTTP_201_CREATED, \
        f"O registro deveria ter sido permitido (201), mas falhou com status {response_duplicate.status_code}. " \
        "Verificar se a lógica de validação de username inesperadamente se tornou case-insensitive."

async def test_register_user_duplicate_username(
    test_async_client: AsyncClient,
    test_user_a_token_and_id: tuple[str, uuid.UUID]
):
    """Testa registro com username duplicado."""
    attempt_data = {
        "email": "anotherunique@example.com",
        "username": user_a_data["username"], 
        "password": "anotherpassword",
    }
    url = f"{settings.API_V1_STR}/auth/register"

    response = await test_async_client.post(url, json=attempt_data)

    assert response.status_code == status.HTTP_409_CONFLICT
    assert "já existe" in response.json()["detail"]

async def test_register_user_duplicate_email(
    test_async_client: AsyncClient,
    test_user_a_token_and_id: tuple[str, uuid.UUID]
):
    """Testa registro com email duplicado."""
    attempt_data = {
        "email": user_a_data["email"],
        "username": "anotherunique_username",
        "password": "anotherpassword",
    }
    url = f"{settings.API_V1_STR}/auth/register"

    response = await test_async_client.post(url, json=attempt_data)

    assert response.status_code == status.HTTP_409_CONFLICT
    assert "já registrado" in response.json()["detail"]

# ==============================
# --- Testes de Validação ---
# ==============================
@pytest.mark.parametrize(
        "field, value, error_type, error_msg_part", [
            ("email", "não-é-um-email", "value_error", "valid email address"),
            ("username", "us", "string_too_short", "String should have at least 3 characters"),
            ("username", "user name com espaco", "string_pattern_mismatch", "match pattern"),
            ("password", "curta", "string_too_short", "String should have at least 8 characters"),
            ("email", None, "missing", "Field required"),
            ("username", None, "missing", "Field required"),
            ("password", None, "missing", "Field required"),
        ]
)

async def test_register_user_invalid_input(
    test_async_client: AsyncClient,
    field: str,
    value: Any,
    error_type: str,
    error_msg_part: str
):
    """Testa registro com dados inválidos específicos."""
    invalid_data = {
        "email": "valid@example.com",
        "username": "validusername",
        "password": "validpassword",
        "full_name": "Valid Name"
    }
    if value is None:
        if field in invalid_data:
           del invalid_data[field]
    else:
        invalid_data[field] = value

    url = f"{settings.API_V1_STR}/auth/register"
    response = await test_async_client.post(url, json=invalid_data)

    assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY
    error_details = response.json()["detail"]
    found_error = False
    for error in error_details:
        if field in error.get("loc", []) and error.get("type") == error_type:
             if error_msg_part in error.get("msg", ""):
                  found_error = True
                  break
    assert found_error, f"Erro esperado para campo '{field}' com tipo '{error_type}' e msg contendo '{error_msg_part}' não encontrado em {error_details}"

# =============================
# --- Testes de Login ---
# =============================
async def test_login_success(
    test_async_client: AsyncClient,
    test_user_a_token_and_id: tuple[str, uuid.UUID]
):
    """Testa login bem-sucedido do Usuário A."""
    login_data = {
        "username": user_a_data["username"],
        "password": user_a_data["password"]
    } # Usa dados do User A
    url = f"{settings.API_V1_STR}/auth/login/access-token"

    response = await test_async_client.post(url, data=login_data) # Form data

    assert response.status_code == status.HTTP_200_OK
    token_data = response.json()
    assert "access_token" in token_data
    assert token_data["token_type"] == "bearer"

async def test_login_wrong_password(
    test_async_client: AsyncClient,
    test_user_a_token_and_id: tuple[str, uuid.UUID]
):
    """Testa login com senha incorreta para o Usuário A."""
    login_data = {
        "username": user_a_data["username"],
        "password": "wrongpassword"
    } 
    url = f"{settings.API_V1_STR}/auth/login/access-token"

    response = await test_async_client.post(url, data=login_data)

    assert response.status_code == status.HTTP_401_UNAUTHORIZED
    assert "incorretos" in response.json()["detail"]

async def test_login_user_not_found(
        test_async_client: AsyncClient
):
    """Testa login com usuário inexistente."""
    login_data = {"username": "nonexistentuser", "password": "password"}
    url = f"{settings.API_V1_STR}/auth/login/access-token"

    response = await test_async_client.post(url, data=login_data)

    assert response.status_code == status.HTTP_401_UNAUTHORIZED 

# =============================
# --- Testes de User /me ---
# =============================

async def test_read_users_me_success(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str], 
    test_user_a_token_and_id: tuple[str, uuid.UUID] 
):
    """Testa obter dados do usuário logado com sucesso."""
    url = f"{settings.API_V1_STR}/auth/users/me"
    _, expected_user_id = test_user_a_token_and_id 

    response = await test_async_client.get(url, headers=auth_headers_a)

    assert response.status_code == status.HTTP_200_OK
    user_data = response.json()
    # Verifica se os campos esperados do modelo User (sem senha) estão presentes
    assert user_data["id"] == str(expected_user_id) 
    assert user_data["email"] == user_a_data["email"]
    assert user_data["username"] == user_a_data["username"]
    assert user_data["full_name"] == user_a_data["full_name"]
    assert "disabled" in user_data
    assert "hashed_password" not in user_data 
    assert "created_at" in user_data

async def test_read_users_me_unauthorized(test_async_client: AsyncClient):
    """Testa acessar /users/me sem autenticação."""
    url = f"{settings.API_V1_STR}/auth/users/me"
    response = await test_async_client.get(url)
    assert response.status_code == status.HTTP_401_UNAUTHORIZED
    assert "Not authenticated" in response.json()["detail"] 

--- Fim de tests/test_auth.py ---

--- Início de tests/test_core_config.py (97 linhas) ---
# tests/test_core_config.py
import pytest
import os
from pydantic import ValidationError
import importlib
from app.core.config import Settings

# =====================================================
#  --- Teste Principal ---
# =====================================================

def test_settings_mail_enabled_missing_credentials(monkeypatch):
    """Testa se a validação falha quando MAIL_ENABLED=True e faltam credenciais."""
    # 1. Limpar variáveis de email pré-existentes
    monkeypatch.delenv("MAIL_ENABLED", raising=False)
    monkeypatch.delenv("MAIL_USERNAME", raising=False)
    monkeypatch.delenv("MAIL_PASSWORD", raising=False)
    monkeypatch.delenv("MAIL_FROM", raising=False)
    monkeypatch.delenv("MAIL_SERVER", raising=False)

    # 2. Definir variáveis obrigatórias não relacionadas a email
    monkeypatch.setenv("JWT_SECRET_KEY", "testsecret")
    monkeypatch.setenv("MONGODB_URL", "mongodb://test")

    # 3. Definir cenário: MAIL_ENABLED=True, mas falta USERNAME
    monkeypatch.setenv("MAIL_ENABLED", "True")
    # NÃO define MAIL_USERNAME
    monkeypatch.setenv("MAIL_PASSWORD", "password")
    monkeypatch.setenv("MAIL_FROM", "sender@example.com")
    monkeypatch.setenv("MAIL_SERVER", "smtp.test.com")

    # 4. Instanciar Settings e verificar a exceção
    with pytest.raises((ValueError, ValidationError)) as exc_info:
        Settings(_env_file=None)

    assert "MAIL_USERNAME, MAIL_PASSWORD, MAIL_FROM e MAIL_SERVER devem ser definidos" in str(exc_info.value)

def test_settings_mail_disabled_credentials_not_needed(monkeypatch):
    """Testa se a validação PASSA quando MAIL_ENABLED=False, mesmo sem credenciais."""
    # 1. Limpar variáveis de email
    monkeypatch.delenv("MAIL_ENABLED", raising=False)
    monkeypatch.delenv("MAIL_USERNAME", raising=False)
    monkeypatch.delenv("MAIL_PASSWORD", raising=False)
    monkeypatch.delenv("MAIL_FROM", raising=False)
    monkeypatch.delenv("MAIL_SERVER", raising=False)

    # 2. Definir variáveis obrigatórias não relacionadas a email
    monkeypatch.setenv("JWT_SECRET_KEY", "testsecret")
    monkeypatch.setenv("MONGODB_URL", "mongodb://test")
    # Defina outras se necessário

    # 3. Definir cenário: MAIL_ENABLED=False, outras ausentes
    monkeypatch.setenv("MAIL_ENABLED", "False")

    # 4. Instanciar Settings e verificar se NÃO levanta exceção
    try:
        settings_instance = Settings(_env_file=None)
        assert not settings_instance.MAIL_ENABLED
        # Verifica se os outros campos são None como esperado
        assert settings_instance.MAIL_USERNAME is None
        assert settings_instance.MAIL_PASSWORD is None
        assert settings_instance.MAIL_FROM is None
        assert settings_instance.MAIL_SERVER is None
    except (ValueError, ValidationError) as e:
        pytest.fail(f"Validação de Settings falhou inesperadamente com MAIL_ENABLED=False: {e}")

# =====================================================
#  --- Teste Secundário ---
# =====================================================

def test_settings_mail_enabled_all_credentials_ok(monkeypatch):
    """Testa se a validação PASSA quando MAIL_ENABLED=True e TUDO está definido."""
    # 1. Limpar
    monkeypatch.delenv("MAIL_ENABLED", raising=False)
    monkeypatch.delenv("MAIL_USERNAME", raising=False)
    monkeypatch.delenv("MAIL_PASSWORD", raising=False)
    monkeypatch.delenv("MAIL_FROM", raising=False)
    monkeypatch.delenv("MAIL_SERVER", raising=False)

    # 2. Definir obrigatórias
    monkeypatch.setenv("JWT_SECRET_KEY", "testsecret")
    monkeypatch.setenv("MONGODB_URL", "mongodb://test")

    # 3. Definir tudo para email
    monkeypatch.setenv("MAIL_ENABLED", "True")
    monkeypatch.setenv("MAIL_USERNAME", "testuser")
    monkeypatch.setenv("MAIL_PASSWORD", "testpass")
    monkeypatch.setenv("MAIL_FROM", "test@example.com")
    monkeypatch.setenv("MAIL_SERVER", "mail.example.com")

    # 4. Verificar se NÃO levanta exceção
    try:
        settings_instance = Settings(_env_file=None)
        assert settings_instance.MAIL_ENABLED
        assert settings_instance.MAIL_USERNAME == "testuser"
    except (ValueError, ValidationError) as e:
        pytest.fail(f"Validação de Settings falhou inesperadamente com todas as credenciais: {e}")--- Fim de tests/test_core_config.py ---

--- Início de tests/test_core_dependencies.py (109 linhas) ---
# tests/test_core_dependencies.py
import pytest
import uuid
from fastapi import HTTPException, status
from unittest.mock import AsyncMock, MagicMock, patch
from app.core.dependencies import get_current_user, get_current_active_user, oauth2_scheme
from app.db import user_crud 
from app.models.user import UserInDB 
from app.models.token import TokenPayload
from datetime import datetime, timezone

pytestmark = pytest.mark.asyncio

# Mock para o DB Dependency (DbDep)
@pytest.fixture
def mock_db():
    return AsyncMock()

# Mock para o Token Dependency (TokenDep)
@pytest.fixture
def mock_valid_token_str():
    return "valid.test.token"

# ===================================================
# --- Testes para get_current_user ---
# ===================================================

async def test_get_current_user_success(mock_db, mock_valid_token_str):
    """Testa get_current_user com token e usuário válidos."""
    test_user_id = uuid.uuid4()
    test_username = "testuser"
    test_user = UserInDB(
        id=test_user_id,
        username=test_username,
        email="test@example.com",
        hashed_password="xxx",
        disabled=False,
        created_at=datetime.now(timezone.utc)
    )
    test_payload = TokenPayload(sub=test_user_id, username=test_username)

    # Mockar decode_token para retornar payload válido
    with patch("app.core.dependencies.decode_token", return_value=test_payload) as mock_decode:
        # Mockar get_user_by_id para retornar o usuário
        with patch("app.core.dependencies.user_crud.get_user_by_id", return_value=test_user) as mock_get_id:
            # Chama a dependência 
            user = await get_current_user(db=mock_db, token=mock_valid_token_str)

            mock_decode.assert_called_once_with(mock_valid_token_str)
            mock_get_id.assert_awaited_once_with(db=mock_db, user_id=test_user_id)
            assert user == test_user

async def test_get_current_user_invalid_token(mock_db, mock_valid_token_str):
    """Testa get_current_user quando decode_token falha (token inválido/expirado)."""
    # Mockar decode_token para retornar None
    with patch("app.core.dependencies.decode_token", return_value=None):
        with pytest.raises(HTTPException) as exc_info:
            await get_current_user(db=mock_db, token=mock_valid_token_str)
        assert exc_info.value.status_code == status.HTTP_401_UNAUTHORIZED
        assert "Não foi possível validar as credenciais" in exc_info.value.detail

async def test_get_current_user_user_not_found(mock_db, mock_valid_token_str):
    """Testa get_current_user quando o usuário do token não existe no DB."""
    test_user_id = uuid.uuid4()
    test_payload = TokenPayload(sub=test_user_id, username="ghost")

    # Mock decode_token para retornar payload válido
    with patch("app.core.dependencies.decode_token", return_value=test_payload):
         # Mock get_user_by_id para retornar None
        with patch("app.core.dependencies.user_crud.get_user_by_id", return_value=None) as mock_get_id:
            with pytest.raises(HTTPException) as exc_info:
                await get_current_user(db=mock_db, token=mock_valid_token_str)
            assert exc_info.value.status_code == status.HTTP_401_UNAUTHORIZED
            assert "Não foi possível validar as credenciais" in exc_info.value.detail
            mock_get_id.assert_awaited_once_with(db=mock_db, user_id=test_user_id)

# ===================================================
# --- Testes para get_current_active_user ---
# ===================================================

async def test_get_current_active_user_disabled():
    """Testa get_current_active_user com um usuário desativado."""
    disabled_user = UserInDB(
        id=uuid.uuid4(),
        username="inactive",
        email="inactive@x.com",
        hashed_password="...",
        disabled=True,
        created_at=datetime.now(timezone.utc)
    )
    # Chama a função diretamente, passando o usuário desativado
    with pytest.raises(HTTPException) as exc_info:
        await get_current_active_user(current_user=disabled_user) 
    assert exc_info.value.status_code == status.HTTP_400_BAD_REQUEST
    assert "Usuário inativo" in exc_info.value.detail

async def test_get_current_active_user_active():
    """Testa get_current_active_user com um usuário ativo."""
    active_user = UserInDB(
        id=uuid.uuid4(),
        username="active",
        email="active@x.com",
        hashed_password="...",
        disabled=False,
        created_at=datetime.now(timezone.utc)
    )
    # Chama a função e verifica se retorna o mesmo usuário
    user = await get_current_active_user(current_user=active_user)
    assert user == active_user--- Fim de tests/test_core_dependencies.py ---

--- Início de tests/test_core_email.py (235 linhas) ---
# tests/test_core_email.py

import uuid
import pytest
import logging 
from unittest.mock import AsyncMock, patch, ANY 
from pydantic import EmailStr
from fastapi_mail import MessageType, MessageSchema
from app.core.email import send_email_async, send_urgent_task_notification, conf
from app.core.config import settings

pytestmark = pytest.mark.asyncio

#  =================================================
# --- Testes de Guarda ---
#  =================================================

async def test_send_email_async_mail_disabled(mocker, caplog):
    """Testa que nenhum email é enviado se MAIL_ENABLED=False."""
    mock_fm_send = mocker.patch("app.core.email.fm.send_message", new_callable=AsyncMock)
    mocker.patch.object(settings, 'MAIL_ENABLED', False)

    await send_email_async(
        subject="Teste Desabilitado",
        recipient_to=["test@example.com"],
        body={"info": "Teste"},
        template_name="dummy_template.html"
    )

    mock_fm_send.assert_not_called()
    assert "Envio de e-mail desabilitado" in caplog.text

async def test_send_email_async_missing_credentials(mocker):
    """Testa que nenhum email é enviado e erro é logado se faltarem credenciais."""
    mock_fm_send = mocker.patch("app.core.email.fm.send_message", new_callable=AsyncMock)
    mocker.patch.object(settings, 'MAIL_ENABLED', True)
    for missing_field in ['MAIL_USERNAME', 'MAIL_PASSWORD', 'MAIL_FROM', 'MAIL_SERVER']:
        mocker.patch.object(settings, 'MAIL_USERNAME', 'user')
        mocker.patch.object(settings, 'MAIL_PASSWORD', 'pass')
        mocker.patch.object(settings, 'MAIL_FROM', 'from@example.com')
        mocker.patch.object(settings, 'MAIL_SERVER', 'server')
        mocker.patch.object(settings, missing_field, None)

        mock_logger = mocker.patch("app.core.email.logger")
        mock_fm_send.reset_mock()
        mock_logger.reset_mock() 

        await send_email_async(
            subject="Teste Credenciais",
            recipient_to=["test@example.com"],
            body={"info": "Teste"}
        )

        mock_fm_send.assert_not_called()
        mock_logger.error.assert_called_once()
        assert "Configurações essenciais de e-mail ausentes" in mock_logger.error.call_args[0][0]

#  =================================================
# --- Testes de Funcionalidade ---
#  =================================================

async def test_send_email_async_with_template_calls_fm(mocker):
    """Testa se send_email_async chama fm.send_message corretamente com template."""
    mock_fm_send = mocker.patch("app.core.email.fm.send_message", new_callable=AsyncMock)
    mocker.patch.object(settings, 'MAIL_ENABLED', True)
    mocker.patch.object(settings, 'MAIL_USERNAME', 'user')
    mocker.patch.object(settings, 'MAIL_PASSWORD', 'pass')
    mocker.patch.object(settings, 'MAIL_FROM', 'sender@example.com')
    mocker.patch.object(settings, 'MAIL_SERVER', 'smtp.example.com')
    mock_logger_info = mocker.patch("app.core.email.logger.info")

    test_subject = "Assunto Template"
    test_recipient = "recipient@example.com"
    test_body_dict = {"key": "value"}
    test_template = "template.html"

    await send_email_async(
        subject=test_subject,
        recipient_to=[test_recipient],
        body=test_body_dict,
        template_name=test_template
    )

    mock_fm_send.assert_called_once()
    message_arg: MessageSchema = mock_fm_send.call_args[0][0] 
    template_arg = mock_fm_send.call_args.kwargs.get('template_name')

    assert isinstance(message_arg, MessageSchema)
    assert message_arg.subject == test_subject
    assert message_arg.recipients == [test_recipient]
    assert message_arg.template_body == test_body_dict
    assert message_arg.body is None
    assert message_arg.subtype == MessageType.html
    assert template_arg == test_template
    assert mock_logger_info.call_count >= 2 

async def test_send_email_async_plain_text_calls_fm(mocker):
    """Testa se send_email_async chama fm.send_message corretamente com texto puro."""
    mock_fm_send = mocker.patch("app.core.email.fm.send_message", new_callable=AsyncMock)
    mocker.patch.object(settings, 'MAIL_ENABLED', True)
    mocker.patch.object(settings, 'MAIL_USERNAME', 'user')
    mocker.patch.object(settings, 'MAIL_PASSWORD', 'pass')
    mocker.patch.object(settings, 'MAIL_FROM', 'sender@example.com')
    mocker.patch.object(settings, 'MAIL_SERVER', 'smtp.example.com')
    mock_logger_info = mocker.patch("app.core.email.logger.info")

    test_subject = "Assunto Plain"
    test_recipient = "plain@example.com"
    test_plain_body = "Corpo simples."

    await send_email_async(
        subject=test_subject,
        recipient_to=[test_recipient],
        body=None,
        plain_text_body=test_plain_body
    )

    mock_fm_send.assert_called_once()
    message_arg: MessageSchema = mock_fm_send.call_args[0][0]
    template_arg = mock_fm_send.call_args.kwargs.get('template_name')

    assert isinstance(message_arg, MessageSchema)
    assert message_arg.subject == test_subject
    assert message_arg.recipients == [test_recipient]
    assert message_arg.template_body is None
    assert message_arg.body == test_plain_body
    assert message_arg.subtype == MessageType.plain
    assert template_arg is None
    assert mock_logger_info.call_count >= 2

async def test_send_email_async_handles_send_exception(mocker):
    """Testa o tratamento de erro se fm.send_message levantar exceção."""
    error_message = "SMTP Error"
    mock_fm_send = mocker.patch(
        "app.core.email.fm.send_message",
        new_callable=AsyncMock,
        side_effect=Exception(error_message)
    )

    mocker.patch.object(settings, 'MAIL_ENABLED', True)
    mocker.patch.object(settings, 'MAIL_USERNAME', 'user')
    mocker.patch.object(settings, 'MAIL_PASSWORD', 'pass')
    mocker.patch.object(settings, 'MAIL_FROM', 'sender@example.com')
    mocker.patch.object(settings, 'MAIL_SERVER', 'smtp.example.com')

    mock_logger_exception = mocker.patch("app.core.email.logger.exception")

    test_recipient = ["fail@example.com"]
    await send_email_async(
        subject="Teste de Erro",
        recipient_to=test_recipient,
        body={"info": "teste"}
    )

    mock_fm_send.assert_called_once() 
    mock_logger_exception.assert_called_once() 
    log_message = mock_logger_exception.call_args[0][0] 
    assert f"Erro ao enviar e-mail para {test_recipient}" in log_message
    assert error_message in log_message

#  =================================================
# --- Testes Unitários ---
#  =================================================

from app.core import email as email_module

@pytest.fixture(autouse=True)
def patch_send_email_async(mocker):
    """Mocka automaticamente send_email_async para todos os testes desta seção."""
    return mocker.patch("app.core.email.send_email_async", new_callable=AsyncMock)


async def test_send_urgent_task_call_args(patch_send_email_async, mocker):
    """Verifica argumentos passados para send_email_async por send_urgent..."""
    test_frontend_url = "http://test.dev"
    mocker.patch.object(settings, 'FRONTEND_URL', test_frontend_url)

    email = "urgent@test.co"
    name = "Urgent Joe"
    title = "Fix Now!"
    task_id = str(uuid.uuid4())
    due_date = "2025-01-01"
    score = 123.456

    await email_module.send_urgent_task_notification(
        user_email=email,
        user_name=name,
        task_title=title,
        task_id=task_id,
        task_due_date=due_date,
        priority_score=score
    )

    patch_send_email_async.assert_called_once()
    call_args = patch_send_email_async.call_args.kwargs

    assert call_args["subject"] == f"🚨 Tarefa Urgente no SmartTask: {title}"
    assert call_args["recipient_to"] == [email]
    assert call_args["template_name"] == "urgent_task.html"
    assert call_args["plain_text_body"] is not None

    body = call_args["body"]
    assert body["task_title"] == title
    assert body["user_name"] == name
    assert body["due_date"] == due_date
    assert body["priority_score"] == f"{score:.2f}" 
    assert body["task_link"] == f"{test_frontend_url}/tasks/{task_id}"
    assert body["project_name"] == settings.PROJECT_NAME

async def test_send_urgent_task_call_args_no_due_no_link(patch_send_email_async, mocker):
    """Verifica argumentos quando não há due_date e FRONTEND_URL."""
    mocker.patch.object(settings, 'FRONTEND_URL', None) 

    email = "nodate@test.co"
    name = "No Date User"
    title = "No Link Task"
    task_id = str(uuid.uuid4())
    score = 500.0

    await email_module.send_urgent_task_notification(
        user_email=email,
        user_name=name,
        task_title=title,
        task_id=task_id,
        task_due_date=None, 
        priority_score=score
    )

    patch_send_email_async.assert_called_once()
    call_args = patch_send_email_async.call_args.kwargs
    assert call_args["recipient_to"] == [email]

    body = call_args["body"]
    assert body["due_date"] == "N/A" 
    assert body["task_link"] is None
--- Fim de tests/test_core_email.py ---

--- Início de tests/test_core_security.py (43 linhas) ---
# tests/test_core_security.py

import pytest
from app.core.security import verify_password, get_password_hash

# Usar uma senha fixa para os testes unitários
TEST_PASSWORD = "senha_super_segura_123"

def test_get_password_hash():
    """Testa se a função get_password_hash retorna uma string não vazia."""
    password_hash = get_password_hash(TEST_PASSWORD)
    assert isinstance(password_hash, str)
    assert len(password_hash) > 0
    assert password_hash != TEST_PASSWORD

def test_verify_password_correct():
    """Testa a verificação com a senha correta."""
    password_hash = get_password_hash(TEST_PASSWORD)
    assert verify_password(TEST_PASSWORD, password_hash) is True

def test_verify_password_incorrect():
    """Testa a verificação com uma senha incorreta."""
    password_hash = get_password_hash(TEST_PASSWORD)
    wrong_password = "senha_incorreta"
    assert verify_password(wrong_password, password_hash) is False

def test_verify_password_invalid_hash():
    """Testa a verificação com um formato de hash inválido."""
    invalid_hash_format = "nao_e_um_hash_bcrypt_valido"
    assert verify_password(TEST_PASSWORD, invalid_hash_format) is False

def test_verify_password_empty_password():
    """Testa a verificação com senha vazia (plain) contra um hash válido."""
    password_hash = get_password_hash(TEST_PASSWORD)
    assert verify_password("", password_hash) is False

def test_get_hash_different_for_same_password():
    """Testa se o hash gerado é diferente a cada vez (devido ao salt)."""
    hash1 = get_password_hash(TEST_PASSWORD)
    hash2 = get_password_hash(TEST_PASSWORD)
    assert hash1 != hash2
    assert verify_password(TEST_PASSWORD, hash1) is True
    assert verify_password(TEST_PASSWORD, hash2) is True--- Fim de tests/test_core_security.py ---

--- Início de tests/test_core_utils.py (136 linhas) ---
# tests/test_core_utils.py
import pytest
from datetime import date, datetime, timedelta, timezone
from freezegun import freeze_time 
from app.core.utils import calculate_priority_score, is_task_urgent
from app.models.task import Task, TaskStatus 
from app.core.config import settings 
import uuid 

# === Testes para calculate_priority_score ===

def test_calculate_priority_invalid_importance():
    """Testa que score é None se importância for inválida."""
    assert calculate_priority_score(importance=0, due_date=None) is None
    assert calculate_priority_score(importance=6, due_date=None) is None

@freeze_time("2025-05-04")
def test_calculate_priority_no_due_date():
    """Testa cálculo sem data de vencimento."""
    expected_score = settings.PRIORITY_DEFAULT_SCORE_NO_DUE_DATE + (3 * settings.PRIORITY_WEIGHT_IMPORTANCE)
    assert calculate_priority_score(importance=3, due_date=None) == round(expected_score, 2)

    expected_score_max = settings.PRIORITY_DEFAULT_SCORE_NO_DUE_DATE + (5 * settings.PRIORITY_WEIGHT_IMPORTANCE)
    assert calculate_priority_score(importance=5, due_date=None) == round(expected_score_max, 2)

@freeze_time("2025-05-04") 
def test_calculate_priority_due_today():
    """Testa cálculo com vencimento hoje."""
    today = date.today()
    expected_score = (settings.PRIORITY_WEIGHT_DUE_DATE / 1.0) + (4 * settings.PRIORITY_WEIGHT_IMPORTANCE)
    assert calculate_priority_score(importance=4, due_date=today) == round(expected_score, 2)

@freeze_time("2025-05-04")
def test_calculate_priority_due_future():
    """Testa cálculo com vencimento no futuro."""
    future_date = date.today() + timedelta(days=10)
    expected_score = (settings.PRIORITY_WEIGHT_DUE_DATE / 10.0) + (2 * settings.PRIORITY_WEIGHT_IMPORTANCE)
    assert calculate_priority_score(importance=2, due_date=future_date) == round(expected_score, 2)

@freeze_time("2025-05-04")
def test_calculate_priority_overdue():
    """Testa cálculo com tarefa atrasada."""
    past_date = date.today() - timedelta(days=5)
    expected_score = settings.PRIORITY_SCORE_IF_OVERDUE + (5 * settings.PRIORITY_WEIGHT_IMPORTANCE)
    assert calculate_priority_score(importance=5, due_date=past_date) == round(expected_score, 2)

# === Testes para is_task_urgent ===

def create_dummy_task(**kwargs) -> Task:
    base_data = {
        "id": uuid.uuid4(),
        "owner_id": uuid.uuid4(),
        "title": "Dummy Task",
        "importance": 3,
        "status": TaskStatus.PENDING,
        "created_at": datetime.now(timezone.utc), 
        "due_date": None,
        "priority_score": None,
    }
    task_data = {**base_data, **kwargs}

    if task_data.get("priority_score") is None and (task_data.get("importance") or task_data.get("due_date")):
         task_data["priority_score"] = calculate_priority_score(
             importance=task_data["importance"],
             due_date=task_data["due_date"]
         )

    return Task(**task_data)

def test_is_task_urgent_no_score_no_due_date():
    """Testa que tarefa sem score e sem prazo não é urgente."""
    task = create_dummy_task(priority_score=None, due_date=None)
    assert is_task_urgent(task) is False

@freeze_time("2025-05-04")
def test_is_task_urgent_high_score():
    """Testa que tarefa com score alto é urgente."""
    high_score = calculate_priority_score(importance=5, due_date=date(2025, 5, 1))
    assert high_score > settings.EMAIL_URGENCY_THRESHOLD
    task = create_dummy_task(priority_score=high_score)
    assert is_task_urgent(task) is True

@freeze_time("2025-05-04")
def test_is_task_urgent_score_below_threshold():
    """Testa que tarefa com score baixo (e não vencida) não é urgente."""
    low_score = settings.EMAIL_URGENCY_THRESHOLD - 10.0
    future_date = date(2025, 5, 10) 
    task = create_dummy_task(priority_score=low_score, due_date=future_date)
    assert task.priority_score < settings.EMAIL_URGENCY_THRESHOLD
    assert is_task_urgent(task) is False

@freeze_time("2025-05-04")
def test_is_task_urgent_due_today():
    """Testa que tarefa com vencimento hoje é urgente (mesmo com score baixo)."""
    low_score = settings.EMAIL_URGENCY_THRESHOLD - 10.0
    today = date.today()
    task = create_dummy_task(due_date=today, priority_score=low_score)
    assert is_task_urgent(task) is True

@freeze_time("2025-05-04")
def test_is_task_urgent_overdue():
    """Testa que tarefa atrasada é urgente (mesmo com score baixo inicial)."""
    low_score = settings.EMAIL_URGENCY_THRESHOLD - 10.0
    past_date = date.today() - timedelta(days=1)
    task = create_dummy_task(due_date=past_date, priority_score=low_score) 
    assert is_task_urgent(task) is True

@freeze_time("2025-05-04")
def test_is_task_urgent_due_future_low_score():
    """Testa que tarefa futura com score baixo não é urgente."""
    future_date = date.today() + timedelta(days=5)
    low_score = settings.EMAIL_URGENCY_THRESHOLD - 20.0
    task = create_dummy_task(due_date=future_date, priority_score=low_score)
    assert is_task_urgent(task) is False

# === Testes de Borda ===

@freeze_time("2025-05-04")
def test_is_task_urgent_score_exactly_at_threshold():
    """Testa que tarefa com score exatamente no limiar não é urgente (usa >)."""
    score_at_threshold = settings.EMAIL_URGENCY_THRESHOLD
    future_date = date.today() + timedelta(days=5) 
    task = create_dummy_task(priority_score=score_at_threshold, due_date=future_date)
    if task.priority_score != score_at_threshold:
        print(f"\nWARN: Score foi recalculado para {task.priority_score} em vez de {score_at_threshold}")
    assert is_task_urgent(task) is False, f"Falhou com score {task.priority_score}, esperado False"

@freeze_time("2025-05-04")
def test_is_task_urgent_score_slightly_above_threshold():
    """Testa que tarefa com score ligeiramente acima do limiar é urgente."""
    score_above_threshold = settings.EMAIL_URGENCY_THRESHOLD + 0.01
    future_date = date.today() + timedelta(days=5) 
    task = create_dummy_task(priority_score=score_above_threshold, due_date=future_date)
    if task.priority_score != score_above_threshold:
         print(f"\nWARN: Score foi recalculado para {task.priority_score} em vez de {score_above_threshold}")
    assert is_task_urgent(task) is True, f"Falhou com score {task.priority_score}, esperado True"--- Fim de tests/test_core_utils.py ---

--- Início de tests/test_core_utils_webhooks.py (148 linhas) ---
# tests/test_core_utils_webhooks.py

import pytest
import logging
import httpx
import respx 
import hmac
import hashlib
import json
from unittest.mock import AsyncMock, patch # Usaremos patch do unittest

from app.core.utils import send_webhook_notification
from app.core.config import settings

pytestmark = pytest.mark.asyncio

# Dados de teste para a tarefa
test_task_data = {
    "id": "f47ac10b-58cc-4372-a567-0e02b2c3d479",
    "owner_id": "a1b2c3d4-e5f6-7890-1234-567890abcdef",
    "title": "Webhook Test Task",
    "importance": 4,
    "status": "pendente",
}
test_event_type = "task.test_event"
test_webhook_url = "http://test-webhook.site/hook" 

@pytest.fixture(autouse=True)
def override_settings_for_webhook(monkeypatch):
    """Sobrescreve configurações de webhook APENAS para estes testes."""
    monkeypatch.setattr(settings, 'WEBHOOK_URL', test_webhook_url)
    monkeypatch.setattr(settings, 'WEBHOOK_SECRET', None)

# Usar respx para mockar as chamadas httpx
@respx.mock
async def test_send_webhook_no_secret(override_settings_for_webhook):
    """Testa o envio de webhook quando não há segredo configurado."""
    respx.post(test_webhook_url).mock(return_value=httpx.Response(200, json={"status": "ok"}))

    await send_webhook_notification(
        event_type=test_event_type,
        task_data=test_task_data
    )

    # Verifica se a chamada HTTP foi feita para a URL correta
    assert respx.calls.call_count == 1
    request = respx.calls.last.request
    assert str(request.url) == test_webhook_url

    # Verifica o payload JSON
    payload = json.loads(request.content)
    assert payload["event"] == test_event_type
    assert payload["task"] == test_task_data
    assert "timestamp" in payload

    # Verifica que o header de assinatura NÃO foi enviado
    assert "X-SmartTask-Signature" not in request.headers

# Usar respx e monkeypatch para setar o segredo
@respx.mock
async def test_send_webhook_with_secret(monkeypatch):
    """Testa o envio de webhook com um segredo e verifica a assinatura HMAC."""
    test_secret = "my-super-secret-webhook-key"
    monkeypatch.setattr(settings, 'WEBHOOK_SECRET', test_secret) 
    monkeypatch.setattr(settings, 'WEBHOOK_URL', test_webhook_url) 

    # Mocka a rota httpx
    route = respx.post(test_webhook_url).mock(return_value=httpx.Response(200))

    await send_webhook_notification(
        event_type=test_event_type,
        task_data=test_task_data
    )

    # Verifica a chamada HTTP
    assert route.called
    request = respx.calls.last.request

    # Verifica que o header de assinatura FOI enviado
    assert "X-SmartTask-Signature" in request.headers
    signature_header = request.headers["X-SmartTask-Signature"]
    assert signature_header.startswith("sha256=")

    # Verifica se a assinatura está correta
    # Recria o payload exato e calcula a assinatura esperada
    payload_dict = {
        "event": test_event_type,
        "task": test_task_data,
    }
    sent_payload_bytes = request.content 
    sent_payload_dict = json.loads(sent_payload_bytes) 
    # Agora pega o timestamp que foi realmente enviado
    payload_dict["timestamp"] = sent_payload_dict["timestamp"]

    # Gera o payload JSON ordenado e encodado como a função faz
    expected_payload_bytes = json.dumps(payload_dict, separators=(',', ':'), sort_keys=True).encode('utf-8')
    secret_bytes = test_secret.encode('utf-8')
    expected_signature = hmac.new(secret_bytes, expected_payload_bytes, hashlib.sha256).hexdigest()

    # Compara a assinatura esperada com a que está no header
    assert signature_header == f"sha256={expected_signature}"


@respx.mock
async def test_send_webhook_http_error(override_settings_for_webhook, mocker):
    """Testa o tratamento de erro HTTP (ex: 404, 500) do servidor do webhook."""
    respx.post(test_webhook_url).mock(return_value=httpx.Response(500, text="Internal Server Error"))

    mock_logger = mocker.patch("app.core.utils.logger")

    await send_webhook_notification(test_event_type, test_task_data)

    mock_logger.error.assert_called_once()
    call_args, _ = mock_logger.error.call_args 
    assert "Erro no servidor do webhook" in call_args[0]
    assert "Status: 500" in call_args[0]
    assert "Internal Server Error" in call_args[0]

@respx.mock
async def test_send_webhook_request_error(override_settings_for_webhook, mocker):
    """Testa o tratamento de erro de rede/conexão ao enviar webhook."""
    respx.post(test_webhook_url).mock(side_effect=httpx.RequestError("Connection failed"))

    mock_logger = mocker.patch("app.core.utils.logger")

    await send_webhook_notification(test_event_type, test_task_data)

    mock_logger.error.assert_called_once()
    call_args, _ = mock_logger.error.call_args
    assert "Erro na requisição ao enviar webhook" in call_args[0]
    assert "Connection failed" in call_args[0]

async def test_send_webhook_url_not_configured(mocker):
    """Testa que nada acontece se WEBHOOK_URL não estiver configurada."""
    with patch('app.core.utils.settings.WEBHOOK_URL', None):
         # Mock para garantir que httpx não seja instanciado ou chamado
        mock_post = mocker.patch("httpx.AsyncClient.post", new_callable=AsyncMock)
        # Mock do logger para garantir que nenhuma tentativa de envio foi logada (exceto o debug)
        mock_logger = mocker.patch("app.core.utils.logger")

        await send_webhook_notification(test_event_type, test_task_data)

        mock_post.assert_not_called()
        assert not mock_logger.info.called
        assert not mock_logger.error.called
        mock_logger.debug.assert_called_once_with(
             "Webhook URL não configurada, pulando envio."
        )--- Fim de tests/test_core_utils_webhooks.py ---

--- Início de tests/test_main.py (90 linhas) ---
# tests/test_main.py

from fastapi import FastAPI
import pytest
import logging
from unittest.mock import MagicMock, patch, AsyncMock
from httpx import AsyncClient, ASGITransport
from app.main import app as fastapi_app, lifespan
from app.core.config import settings 

pytestmark = pytest.mark.asyncio

async def test_read_root(test_async_client: AsyncClient):
    """Testa o endpoint raiz '/'."""
    response = await test_async_client.get("/")
    assert response.status_code == 200
    assert f"Bem-vindo à {settings.PROJECT_NAME}!" in response.json()["message"]


async def test_lifespan_db_connection_failure(mocker, caplog):
    """
    Testa o 'lifespan' (manual) quando a conexão inicial falha.
    Verifica se o erro crítico é logado e se o yield ocorre.
    """
    caplog.set_level(logging.CRITICAL)

    # Mockar as funções chamadas pelo lifespan
    mock_connect = mocker.patch('app.main.connect_to_mongo', return_value=None)
    # Mockar close_mongo para verificar se é chamado no final (não será neste caso)
    mock_close = mocker.patch('app.main.close_mongo_connection', new_callable=AsyncMock)
    # Mockar as funções de índice para garantir que não são chamadas
    mock_create_user_idx = mocker.patch('app.main.create_user_indexes', new_callable=AsyncMock)
    mock_create_task_idx = mocker.patch('app.main.create_task_indexes', new_callable=AsyncMock)


    # Simular a execução do context manager do lifespan
    async with lifespan(fastapi_app):
        # O código dentro do 'async with' é executado após o 'yield'
        # Verifica se o log crítico foi emitido *antes* do yield
        assert "Falha fatal ao conectar ao MongoDB na inicialização." in caplog.text
        # Verifica se os índices não foram chamados
        mock_create_user_idx.assert_not_called()
        mock_create_task_idx.assert_not_called()

    # Após o 'async with', a parte de shutdown do lifespan executa
    mock_connect.assert_awaited_once()
    # Close não deve ser chamado, pois retornamos cedo
    mock_close.assert_not_called()


async def test_lifespan_index_creation_failure(mocker, caplog):
    """
    Testa o 'lifespan' (manual) quando ocorre erro na criação de índices.
    Verifica se o erro é logado e se a limpeza (close) ainda ocorre.
    """
    caplog.set_level(logging.ERROR)
    test_exception = Exception("Erro simulado no índice")
    mock_db_instance = AsyncMock()

    # Mockar as funções chamadas pelo lifespan
    mock_connect = mocker.patch('app.main.connect_to_mongo', return_value=mock_db_instance)
    mock_close = mocker.patch('app.main.close_mongo_connection', new_callable=AsyncMock)
    # Fazer a criação de índice de usuário falhar
    mock_create_user_idx = mocker.patch('app.main.create_user_indexes', side_effect=test_exception)
    mock_create_task_idx = mocker.patch('app.main.create_task_indexes', new_callable=AsyncMock)

    # Mockar o app.state.db para a função de índice 
    mock_state = MagicMock()
    mock_state.db = mock_db_instance 

    # Criar o mock do app e atribuir o mock state
    mock_app = MagicMock(spec=FastAPI)
    mock_app.state = mock_state

    try:
        async with lifespan(mock_app):
             pass
    except Exception as e:
         pytest.fail(f"Lifespan levantou uma exceção inesperada: {e}")

    # Verifica chamadas e logs
    mock_connect.assert_awaited_once()
    # A função mockada de user_indexes foi chamada
    mock_create_user_idx.assert_awaited_once_with(mock_db_instance)
     # Task indexes não foi chamado devido à exceção anterior
    mock_create_task_idx.assert_not_called()
    assert "Erro durante a criação de índices" in caplog.text
    assert str(test_exception) in caplog.text
    # Verifica que a conexão foi fechada mesmo após o erro nos índices
    mock_close.assert_awaited_once()--- Fim de tests/test_main.py ---

--- Início de tests/test_tasks.py (1048 linhas) ---
# tests/test_tasks.py
# ==========================================
# --- Importações ---
# ==========================================
import unittest.mock
from unittest.mock import AsyncMock, ANY
from freezegun import freeze_time
import pytest
from httpx import AsyncClient
from fastapi import status
from typing import Dict, List, Any
import uuid
import pytest_asyncio
from app.core.config import settings
from app.models.task import TaskStatus
from datetime import date, timedelta, datetime, timezone
from tests.conftest import user_a_data

# ==========================================
# --- Criação do Mock Webhook ---
# ==========================================
@pytest.fixture(
        autouse=True
)

def auto_mock_send_webhook(mocker):
    """
    Aplica automaticamente o mock para send_webhook_notification para todos
    os testes neste módulo.
    """
    mocker.patch(
        "app.routers.tasks.send_webhook_notification",
        new_callable=unittest.mock.AsyncMock,
    )

# ==========================================
# --- Criação do Loop Assíncrono ---
# ==========================================
pytestmark = pytest.mark.asyncio

# ==========================================
# --- Criação do Base Task Data ---
# ==========================================
base_task_create_data = {
    "title": "Tarefa de Teste Padrão",
    "description": "Descrição da tarefa padrão",
    "importance": 3,
}

# ==========================================
# --- Testes de Criação ---
# ==========================================
async def test_create_task_success(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
):
    """Testa a criação bem-sucedida de uma tarefa e verifica chamada do webhook."""
    
    url = f"{settings.API_V1_STR}/tasks/"
    response = await test_async_client.post(
        url,
        json=base_task_create_data,
        headers=auth_headers_a
    ) 

    assert response.status_code == status.HTTP_201_CREATED
    response_data = response.json()
    assert response_data["title"] == base_task_create_data["title"]
    assert response_data["importance"] == base_task_create_data["importance"]
    assert response_data["status"] == TaskStatus.PENDING.value
    assert "id" in response_data
    assert "owner_id" in response_data
    assert "created_at" in response_data
    assert "priority_score" in response_data

async def test_create_task_unauthorized(
        test_async_client: AsyncClient
):
     """Testa criar tarefa sem autenticação."""
     url = f"{settings.API_V1_STR}/tasks/"
     response = await test_async_client.post(url, json=base_task_create_data) 
     assert response.status_code == status.HTTP_401_UNAUTHORIZED

# ==========================================
# --- Testes de Criação e Atualização ---
# ==========================================

@pytest.mark.parametrize(
    "field, length", [
        ("title", 100), 
        ("description", 500), 
    ]
)

async def test_create_task_max_length_success(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    field: str,
    length: int,
):
    """Testa criar tarefa com campos string no comprimento máximo permitido."""
    payload = base_task_create_data.copy()
    payload[field] = "X" * length 
    url = f"{settings.API_V1_STR}/tasks/"
    response = await test_async_client.post(url, json=payload, headers=auth_headers_a)
    assert response.status_code == status.HTTP_201_CREATED
    response_data = response.json()
    assert response_data[field] == payload[field]


@pytest.mark.parametrize(
    "field, length", [
        ("title", 101), 
        ("description", 501), 
    ]
)

async def test_create_task_max_length_fail(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    field: str,
    length: int,
):
    """Testa criar tarefa com campos string acima do comprimento máximo."""
    payload = base_task_create_data.copy()
    payload[field] = "X" * length
    url = f"{settings.API_V1_STR}/tasks/"
    response = await test_async_client.post(url, json=payload, headers=auth_headers_a)
    assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY
    assert f"String should have at most {length -1} characters" in response.text


async def test_create_task_explicit_nulls_optional(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
):
    """Testa criar tarefa enviando explicitamente null para campos opcionais."""
    payload = base_task_create_data.copy()
    payload["description"] = None
    payload["due_date"] = None
    payload["tags"] = None
    payload["project"] = None

    url = f"{settings.API_V1_STR}/tasks/"
    response = await test_async_client.post(url, json=payload, headers=auth_headers_a)
    assert response.status_code == status.HTTP_201_CREATED
    response_data = response.json()
    assert response_data["description"] is None
    assert response_data["due_date"] is None
    assert response_data["tags"] is None
    assert response_data["project"] is None


async def test_update_task_explicit_nulls_optional(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
):
    """Testa atualizar tarefa definindo campos opcionais como null explicitamente."""
    url_create = f"{settings.API_V1_STR}/tasks/"
    create_payload = {
        **base_task_create_data,
        "description": "Descrição inicial",
        "due_date": date.today().isoformat(),
        "tags": ["inicial"],
        "project": "Projeto Inicial"
    }
    create_resp = await test_async_client.post(url_create, json=create_payload, headers=auth_headers_a)
    assert create_resp.status_code == status.HTTP_201_CREATED
    task_id = create_resp.json()["id"]

    # Act: Atualizar enviando nulls
    url_put = f"{settings.API_V1_STR}/tasks/{task_id}"
    update_payload = {
        "description": None,
        "due_date": None,
        "tags": None, 
        "project": None,
    }
    response = await test_async_client.put(url_put, json=update_payload, headers=auth_headers_a)
    assert response.status_code == status.HTTP_200_OK
    response_data = response.json()
    assert response_data["description"] is None
    assert response_data["due_date"] is None
    assert response_data["tags"] is None 
    assert response_data["project"] is None

# ==========================================
# --- Testes de Validação ---
# ==========================================
@pytest.mark.parametrize(
    "field, value, error_type, error_msg_part", [
        ("title", "T2", "string_too_short", "String should have at least 3 characters"),
        ("importance", 0, "greater_than_equal", "Input should be greater than or equal to 1"),
        ("importance", 6, "less_than_equal", "Input should be less than or equal to 5"),
        ("due_date", "nao-e-data", "date_from_datetime_parsing", "invalid character"),
        ("status", "invalido", "enum", "Input should be"),
    ]
)

async def test_create_task_invalid_input(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    field: str, value: Any, error_type: str, error_msg_part: str
):
    """Testa criar tarefa com dados inválidos."""
    invalid_data = base_task_create_data.copy()
    if value is None:
         if field in ["title", "importance"]:
              if field in invalid_data: 
                   del invalid_data[field]
         elif field == "status":
              pytest.skip("Teste 'None' não aplicável para 'status' com default.")
              return
         else:
             invalid_data[field] = value
    else:
        invalid_data[field] = value

    url = f"{settings.API_V1_STR}/tasks/"
    response = await test_async_client.post(url, json=invalid_data, headers=auth_headers_a)
    assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY
    error_details = response.json()["detail"]
    found_error = False
    for error in error_details:
        if field in error.get("loc", []) and error.get("type") == error_type:
            if error_msg_part in error.get("msg", ""):
                found_error = True
                break
    assert found_error, f"Erro esperado para campo '{field}' tipo '{error_type}' msg '{error_msg_part}' não encontrado em {error_details}"

@pytest.mark.parametrize(
    "field, value, error_type, error_msg_part", [
        ("title", "T2", "string_too_short", "String should have at least 3 characters"),
        ("importance", 0, "greater_than_equal", "Input should be greater than or equal to 1"),
        ("importance", 6, "less_than_equal", "Input should be less than or equal to 5"),
        ("due_date", "nao-e-data", "date_from_datetime_parsing", "invalid character"),
        ("status", "invalido", "enum", "Input should be"), 
    ]
)

async def test_update_task_invalid_input(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    field: str, value: Any, error_type: str, error_msg_part: str
):
    """Testa atualizar tarefa com dados inválidos."""
    # Arrange: Criar uma tarefa primeiro
    url = f"{settings.API_V1_STR}/tasks/"
    create_resp = await test_async_client.post(url, json=base_task_create_data, headers=auth_headers_a)
    assert create_resp.status_code == 201
    task_id = create_resp.json()["id"]

    # Act: Tentar atualizar com dado inválido
    invalid_update_payload = {field: value}
    url_put = f"{settings.API_V1_STR}/tasks/{task_id}"
    response = await test_async_client.put(url_put, json=invalid_update_payload, headers=auth_headers_a)

    # Assert
    assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY
    error_details = response.json()["detail"]
    found_error = False
    for error in error_details:
        if field in error.get("loc", []) and error.get("type") == error_type:
            if error_msg_part in error.get("msg", ""):
                found_error = True
                break
    assert found_error, f"Erro esperado para campo '{field}' com tipo '{error_type}' e msg contendo '{error_msg_part}' não encontrado em {error_details}"

async def test_update_task_empty_payload(
     test_async_client: AsyncClient, auth_headers_a: Dict[str, str]
):
    """Testa atualizar tarefa com payload vazio (deve retornar 400)."""
    # Arrange: Criar tarefa
    url = f"{settings.API_V1_STR}/tasks/"
    create_resp = await test_async_client.post(url, json=base_task_create_data, headers=auth_headers_a)
    assert create_resp.status_code == 201
    task_id = create_resp.json()["id"]

    # Act: Tentar atualizar com payload vazio
    url_put = f"{settings.API_V1_STR}/tasks/{task_id}"
    response = await test_async_client.put(url_put, json={}, headers=auth_headers_a) # Payload vazio

    # Assert: Esperamos 400 (conforme nossa lógica em update_task)
    assert response.status_code == status.HTTP_400_BAD_REQUEST
    assert "Nenhum campo válido fornecido" in response.json()["detail"]

# ==========================================
# --- Testes de Listagem ---
# ==========================================
async def test_list_tasks_success(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str]
):
    """Testa se User A lista apenas suas tarefas criadas neste teste."""
    url = f"{settings.API_V1_STR}/tasks/"
    task1 = {**base_task_create_data, "title": "Task A1 List", "importance": 5, "project": "Alpha"}
    task2 = {**base_task_create_data, "title": "Task A2 List", "status": TaskStatus.IN_PROGRESS.value, "tags": ["urgent"]}
    resp1 = await test_async_client.post(url, json=task1, headers=auth_headers_a)
    assert resp1.status_code == 201
    resp2 = await test_async_client.post(url, json=task2, headers=auth_headers_a)
    assert resp2.status_code == 201

    response = await test_async_client.get(url, headers=auth_headers_a)

    assert response.status_code == status.HTTP_200_OK
    tasks = response.json()
    assert isinstance(tasks, list)
    # Com scope='function', o DB é limpo, então só essas 2 devem existir
    assert len(tasks) == 2
    titles = {task["title"] for task in tasks}
    assert task1["title"] in titles
    assert task2["title"] in titles

async def test_list_tasks_unauthorized(
        test_async_client: AsyncClient
):
     """Testa listar tarefas sem autenticação."""
     url = f"{settings.API_V1_STR}/tasks/"
     response = await test_async_client.get(url)
     assert response.status_code == status.HTTP_401_UNAUTHORIZED

async def test_list_tasks_does_not_show_other_users_tasks(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    auth_headers_b: Dict[str, str]
):
    """Garante que User B não vê as tarefas do User A."""
    url = f"{settings.API_V1_STR}/tasks/"
    task_a = {**base_task_create_data, "title": "Tarefa Secreta A"}
    resp_a = await test_async_client.post(url, json=task_a, headers=auth_headers_a)
    assert resp_a.status_code == 201

    response_b = await test_async_client.get(url, headers=auth_headers_b)

    assert response_b.status_code == status.HTTP_200_OK
    tasks_b = response_b.json()
    assert isinstance(tasks_b, list)
    assert len(tasks_b) == 0 # Lista de B deve estar vazia

async def test_list_tasks_filter_non_existent_project(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    create_filter_sort_tasks: List[Dict] 
):
    """Testa listar tarefas filtrando por um projeto que não existe."""
    url = f"{settings.API_V1_STR}/tasks/?project=ProjetoInexistente123"
    response = await test_async_client.get(url, headers=auth_headers_a)
    assert response.status_code == status.HTTP_200_OK
    tasks = response.json()
    assert isinstance(tasks, list)
    assert len(tasks) == 0 

async def test_list_tasks_filter_non_existent_tag(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    create_filter_sort_tasks: List[Dict]
):
    """Testa listar tarefas filtrando por uma tag que nenhuma tarefa possui."""
    url = f"{settings.API_V1_STR}/tasks/?tag=tag_nao_existe"
    response = await test_async_client.get(url, headers=auth_headers_a)
    assert response.status_code == status.HTTP_200_OK
    tasks = response.json()
    assert isinstance(tasks, list)
    assert len(tasks) == 0

async def test_list_tasks_filter_multiple_tags_no_match(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    create_filter_sort_tasks: List[Dict]
):
    """Testa listar tarefas filtrando por múltiplas tags onde nenhuma tarefa possui TODAS."""
    url = f"{settings.API_V1_STR}/tasks/?tag=t1&tag=t3"
    response = await test_async_client.get(url, headers=auth_headers_a)
    assert response.status_code == status.HTTP_200_OK
    tasks = response.json()
    assert isinstance(tasks, list)
    assert len(tasks) == 0 

async def test_list_tasks_filter_status_no_match(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    create_filter_sort_tasks: List[Dict]
):
    """Testa listar tarefas filtrando por um status que nenhuma tarefa possui (ex: cancelada)."""
    url = f"{settings.API_V1_STR}/tasks/?status={TaskStatus.CANCELLED.value}"
    response = await test_async_client.get(url, headers=auth_headers_a)
    assert response.status_code == status.HTTP_200_OK
    tasks = response.json()
    assert isinstance(tasks, list)
    assert len(tasks) == 0 

@freeze_time("2025-05-04")

async def test_list_tasks_filter_due_before_very_early(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    create_filter_sort_tasks: List[Dict]
):
    """Testa listar tarefas filtrando com due_before muito no passado."""
    early_date = "2024-01-01"
    url = f"{settings.API_V1_STR}/tasks/?due_before={early_date}"
    response = await test_async_client.get(url, headers=auth_headers_a)
    assert response.status_code == status.HTTP_200_OK
    tasks = response.json()
    assert isinstance(tasks, list)
    assert len(tasks) == 0 

# ========================================
# --- Testes de Paginação ---
# ========================================

async def test_list_tasks_pagination_limit_1(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    create_filter_sort_tasks: List[Dict] 
):
    """Testa a paginação com limit=1."""
    url = f"{settings.API_V1_STR}/tasks/?limit=1"
    response = await test_async_client.get(url, headers=auth_headers_a)
    assert response.status_code == status.HTTP_200_OK
    tasks = response.json()
    assert isinstance(tasks, list)
    assert len(tasks) == 1 

async def test_list_tasks_pagination_skip_all(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    create_filter_sort_tasks: List[Dict] 
):
    """Testa a paginação pulando todas as tarefas ou mais."""
    total_tasks_in_fixture = 5
    url = f"{settings.API_V1_STR}/tasks/?skip={total_tasks_in_fixture}"
    response = await test_async_client.get(url, headers=auth_headers_a)
    assert response.status_code == status.HTTP_200_OK
    tasks = response.json()
    assert isinstance(tasks, list)
    assert len(tasks) == 0 

    url_skip_more = f"{settings.API_V1_STR}/tasks/?skip={total_tasks_in_fixture + 5}"
    response_skip_more = await test_async_client.get(url_skip_more, headers=auth_headers_a)
    assert response_skip_more.status_code == status.HTTP_200_OK
    tasks_skip_more = response_skip_more.json()
    assert isinstance(tasks_skip_more, list)
    assert len(tasks_skip_more) == 0

async def test_list_tasks_pagination_limit_0(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
):
    """Testa a paginação com limit=0 (deve ser bloqueado pela validação)."""
    url = f"{settings.API_V1_STR}/tasks/?limit=0"
    response = await test_async_client.get(url, headers=auth_headers_a)
    assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY
    # Verificar a mensagem de erro específica seria ainda melhor
    assert "Input should be greater than or equal to 1" in response.text

async def test_list_tasks_pagination_limit_too_high(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
):
    """Testa a paginação com limit > 1000 (deve ser bloqueado pela validação)."""
    url = f"{settings.API_V1_STR}/tasks/?limit=1001"
    response = await test_async_client.get(url, headers=auth_headers_a)
    assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY
    assert "Input should be less than or equal to 1000" in response.text

# ========================================
# --- Testes de Filtros e Paginação ---
# ========================================

async def test_list_tasks_filter_and_pagination(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    create_filter_sort_tasks: List[Dict] 
):
    """Testa filtro por projeto e paginação (skip=1, limit=2)."""
    url = f"{settings.API_V1_STR}/tasks/?project=Filtro&skip=1&limit=2"
    response = await test_async_client.get(url, headers=auth_headers_a)
    assert response.status_code == status.HTTP_200_OK
    tasks = response.json()
    assert isinstance(tasks, list)
    assert len(tasks) == 2

# ========================================
# --- Testes de Filtros e Ordenação ---
# ========================================

@pytest_asyncio.fixture(
        scope="function"
)

async def create_filter_sort_tasks(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str]
) -> List[Dict]:
    """Cria um conjunto de tarefas com variações para testes."""
    url = f"{settings.API_V1_STR}/tasks/"
    tasks_to_create = [
        {"title": "Filter Task P1 High", "importance": 5, "project": "Filtro", "status": TaskStatus.PENDING.value, "due_date": "2026-01-01", "tags": ["t1", "t2"]},
        {"title": "Filter Task P1 Low", "importance": 1, "project": "Filtro", "status": TaskStatus.PENDING.value, "due_date": "2026-02-01"},
        {"title": "Filter Task P2 Medium", "importance": 3, "project": "Outro", "status": TaskStatus.IN_PROGRESS.value, "tags": ["t2"]},
        {"title": "Filter Task P1 Medium", "importance": 3, "project": "Filtro", "status": TaskStatus.PENDING.value, "due_date": "2025-12-15", "tags": ["t3"]}, 
        {"title": "Filter Task P1 Done", "importance": 4, "project": "Filtro", "status": TaskStatus.COMPLETED.value}, 
    ]
    created_tasks = []
    for task_data in tasks_to_create:
        response = await test_async_client.post(url, json=task_data, headers=auth_headers_a)
        assert response.status_code == 201
        created_tasks.append(response.json())
    return created_tasks

async def test_list_tasks_filter_by_project(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    create_filter_sort_tasks: List[Dict]
):
    url = f"{settings.API_V1_STR}/tasks/?project=Filtro"
    response = await test_async_client.get(url, headers=auth_headers_a)
    assert response.status_code == 200
    tasks = response.json()
    assert len(tasks) == 4 
    assert all(task["project"] == "Filtro" for task in tasks)

async def test_list_tasks_filter_by_status(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    create_filter_sort_tasks: List[Dict]
):
    url = f"{settings.API_V1_STR}/tasks/?status=pendente"
    response = await test_async_client.get(url, headers=auth_headers_a)
    assert response.status_code == 200
    tasks = response.json()
    assert len(tasks) == 3 
    assert all(task["status"] == TaskStatus.PENDING.value for task in tasks)

async def test_list_tasks_filter_by_single_tag(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    create_filter_sort_tasks: List[Dict]
):
    url = f"{settings.API_V1_STR}/tasks/?tag=t2"
    response = await test_async_client.get(url, headers=auth_headers_a)
    assert response.status_code == 200
    tasks = response.json()
    assert len(tasks) == 2 
    titles = {task["title"] for task in tasks}
    assert "Filter Task P1 High" in titles
    assert "Filter Task P2 Medium" in titles

async def test_list_tasks_filter_by_multiple_tags(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    create_filter_sort_tasks: List[Dict]
):
    url = f"{settings.API_V1_STR}/tasks/?tag=t1&tag=t2"
    response = await test_async_client.get(url, headers=auth_headers_a)
    assert response.status_code == 200
    tasks = response.json()
    assert len(tasks) == 1 
    assert tasks[0]["title"] == "Filter Task P1 High"

async def test_list_tasks_sort_by_priority(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    create_filter_sort_tasks: List[Dict]
):
    url = f"{settings.API_V1_STR}/tasks/?sort_by=priority_score&sort_order=desc"
    response = await test_async_client.get(url, headers=auth_headers_a)
    assert response.status_code == 200
    tasks = response.json()
    assert len(tasks) == 5 
    scores = [task.get("priority_score") for task in tasks if task.get("priority_score") is not None]
    assert scores == sorted(scores, reverse=True)

async def test_list_tasks_sort_by_due_date_asc(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    create_filter_sort_tasks: List[Dict]
):
    url = f"{settings.API_V1_STR}/tasks/?sort_by=due_date&sort_order=asc"
    response = await test_async_client.get(url, headers=auth_headers_a)
    assert response.status_code == 200
    tasks = response.json()
    assert len(tasks) == 5
    due_dates = [task.get("due_date") for task in tasks if task.get("due_date")]
    assert due_dates == sorted(due_dates)
    assert tasks[0]["due_date"] is None or tasks[0]["due_date"] == "2025-12-15"

# ========================================
# --- Testes GET /tasks/{id} ---
# ========================================

async def test_get_specific_task_success(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str] 
):
    """Testa buscar uma tarefa específica do usuário."""
    # Criar uma tarefa usando User A
    url_create = f"{settings.API_V1_STR}/tasks/"
    create_response = await test_async_client.post(url_create, json=base_task_create_data, headers=auth_headers_a) 
    assert create_response.status_code == 201
    task_id = create_response.json()["id"]

    # Buscar a tarefa criada usando User A
    url_get = f"{settings.API_V1_STR}/tasks/{task_id}"
    get_response = await test_async_client.get(url_get, headers=auth_headers_a) 

    assert get_response.status_code == status.HTTP_200_OK
    response_data = get_response.json()
    assert response_data["id"] == task_id
    assert response_data["title"] == base_task_create_data["title"] 

async def test_get_specific_task_not_found(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str] 
):
    """Testa buscar uma tarefa com ID inexistente."""
    non_existent_id = uuid.uuid4()
    url = f"{settings.API_V1_STR}/tasks/{non_existent_id}"
    response = await test_async_client.get(url, headers=auth_headers_a)
    assert response.status_code == status.HTTP_404_NOT_FOUND

async def test_get_specific_task_unauthorized(
        test_async_client: AsyncClient
):
    """Testa buscar tarefa específica sem autenticação."""
    some_id = uuid.uuid4()
    url = f"{settings.API_V1_STR}/tasks/{some_id}"
    response = await test_async_client.get(url) 
    assert response.status_code == status.HTTP_401_UNAUTHORIZED

async def test_get_other_user_task_forbidden(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    auth_headers_b: Dict[str, str]
):
    """Garante que User B não consegue obter a tarefa do User A por ID."""
    # Arrange: User A cria tarefa
    url = f"{settings.API_V1_STR}/tasks/"
    task_a_data = {**base_task_create_data, "title": "Task A para GET"}
    resp_a = await test_async_client.post(url, json=task_a_data, headers=auth_headers_a)
    assert resp_a.status_code == 201
    task_a_id = resp_a.json()["id"]

    # Act: User B tenta obter a tarefa de User A
    url_get = f"{settings.API_V1_STR}/tasks/{task_a_id}"
    response_b = await test_async_client.get(url_get, headers=auth_headers_b)

    # Assert: Deve falhar com 404 (pois o findOne combina id E owner_id)
    assert response_b.status_code == status.HTTP_404_NOT_FOUND

# ========================================
# --- Testes PUT /tasks/{id} ---
# ========================================

async def test_update_task_success(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
):
    """Testa atualizar uma tarefa com sucesso e verifica chamada do webhook."""
    # Arrange: Criar tarefa
    url = f"{settings.API_V1_STR}/tasks/"
    create_resp = await test_async_client.post(
        url,
        json=base_task_create_data,
        headers=auth_headers_a
    )
    assert create_resp.status_code == 201
    task_id = create_resp.json()["id"]
    original_score = create_resp.json().get("priority_score")

    # Act: Atualizar a tarefa
    url_put = f"{settings.API_V1_STR}/tasks/{task_id}"
    update_payload = {
        "title": "Título Atualizado",
        "status": TaskStatus.COMPLETED.value,
        "importance": 5
    } 
    response = await test_async_client.put(
        url_put,
        json=update_payload,
        headers=auth_headers_a
    )

    # Assert
    assert response.status_code == status.HTTP_200_OK
    data = response.json()
    assert data["id"] == task_id
    assert data["title"] == update_payload["title"]
    assert data["status"] == update_payload["status"]
    assert data["importance"] == update_payload["importance"]
    assert "updated_at" in data and data["updated_at"] is not None
    assert "priority_score" in data
    assert data["priority_score"] != original_score

async def test_update_task_not_found(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str]
):
    """Testa atualizar tarefa inexistente."""
    url = f"{settings.API_V1_STR}/tasks/{uuid.uuid4()}" 
    response = await test_async_client.put(url, json={"title": "Inexistente"}, headers=auth_headers_a)
    assert response.status_code == status.HTTP_404_NOT_FOUND

async def test_update_other_user_task_forbidden(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    auth_headers_b: Dict[str, str]
):
    """Testa se User B não pode atualizar tarefa do User A."""
    # Arrange: User A cria tarefa
    url = f"{settings.API_V1_STR}/tasks/"
    resp_a = await test_async_client.post(url, json=base_task_create_data, headers=auth_headers_a)
    assert resp_a.status_code == 201
    task_a_id = resp_a.json()["id"]

    # Act: User B tenta atualizar
    url_put = f"{settings.API_V1_STR}/tasks/{task_a_id}"
    response_b = await test_async_client.put(url_put, json={"title": "Hackeado?"}, headers=auth_headers_b)

    # Assert: Falha com 404
    assert response_b.status_code == status.HTTP_404_NOT_FOUND

async def test_get_specific_task_success(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str]
):
    """Testa buscar uma tarefa específica do usuário A."""
    url_create = f"{settings.API_V1_STR}/tasks/"
    create_response = await test_async_client.post(url_create, json=base_task_create_data, headers=auth_headers_a) # << CORRIGIDO
    assert create_response.status_code == 201
    task_id = create_response.json()["id"]

    url_get = f"{settings.API_V1_STR}/tasks/{task_id}"
    get_response = await test_async_client.get(url_get, headers=auth_headers_a) # << CORRIGIDO

    assert get_response.status_code == status.HTTP_200_OK
    response_data = get_response.json()
    assert response_data["id"] == task_id
    assert response_data["title"] == base_task_create_data["title"]

async def test_get_specific_task_not_found(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str] 
):
    """Testa buscar uma tarefa com ID inexistente."""
    non_existent_id = uuid.uuid4()
    url = f"{settings.API_V1_STR}/tasks/{non_existent_id}"
    response = await test_async_client.get(url, headers=auth_headers_a) 
    assert response.status_code == status.HTTP_404_NOT_FOUND

async def test_get_specific_task_unauthorized(
        test_async_client: AsyncClient
):
     """Testa buscar tarefa sem autenticação."""
     some_valid_id_placeholder = uuid.uuid4()
     url = f"{settings.API_V1_STR}/tasks/{some_valid_id_placeholder}"
     response = await test_async_client.get(url)
     assert response.status_code == status.HTTP_401_UNAUTHORIZED

async def test_get_other_user_task_forbidden(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    auth_headers_b: Dict[str, str]
):
    """Garante que User B não consegue obter a tarefa do User A por ID."""
    url = f"{settings.API_V1_STR}/tasks/"
    task_a_data = {**base_task_create_data, "title": "Task A para GET"}
    resp_a = await test_async_client.post(url, json=task_a_data, headers=auth_headers_a)
    assert resp_a.status_code == 201
    task_a_id = resp_a.json()["id"]

    url_get = f"{settings.API_V1_STR}/tasks/{task_a_id}"
    response_b = await test_async_client.get(url_get, headers=auth_headers_b)

    assert response_b.status_code == status.HTTP_404_NOT_FOUND

# ==========================================
# --- Testes DELETE /tasks/{id} ---
# ==========================================

async def test_delete_task_success(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str]
):
    """Testa deletar uma tarefa com sucesso."""
    # Arrange: Criar tarefa
    url = f"{settings.API_V1_STR}/tasks/"
    create_resp = await test_async_client.post(url, json=base_task_create_data, headers=auth_headers_a)
    assert create_resp.status_code == 201
    task_id = create_resp.json()["id"]

    # Act: Deletar a tarefa
    url_delete = f"{settings.API_V1_STR}/tasks/{task_id}"
    delete_response = await test_async_client.delete(url_delete, headers=auth_headers_a)

    # Assert (Delete)
    assert delete_response.status_code == status.HTTP_204_NO_CONTENT

    # Assert (Verificar Get posterior falha)
    url_get = f"{settings.API_V1_STR}/tasks/{task_id}"
    get_response = await test_async_client.get(url_get, headers=auth_headers_a)
    assert get_response.status_code == status.HTTP_404_NOT_FOUND

async def test_delete_task_not_found(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str]
):
    """Testa deletar tarefa inexistente."""
    url = f"{settings.API_V1_STR}/tasks/{uuid.uuid4()}" # ID aleatório
    response = await test_async_client.delete(url, headers=auth_headers_a)
    assert response.status_code == status.HTTP_404_NOT_FOUND

async def test_delete_other_user_task_forbidden(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    auth_headers_b: Dict[str, str]
):
    """Testa se User B não pode deletar tarefa do User A."""
    # Arrange: User A cria tarefa
    url = f"{settings.API_V1_STR}/tasks/"
    resp_a = await test_async_client.post(url, json=base_task_create_data, headers=auth_headers_a)
    assert resp_a.status_code == 201
    task_a_id = resp_a.json()["id"]

    # Act: User B tenta deletar
    url_delete = f"{settings.API_V1_STR}/tasks/{task_a_id}"
    response_b = await test_async_client.delete(url_delete, headers=auth_headers_b)

    # Assert: Falha com 404
    
# ==========================================
# --- Testes de Segurança (JWT) ---
# ==========================================

async def test_access_tasks_invalid_token_format(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str] 
):
    """Testa acessar /tasks com um token JWT mal formatado."""
    url = f"{settings.API_V1_STR}/tasks/"
    invalid_headers = {"Authorization": "Bearer tokeninvalido.nao.jwt"}
    response = await test_async_client.get(url, headers=invalid_headers)
    assert response.status_code == status.HTTP_401_UNAUTHORIZED
    assert "validar as credenciais" in response.json()["detail"]


async def test_access_tasks_token_wrong_secret(
    test_async_client: AsyncClient,
    mocker 
):
    """Testa acessar /tasks com um token assinado com segredo incorreto."""
    from app.core.security import create_access_token
    from app.models.token import TokenPayload

    # 1. Criando um usuário para ter um ID válido 
    user_id_dummy = uuid.uuid4()
    username_dummy = "dummyuser"

    # 2. Gerando um token JWT usando uma chave secreta diferente da configuração
    wrong_secret = "outra-chave-secreta-bem-diferente"
    assert wrong_secret != settings.JWT_SECRET_KEY
    token_wrong_key = create_access_token(
        subject=user_id_dummy,
        username=username_dummy,
    )
    import jwt as jose_jwt 
    to_encode = {"sub": str(user_id_dummy), "username": username_dummy, "exp": datetime.now(timezone.utc) + timedelta(minutes=15)}
    token_really_wrong_key = jose_jwt.encode(to_encode, wrong_secret, algorithm=settings.JWT_ALGORITHM)


    # 3. Tentando acessar a API com este token
    url = f"{settings.API_V1_STR}/tasks/"
    invalid_headers = {"Authorization": f"Bearer {token_really_wrong_key}"}
    response = await test_async_client.get(url, headers=invalid_headers)

    assert response.status_code == status.HTTP_401_UNAUTHORIZED
    assert "validar as credenciais" in response.json()["detail"]


@freeze_time("2025-05-04 18:35:00")

async def test_access_tasks_expired_token(
    test_async_client: AsyncClient,
    test_user_a_token_and_id: tuple[str, uuid.UUID],
    mocker
):
    """Testa acessar /tasks com um token JWT expirado."""
    import jwt as jose_jwt
    from datetime import datetime, timedelta, timezone

    _, user_id = test_user_a_token_and_id

    # 1. Criando um token com data de expiração no passado
    past_time = datetime.now(timezone.utc) - timedelta(minutes=30)
    expired_payload = {
        "sub": str(user_id), 
        "username": user_a_data["username"],
        "exp": past_time
    }
    expired_token = jose_jwt.encode(
        expired_payload,
        settings.JWT_SECRET_KEY,
        algorithm=settings.JWT_ALGORITHM
    )

    # 2. Tente acessar a API com o token expirado
    url = f"{settings.API_V1_STR}/tasks/"
    invalid_headers = {"Authorization": f"Bearer {expired_token}"}
    response = await test_async_client.get(url, headers=invalid_headers)

    assert response.status_code == status.HTTP_401_UNAUTHORIZED
    assert "validar as credenciais" in response.json()["detail"]

@pytest.mark.parametrize(
    "param_name, injected_value", [
        ("project", {"$ne": "some_project"}), 
        ("project", "; --"), 
        ("project", "' OR '1'='1"), 
        ("tag", {"$ne": "some_tag"}), 
        ("tag", "*"),
        ("tag", "t1; DROP TABLE tasks; --"), 
    ]
)

async def test_list_tasks_filter_injection_attempt_string(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    param_name: str,
    injected_value: Any,
):
    """
    Testa tentativas de injeção em filtros de string (project, tag).
    Espera-se erro 422 (Validação) pois o tipo esperado é string simples.
    """
    url = f"{settings.API_V1_STR}/tasks/?{param_name}={str(injected_value)}" 

    response = await test_async_client.get(url, headers=auth_headers_a)

    assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY \
           or response.status_code == status.HTTP_200_OK, \
           f"Recebido status inesperado {response.status_code} para injeção em '{param_name}'"

    if response.status_code == status.HTTP_200_OK:
        tasks = response.json()
        assert isinstance(tasks, list)
        print(f"WARN: Injeção em '{param_name}' retornou 200 OK. Resultado: {tasks}")

async def test_list_tasks_filter_regex_injection(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    create_filter_sort_tasks: List[Dict]
):
    """
    Testa especificamente a injeção de $regex no filtro 'project'.
    MongoDB pode aceitar regex, mas Pydantic deve garantir que é tratado como string.
    """
    payload_str = "/.*/" 
    url = f"{settings.API_V1_STR}/tasks/?project={payload_str}"
    response = await test_async_client.get(url, headers=auth_headers_a)

    assert response.status_code == status.HTTP_200_OK
    tasks = response.json()
    assert isinstance(tasks, list)
    found_literal_match = any(task.get("project") == payload_str for task in tasks)
    assert not found_literal_match or len(tasks) == 0, \
           "Injeção de Regex parece ter encontrado resultados inesperados ou foi tratada literalmente."
    
# ================================================
# --- Testes de Notificação Imediata de E-mail ---
# ================================================

@freeze_time("2025-05-04") 
async def test_create_task_triggers_immediate_urgent_email(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    mocker, 
):
    """
    Testa se a criação de uma tarefa claramente urgente dispara
    a background task para envio imediato de e-mail.
    """
    # Mockar a função de envio de email que é chamada pela rota
    mock_send_email = mocker.patch(
        "app.routers.tasks.send_urgent_task_notification",
        new_callable=AsyncMock
    )
    # Mockar is_task_urgent para garantir que ela retorne True neste teste
    mocker.patch("app.routers.tasks.is_task_urgent", return_value=True)

    urgent_task_payload = {
        "title": "Tarefa Super Urgente Imediata",
        "description": "Precisa de email agora",
        "importance": 5,
        "due_date": (date.today() - timedelta(days=1)).isoformat() 
    }

    url = f"{settings.API_V1_STR}/tasks/"
    response = await test_async_client.post(url, json=urgent_task_payload, headers=auth_headers_a)

    # Verifica a criação da tarefa
    assert response.status_code == status.HTTP_201_CREATED
    created_task_data = response.json()

    # Verifica se a função de envio de email foi chamada na background task
    mock_send_email.assert_called_once()

    # Verificar alguns argumentos chave passados para a função mockada
    call_args = mock_send_email.call_args.kwargs
    assert call_args["user_email"] == user_a_data["email"] 
    assert call_args["task_title"] == urgent_task_payload["title"]
    assert call_args["task_id"] == created_task_data["id"]


@freeze_time("2025-05-04") 
async def test_create_task_does_not_trigger_immediate_non_urgent_email(
    test_async_client: AsyncClient,
    auth_headers_a: Dict[str, str],
    mocker, 
):
    """
    Testa se a criação de uma tarefa claramente NÃO urgente NÃO dispara
    a background task para envio imediato de e-mail.
    """
    # Mockar a função de envio de email
    mock_send_email = mocker.patch(
        "app.routers.tasks.send_urgent_task_notification",
        new_callable=AsyncMock
    )
    # Mockar is_task_urgent para garantir que retorne False
    mocker.patch("app.routers.tasks.is_task_urgent", return_value=False)

    # Dados para uma tarefa que NÃO deve ser urgente
    non_urgent_task_payload = {
        "title": "Tarefa Não Urgente Imediata",
        "description": "Sem pressa",
        "importance": 1,
        "due_date": (date.today() + timedelta(days=30)).isoformat() 
    }

    url = f"{settings.API_V1_STR}/tasks/"
    response = await test_async_client.post(url, json=non_urgent_task_payload, headers=auth_headers_a)

    # Verifica a criação da tarefa
    assert response.status_code == status.HTTP_201_CREATED

    # Verifica que a função de envio de email NÃO foi chamada
    mock_send_email.assert_not_called()--- Fim de tests/test_tasks.py ---

--- Início de tests/test_worker.py (343 linhas) ---
# tests/test_worker.py

import pytest
import uuid
from datetime import date, datetime, timedelta, timezone
from unittest.mock import AsyncMock, MagicMock, call 
import logging
from app.worker import check_and_notify_urgent_tasks 
from app.models.task import Task, TaskStatus
from app.models.user import UserInDB
from app.core.config import settings

pytestmark = pytest.mark.asyncio

# === Fixtures de Dados de Teste ===

# Usuário ativo com e-mail
user_active_with_email = UserInDB(
    id=uuid.uuid4(),
    username="testworkeruser",
    email="worker@example.com",
    full_name="Worker Test User",
    hashed_password="fakehash",
    disabled=False,
    created_at=datetime.now(timezone.utc)
)

# Usuário desativado
user_disabled = UserInDB(
    id=uuid.uuid4(),
    username="disableduser",
    email="disabled@example.com",
    full_name="Disabled User",
    hashed_password="fakehash",
    disabled=True,
    created_at=datetime.now(timezone.utc)
)

# Tarefa Urgente por Score Alto
task_urgent_score = Task(
    id=uuid.uuid4(),
    owner_id=user_active_with_email.id, # Pertence ao usuário ativo
    title="Urgent High Score Task",
    importance=5,
    status=TaskStatus.PENDING,
    created_at=datetime.now(timezone.utc) - timedelta(days=1),
    priority_score=settings.EMAIL_URGENCY_THRESHOLD + 50.0, # Score acima do limiar
    due_date=date.today() + timedelta(days=10) # Prazo futuro (urgente pelo score)
)

# Tarefa Urgente por Prazo Atrasado (mesmo com score baixo)
task_urgent_overdue = Task(
    id=uuid.uuid4(),
    owner_id=user_active_with_email.id, # Pertence ao usuário ativo
    title="Urgent Overdue Task",
    importance=1,
    status=TaskStatus.PENDING,
    created_at=datetime.now(timezone.utc) - timedelta(days=5),
    priority_score=10.0, # Score abaixo do limiar
    due_date=date.today() - timedelta(days=1) # Atrasada
)

# Tarefa Urgente por Prazo Hoje (mesmo com score baixo)
task_urgent_due_today = Task(
    id=uuid.uuid4(),
    owner_id=user_active_with_email.id, # Pertence ao usuário ativo
    title="Urgent Due Today Task",
    importance=2,
    status=TaskStatus.IN_PROGRESS,
    created_at=datetime.now(timezone.utc) - timedelta(days=2),
    priority_score=20.0, # Score abaixo do limiar
    due_date=date.today() # Vence hoje
)

# Tarefa NÃO Urgente
task_not_urgent = Task(
    id=uuid.uuid4(),
    owner_id=user_active_with_email.id, # Pertence ao usuário ativo
    title="Not Urgent Task",
    importance=3,
    status=TaskStatus.PENDING,
    created_at=datetime.now(timezone.utc),
    priority_score=settings.EMAIL_URGENCY_THRESHOLD - 10.0, # Score baixo
    due_date=date.today() + timedelta(days=5) # Prazo futuro
)

# Tarefa Concluída (não deve ser notificada)
task_completed = Task(
    id=uuid.uuid4(),
    owner_id=user_active_with_email.id,
    title="Completed Urgent Task",
    importance=5,
    status=TaskStatus.COMPLETED, # Concluída
    created_at=datetime.now(timezone.utc) - timedelta(days=10),
    priority_score=settings.EMAIL_URGENCY_THRESHOLD + 100.0, # Score alto
    due_date=date.today() - timedelta(days=2) # Atrasada
)

# Tarefa pertencente a usuário desativado
task_disabled_user = Task(
    id=uuid.uuid4(),
    owner_id=user_disabled.id, # Usuário desativado
    title="Disabled User Urgent Task",
    importance=5,
    status=TaskStatus.PENDING,
    created_at=datetime.now(timezone.utc),
    priority_score=settings.EMAIL_URGENCY_THRESHOLD + 50.0 # Score alto
)

# === Testes da Função check_and_notify_urgent_tasks ===

async def test_worker_no_urgent_tasks(mocker):
    """Testa o worker quando não há tarefas urgentes no 'banco'."""
    # Mock DB e Collections
    mock_db = MagicMock()
    mock_tasks_collection = MagicMock()
    mock_db.__getitem__.return_value = mock_tasks_collection 

    # Configura o 'find' para retornar um cursor assíncrono vazio
    mock_cursor = AsyncMock()
    mock_cursor.__aiter__.return_value = [] 
    mock_tasks_collection.find.return_value = mock_cursor

    # Mock get_user_by_id (não deve ser chamado se não houver tarefas)
    mock_get_user = mocker.patch("app.worker.user_crud.get_user_by_id", new_callable=AsyncMock)

    # Mock da função de envio de email (não deve ser chamada)
    mock_send_email = mocker.patch("app.worker.send_urgent_task_notification", new_callable=AsyncMock)

    # Chama a função do worker com o contexto mockado
    ctx = {"db": mock_db}
    await check_and_notify_urgent_tasks(ctx)

    # Asserções
    mock_tasks_collection.find.assert_called_once() 
    mock_get_user.assert_not_called()
    mock_send_email.assert_not_called() 


async def test_worker_one_urgent_task_active_user(mocker):
    """Testa o worker com uma tarefa urgente e usuário ativo."""
    mock_db = MagicMock()
    mock_tasks_collection = MagicMock()
    mock_users_collection = MagicMock() 

    # Fazer db["tasks"] retornar tasks_collection, db["users"] retornar users_collection
    def db_getitem_side_effect(key):
        if key == "tasks": return mock_tasks_collection
        if key == "users": return mock_users_collection
        raise KeyError(key)
    mock_db.__getitem__.side_effect = db_getitem_side_effect

    # Configura 'find' para retornar um cursor com uma tarefa urgente (convertida pra dict)
    task_dict = task_urgent_score.model_dump(mode='json')
    mock_cursor = AsyncMock()
    mock_cursor.__aiter__.return_value = [task_dict]
    mock_tasks_collection.find.return_value = mock_cursor

    # Mock get_user_by_id para retornar o usuário ativo
    mock_get_user = mocker.patch(
        "app.worker.user_crud.get_user_by_id",
        new_callable=AsyncMock,
        return_value=user_active_with_email 
    )

    # Mock da função de envio de email
    mock_send_email = mocker.patch("app.worker.send_urgent_task_notification", new_callable=AsyncMock)

    # Chama a função do worker
    ctx = {"db": mock_db}
    await check_and_notify_urgent_tasks(ctx)

    # Asserções
    mock_tasks_collection.find.assert_called_once()
    mock_get_user.assert_called_once_with(mock_db, task_urgent_score.owner_id) 
    mock_send_email.assert_called_once() 

    # Verificar argumentos do email (opcional, mas bom)
    call_args = mock_send_email.call_args.kwargs
    assert call_args['user_email'] == user_active_with_email.email
    assert call_args['user_name'] == user_active_with_email.full_name
    assert call_args['task_title'] == task_urgent_score.title
    assert call_args['task_id'] == str(task_urgent_score.id)


async def test_worker_mix_urgent_non_urgent_completed(mocker):
    """Testa com mistura de tarefas (urgente, não urgente, concluída)."""
    mock_db = MagicMock()
    mock_tasks_collection = MagicMock()
    mock_users_collection = MagicMock()
    def db_getitem_side_effect(key):
        if key == "tasks": return mock_tasks_collection
        if key == "users": return mock_users_collection
        raise KeyError(key)
    mock_db.__getitem__.side_effect = db_getitem_side_effect

    tasks_in_db = [
        task_not_urgent.model_dump(mode='json'),
        task_urgent_overdue.model_dump(mode='json'), 
        task_completed.model_dump(mode='json'),
    ]
    mock_cursor = AsyncMock()
    filtered_tasks = [task_urgent_overdue.model_dump(mode='json')]
    mock_cursor.__aiter__.return_value = filtered_tasks
    mock_tasks_collection.find.return_value = mock_cursor

    # Mock get_user_by_id
    mock_get_user = mocker.patch(
        "app.worker.user_crud.get_user_by_id",
        new_callable=AsyncMock,
        return_value=user_active_with_email
    )

    # Mock do email
    mock_send_email = mocker.patch("app.worker.send_urgent_task_notification", new_callable=AsyncMock)

    # Chama o worker
    ctx = {"db": mock_db}
    await check_and_notify_urgent_tasks(ctx)

    # Asserções
    mock_tasks_collection.find.assert_called_once() 
    # get_user foi chamado APENAS para a tarefa que a query retornou (urgent_overdue)
    mock_get_user.assert_called_once_with(mock_db, task_urgent_overdue.owner_id)
    # send_email foi chamado APENAS uma vez (para a tarefa urgente)
    mock_send_email.assert_called_once()
    call_args = mock_send_email.call_args.kwargs
    assert call_args['task_title'] == task_urgent_overdue.title


async def test_worker_urgent_task_disabled_user(mocker):
    """Testa que email não é enviado para tarefa urgente de usuário desativado."""
    mock_db = MagicMock()
    mock_tasks_collection = MagicMock()
    mock_users_collection = MagicMock()
    def db_getitem_side_effect(key):
        if key == "tasks": return mock_tasks_collection
        if key == "users": return mock_users_collection
        raise KeyError(key)
    mock_db.__getitem__.side_effect = db_getitem_side_effect

    # Cursor com a tarefa do usuário desativado
    mock_cursor = AsyncMock()
    mock_cursor.__aiter__.return_value = [task_disabled_user.model_dump(mode='json')]
    mock_tasks_collection.find.return_value = mock_cursor

    # Mock get_user_by_id para retornar o usuário desativado
    mock_get_user = mocker.patch(
        "app.worker.user_crud.get_user_by_id",
        new_callable=AsyncMock,
        return_value=user_disabled
    )

    # Mock do email (NÃO deve ser chamado)
    mock_send_email = mocker.patch("app.worker.send_urgent_task_notification", new_callable=AsyncMock)

    # Chama o worker
    ctx = {"db": mock_db}
    await check_and_notify_urgent_tasks(ctx)

    # Asserções
    mock_tasks_collection.find.assert_called_once()
    mock_get_user.assert_called_once_with(mock_db, user_disabled.id)
    mock_send_email.assert_not_called() 


async def test_worker_multiple_urgent_tasks(mocker):
    """Testa o envio de múltiplas notificações."""
    mock_db = MagicMock()
    mock_tasks_collection = MagicMock()
    mock_users_collection = MagicMock()
    def db_getitem_side_effect(key):
        if key == "tasks": return mock_tasks_collection
        if key == "users": return mock_users_collection
        raise KeyError(key)
    mock_db.__getitem__.side_effect = db_getitem_side_effect

    # Cursor com múltiplas tarefas urgentes
    urgent_tasks_list = [
        task_urgent_score.model_dump(mode='json'),
        task_urgent_overdue.model_dump(mode='json'),
        task_urgent_due_today.model_dump(mode='json')
    ]
    mock_cursor = AsyncMock()
    mock_cursor.__aiter__.return_value = urgent_tasks_list
    mock_tasks_collection.find.return_value = mock_cursor

    # Mock get_user_by_id para sempre retornar o usuário ativo
    mock_get_user = mocker.patch(
        "app.worker.user_crud.get_user_by_id",
        new_callable=AsyncMock,
        return_value=user_active_with_email
    )

    # Mock do email
    mock_send_email = mocker.patch("app.worker.send_urgent_task_notification", new_callable=AsyncMock)

    # Chama o worker
    ctx = {"db": mock_db}
    await check_and_notify_urgent_tasks(ctx)

    # Asserções
    assert mock_tasks_collection.find.call_count == 1
    # Verifica se get_user foi chamado para cada tarefa urgente
    assert mock_get_user.call_count == len(urgent_tasks_list)
    # Verifica se send_email foi chamado para cada tarefa urgente
    assert mock_send_email.call_count == len(urgent_tasks_list)

    # Verifica a chamada para a primeira tarefa
    expected_call_args_score = {
        'user_email': user_active_with_email.email,
        'user_name': user_active_with_email.full_name,
        'task_title': task_urgent_score.title,
        'task_id': str(task_urgent_score.id),
        'task_due_date': str(task_urgent_score.due_date),
        'priority_score': task_urgent_score.priority_score
    }
    mock_send_email.assert_any_call(**expected_call_args_score)


async def test_worker_db_unavailable(mocker):
    """
    Testa o comportamento do worker se o DB não estiver no contexto
    e verifica se o erro é logado.
    """    # Mock para envio de email (não deve ser chamado)
    mock_send_email = mocker.patch("app.worker.send_urgent_task_notification", new_callable=AsyncMock)

    # Cria o mock do log
    mock_logger = mocker.patch("app.worker.logger")

    # Chama a função do worker com contexto VAZIO
    ctx = {}
    # Remover o with caplog:
    await check_and_notify_urgent_tasks(ctx)

    # Verifica que a função de email não foi chamada
    mock_send_email.assert_not_called()

    # <<< ADIÇÃO (Opcional): Verificar se o logger mockado foi chamado >>>
    # Isso substitui a verificação do texto no caplog
    mock_logger.error.assert_called_once_with(
        "Conexão com o banco de dados não disponível no contexto ARQ."
    )--- Fim de tests/test_worker.py ---
